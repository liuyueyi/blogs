<!DOCTYPE html>
<html lang="">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SpringMVC支持跨域的几种姿势"/>




  <meta name="keywords" content="Java,Spring,Jsonp,CORS," />





  <link rel="alternate" href="/hexblog/atom.xml" title="Z+ | Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/hexblog/favicon.ico?v=1.1" />



<link rel="canonical" href="https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/"/>


<meta name="description" content="SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？  后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数">
<meta name="keywords" content="Java,Spring,Jsonp,CORS">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC支持跨域的几种姿势">
<meta property="og:url" content="https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/index.html">
<meta property="og:site_name" content="Z+ | Blog">
<meta property="og:description" content="SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？  后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://s17.mogucdn.com/mlcdn/c45406/180118_3a5f1elgbj9ibc85fk5j9401b5hde_2350x1032.jpg">
<meta property="og:image" content="https://s10.mogucdn.com/mlcdn/c45406/180103_61hi8f7kldkl202fked3k2g0ial1e_640x340.jpg">
<meta property="og:updated_time" content="2018-01-18T12:30:56.242Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpringMVC支持跨域的几种姿势">
<meta name="twitter:description" content="SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？  后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数">
<meta name="twitter:image" content="https://s17.mogucdn.com/mlcdn/c45406/180118_3a5f1elgbj9ibc85fk5j9401b5hde_2350x1032.jpg">


<link rel="stylesheet" type="text/css" href="/hexblog/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> SpringMVC支持跨域的几种姿势 - Z+ | Blog </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/hexblog/." class="logo">Z+ | Blog</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/hexblog/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/hexblog/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">



    <header class="post-header">
      <h1 class="post-title">
        
          SpringMVC支持跨域的几种姿势
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          <i class="fa fa-calendar"></i>
          2018-01-19
          
              | <i class="fa fa-folder"></i>
              
                - <a href="/hexblog/categories/Java/">Java</a>
              
                - <a href="/hexblog/categories/Java/Spring/">Spring</a>
              
          
        </span>

      </div>
    </header>



    
            <div class="post-content">
            <h1 id="SpringMVC支持跨域的几种姿势"><a href="#SpringMVC支持跨域的几种姿势" class="headerlink" title="SpringMVC支持跨域的几种姿势"></a>SpringMVC支持跨域的几种姿势</h1><blockquote>
<p>跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？</p>
</blockquote>
<p>后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数</p>
<a id="more"></a>
<h2 id="I-Jsonp的支持"><a href="#I-Jsonp的支持" class="headerlink" title="I. Jsonp的支持"></a>I. Jsonp的支持</h2><p>jsonp的请求表现方式就是url里面会多一个参数 callback，一般如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callback=jQuery21105810685605043302_1516257942328</span><br></pre></td></tr></table></figure>
<p>jsonp的返回与一般调用方式的返回也会有点区别，会在外面包装一层，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery21105810685605043302_1516257942328(...);</span><br></pre></td></tr></table></figure>
<p>springmvc中，jsonp的支持却是比较简单了，不需要对现有的接口进行任何处理，只需要像下面这么玩即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonpAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> </span>&#123;    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">JsonpAdvice</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"callback"</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析说明"><a href="#分析说明" class="headerlink" title="分析说明"></a>分析说明</h3><p>首先是利用了注解 <code>@ControllerAdvice</code> ， 这个注解在后面说到的统一异常处理时，也会用到，从命名也可以看出，就是为Controller添加一个切面，简单来讲，就是在直接返回数据前，对返回的结果包装一把；从实现也可以看出，主要的逻辑就在 <code>AbstractJsonpResponseBodyAdvice</code> 里面，所以有必要看一下这个东西是怎么支持的了</p>
<p>核心的代码逻辑就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeBodyWriteInternal</span><span class="params">(MappingJacksonValue bodyContainer, MediaType contentType,</span></span></span><br><span class="line"><span class="function"><span class="params">		MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (String name : <span class="keyword">this</span>.jsonpQueryParamNames) &#123;</span><br><span class="line">		String value = servletRequest.getParameter(name);</span><br><span class="line">		<span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!isValidJsonpQueryParam(value)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">"Ignoring invalid jsonp parameter value: "</span> + value);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 下面三行是主要的逻辑</span></span><br><span class="line">			MediaType contentTypeToUse = getContentType(contentType, request, response);</span><br><span class="line">			response.getHeaders().setContentType(contentTypeToUse);</span><br><span class="line">			bodyContainer.setJsonpFunction(value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看可能看不太明白究竟做了什么，写了个测试，debug下相关的参数如下</p>
<p><img src="https://s17.mogucdn.com/mlcdn/c45406/180118_3a5f1elgbj9ibc85fk5j9401b5hde_2350x1032.jpg" alt="IMAGE"></p>
<p>即，修改返回的 content-type 为： application/javascript</p>
<p>返回的Container里面设置了jsonpFunction，为请求参数的value，至于是在什么时候封装的返回结果呢？这个有待后续补全</p>
<h2 id="II-支持cors跨域"><a href="#II-支持cors跨域" class="headerlink" title="II. 支持cors跨域"></a>II. 支持cors跨域</h2><blockquote>
<p>Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求</p>
</blockquote>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否</p>
<p><strong>所以问题就来了，安全如何保证？</strong></p>
<p>一般而言，为了避免夸站点攻击(csrf)，常见的手段无非：</p>
<ul>
<li>身份校验（比如要求用户登录）</li>
<li>token验证</li>
<li>ip白名单</li>
<li>来源referer校验</li>
<li>频率限制</li>
</ul>
<h3 id="2-实现方式"><a href="#2-实现方式" class="headerlink" title="2. 实现方式"></a>2. 实现方式</h3><p>要支持csrf，也比较简单了，无非就是设置下responseHeader了, 一般需要设置以下几项</p>
<ul>
<li>Access-Control-Allow-Origin: *; // 允许的来源</li>
<li>Access-Control-Allow-Methods: GET, POST, PUT, DELETE</li>
<li>Access-Control-Allow-Credentials: true</li>
<li>Access-Control-Allow-Headers: Content-Type</li>
<li>Access-Control-Max-Age: 1800 //30 min</li>
</ul>
<p>所以实现起来的方式就比较多了，一个是新增一个filter，主动设置下返回头，当然spring mvc提供了更友好的方式了</p>
<p>常见的几种手段如下: </p>
<h4 id="a-xml配置方式"><a href="#a-xml配置方式" class="headerlink" title="a. xml配置方式"></a>a. xml配置方式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:cors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/ajax/*"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">allowed-origins</span>=<span class="string">"*"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">max-age</span>=<span class="string">"3600"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:cors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="b-注解方式"><a href="#b-注解方式" class="headerlink" title="b. 注解方式"></a>b. 注解方式</h4><p>在controller方法上，添加下面这个注解即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(origins = <span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"xx"</span>&#125;, </span><br><span class="line">  method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseWrapper&lt;WxBaseResponse&gt; <span class="title">create</span><span class="params">(HttpServletRequest httpServletRequest)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-直接修改返回的responseHeader"><a href="#c-直接修改返回的responseHeader" class="headerlink" title="c. 直接修改返回的responseHeader"></a>c. 直接修改返回的responseHeader</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, request.getHeader(<span class="string">"origin"</span>));</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"*"</span>);</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="III-小结"><a href="#III-小结" class="headerlink" title="III. 小结"></a>III. 小结</h2><p>上面介绍了两种方式，支持起来都比较简单</p>
<ul>
<li>jsonp: 通过ControllerAdvice拦截Controller，然后继承AbstractJsonpResponseBodyAdvice即可</li>
<li>cors: 通过xml配置或者直接使用 @CrossOrigin注解</li>
</ul>
<h2 id="IV-其他"><a href="#IV-其他" class="headerlink" title="IV. 其他"></a>IV. 其他</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正</p>
<h3 id="扫描关注，java分享"><a href="#扫描关注，java分享" class="headerlink" title="扫描关注，java分享"></a>扫描关注，java分享</h3><p><img src="https://s10.mogucdn.com/mlcdn/c45406/180103_61hi8f7kldkl202fked3k2g0ial1e_640x340.jpg" alt="QrCode"></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
      <i class="fa fa-tags"></i>
			<a href="/hexblog/tags/Java/">Java</a>
		  
      <i class="fa fa-tags"></i>
			<a href="/hexblog/tags/Spring/">Spring</a>
		  
      <i class="fa fa-tags"></i>
			<a href="/hexblog/tags/Jsonp/">Jsonp</a>
		  
      <i class="fa fa-tags"></i>
			<a href="/hexblog/tags/CORS/">CORS</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/hexblog/2018/01/20/Batik渲染png图片异常的bug修复/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Batik渲染png图片异常的bug修复</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/hexblog/2018/01/18/SpringMVC返回图片的几种方式/">
        <span class="next-text nav-default">SpringMVC返回图片的几种方式</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2017 -
    
    2018
    <span class="footer-author">YiHui.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/hexblog/lib/jquery/jquery-3.1.1.min.js"></script>
  

  


<link rel="stylesheet" href="https://netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <script type="text/javascript" src="/hexblog/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/hexblog/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>

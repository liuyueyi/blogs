<!DOCTYPE html><html lang="zh-CN"><head><meta name="google-site-verification" content="PR6S72-htn-N1oDn9ENMcwi5niLKk0uebDzmRS-oivs"><meta property="wb:webmaster" content="320520520031fedd"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好好学习，努力搬砖，天天吃草"><title>Java并发学习之线程池ThreadPoolExecutor的小结 | 一灰灰Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/hexblog/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/hexblog/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/hexblog/favicon.ico"><link rel="bookmark" href="/hexblog/favicon.ico"><link rel="apple-touch-icon" href="/hexblog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/hexblog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java并发学习之线程池ThreadPoolExecutor的小结</h1><a id="logo" href="/hexblog/.">一灰灰Blog</a><p style="font-size:18px" class="description">一灰灰的个人博客网站</p></div><div id="nav-menu"><a href="/hexblog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/hexblog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/hexblog/about/"><i class="fa fa-user"> 关于</i></a><a href="https://zbang.online/webs"><i class="fa fa-rss"> 网站</i></a><hr><br><div id="nav-sub-menu"><a href="/hexblog/categories/技术"><i class="fa fa-right"> 技术</i></a><a href="/hexblog/categories/工作"><i class="fa fa-right"> 工作</i></a><a href="/hexblog/categories/生活"><i class="fa fa-right"> 生活</i></a><a href="/hexblog/categories/杂记"><i class="fa fa-right"> 杂记</i></a></div></div>
<div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="blog"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/hexblog/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java并发学习之线程池ThreadPoolExecutor的小结 <span style="font-size:14px;color:#40759b;font-style:italic;border-bottom: 1px solid #e5e5e5;">&gt;&gt;&gt; by 一灰灰Blog</span></h1><div class="post-meta"><a href="/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/#saveImg" class="saveImg-icon"></a><a href="/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/#comments" class="comment-count"></a><p><span class="date">Mar 06, 2018</span><span><a href="/hexblog/categories/技术/" class="category">技术</a><a href="/hexblog/categories/技术/Java/" class="category">Java</a><a href="/hexblog/categories/技术/Java/并发/" class="category">并发</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="Java并发学习之线程池ThreadPoolExecutor的小结"><a href="#Java并发学习之线程池ThreadPoolExecutor的小结" class="headerlink" title="Java并发学习之线程池ThreadPoolExecutor的小结"></a>Java并发学习之线程池ThreadPoolExecutor的小结</h1><p>本篇博文将带着问题来回顾小结多线程池相关的知识点</p>
<ol>
<li>线程池的几种创建方式</li>
<li>线程池的优点是什么</li>
<li>应用场景</li>
<li>如何使用</li>
<li>实现原理</li>
<li>异常状况怎么处理</li>
<li>线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑</li>
<li>线程池中的线程回收机制</li>
</ol>
<a id="more"></a>
<h2 id="I-什么是线程池"><a href="#I-什么是线程池" class="headerlink" title="I. 什么是线程池"></a>I. 什么是线程池</h2><h3 id="1-通俗讲解"><a href="#1-通俗讲解" class="headerlink" title="1. 通俗讲解"></a>1. 通俗讲解</h3><p>我们先举一个小例子来说一下什么是线程池，以及线程池的工作方式</p>
<p>首先在看一下线程池中提交一个任务的流程图</p>
<p><img src="https://s3.mogucdn.com/mlcdn/c45406/180306_1hd4i1726di8j655200j2e824f355_804x1176.png" alt="流程图"></p>
<p>下面就是实际的case：基本上大家都去过银行，我们就以到银行的柜台上办理业务的流程来说明线程池，我们先假设这里有一个xx银行（这里是广告位，待租😉），总共有8个柜台，平时只开放4个柜台，大厅内总共有20个座位。</p>
<ul>
<li>那么来一个办理业务的，如果开放的四个柜台上，有空的，直接上去办理业务即可</li>
<li>如果四个柜台都在处理业务了，那么办理业务则需要取一个号，到大厅的座位上等着叫号</li>
<li>如果大厅坐满了，银行经理决定开放所有的柜台，那么新来办理的人直接到新的柜台上处理</li>
<li>如果所有柜台都在处理，且大厅也满了，这个时候就告诉新来办理业务的现在已经满载了，你们到xxx地的银行去办理吧（或者回家等下午再来好了）</li>
</ul>
<p>从流程上的对比来看，就很相似了，虽然实际上银行可不会因为人的太多来新增开放柜台的数量，下面简单的将上面的case映射到线程池的成员上</p>
<ul>
<li>4个开放柜台 ： 对应线程池的corePoolSize(核心工作线程数)</li>
<li>8个总柜台：对应线程池的maximumPoolSize(最大工作线程数)</li>
<li>20个座位：对应线程池的workQueue(任务队列)</li>
</ul>
<p>所以线程池中提交一个任务时，优先看核心工作线程数是否已满，未满时，直接创建线程执行；已满，则丢入队列；如果队列也满了，则判断工作线程数是否超过最大数，没有则直接创建线程执行；否则直接“丢弃”这个任务了 （注意这个丢弃不是真的丢弃，其处理策略可以由你自己定义）</p>
<p>上面是基本流程，并没有涉及到工作线程的回收，线程池的状态（比如银行是否打烊了），任务的执行策略等</p>
<h3 id="2-线程池说明"><a href="#2-线程池说明" class="headerlink" title="2. 线程池说明"></a>2. 线程池说明</h3><p>线程池是一种多线程的处理机制，主要是为了减少线程的频繁创建和销毁，从而提升系统效率</p>
<p><strong>使用线程池优点</strong></p>
<ol>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>可以根据系统的承受能力，调整线程池中工作线线程的数量</li>
</ol>
<p><strong>使用线程池场景</strong></p>
<p>我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3</p>
<p>如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升</p>
<p>一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理</p>
<h3 id="3-线程池组成"><a href="#3-线程池组成" class="headerlink" title="3. 线程池组成"></a>3. 线程池组成</h3><p>类定义： <code>java.util.concurrent.ThreadPoolExecutor</code></p>
<p>构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize, // 最大线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime, // 存活时间</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 排队队列</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory, // 创建线程的工作类</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> <span class="comment">// 线程数满，队列满时具体任务策略</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="II-线程池使用"><a href="#II-线程池使用" class="headerlink" title="II. 线程池使用"></a>II. 线程池使用</h2><h3 id="1-构造参数详解"><a href="#1-构造参数详解" class="headerlink" title="1. 构造参数详解"></a>1. 构造参数详解</h3><p>构造参数较多，创建一个线程池，当然首先得搞清楚这些参数是干嘛用的</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>corePoolSize</td>
<td>核心工作线程数</td>
<td>没有任务时，线程池中允许存在的最小空闲线程数 <br> <code>工作线程数 &lt; corePoolSize</code>时，提交任务创建工作线程来执行任务</td>
</tr>
<tr>
<td>maximumPoolSize</td>
<td>最大工作线程数</td>
<td>线程池中允许出现的最大工作线程数量 <br> 当<code>队列满 &amp;&amp; 工作线程数 &lt; maximumPoolSize</code>时，新的队列将创建线程来执行；<br> 如果<code>队列没有边界</code>，那么这个参数没有意义</td>
</tr>
<tr>
<td>workQueue</td>
<td>任务队列</td>
<td>保存待执行任务的阻塞队列；<br> 当 <code>(工作线程数 &gt;= corePoolSize) &amp;&amp; (任务数 &lt; 任务队列长度)</code>时，任务会offer()入队等待</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>工作线程最大空闲时间</td>
<td>当<code>线程数 &gt; corePoolSize</code>时，这个参数表示空闲线程存活时间； <br> 超时的空闲线程，会被回收掉，直到<code>线程数==corePoolSzie</code>; <br> 当<code>allowCoreThreadTimeOut=true</code>时，则超时的核心工作线程也会被回收</td>
</tr>
<tr>
<td>unit</td>
<td>时间单位</td>
<td>keepAliveTime的时间单位</td>
</tr>
<tr>
<td>threadFactory</td>
<td>线程创建工厂</td>
<td>创建线程的工厂类，可以在这里指定创建线程的name，设置守护线程，异常case处理等</td>
</tr>
<tr>
<td>handler</td>
<td>饱和策略执行器</td>
<td>线程池和队列都已满时，新提交任务的处理策略 <br> 默认是Abort(直抛Reject异常)，包括Discard(LIFO规则丢弃)、DiscardOldest(LRU规则丢弃) 以及 CallerRuns(调用者线程执行)，允许自定义执行器</td>
</tr>
</tbody>
</table>
<h3 id="2-线程池的创建"><a href="#2-线程池的创建" class="headerlink" title="2. 线程池的创建"></a>2. 线程池的创建</h3><h4 id="直接调用构造方法创建"><a href="#直接调用构造方法创建" class="headerlink" title="直接调用构造方法创建"></a>直接调用构造方法创建</h4><p>最直观的方式，直接构造方法new一个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报警线程池</span></span><br><span class="line">ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">5</span>, <span class="number">60</span>,</span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(<span class="number">10</span>),</span><br><span class="line">    <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"test-thread"</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 线程创建工厂，主要设置为非守护线程，指定线程名，设置优先级</span></span><br><span class="line"><span class="comment">// 关于这个工厂类，推荐看netty的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadFactory</span><span class="params">(String poolName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == poolName) &#123;</span><br><span class="line">            poolName = <span class="string">"pool"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = poolName + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="利用-Executors创建"><a href="#利用-Executors创建" class="headerlink" title="利用 Executors创建"></a>利用 Executors创建</h4><p>jdk1.5+ 中提供了 <code>java.util.concurrent.Executors</code> 来创建常见的集中线程池方式</p>
<p>关于各种线程池的说明可以参考: <a href="https://my.oschina.net/u/566591/blog/1591056" target="_blank" rel="noopener">Java并发学习之玩转线程池</a></p>
<p>固定大小线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个固定大小的线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作窃取线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建单线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存线程池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时任务线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不可配置线程池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123;</span><br><span class="line">    if (executor == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new DelegatedExecutorService(executor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3. 提交任务"></a>3. 提交任务</h3><p>execute: 提交无须返回值的任务</p>
<p>submit(Runnable): 适用于提交需要返回值的任务</p>
<ul>
<li>相比较于上面的，区别是这个会返回一个 Future<v> 对象，通过调用future.get()可以获取线程的返回值，</v></li>
<li>其中这个方程是线程阻塞的，直到返回了结果之后，才会继续执行下去</li>
</ul>
<h3 id="4-关闭线程池"><a href="#4-关闭线程池" class="headerlink" title="4. 关闭线程池"></a>4. 关闭线程池</h3><p>shutdown(): 有序地关闭线程池，已提交的任务会被执行(包含正在执行和任务队列中的)，但会拒绝新任务</p>
<p>shutdownNow(): 立即(尝试)停止执行所有任务(包含正在执行和任务队列中的)，并返回待执行任务列表</p>
<h2 id="III-线程池实现原理"><a href="#III-线程池实现原理" class="headerlink" title="III. 线程池实现原理"></a>III. 线程池实现原理</h2><h3 id="1-线程池状态"><a href="#1-线程池状态" class="headerlink" title="1. 线程池状态"></a>1. 线程池状态</h3><p>线程池状态流程如下：</p>
<p>RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED</p>
<p>每个状态含义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高3位111，低29位为0 该状态下线程池会接收新提交任务和执行队列任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高3位000，低29位为0 该状态下线程池不再接收新任务，但还会继续执行队列任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高3位001，低29位为0 该状态下线程池不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高3位010，低29位为0 该状态下线程池的所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高3位011，低29位为0 该状态下表明线程池terminated()方法已经调用完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>
<h3 id="2-任务提交逻辑"><a href="#2-任务提交逻辑" class="headerlink" title="2. 任务提交逻辑"></a>2. 任务提交逻辑</h3><p>最开始的流图就说明了任务提交后的流程，针对流程块也就不继续细说，只提一个注意点</p>
<ol>
<li><p>若实际工作线程数workers&lt;核心工作线程数corePoolSize，则创建新工作线程来执行新任务execute(Runable)</p>
</li>
<li><p>若实际工作线程数workers&gt;=核心工作线程数corePoolSize(核心工作线程们都在执行任务)且任务队列workQueue未满，则将任务加入到任务队列workQueue中</p>
</li>
<li><p>若任务队列workQueue已满，则创建新工作线程来执行任务execute()</p>
</li>
<li><p>若实际工作线程数workers&gt;=最大工作线程数maximumPoolSize(所有线程都在执行任务)，此时任务数已饱和，需要根据饱和拒绝策略rejectedExecutionHandler执行相对应的饱和拒绝操作</p>
</li>
</ol>
<p>线程池的总体设计是基于性能考虑，尽可能避免获取全局锁：</p>
<ol>
<li><p>由于创建新线程时都需要获取全局锁，因此步骤1和步骤3必须加锁</p>
</li>
<li><p>为了避免多次获取全局锁(性能伸缩瓶颈)，当实际工作线程数&gt;=核心工作线程数时，之后会执行步骤2(入队时无须获取全局锁)</p>
</li>
</ol>
<p>线程池内线程回收策略</p>
<ol>
<li><p>若实际工作线程数workers&gt;核心工作线程数corePoolSize，回收空闲时间超过keepAliveTime的空闲的非核心线程(减少工作线程数直到&lt;=核心工作线程数即可)</p>
</li>
<li><p>若设置allowCoreThreadTimeOut为true时，则超过keepAliveTime的空闲的核心工作线程也会被回收</p>
</li>
</ol>
<h3 id="3-任务执行"><a href="#3-任务执行" class="headerlink" title="3. 任务执行"></a>3. 任务执行</h3><p>说明，下面两段代码解析来自转载： <a href="https://juejin.im/entry/5a80065f5188257a7f1da4c1?utm_source=gold_browser_extension" target="_blank" rel="noopener">并发番@ThreadPoolExecutor</a></p>
<h4 id="execute-提交任务"><a href="#execute-提交任务" class="headerlink" title="execute() - 提交任务"></a>execute() - 提交任务</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.若实际工作线程数 &lt; 核心工作线程数，会尝试创建一个工作线程去执行该</span></span><br><span class="line"><span class="comment"> * 任务，即该command会作为该线程的第一个任务，即第一个firstTask</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.若任务入队成功，仍需要执行双重校验，原因有两点：</span></span><br><span class="line"><span class="comment"> *      - 第一个是去确认是否需要新建一个工作线程，因为可能存在</span></span><br><span class="line"><span class="comment"> *        在上次检查后已经死亡died的工作线程</span></span><br><span class="line"><span class="comment"> *      - 第二个是可能在进入该方法后线程池被关闭了，</span></span><br><span class="line"><span class="comment"> *        比如执行shutdown()</span></span><br><span class="line"><span class="comment"> *   因此需要再次检查state状态，并分别处理以上两种情况：</span></span><br><span class="line"><span class="comment"> *      - 若线程池中已无可用工作线程了，则需要新建一个工作线程 </span></span><br><span class="line"><span class="comment"> *      - 若线程池已被关闭，则需要回滚入队列(若有必要)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.若任务入队失败(比如队列已满)，则需要新建一个工作线程； </span></span><br><span class="line"><span class="comment"> *      - 若新建线程失败，说明线程池已停止或者已饱和，必须执行拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新任务不允许为空，空则抛出NPE</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctl 为线程池状态控制器，用于保证线程池状态和工作线程数 </span></span><br><span class="line">    <span class="comment">// 低29位为工作线程数量，高3位为线程池状态</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * case1：当实际工作线程数 &lt; 核心工作线程数时</span></span><br><span class="line"><span class="comment">     * 执行方案：会创建一个新的工作线程去执行该任务</span></span><br><span class="line"><span class="comment">     * 注意：此时即使有其他空闲的工作线程也还是会新增工作线程，</span></span><br><span class="line"><span class="comment">     *      直到达到核心工作线程数为止</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 新增工作线程，true表示要对比的是核心工作线程数</span></span><br><span class="line"><span class="comment">         * 一旦新增成功就开始执行当前任务</span></span><br><span class="line"><span class="comment">         * 期间也会通过自旋获取队列任务进行执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 需要重新获取控制器状态，说明新增线程失败</span></span><br><span class="line"><span class="comment">         * 线程失败的原因可能有两种：</span></span><br><span class="line"><span class="comment">         *  - 1.线程池已被关闭，非RUNNING状态的线程池是不允许接收新任务的</span></span><br><span class="line"><span class="comment">         *  - 2.并发时，假如都通过了workerCountOf(c) &lt; corePoolSize校验，但其他线程</span></span><br><span class="line"><span class="comment">         *      可能会在addWorker前先创建出线程，导致workerCountOf(c) &gt;= corePoolSize，</span></span><br><span class="line"><span class="comment">         *      即实际工作线程数 &gt;= 核心工作线程数，此时需要进入case2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * case2：当实际工作线程数&gt;=核心线程数时，新提交任务需要入队</span></span><br><span class="line"><span class="comment">     * 执行方案：一旦入队成功，仍需要处理线程池状态突变和工作线程死亡的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双重校验</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * recheck的目的是为了防止线程池状态的突变 - 即被关闭</span></span><br><span class="line"><span class="comment">         * 一旦线程池非RUNNING状态时，除了从队列中移除该任务(回滚)外</span></span><br><span class="line"><span class="comment">         * 还需要执行任务拒绝策略处理新提交的任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">//执行任务拒绝策略</span></span><br><span class="line">            reject(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 若线程池还是RUNNING状态 或 </span></span><br><span class="line"><span class="comment">         *  队列移除失败(可能正好被一个工作线程拿到处理了)</span></span><br><span class="line"><span class="comment">         * 此时需要确保至少有一个工作线程还可以干活</span></span><br><span class="line"><span class="comment">         * 补充一句：之所有无须与核心工作线程数或最大线程数相比，而只是比较0的原因是</span></span><br><span class="line"><span class="comment">         *          只要保证有一个工作线程可以干活就行，它会自动去获取任务</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 若工作线程都已死亡，需要新增一个工作线程去干活</span></span><br><span class="line"><span class="comment">             * 死亡原因可能是线程超时或者异常等等复杂情况</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 第一个参数为null指的是传入一个空任务，</span></span><br><span class="line"><span class="comment">             * 目的是创建一个新工作线程去处理队列中的剩余任务</span></span><br><span class="line"><span class="comment">             * 第二个参数为false目的是提示可以扩容到最大工作线程数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * case3：一旦线程池被关闭 或者 新任务入队失败(队列已满)</span></span><br><span class="line"><span class="comment">     * 执行方案：会尝试创建一个新的工作线程，并允许扩容到最大工作线程数</span></span><br><span class="line"><span class="comment">     * 注意：一旦创建失败，比如超过最大工作线程数，需要执行任务拒绝策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//执行任务拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然非常少，但是逻辑还是比较多的，创建线程是根据 <code>addWorker</code>方法来实现的，其主要逻辑为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增工作线程需要遵守线程池控制状态规定和边界限制</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core core为true时允许扩容到核心工作线程数，否则为最大工作线程数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 新增成功返回true，失败返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重试标签</span></span><br><span class="line">    retry:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 外部自旋 -&gt; 目的是确认是否能够新增工作线程</span></span><br><span class="line"><span class="comment">     * 允许新增线程的条件有两个：</span></span><br><span class="line"><span class="comment">     *   1.满足线程池状态条件 -&gt; 条件一</span></span><br><span class="line"><span class="comment">     *   2.实际工作线程满足数量边界条件 -&gt; 条件二</span></span><br><span class="line"><span class="comment">     * 不满足条件时会直接返回false，表示新增工作线程失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取原子控制量 - 包含workerCount(实际工作线程数)和runState(线程池状态)</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 条件一.判断是否满足线程池状态条件</span></span><br><span class="line"><span class="comment">         *  1.只有两种情况允许新增线程：</span></span><br><span class="line"><span class="comment">         *    1.1 线程池状态==RUNNING</span></span><br><span class="line"><span class="comment">         *    1.2 线程池状态==SHUTDOWN且firstTask为null同时队列非空</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  2.线程池状态&gt;=SHUTDOWN时不允许接收新任务，具体如下：</span></span><br><span class="line"><span class="comment">         *    2.1 线程池状态&gt;SHUTDOWN，即为STOP、TIDYING、TERMINATED</span></span><br><span class="line"><span class="comment">         *    2.2 线程池状态==SHUTDOWN，但firstTask非空</span></span><br><span class="line"><span class="comment">         *    2.3 线程池状态==SHUTDOWN且firstTask为空，但队列为空</span></span><br><span class="line"><span class="comment">         *  补充：针对1.2、2.2、2.3的情况具体请参加后面的"小问答"环节</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/***</span></span><br><span class="line"><span class="comment">         * 内部自旋 -&gt; 条件二.判断实际工作线程数是否满足数量边界条件</span></span><br><span class="line"><span class="comment">         *   -数量边界条件满足会对尝试workerCount实现CAS自增，否则新增失败</span></span><br><span class="line"><span class="comment">         *   -当CAS失败时会再次重新判断是否满足新增条件：</span></span><br><span class="line"><span class="comment">         *       1.若此期间线程池状态突变(被关闭)，重新判断线程池状态条件和数量边界条件</span></span><br><span class="line"><span class="comment">        *        2.若此期间线程池状态一致，则只需重新判断数量边界条件</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//读取实际工作线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 新增工作线程会因两种实际工作线程数超标情况而失败：</span></span><br><span class="line"><span class="comment">             *  1.实际工作线程数 &gt;= 最大容量</span></span><br><span class="line"><span class="comment">             *  2.实际工作线程数 &gt; 工作线程比较边界数(当前最大扩容数)</span></span><br><span class="line"><span class="comment">             *   -若core = true，比较边界数 = 核心工作线程数</span></span><br><span class="line"><span class="comment">             *   -若core = false，比较边界数 = 最大工作线程数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 实际工作线程计数CAS自增:</span></span><br><span class="line"><span class="comment">             *   1.一旦成功直接退出整个retry循环，表明新增条件都满足</span></span><br><span class="line"><span class="comment">             *   2.因并发竞争导致CAS更新失败的原因有三种: </span></span><br><span class="line"><span class="comment">             *      2.1 线程池刚好已新增一个工作线程</span></span><br><span class="line"><span class="comment">             *        -&gt; 计数增加，只需重新判断数量边界条件</span></span><br><span class="line"><span class="comment">             *      2.2 刚好其他工作线程运行期发生错误或因超时被回收</span></span><br><span class="line"><span class="comment">             *        -&gt; 计数减少，只需重新判断数量边界条件</span></span><br><span class="line"><span class="comment">             *      2.3 刚好线程池被关闭 </span></span><br><span class="line"><span class="comment">             *        -&gt; 计数减少，工作线程被回收，</span></span><br><span class="line"><span class="comment">             *           需重新判断线程池状态条件和数量边界条件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重新读取原子控制量 -&gt; 原因是在此期间可能线程池被关闭了</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 快速检测是否发生线程池状态突变</span></span><br><span class="line"><span class="comment">             *  1.若状态突变，重新判断线程池状态条件和数量边界条件</span></span><br><span class="line"><span class="comment">             *  2.若状态一致，则只需重新判断数量边界条件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是addWorker方法的一个分割线</span></span><br><span class="line"><span class="comment">     * 前面的代码的作用是决定了线程池接受还是拒绝新增工作线程</span></span><br><span class="line"><span class="comment">     * 后面的代码的作用是真正开始新增工作线程并封装成Worker接着执行后续操作</span></span><br><span class="line"><span class="comment">     * PS:虽然笔者觉得这个方法其实可以拆分成两个方法的(在break retry的位置)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录新增的工作线程是否开始工作</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录新增的worker是否成功添加到workers集合中</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新提交的任务和当前线程封装成一个Worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取新创建的实际工作线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检测是否有可执行任务的线程，即是否成功创建了新的工作线程</span></span><br><span class="line"><span class="comment">         *   1.若存在，则选择执行任务</span></span><br><span class="line"><span class="comment">         *   2.若不存在，则需要执行addWorkerFailed()方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 新增工作线程需要加全局锁</span></span><br><span class="line"><span class="comment">             * 目的是为了确保安全更新workers集合和largestPoolSize</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 获得全局锁后，需再次检测当前线程池状态</span></span><br><span class="line"><span class="comment">                 * 原因在于预防两种非法情况：</span></span><br><span class="line"><span class="comment">                 *  1.线程工厂创建线程失败</span></span><br><span class="line"><span class="comment">                 *  2.在锁被获取之前，线程池就被关闭了</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 只有两种情况是允许添加work进入works集合的</span></span><br><span class="line"><span class="comment">                 * 也只有进入workers集合后才是真正的工作线程，并开始执行任务</span></span><br><span class="line"><span class="comment">                 *  1.线程池状态为RUNNING(即rs&lt;SHUTDOWN)</span></span><br><span class="line"><span class="comment">                 *  2.线程池状态为SHUTDOWN且传入一个空任务</span></span><br><span class="line"><span class="comment">                 *  (理由参见：小问答之快速检测线程池状态?) </span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 若线程处于活动状态时，说明线程已启动，需要立即抛出"线程状态非法异常"</span></span><br><span class="line"><span class="comment">                     * 原因是线程是在后面才被start的，已被start的不允许再被添加到workers集合中</span></span><br><span class="line"><span class="comment">                     * 换句话说该方法新增线程时，而线程是新的，本身应该是初始状态(new)</span></span><br><span class="line"><span class="comment">                     * 可能出现的场景：自定义线程工厂newThread有可能会提前启动线程</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//由于加锁，所以可以放心的加入集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//更新最大工作线程数，由于持有锁，所以无需CAS</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//确认新建的worker已被添加到workers集合中  </span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//千万不要忘记主动解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 一旦新建工作线程被加入工作线程集合中，就意味着其可以开始干活了</span></span><br><span class="line"><span class="comment">             * 有心的您肯定发现在线程start之前已经释放锁了</span></span><br><span class="line"><span class="comment">             * 原因在于一旦workerAdded为true时，说明锁的目的已经达到</span></span><br><span class="line"><span class="comment">             * 根据最小化锁作用域的原则，线程执行任务无须加锁，这是种优化</span></span><br><span class="line"><span class="comment">             * 也希望您在使用锁时尽量保证锁的作用域最小化</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 启动线程，开始干活啦</span></span><br><span class="line"><span class="comment">                 * 若您看过笔者的"并发番<span class="doctag">@Thread</span>一文通"肯定知道start()后，</span></span><br><span class="line"><span class="comment">                 * 一旦线程初始化完成便会立即调用run()方法</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                t.start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//确认该工作线程开始干活了</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若新建工作线程失败或新建工作线程后没有成功执行，需要做新增失败处理</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果表明新建的工作线程是否已启动执行</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>小问：快速检测线程状态时，情况1.2、2.1、2.3的意义是什么？</strong></p>
<p>小答：在阐明这个问题之前，我们先明确两个知识点：</p>
<ol>
<li><p>新增Worker的目的是处理任务，任务来源分初始任务和队列任务(即剩余的待处理任务)</p>
</li>
<li><p>线程池在非RUNNING状态下是不允许接收新任务的，换句话说您都要下班了，难道还想接新需求？</p>
</li>
</ol>
<p>针对2.1 - &gt; 线程池状态==SHUTDOWN，但firstTask！= null，不允许新增Worker<br>当线程池状态为SHUTDOWN时，由于不允许接收新任务，因此一旦firstTask！= null需要直接拒绝</p>
<p>针对2.2 - &gt; 线程池状态==SHUTDOWN，且firstTask == null， 但队列为空， 不允许新增Worker<br>当firstTask为null时，说明调用addWorker()目的不是为了处理新增任务<br>那么其目的应该是为了处理剩余任务，即队列中的任务，而一旦队列为空，那也没必要新增Worker了</p>
<p>针对1.2 - &gt; 若线程池状态==SHUTDOWN，必须满足firstTask为null且队列非空，才允许新增Worker<br>当线程池状态为SHUTDOWN时(调用shutdown())，此时不允许接收新任务，因此firstTask必须为null<br>但需要处理剩余任务，因此队列必须非空，否则新增的工作线程就无任务可做，那就没意义了<br>结论：传入一个空任务的目的是为了新增工作线程去处理任务队列中的剩余任务</p>
<h3 id="3-Worker类详解"><a href="#3-Worker类详解" class="headerlink" title="3. Worker类详解"></a>3. Worker类详解</h3><p>worker包装了任务的调度，用于封装工作线程和任务并管理工作线程的中断状态等功能</p>
<blockquote>
<p>由于工作线程和worker实例是一对一的关系，因为可以简单的理解工作线程等价于worker，尤其是谈及数量时，比如创建工作线程实际上就是创建一个worker</p>
</blockquote>
<p>线程在线程池执行任务的工作流程：</p>
<ol>
<li><p>工作线程开始执行前，需先对worker加锁，任务完成解锁</p>
</li>
<li><p>任务执行前后分别执行beforeExecute()和afterExecute()方法</p>
</li>
<li><p>执行中遇到异常会向外抛出，线程是否死亡取决于您对于异常的处理</p>
</li>
<li><p>每个任务执行完后，当前工作线程任务完成数自增，同时会循环调用getTask()从任务队列中反复获取任务并执行，无任务可执行时线程会阻塞在该方法上</p>
</li>
<li><p>当工作线程因各种理由退出时，会执行processWorkerExit()回收线程(核心是将该worker从workers集合中移除，注意之前worker已经退出任务循环，因此已经不再做工了，从集合移除后就方便gc了)</p>
</li>
</ol>
<p><strong>问：worker中断如何控制的</strong></p>
<ol>
<li><p>当工作线程真正开始执行之前，不允许被中断</p>
</li>
<li><p>当工作线程正在执行任务时，不允许被中断</p>
</li>
<li><p>当工作线程正等待从任务队列中获取任务getTask()时才能被中断</p>
</li>
<li><p>调用interruptIdleWorkers()中断空闲线程时必须先获得worker锁</p>
</li>
</ol>
<p><strong>问：为什么Worker不被设计成可重入锁？</strong></p>
<p>由于在动态控制方法中可能会中断线程，比如调用interruptIdleWorkers()，由此该方法在执行interrupt()之前会调用worker.tryLock()，若此时允许重入，就会导致线程被意外中断，这跟当工作线程正在执行任务时，不允许被中断准则是相违背的</p>
<h2 id="IV-问题解答"><a href="#IV-问题解答" class="headerlink" title="IV. 问题解答"></a>IV. 问题解答</h2><h3 id="1-如何创建线程池"><a href="#1-如何创建线程池" class="headerlink" title="1. 如何创建线程池"></a>1. 如何创建线程池</h3><p>直接根据构造方法创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor#ThreadPoolExecutor(int, int, long,</span><br><span class="line">    java.util.concurrent.TimeUnit, </span><br><span class="line">    java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt;,</span><br><span class="line">    java.util.concurrent.ThreadFactory,</span><br><span class="line">    java.util.concurrent.RejectedExecutionHandler)</span><br></pre></td></tr></table></figure>
<p>利用 Executors 创建线程池</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.Executors#newFixedThreadPool(int)</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#newWorkStealingPool(int)</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#newSingleThreadExecutor()</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#newCachedThreadPool()</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#newSingleThreadScheduledExecutor()</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#newScheduledThreadPool(int)</span><br><span class="line"></span><br><span class="line">java.util.concurrent.Executors#unconfigurableExecutorService</span><br></pre></td></tr></table></figure>
<h3 id="2-线程池的适用场景"><a href="#2-线程池的适用场景" class="headerlink" title="2. 线程池的适用场景"></a>2. 线程池的适用场景</h3><p><strong>优点</strong></p>
<p>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务<br>可以根据系统的承受能力，调整线程池中工作线线程的数量</p>
<p><strong>使用线程池场景</strong></p>
<p>我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3</p>
<p>如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升</p>
<p>一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理</p>
<h3 id="3-如何使用线程池"><a href="#3-如何使用线程池" class="headerlink" title="3. 如何使用线程池"></a>3. 如何使用线程池</h3><p>创建线程池，提交任务</p>
<ul>
<li>execute 适用于提交没有返回结果的任务</li>
<li>submit 适用于提交有返回结果的任务， 返回一个Futrure的包装类</li>
</ul>
<h3 id="4-线程池实现原理-amp-任务提交后的流程"><a href="#4-线程池实现原理-amp-任务提交后的流程" class="headerlink" title="4. 线程池实现原理 &amp; 任务提交后的流程"></a>4. 线程池实现原理 &amp; 任务提交后的流程</h3><p>在实现原理中会穿插上任务提交后的流程，所以就放在一起了</p>
<p>首先从提交一个任务开始：</p>
<ul>
<li>首先判断工作线程数是否小于核心工作线程数，是则直接创建工作线程执行</li>
<li>否，则将任务丢入任务队列中</li>
<li>若任务队列已满，且工作线程数 &lt; 最大工作线程数，则直接创建工作线程执行任务</li>
<li>若队列满，且工作线程数达到最大值，则采用拒绝任务策略</li>
</ul>
<p>其中上面的任务进队or创建线程执行，都需要关注线程池的状态，每个状态对应的原则</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
<th>限制</th>
</tr>
</thead>
<tbody>
<tr>
<td>RUNNING</td>
<td>运行状态</td>
<td>线程池会接收新提交任务和执行队列任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>关闭状态</td>
<td>线程池不再接收新任务，但还会继续执行队列任务</td>
</tr>
<tr>
<td>STOP</td>
<td>停止状态</td>
<td>不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>整理状态</td>
<td>所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated()</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态</td>
<td>线程池terminated()方法已经调用完成</td>
</tr>
</tbody>
</table>
<p>接着上面，工作线程执行完毕之后，会尝试从任务队列中获取任务来执行，如果队列为空，则阻塞；此时工作线程空闲</p>
<p>根据工作线程的回收机制</p>
<ul>
<li>允许回收核心工作线程时，将所有空闲时间大于keepAliveTime的线程回收掉</li>
<li>不允许回收核心工作线程，回收空闲时间大于keepAliveTime的线程，知道工作线程数量为核心工作线程数</li>
</ul>
<h3 id="5-异常状况处理"><a href="#5-异常状况处理" class="headerlink" title="5. 异常状况处理"></a>5. 异常状况处理</h3><p><strong>submit()异常处理</strong></p>
<ol>
<li>异常会保存在Future对象的ExecutionException中，可以在调用get()使用try-catch方式捕获，有N个任务有异常就会抛出来N个异常，但不会终止当前工作线程</li>
<li>单独设置UncaughtExceptionHandler没卵用，但结合(3)使用就有效</li>
<li>允许在submit()方法内部用try-catch捕获该异常，同样不会终止当前线程</li>
<li>若想在内部处理异常，还可以重写afterExecute()方法，</li>
</ol>
<p><strong>execute()异常处理</strong></p>
<ol>
<li>默认会在execute()方法内部直接抛出异常，注意这不会中断线程池运行，但会终止当前工作线程，并重新创建新的工作线程执行该任务</li>
<li>允许在execute()方法内部用try-catch捕获该异常，好处是不会终止当前线程并重新创建一个新的线程了</li>
<li>重写afterExecute()方法</li>
<li>还可以设置UncaughtExceptionHandler</li>
</ol>
<p>一个实例如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(), </span><br><span class="line">    <span class="comment">//我们自定义一个线程工厂和重写线程的setUncaughtExceptionHandler方法</span></span><br><span class="line">    <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(Thread.currentThread().getThreadGroup(), r, <span class="string">"thread-"</span></span><br><span class="line">                    + (threadNumber.getAndIncrement()));</span><br><span class="line">            thread.setUncaughtExceptionHandler((t,e) -&gt; System.out.println(e));</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="6-线程池关闭"><a href="#6-线程池关闭" class="headerlink" title="6. 线程池关闭"></a>6. 线程池关闭</h3><p>关闭线程池主要有两种方式，两者的区别是：</p>
<ul>
<li>shutdown() : 队列剩余任务全部执行完毕再终止</li>
<li>shutdownNow() : 放弃执行队列剩余任务，但会将它们返回</li>
</ul>
<p>两者的共性在于：</p>
<ul>
<li>正在执行中的任务会继续执行，不会被终止或放弃</li>
<li>新提交的任务会被直接拒绝</li>
</ul>
<h2 id="V-其他"><a href="#V-其他" class="headerlink" title="V. 其他"></a>V. 其他</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/wolf909867753/article/details/77500625" target="_blank" rel="noopener">Java-线程池专题（什么是线程池，如何使用，为什么要用）</a></li>
<li><a href="https://juejin.im/entry/5a80065f5188257a7f1da4c1?utm_source=gold_browser_extension" target="_blank" rel="noopener">并发番@ThreadPoolExecutor</a></li>
</ul>
<h3 id="个人博客：-Z-blog"><a href="#个人博客：-Z-blog" class="headerlink" title="个人博客： Z+|blog"></a>个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener">Z+|blog</a></h3><p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener">小灰灰Blog</a></p>
<h3 id="扫描关注"><a href="#扫描关注" class="headerlink" title="扫描关注"></a>扫描关注</h3><p><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode"></p>
</div><div class="tags"><a href="/hexblog/tags/Java/">Java</a><a href="/hexblog/tags/并发/">并发</a><a href="/hexblog/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a></div><div style="text-align:center"><br><button style="color:red;background-color: #f44336;border: none;border-radius: 8px;color: white;padding: 10px 30px;text-align: center;text-decoration: none;font-size: 16px;" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">打赏</button><br><span style="display: block;color: #9d9d9d;font: 14px/2 &amp;quot;Microsoft Yahei&amp;quot;">如果觉得我的文章对您有帮助，请随意打赏。</span><br><div id="QR" style="display: none; margin-top: 20px;" class="row"><div id="wechat" style="display: inline-block;width:44%;margin-left:6%;text-align:center;"><a href="javascript:void(0)"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png" alt="WeChat Pay" style="width:80%;height:80%;max-height:200px;max-width:200px"></a><p style="text-align:center">微信打赏</p></div><div id="alipay" style="display: inline-block;width:44%;text-align:center"><a href="javascript:void(0)"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png" alt="Alipay" style="width:80%;height:80%;max-height:200px;max-width:200px"></a><p style="text-align:center">支付宝打赏</p></div></div></div><div class="article-footer-copyright"><url><li>版权声明：本文由<b> 一灰灰 </b><span>发表于</span><a href="/hexblog/"> 一灰灰Blog </a></li><li>转载声明：自由转载-非商用-非衍生-保持署名，非商业转载请注明作者及出处，商业转载请联系作者本人。</li><li id="blogTitleCp">文章标题：<a>Java并发学习之线程池ThreadPoolExecutor的小结</a></li><li>文章链接：<a id="blogLink"></a><script>var blogLink = decodeURI(window.location.href);
var doc = document.getElementById('blogLink');
doc.setAttribute("href", blogLink);
doc.innerHTML=blogLink;</script></li></url></div><div class="post-share"><div><script src="https://s3.mogucdn.com/mlcdn/c45406/1520387600580_dom-to-image.min.js" charset="utf-8"></script><script>var url;
console.log('start--->',(new Date()).valueOf());
domtoimage.toPng(document.getElementsByClassName('layout-l')[0])
    .then(function (dataUrl) {
        url = dataUrl;
        console.log('end--->',(new Date()).valueOf());
     })
    .catch(function (error) {});
function link() {
    var title = document.getElementById('blogTitleCp').children[0].innerText;
    console.log("blog title: ", title);
    window.open().document.write('<html><head><title>'+ title + '</title></head><body><div style=\'text-align:center\' ><a download="一灰灰Blog博文_' + title + '.png" href="'+url+'"><img title="点击下载博文图：' + title + '" src="' + url + '" /></a></div></body></html>');
}</script><span style="float:center;font-size:20px;font-weight:solid;color:gray">渲染：</span><a id="saveImg" href="javascript:void(0)" onclick="link()" class="save_img">保存图片</a></div><div id="share" class="soshm social-share"><span style="float:center;font-size:20px;font-weight:solid;color:gray">分享：</span></div></div><div class="post-nav"><a href="/hexblog/2018/03/08/JQuery-实战笔记一/" class="pre">JQuery 实战笔记一</a><a href="/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/" class="next">7. 报警系统QuickAlarm之默认报警规则扩展</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zNDY0OC8xMTE4NQ=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei"> 文章目录</i><a title="点击展开或隐藏分类" href="javascript:void(0)" onclick="showOrHide('toc', 'toc-expand', 'none')"><span id="toc-expand" style="font-size:12px;color:red"> 点击收起 </span></a></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java并发学习之线程池ThreadPoolExecutor的小结"><span class="toc-text">Java并发学习之线程池ThreadPoolExecutor的小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-什么是线程池"><span class="toc-text">I. 什么是线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-通俗讲解"><span class="toc-text">1. 通俗讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-线程池说明"><span class="toc-text">2. 线程池说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-线程池组成"><span class="toc-text">3. 线程池组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-线程池使用"><span class="toc-text">II. 线程池使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-构造参数详解"><span class="toc-text">1. 构造参数详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-线程池的创建"><span class="toc-text">2. 线程池的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#直接调用构造方法创建"><span class="toc-text">直接调用构造方法创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-Executors创建"><span class="toc-text">利用 Executors创建</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-提交任务"><span class="toc-text">3. 提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-关闭线程池"><span class="toc-text">4. 关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#III-线程池实现原理"><span class="toc-text">III. 线程池实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-线程池状态"><span class="toc-text">1. 线程池状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-任务提交逻辑"><span class="toc-text">2. 任务提交逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-任务执行"><span class="toc-text">3. 任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-提交任务"><span class="toc-text">execute() - 提交任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Worker类详解"><span class="toc-text">3. Worker类详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IV-问题解答"><span class="toc-text">IV. 问题解答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-如何创建线程池"><span class="toc-text">1. 如何创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-线程池的适用场景"><span class="toc-text">2. 线程池的适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-如何使用线程池"><span class="toc-text">3. 如何使用线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-线程池实现原理-amp-任务提交后的流程"><span class="toc-text">4. 线程池实现原理 &amp; 任务提交后的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-异常状况处理"><span class="toc-text">5. 异常状况处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-线程池关闭"><span class="toc-text">6. 线程池关闭</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V-其他"><span class="toc-text">V. 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#个人博客：-Z-blog"><span class="toc-text">个人博客： Z+|blog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扫描关注"><span class="toc-text">扫描关注</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><a href="/hexblog/about/"><i class="fa fa-user"> 一灰灰Blog</i></a><a title="点击展开或收起条目" href="javascript:void(0)" onclick="showOrHide('info-list', 'info-list-expand', 'none')"><span id="info-list-expand" style="font-size:12px;color:red"> 点击收起 </span></a></div><ul class="post-list info-list"><li style="text-align:center"><img src="//s3.mogucdn.com/mlcdn/c45406/170419_637cgff527i8k9k8h512iaf36cdia_600x600.jpg" style="max-width:80px;radius:80px"/><p style="text-align:center">好好学习，天天搬砖</p><hr style="height:0.1px;border:none;border-top:1px dashed #0066CC;"/></li><li class="post-list-item"><a href="mailto:bangzewu@126.com" title="126邮箱" class="post-list-link"><i class="fa fa-email">  bangzewu@126.com</i></a></li><li class="post-list-item"><a href="//github.com/liuyueyi" title="Git主页" target="_blank" class="post-list-link"><i class="fa fa-github">  github.com/liuyueyi</i></a></li><li class="post-list-item"><a href="" title="QQ" class="post-list-link"><i class="fa fa-you">  QQ:3302797840</i></a></li><li class="post-list-item"><a href="//weibo.com/p/1005052169825577/home" title="微博主页" target="_blank" class="post-list-link"><i class="fa fa-weibo">  微博:小灰灰Blog</i></a></li><li class="post-list-item"><i class="fa fa-weixin">  微信公众号</i></li><li style="text-align:center" class="post-list-item"><img src="https://s10.mogucdn.com/mlcdn/c45406/171229_1cgld3igbelkbc70cd8af1j3809kb_150x150.jpg"/></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章(10)</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/18/Java学习之NIO相关/">Java学习之NIO相关</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/18/Java学习之IO相关/">Java学习之IO相关</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/15/JVM学习之垃圾回收机制/">JVM学习之垃圾回收机制</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/15/熔断Hystrix使用尝鲜/">熔断Hystrix使用尝鲜</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/13/JVM学习之内存结构/">JVM学习之内存结构</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/13/JVM学习之Java类的加载机制/">JVM学习之Java类的加载机制</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/12/Chrome插件之DomToImage实现/">Chrome插件之DomToImage实现</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/08/JQuery-实战笔记一/">JQuery 实战笔记一</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/">Java并发学习之线程池ThreadPoolExecutor的小结</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/">7. 报警系统QuickAlarm之默认报警规则扩展</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类(43)</i><a title="点击展开或隐藏分类" href="javascript:void(0)" onclick="showOrHide('category-list-child', 'category-expand', 'block')"><span id="category-expand" style="font-size:12px;color:red"> 点击展开 </span></a></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/工作/">工作</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/工作/技术尝鲜/">技术尝鲜</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/">技术</a><span class="category-list-count">39</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Android/">Android</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Android/一封/">一封</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/BugFix/">BugFix</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/BugFix/Java/">Java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/BugFix/Java/Image/">Image</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/">Java</a><span class="category-list-count">18</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/IO/">IO</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/JDK/">JDK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/JVM/">JVM</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/JavaWeb/">JavaWeb</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/Spring/">Spring</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Java/并发/">并发</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Quick系列项目/">Quick系列项目</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Quick系列项目/QuickAlarm/">QuickAlarm</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Quick系列项目/QuickSpi/">QuickSpi</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Shell/">Shell</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Shell/Git/">Git</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Shell/Git/Maven/">Maven</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Shell/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/Shell/环境搭建/">环境搭建</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/前端/">前端</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/前端/Chrome/">Chrome</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/技术/前端/Jquery/">Jquery</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/杂记/">杂记</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/杂记/idea/">idea</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/生活/">生活</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/生活/随笔/">随笔</a><span class="category-list-count">1</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签墙(43)</i><a title="点击展开或隐藏分类" href="javascript:void(0)" onclick="showOrHide('tagcloud', 'tag-expand', 'none')"><span id="tag-expand" style="font-size:12px;color:red"> 点击收起 </span></a></div><div class="tagcloud"><!--!= tagcloud({min_font: 15, max_font: 15, amount: 100, orderby: 'count'})--><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Filter/">Filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/日记/">日记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Android/">Android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/一封/">一封</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/RelativeLayout/">RelativeLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/CountDownTimer/">CountDownTimer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Bugfix/">Bugfix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Java/">Java</a><span class="tag-list-count">32</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/batik/">batik</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Png/">Png</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Gitbook/">Gitbook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Centos/">Centos</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/教程/">教程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Chrome/">Chrome</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/工具/">工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/并发/">并发</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ForkJoin/">ForkJoin</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/笔记/">笔记</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Reflect/">Reflect</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Jquery/">Jquery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ClassLoader/">ClassLoader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/双亲委托/">双亲委托</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/内存结构/">内存结构</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/垃圾回收/">垃圾回收</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JavaWeb/">JavaWeb</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Servlet/">Servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JDK/">JDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Initialize/">Initialize</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/File/">File</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ScheduledExecutorService/">ScheduledExecutorService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/clone/">clone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/beancopy/">beancopy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/配置/">配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Redis/">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/distributeLock/">distributeLock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/SPI/">SPI</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/整体设计/">整体设计</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/使用手册/">使用手册</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Spring/">Spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/RequestParam/">RequestParam</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Jsonp/">Jsonp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/CORS/">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Exception/">Exception</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Response/">Response</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Github/">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Maven/">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/BugFix/">BugFix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/BufferedImage/">BufferedImage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Jpeg/">Jpeg</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Okhttp/">Okhttp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/QuickAlarm/">QuickAlarm</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/hystrix/">hystrix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/随笔/">随笔</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/IO/">IO</a><span class="tag-list-count">2</span></li></ul></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档(43)</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/03/">三月 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/02/">二月 2018</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/01/">一月 2018</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2017/12/">十二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2017/09/">九月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2017/05/">五月 2017</a><span class="archive-list-count">4</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 更多链接</i></div><ul style="padding-top:10px"></ul><li style="padding-top:2px"><a href="//my.oschina.net/u/566591" title="开源中国" target="_blank">开源中国</a></li><li style="padding-top:2px"><a href="//blog.csdn.net/liuyueyi25" title="CSDN" target="_blank">CSDN</a></li><li style="padding-top:2px"><a href="//www.jianshu.com/u/5902ab08e670" title="简书" target="_blank">简书</a></li><li style="padding-top:2px"><a href="//juejin.im/user/5a2a4b095188252ae93adbbf/posts" title="掘金" target="_blank">掘金</a></li><li style="padding-top:2px"><a href="//www.toutiao.com/c/user/69862071663/#mid=1579653107239950" title="头条" target="_blank">头条</a></li><li style="padding-top:2px"><a href="//cloud.tencent.com/developer/column/1847" title="云+" target="_blank">云+</a></li><li style="padding-top:2px"><a href="//github.com/liuyueyi" title="Github" target="_blank">Github</a></li><li style="padding-top:2px"><a href="//gitee.com/liuyueyi" title="Gitee" target="_blank">Gitee</a></li></div><div class="widget"><div class="widget-title"><i onclick="var qr = document.getElementById('qrcode'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}" style="cursor:pointer" class="fa fa-hit"> 点赞(点击展开)</i></div><ul id="qrcode" style="display:none;" class="post-list"><br/><li style="text-align:center" class="post-list-item"><a href="javascript:void(0)" target="_blank"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png" alt="WeChat Pay" style="width:75%"/><br/><p style="text-align:center">微信打赏</p></a></li><li style="text-align:center" class="post-list-item"><a href="javascript:void(0)" target="_blank"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png" alt="Alipay" style="width:75%"/><br/><p style="text-align:center">支付宝打赏</p></a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="https://zbang.online/webs"><img src="//s3.mogucdn.com/mlcdn/c45406/170419_637cgff527i8k9k8h512iaf36cdia_600x600.jpg" style="max-width: 44px;border-radius:44px"></a></p><p><a href="https://github.com/liuyueyi" target="_blank">GitHub</a> |  <a href="mailto:bangzewu@126.com">email</a> |  <a href="/hexblog/about/">关于 |</a><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p></p><p><span> Copyright &copy;<a href="/hexblog/." rel="nofollow">YiHui.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?028d9e53f991d9739ecc7cc42e13c500";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/hexblog/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/hexblog/js/toctotop.js?v=2.0.1" async></script><script src="https://s3.mogucdn.com/mlcdn/c45406/1520407228303_social-share.min.js" charset="utf-8"></script><link rel="stylesheet" href="https://s3.mogucdn.com/mlcdn/c45406/1518422561591_share.min.css"><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body><script type="text/javascript" src="/hexblog/js/common.js?v=2.0.1" async></script></html>
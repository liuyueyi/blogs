<!DOCTYPE html><html lang="zh-CN"><head><meta property="wb:webmaster" content="320520520031fedd"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="好好学习，努力搬砖，天天吃草"><title>3. SPI框架实现之旅三：实现说明 | Z+ | Blog</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/hexblog/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/hexblog/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/hexblog/favicon.ico"><link rel="bookmark" href="/hexblog/favicon.ico"><link rel="apple-touch-icon" href="/hexblog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/hexblog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">3. SPI框架实现之旅三：实现说明</h1><a id="logo" href="/hexblog/.">Z+ | Blog</a><p style="font-size:18px" class="description">小灰灰的个人博客网站</p></div><div id="nav-menu"><a href="/hexblog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/hexblog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/hexblog/about/"><i class="fa fa-user"> 关于</i></a><a href="https://zbang.online/webs"><i class="fa fa-rss"> 网站</i></a></div>
<div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="blog"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/hexblog/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">3. SPI框架实现之旅三：实现说明</h1><div class="post-meta"><a href="/hexblog/2017/05/29/SPI框架实现之旅三：实现说明/#comments" class="comment-count"></a><p><span class="date">May 29, 2017</span><span><a href="/hexblog/categories/Quick系列项目/" class="category">Quick系列项目</a><a href="/hexblog/categories/Quick系列项目/QuickSpi/" class="category">QuickSpi</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="实现说明"><a href="#实现说明" class="headerlink" title="实现说明"></a>实现说明</h1><blockquote>
<p>前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 <code>SpiLoader</code>中的部分实现； 本篇则主要介绍<code>SpiLoader</code>类的实现</p>
</blockquote>
<p>类图结构如下：</p>
<p><img src="https://static.oschina.net/uploads/img/201705/27183336_TOny.png" alt="https://static.oschina.net/uploads/img/201705/27183336_TOny.png"></p>
<a id="more"></a>
<h2 id="SpiLoader-全解析"><a href="#SpiLoader-全解析" class="headerlink" title="SpiLoader 全解析"></a>SpiLoader 全解析</h2><blockquote>
<p>spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等</p>
</blockquote>
<h3 id="1-获取spiLoader对象"><a href="#1-获取spiLoader对象" class="headerlink" title="1. 获取spiLoader对象"></a>1. 获取spiLoader对象</h3><blockquote>
<p><code>SpiLoader</code> 是一个泛型对象，每个SPI接口，对应一个<code>SpiLoader&lt;T&gt;</code> 对象，我们提供了一个静态方法来获取这个对象</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* spiLoader缓存, 其中key为 spi接口, value为对应的Loader对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, SpiLoader&lt;?&gt;&gt; loaderCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">SpiLoader&lt;T&gt; <span class="title">load</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> == type) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"common cannot be null..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"common class:"</span> + type + <span class="string">" must be interface!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!withSpiAnnotation(type)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"common class:"</span> + type + <span class="string">" must have the annotation of @Spi"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   SpiLoader&lt;T&gt; spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type);</span><br><span class="line">   <span class="keyword">if</span> (spiLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">       loaderCache.putIfAbsent(type, <span class="keyword">new</span> SpiLoader&lt;&gt;(type));</span><br><span class="line">       spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> spiLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>上面有几个校验，前一篇已经说明，不再赘述</li>
<li>上面新建对象，不是线程安全的</li>
</ul>
<h3 id="2-新建-SpiLoader对象"><a href="#2-新建-SpiLoader对象" class="headerlink" title="2. 新建 SpiLoader对象"></a>2. 新建 <code>SpiLoader</code>对象</h3><blockquote>
<p>创建对象，主要会初始化选择器</p>
</blockquote>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SpiLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 初始化默认的选择器, 为保留项目, 必然会提供的服务</span></span><br><span class="line">   selectorInstanceCacheMap.putIfAbsent(DefaultSelector.class, DEFAULT_SELECTOR);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.spiInterfaceType = type;</span><br><span class="line">   initSelector();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Spi ano = spiInterfaceType.getAnnotation(Spi.class);</span><br><span class="line">   <span class="keyword">if</span> (ano == <span class="keyword">null</span>) &#123;</span><br><span class="line">       currentSelector = initSelector(DefaultSelector.class);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       currentSelector = initSelector(ano.selector());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   Method[] methods = <span class="keyword">this</span>.spiInterfaceType.getMethods();</span><br><span class="line">   currentMethodSelector = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   SelectorWrapper temp;</span><br><span class="line">   <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">       <span class="keyword">if</span> (!method.isAnnotationPresent(SpiAdaptive.class)) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector());</span><br><span class="line">       <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       currentMethodSelector.put(method.getName(), temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SelectorWrapper <span class="title">initSelector</span><span class="params">(Class&lt;? extends ISelector&gt; clz)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 优先从选择器缓存中获取类型对应的选择器</span></span><br><span class="line">   <span class="keyword">if</span> (selectorInstanceCacheMap.containsKey(clz)) &#123;</span><br><span class="line">       <span class="keyword">return</span> selectorInstanceCacheMap.get(clz);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       ISelector selector = clz.newInstance();</span><br><span class="line">       Class paramClz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       Type[] types = clz.getGenericInterfaces();</span><br><span class="line">       <span class="keyword">for</span> (Type t : types) &#123;</span><br><span class="line">           <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">               paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Assert.check(paramClz != <span class="keyword">null</span>);</span><br><span class="line">       SelectorWrapper wrapper = <span class="keyword">new</span> SelectorWrapper(selector, paramClz);</span><br><span class="line">       selectorInstanceCacheMap.putIfAbsent(clz, wrapper);</span><br><span class="line">       <span class="keyword">return</span> wrapper;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal selector defined! yous:"</span> + clz);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><ul>
<li>持有一个选择器缓存列表，<code>selectorInstanceCacheMap</code><ul>
<li>保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在</li>
<li>不做成全局唯一的原因是尽量隔离, 比如  <code>ParamsSelector</code> 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类</li>
</ul>
</li>
<li>类选择器 + 方法选择器<ul>
<li><code>currentSelector</code> ： 类选择器, 解析 <code>@Spi</code> 注解获取，适用于静态选择 + 动态选择两种使用方式</li>
<li><code>currentMethodSelector</code> : 方法选择器，解析 <code>@SpiAdaptive</code> 注解获取， 仅适用于动态选择SPI实现的方式</li>
<li>优先级： 方法上定义的选择器 由于  类上定义的选择器； 方法上未定义时，默认使用类定义的选择器</li>
</ul>
</li>
</ul>
<h3 id="3-静态使用"><a href="#3-静态使用" class="headerlink" title="3. 静态使用"></a>3. 静态使用</h3><blockquote>
<p>静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回</p>
</blockquote>
<h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据传入条件, 选择具体的spi实现类</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* 这里要求conf的类型和选择器的参数类型匹配, 否则会尝试使用默认的选择器补救, 若补救失败, 则抛异常</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> conf</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> NoSpiMatchException</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getService</span><span class="params">(Object conf)</span> <span class="keyword">throws</span> NoSpiMatchException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (spiImplClassCacheMap == <span class="keyword">null</span> || spiImplClassCacheMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">       loadSpiService();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!currentSelector.getConditionType().isAssignableFrom(conf.getClass())) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数类型不匹配时, 判断是否可以根据默认的选择器来获取</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (conf <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">           <span class="keyword">return</span> (T) DEFAULT_SELECTOR.getSelector().selector(spiImplClassCacheMap, conf);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数类型完全不匹配, 则抛参数异常</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"conf spiInterfaceType should be sub class of ["</span> + currentSelector.getConditionType() + <span class="string">"] but yours:"</span> + conf.getClass());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> (T) currentSelector.getSelector().selector(spiImplClassCacheMap, conf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-2"><a href="#说明-2" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p><code>spiImplClassCacheMap</code> </p>
<p> spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑</p>
</li>
<li><p>校验</p>
<p>校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行</p>
<p>当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的）</p>
</li>
<li><p>静态使用方式，使用类定义选择器 : <code>currentSelector</code></p>
<ul>
<li><p>静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的</p>
</li>
<li><p>静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释</p>
<pre><code>IPrint 是一个Spi接口， 有两个实现   FilePrint,   ConsolePrint
假设 `currentSelector=DefaultSelector`， 方法  methodA 上定义的是  ParamsSelector 时

静态使用方式，获取一个spi实现，希望在所有的spi接口使用处，都输出到文件，用户根据 `FilePrint` 选择  FilePrint 这个类来执行具体的输出逻辑， 如果在调用 methodA 方法执行时， 假设根据  ParamsSelector 判断， ConsolePrint 才满足这儿条件，这是相当于在具体实现时，换成了另一个 ConsolePrint, 这下子就与我们的初衷背离了（如果目标是想实现这个场景，显然动态适配的方式才是正确的使用姿势）
</code></pre></li>
</ul>
</li>
<li><p>loadService 的逻辑后面详细说明</p>
</li>
</ol>
<h3 id="4-动态使用"><a href="#4-动态使用" class="headerlink" title="4. 动态使用"></a>4. 动态使用</h3><blockquote>
<p>动态使用区别于静态的直接确定实现类， 通过<code>getService</code> 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行</p>
</blockquote>
<h4 id="设计的出发点"><a href="#设计的出发点" class="headerlink" title="设计的出发点"></a>设计的出发点</h4><p>可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？</p>
<p>考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的</p>
<p>最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回</p>
<h4 id="实现如下"><a href="#实现如下" class="headerlink" title="实现如下"></a>实现如下</h4><p>和静态实现的逻辑差不多，一般流程如下:</p>
<ul>
<li>判断spi实现类的映射关系表是否初始化，若没有则初始化</li>
<li>获取选择器<ul>
<li>优先从方法选择器中查找， 若存在，则直接选中；</li>
<li>不存在，则使用类选择器</li>
</ul>
</li>
<li>校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件）</li>
<li>返回实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getService</span><span class="params">(Object conf, String methodName)</span> <span class="keyword">throws</span> NoSpiMatchException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (spiImplClassCacheMap == <span class="keyword">null</span> || spiImplClassCacheMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">       loadSpiService();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先获取对应的selector</span></span><br><span class="line">   SelectorWrapper selector = currentMethodSelector.get(methodName);</span><br><span class="line">   <span class="keyword">if</span> (selector == <span class="keyword">null</span>) &#123; <span class="comment">// 自适应方法上未定义选择器, 则默认继承类的</span></span><br><span class="line">       selector = currentSelector;</span><br><span class="line">       currentMethodSelector.putIfAbsent(methodName, selector);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; <span class="comment">// 选择器类型校验</span></span><br><span class="line">       <span class="keyword">if</span> (!(conf <span class="keyword">instanceof</span> String)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"conf spiInterfaceType should be sub class of ["</span> + currentSelector.getConditionType() + <span class="string">"] but yours:"</span> + conf.getClass());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       selector = DEFAULT_SELECTOR;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (spiImplMethodCacheMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplClassCacheMap, conf);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 采用默认的选择器,根据指定name 进行查询时, 需要兼容一下, 因为method对应的缓存key为  SpiImpName_methodName</span></span><br><span class="line">       <span class="keyword">if</span> (DEFAULT_SELECTOR.equals(selector)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (spiImplMethodCacheMap.containsKey(conf)) &#123;</span><br><span class="line">               <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplMethodCacheMap, conf);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (spiImplClassCacheMap.containsKey(conf)) &#123;</span><br><span class="line">               <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplClassCacheMap, conf);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplMethodCacheMap, conf + <span class="string">"_"</span> + methodName);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplMethodCacheMap, conf);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">return</span> (T) selector.getSelector().selector(spiImplClassCacheMap, conf);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-3"><a href="#说明-3" class="headerlink" title="说明"></a>说明</h4><ol>
<li>这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑）</li>
<li>区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器</li>
<li><p>默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 <code>spiImplMethodCacheMap</code> 中key的生成，有一个小转换</p>
<pre><code>若实现类上没有 @SpiConf注解，或者 @SpiConf的注解没有定义 name 属性，则类的唯一标识name为：简单类名； 否则为指定的name属性

若方法上显示使用 @SpiConf 指定了name属性，则key的生成规则为： 方法注解上指定的name； 
如果没有 @SpiConf注解，或其中没有指定name属性，则key生成规则:  类name属性 + 下划线 + 方法名
</code></pre><p> 这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来</p>
</li>
<li><p>动态生成代理类的逻辑，放在最后进行说明</p>
</li>
</ol>
<h3 id="5-spi实现类映射关系表初始化"><a href="#5-spi实现类映射关系表初始化" class="headerlink" title="5. spi实现类映射关系表初始化"></a>5. spi实现类映射关系表初始化</h3><blockquote>
<p>为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干</p>
</blockquote>
<h4 id="缓存结构"><a href="#缓存结构" class="headerlink" title="缓存结构"></a>缓存结构</h4><p>使用了两个Map：</p>
<ul>
<li>一个是类级别的映射关系 <code>spiImplClassCacheMap</code><ul>
<li>静态使用时，只会用搞这个</li>
<li>动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断</li>
<li>key：  <code>@SpiConf</code> 注解中定义的name； 或者spi实现类的简单类名</li>
</ul>
</li>
<li>一个是方法的映射关系 <code>spiImplMethodCacheMap</code><ul>
<li>动态适配时， 选择器优先从这里进行判断</li>
<li>key:   <code>@SpiConf</code> 注解中定义的name； 或者是 实现类的 name + “_” + 方法名</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* name : spiImpl 的映射表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplClassCacheMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自适应时, 根据方法选择实现; name : spiImpl 的映射表</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplMethodCacheMap;</span><br></pre></td></tr></table></figure>
<h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadSpiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceMethodList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType);</span><br><span class="line"></span><br><span class="line">   SpiConf spiConf;</span><br><span class="line">   String implName;</span><br><span class="line">   <span class="keyword">int</span> implOrder;</span><br><span class="line">   <span class="keyword">for</span> (T t : serviceLoader) &#123;</span><br><span class="line">       spiConf = t.getClass().getAnnotation(SpiConf.class);</span><br><span class="line">       Map&lt;String, String&gt; map;</span><br><span class="line">       <span class="keyword">if</span> (spiConf == <span class="keyword">null</span>) &#123;</span><br><span class="line">           implName = t.getClass().getSimpleName();</span><br><span class="line">           implOrder = SpiImplWrapper.DEFAULT_ORDER;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数</span></span><br><span class="line">           <span class="keyword">if</span> (currentSelector.getSelector() <span class="keyword">instanceof</span> ParamsSelector) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"spiImpl must contain annotation @SpiConf!"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           map = Collections.emptyMap();</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           implName = spiConf.name();</span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isBlank(implName)) &#123;</span><br><span class="line">               implName = t.getClass().getSimpleName();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           implOrder = spiConf.order() &lt; <span class="number">0</span> ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order();</span><br><span class="line"></span><br><span class="line">           map = parseParms(spiConf.params());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 添加一个类级别的封装类</span></span><br><span class="line">       spiServiceList.add(<span class="keyword">new</span> SpiImplWrapper&lt;&gt;(t, implOrder, implName, map));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法</span></span><br><span class="line">       Method[] methods = t.getClass().getDeclaredMethods();</span><br><span class="line">       String methodImplName;</span><br><span class="line">       <span class="keyword">int</span> methodImplOrder;</span><br><span class="line">       Map&lt;String, String&gt; methodParams;</span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">           spiConf = method.getAnnotation(SpiConf.class);</span><br><span class="line">           <span class="keyword">if</span> (spiConf == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 方法上有自定义注解, 且定义的name与类实现名不同, 则直接采用</span></span><br><span class="line">           <span class="comment">// 否则采用  ServiceName_MethodName 方式定义</span></span><br><span class="line">           <span class="keyword">if</span> (StringUtils.isBlank(spiConf.name()) || implName.equals(spiConf.name())) &#123;</span><br><span class="line">               methodImplName = implName + <span class="string">"_"</span> + method.getName();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               methodImplName = spiConf.name();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 优先级, 以最小的为准 （即一个类上的优先级很低, 也可以定义优先级高的方法）</span></span><br><span class="line">           <span class="comment">// 方法注解未定义顺序时, 继承类上的顺序</span></span><br><span class="line">           methodImplOrder = Math.min(implOrder, spiConf.order() &lt; <span class="number">0</span> ? implOrder : spiConf.order());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">// 自适应方法的参数限制, 要求继承类上的参数</span></span><br><span class="line">           methodParams = parseParms(spiConf.params());</span><br><span class="line">           <span class="keyword">if</span> (map.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 方法的参数限定会继承类上的参数限定</span></span><br><span class="line">               <span class="keyword">if</span> (methodParams.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                   methodParams = map;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   methodParams.putAll(map);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           spiServiceMethodList.add(<span class="keyword">new</span> SpiImplWrapper&lt;&gt;(t, methodImplOrder, methodImplName, methodParams));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (spiServiceList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"no spiImpl implements spi: "</span> + spiInterfaceType);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.spiImplClassCacheMap = initSpiImplMap(spiServiceList);</span><br><span class="line">   <span class="keyword">this</span>.spiImplMethodCacheMap = initSpiImplMap(spiServiceMethodList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; initSpiImplMap(List&lt;SpiImplWrapper&lt;T&gt;&gt; list) &#123;</span><br><span class="line">   <span class="comment">// 映射为map, 限定不能重名</span></span><br><span class="line">   Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; tempMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   <span class="keyword">for</span> (SpiImplWrapper&lt;T&gt; wrapper : list) &#123;</span><br><span class="line">       <span class="keyword">if</span> (tempMap.containsKey(wrapper.getName())) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"duplicate spiImpl name "</span> + wrapper.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tempMap.put(wrapper.getName(), wrapper);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> tempMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑可以分为两块，一块是上半边的初始化，获取<code>spiImplClassCacheMap</code>;<br>下一块则是扫描实现类的所有方法，将方法上标有<code>@SpiConf</code>注解的捞出来，用于初始化 <code>spiImplMethodCacheMap</code></p>
<h4 id="说明-4"><a href="#说明-4" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p>缓存结构中value为  <code>SpiImplWrapper</code></p>
<ul>
<li><p>缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T spiImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> order;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* spiImpl 的标识name, 要求唯一</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> com.hust.hui.quicksilver.spi.selector.DefaultSelector 选择具体的SpiImpl 时使用&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 参数校验规则</span></span><br><span class="line"><span class="comment">* &lt;p/&gt;</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> com.hust.hui.quicksilver.spi.selector.ParamsSelector&#125; 选择具体的SpiImpl 时使用</span></span><br><span class="line"><span class="comment">* 要求每个实现类都有注解  &#123;<span class="doctag">@link</span> SpiConf&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; paramCondition;</span><br></pre></td></tr></table></figure>
</li>
<li><p>name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明</p>
</li>
</ul>
</li>
<li><p>采用 <code>ParamsSelector</code> 时， 要求  <code>@SpiConf</code> 注解必须存在</p>
</li>
<li><p>注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题</p>
<pre><code>// todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法
Method[] methods = t.getClass().getDeclaredMethods();
</code></pre></li>
</ol>
<h2 id="动态代码生成"><a href="#动态代码生成" class="headerlink" title="动态代码生成"></a>动态代码生成</h2><blockquote>
<p>上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法</p>
</blockquote>
<h3 id="1-代理类格式"><a href="#1-代理类格式" class="headerlink" title="1. 代理类格式"></a>1. 代理类格式</h3><p>采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码</p>
<ol>
<li>获取具体的实现类 （调用上面的 <code>SpiLoader.getService(conf, methodName</code>）</li>
<li>执行实现类的接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hust.hui.quicksilver.spi.test.print;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hust.hui.quicksilver.spi.SpiLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPrint</span>$<span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">hust</span>.<span class="title">hui</span>.<span class="title">quicksilver</span>.<span class="title">spi</span>.<span class="title">test</span>.<span class="title">print</span>.<span class="title">IPrint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(java.lang.String arg0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, <span class="string">"print"</span>);</span><br><span class="line">            spiImpl.print(arg0);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adaptivePrint</span><span class="params">(java.lang.String arg0, java.lang.String arg1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, <span class="string">"adaptivePrint"</span>);</span><br><span class="line">            spiImpl.adaptivePrint(arg0, arg1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行）</p>
<h4 id="代理类生成"><a href="#代理类生成" class="headerlink" title="代理类生成"></a>代理类生成</h4><p>对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建SPI接口的实现代理类, 在执行动态适配的方法时, 调用SpiLoader的 spiImpl选择器, 选择具体的实现类执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildTempImpl</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    StringBuilder codeBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    codeBuilder.append(<span class="string">"package "</span>).append(type.getPackage().getName()).append(<span class="string">";"</span>);</span><br><span class="line">    codeBuilder.append(<span class="string">"\nimport "</span>).append(SpiLoader.class.getName()).append(<span class="string">";"</span>);</span><br><span class="line">    codeBuilder.append(<span class="string">"\npublic class "</span>).append(type.getSimpleName()).append(<span class="string">"$Proxy implements "</span>).append(type.getCanonicalName()).append(<span class="string">" &#123;\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        Class&lt;?&gt; returnType = method.getReturnType(); <span class="comment">//函数返回值</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<span class="comment">//函数参数列表</span></span><br><span class="line">        Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();<span class="comment">//函数异常列表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// build method code</span></span><br><span class="line">        StringBuilder code = <span class="keyword">new</span> StringBuilder(<span class="number">512</span>);</span><br><span class="line">        <span class="keyword">if</span> (parameterTypes.length &lt; <span class="number">0</span>) &#123;   <span class="comment">//检查该函数参数列表中，第一个参数作为选择器参数</span></span><br><span class="line">            code.append(<span class="string">"throw new IllegalArgumentException(\"there should be one argument for selector to choose spiImpl\")"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 SpiAdaptive注解的, 采用默认的注解方式</span></span><br><span class="line">            code.append(<span class="string">"try&#123;\n"</span>);</span><br><span class="line">            code.append(type.getName()).append(<span class="string">" spiImpl="</span>)</span><br><span class="line">                    .append(<span class="string">"SpiLoader.load("</span>)</span><br><span class="line">                    .append(type.getName()).append(<span class="string">".class"</span>)</span><br><span class="line">                    .append(<span class="string">").getService(arg0,\""</span>)</span><br><span class="line">                    .append(method.getName())</span><br><span class="line">                    .append(<span class="string">"\");"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"void"</span>.equals(returnType.getName())) &#123;</span><br><span class="line">                code.append(<span class="string">"return "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            code.append(<span class="string">"spiImpl."</span>).append(method.getName()).append(<span class="string">"(arg0"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                code.append(<span class="string">","</span>).append(<span class="string">"arg"</span>).append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            code.append(<span class="string">");"</span>);</span><br><span class="line">            code.append(<span class="string">"\n&#125; catch(com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e)&#123;\nthrow new java.lang.RuntimeException(e);\n&#125;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// build method signature</span></span><br><span class="line">        codeBuilder.append(<span class="string">"\npublic "</span>).append(returnType.getName()).append(<span class="string">" "</span>).append(method.getName())</span><br><span class="line">                .append(<span class="string">"("</span>).append(parameterTypes[<span class="number">0</span>].getName()).append(<span class="string">" arg0"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            codeBuilder.append(<span class="string">", "</span>).append(parameterTypes[i].getName()).append(<span class="string">" arg"</span>).append(i);</span><br><span class="line">        &#125;</span><br><span class="line">        codeBuilder.append(<span class="string">") "</span>);</span><br><span class="line">        <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            codeBuilder.append(<span class="string">"throw "</span>).append(exceptionTypes[<span class="number">0</span>].getName());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                codeBuilder.append(<span class="string">", "</span>).append(exceptionTypes[i].getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        codeBuilder.append(<span class="string">"&#123;\n"</span>);</span><br><span class="line">        codeBuilder.append(code.toString()).append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codeBuilder.append(<span class="string">"\n&#125;"</span>);</span><br><span class="line">    <span class="keyword">return</span> codeBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="动态编译运行"><a href="#动态编译运行" class="headerlink" title="动态编译运行"></a>动态编译运行</h4><p>动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">compile</span><span class="params">(String code, Class&lt;T&gt; interfaceType, ClassLoader classLoader)</span> <span class="keyword">throws</span> SpiProxyCompileException </span>&#123;</span><br><span class="line">   GroovyClassLoader loader = <span class="keyword">new</span> GroovyClassLoader(classLoader);</span><br><span class="line">   Class clz = loader.parseClass(code);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!interfaceType.isAssignableFrom(clz)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"illegal proxy type!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> (T) clz.newInstance();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SpiProxyCompileException(<span class="string">"init spiProxy error! msg: "</span> + e.getMessage());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了</p>
<h3 id="博客系列链接："><a href="#博客系列链接：" class="headerlink" title="博客系列链接："></a>博客系列链接：</h3><ul>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95/">SPI框架实现之旅四：使用测试</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%AF%B4%E6%98%8E/">SPI框架实现之旅三：实现说明</a></li>
<li><a href="/hexblog/2018/05/30/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%BA%8C%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/">SPI框架实现之旅二：整体设计</a></li>
<li><a href="/hexblog/2017/05/29/SPI%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E4%B9%8B%E6%97%85%E4%B8%80%EF%BC%9A%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/">SPI框架实现之旅一：背景介绍</a></li>
</ul>
<h3 id="项目-QuickAlarm"><a href="#项目-QuickAlarm" class="headerlink" title="项目: QuickAlarm"></a>项目: QuickAlarm</h3><ul>
<li>项目地址： <a href="https://github.com/liuyueyi/quick-spi" target="_blank" rel="noopener">Quick-SPI</a></li>
<li>博客地址： <a href="https://liuyueyi.github.io/hexblog/" target="_blank" rel="noopener">小灰灰Blog</a></li>
</ul>
<h3 id="个人博客：-Z-blog"><a href="#个人博客：-Z-blog" class="headerlink" title="个人博客： Z+|blog"></a>个人博客： <a href="https://liuyueyi.github.io/hexblog" target="_blank" rel="noopener">Z+|blog</a></h3><p>基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛</p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: <a href="https://weibo.com/p/1005052169825577/home" target="_blank" rel="noopener">小灰灰Blog</a></p>
<h3 id="扫描关注"><a href="#扫描关注" class="headerlink" title="扫描关注"></a>扫描关注</h3><p><img src="https://s17.mogucdn.com/mlcdn/c45406/180209_74fic633aebgh5dgfhid2fiiggc99_1220x480.png" alt="QrCode"></p>
</div><div class="tags"><a href="/hexblog/tags/Java/">Java</a><a href="/hexblog/tags/SPI/">SPI</a></div><div style="text-align:center"><button style="color:red;background-color: #f44336;border: none;border-radius: 8px;color: white;padding: 10px 30px;text-align: center;text-decoration: none;font-size: 16px;" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">打赏</button></div><div id="QR" style="display: none; margin-top: 20px;" class="row"><div id="wechat" style="display: inline-block;width:44%;margin-left:6%;text-align:center;"><a href="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png" alt="WeChat Pay" style="width:80%;height:80%;max-height:200px;max-width:200px"></a><p style="text-align:center">微信打赏</p></div><div id="alipay" style="display: inline-block;width:44%;text-align:center"><a href="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png" alt="Alipay" style="width:80%;height:80%;max-height:200px;max-width:200px"></a><p style="text-align:center">支付宝打赏</p></div></div><div class="post-share"><div id="share" class="soshm social-share"><span style="float:center;font-size:20px;font-weight:solid;color:gray">分享到: </span></div></div><div class="post-nav"><a href="/hexblog/2017/05/30/SPI框架实现之旅四：使用测试/" class="pre">4. SPI框架实现之旅四：使用测试</a><a href="/hexblog/2017/05/28/SPI框架实现之旅二：整体设计/" class="next">2. SPI框架实现之旅二：整体设计</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#实现说明"><span class="toc-text">实现说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpiLoader-全解析"><span class="toc-text">SpiLoader 全解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-获取spiLoader对象"><span class="toc-text">1. 获取spiLoader对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-新建-SpiLoader对象"><span class="toc-text">2. 新建 SpiLoader对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-1"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明-1"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-静态使用"><span class="toc-text">3. 静态使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-2"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明-2"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-动态使用"><span class="toc-text">4. 动态使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设计的出发点"><span class="toc-text">设计的出发点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现如下"><span class="toc-text">实现如下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明-3"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-spi实现类映射关系表初始化"><span class="toc-text">5. spi实现类映射关系表初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#缓存结构"><span class="toc-text">缓存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-3"><span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明-4"><span class="toc-text">说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态代码生成"><span class="toc-text">动态代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-代理类格式"><span class="toc-text">1. 代理类格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#代理类生成"><span class="toc-text">代理类生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态编译运行"><span class="toc-text">动态编译运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#博客系列链接："><span class="toc-text">博客系列链接：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#项目-QuickAlarm"><span class="toc-text">项目: QuickAlarm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#个人博客：-Z-blog"><span class="toc-text">个人博客： Z+|blog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扫描关注"><span class="toc-text">扫描关注</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><a href="/hexblog/about/"><i class="fa fa-user"> 小灰灰Blog</i></a></div><ul class="post-list"><li style="text-align:center"><img src="//s3.mogucdn.com/mlcdn/c45406/170419_637cgff527i8k9k8h512iaf36cdia_600x600.jpg" style="max-width:80px;radius:80px"/><p style="text-align:center">好好学习，天天搬砖</p><hr style="height:0.1px;border:none;border-top:1px dashed #0066CC;"/></li><li class="post-list-item"><a href="mailto:bangzewu@126.com" title="126邮箱" class="post-list-link"><i class="fa fa-email">  bangzewu@126.com</i></a></li><li class="post-list-item"><a href="//github.com/liuyueyi" title="Git主页" target="_blank" class="post-list-link"><i class="fa fa-github">  github.com/liuyueyi</i></a></li><li class="post-list-item"><a href="//weibo.com/p/1005052169825577/home" title="微博主页" target="_blank" class="post-list-link"><i class="fa fa-weibo">  微博小灰灰Blog</i></a></li><li class="post-list-item"><i class="fa fa-weixin">  微信公众号</i></li><li style="text-align:center" class="post-list-item"><img src="https://s10.mogucdn.com/mlcdn/c45406/171229_1cgld3igbelkbc70cd8af1j3809kb_150x150.jpg"/></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/">Java并发学习之线程池ThreadPoolExecutor的小结</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/">7. 报警系统QuickAlarm之默认报警规则扩展</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/12/借助GitHub搭建属于自己的maven仓库教程/">借助GitHub搭建属于自己的maven仓库教程</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/11/报警系统QuickAlarm使用手册/">6. 报警系统QuickAlarm使用手册</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/11/报警系统QuickAlarm之频率统计及接口封装/">5. 报警系统QuickAlarm之频率统计及接口封装</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/11/报警系统QuickAlarm之报警规则解析/">4. 报警系统QuickAlarm之报警规则解析</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/">3. 报警系统QuickAlarm之报警规则的设定与加载</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/">2. 报警系统QuickAlarm之报警执行器的设计与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/09/报警系统QuickAlarm总纲/">1. 报警系统QuickAlarm设计总纲</a></li><li class="post-list-item"><a class="post-list-link" href="/hexblog/2018/02/08/Java可以如何实现文件变动的监听/">Java可以如何实现文件变动的监听</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Android/">Android</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Android/一封/">一封</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/BugFix/">BugFix</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/BugFix/Java/">Java</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/BugFix/Java/Image/">Image</a><span class="category-list-count">2</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/">Java</a><span class="category-list-count">13</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/Concurrency/">Concurrency</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/JDK/">JDK</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/JavaWeb/">JavaWeb</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/Spring/">Spring</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Java/Tool/">Tool</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Quick系列项目/">Quick系列项目</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Quick系列项目/QuickAlarm/">QuickAlarm</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Quick系列项目/QuickSpi/">QuickSpi</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Shell/">Shell</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Shell/Git/">Git</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Shell/Git/Maven/">Maven</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Shell/Nginx/">Nginx</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/Shell/环境搭建/">环境搭建</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/hexblog/categories/随笔/">随笔</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签墙</i></div><div class="tagcloud"><!--!= tagcloud({min_font: 15, max_font: 15, amount: 100, orderby: 'count'})--><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Spring/">Spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/日记/">日记</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/一封/">一封</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/RelativeLayout/">RelativeLayout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/CountDownTimer/">CountDownTimer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Bugfix/">Bugfix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Java/">Java</a><span class="tag-list-count">26</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/batik/">batik</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Png/">Png</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Gitbook/">Gitbook</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Centos/">Centos</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Reflect/">Reflect</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JavaWeb/">JavaWeb</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Filter/">Filter</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Servlet/">Servlet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JDK/">JDK</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Initialize/">Initialize</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/File/">File</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ScheduledExecutorService/">ScheduledExecutorService</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/clone/">clone</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/beancopy/">beancopy</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Nginx/">Nginx</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/distributeLock/">distributeLock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Android/">Android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/RequestParam/">RequestParam</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Jsonp/">Jsonp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/CORS/">CORS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Exception/">Exception</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Response/">Response</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/JVM/">JVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Github/">Github</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Maven/">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/BugFix/">BugFix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/BufferedImage/">BufferedImage</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Jpeg/">Jpeg</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Okhttp/">Okhttp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/SPI/">SPI</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/QuickAlarm/">QuickAlarm</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/教程/">教程</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/整体设计/">整体设计</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/使用手册/">使用手册</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/配置/">配置</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/Redis/">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/工具/">工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/并发/">并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexblog/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/hexblog/archives/2017/05/">五月 2017</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 更多链接</i></div><ul style="padding-top:10px"></ul><li style="padding-top:2px"><a href="//my.oschina.net/u/566591" title="开源中国" target="_blank">开源中国</a></li><li style="padding-top:2px"><a href="//blog.csdn.net/liuyueyi25" title="CSDN" target="_blank">CSDN</a></li><li style="padding-top:2px"><a href="//www.jianshu.com/u/5902ab08e670" title="简书" target="_blank">简书</a></li><li style="padding-top:2px"><a href="//juejin.im/user/5a2a4b095188252ae93adbbf/posts" title="掘金" target="_blank">掘金</a></li><li style="padding-top:2px"><a href="//www.toutiao.com/c/user/69862071663/#mid=1579653107239950" title="头条" target="_blank">头条</a></li></div><div class="widget"><div class="widget-title"><i onclick="var qr = document.getElementById('qrcode'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}" style="cursor:pointer" class="fa fa-hit"> 点赞(点击展开)</i></div><ul id="qrcode" style="display:none;" class="post-list"><br/><li style="text-align:center" class="post-list-item"><a href="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png" target="_blank"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_50136i33id9e49j1f7k2e219e3ldf_800x798.png" alt="WeChat Pay" style="width:75%"/><br/><p style="text-align:center">微信打赏</p></a></li><li style="text-align:center" class="post-list-item"><a href="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png" target="_blank"><img src="https://s3.mogucdn.com/mlcdn/c45406/180104_0e6afl33b23lacj6ji2d7d060aiak_798x800.png" alt="Alipay" style="width:75%"/><br/><p style="text-align:center">支付宝打赏</p></a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="https://zbang.online/webs"><img src="//s3.mogucdn.com/mlcdn/c45406/170419_637cgff527i8k9k8h512iaf36cdia_600x600.jpg" style="max-width: 44px;border-radius:44px"></a></p><p><a href="https://github.com/liuyueyi" target="_blank">GitHub</a> |  <a href="mailto:bangzewu@126.com">email</a> |  <a href="/hexblog/about/">关于 |</a><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p></p><p><span> Copyright &copy;<a href="/hexblog/." rel="nofollow">YiHui.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?028d9e53f991d9739ecc7cc42e13c500";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/hexblog/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/hexblog/js/toctotop.js?v=2.0.1" async></script><script src="https://s3.mogucdn.com/mlcdn/c45406/1518420912429_social-share.min.js" charset="utf-8"></script><link rel="stylesheet" href="https://s3.mogucdn.com/mlcdn/c45406/1518422561591_share.min.css"></body></html>
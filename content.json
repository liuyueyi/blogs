[{"title":"Java面试知识要点之Redis篇","slug":"Java面试知识要点之Redis篇","date":"2018-04-26T11:48:20.000Z","updated":"2018-04-26T12:33:16.597Z","comments":true,"path":"2018/04/26/Java面试知识要点之Redis篇/","link":"","permalink":"https://zbang.online/hexblog/2018/04/26/Java面试知识要点之Redis篇/","excerpt":"I. 问题列表 什么是redis 和memcache的区别 支持的数据结构以及常用命令 如何支持并发？ 如何保证原子性 回收算法 大量数据插入的问题 分区相关 如何扩容 常见性能问题以及优化建议 如何借助redis做消息队列 如何借助redis实现分布式锁","text":"I. 问题列表 什么是redis 和memcache的区别 支持的数据结构以及常用命令 如何支持并发？ 如何保证原子性 回收算法 大量数据插入的问题 分区相关 如何扩容 常见性能问题以及优化建议 如何借助redis做消息队列 如何借助redis实现分布式锁 II. 解答1. 什么是redis简单来说，redis是一个非关系型的、基于内存的，可持久化存储的kv数据库，value支持的数据结构包含String，List, Set, ZSet(排序集合)和hash，单进程模式，支持简单的事物功能；常作为缓存来使用，也可以作为计数器 2. redis与memcache之间对比 脚踏两只船的困惑 - Memcached与Redis 一般来讲，生产环境中会大量用到缓存，而缓存的选择，较多的就是redis和memcache了，所以他们两经常拿出来对比，个人没有使用过memcache，因此主要内容参考网上信息 redis memcache 支持持久化 不支持持久化 单进程 多线程服务支持，非阻塞IO复用 内存，非关系型数据库 纯内存，kv结构，缓存系统 value类型： String, List, Set, ZSet, Hash 文本，二进制 额外功能：发布/订阅模式，主从分区，序列化，lua脚本 多线程支持 会导致内存碎片，需要多少空间申请多少空间 避免了内存碎片，采用chunk进行封装 简单来讲，两者都可以用来做缓存，但是 鉴于memcache没法持久化，因此对数据有落盘需求的，必须选择redis redis支持更多类型的数据结构，在某些场景下更通用 redis单进程模式，memcache多线程IO复用模式，对性能而言，后者更好 有一个说法： 使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升； 除此以外，优先考虑Redis； 3. redis支持的数据结构及常见命令上面列出了redis支持的几种数据结构，String, List, Set, ZSet, Hash， 下面依次进行说明 a. String最常见的一种类型，value就是一个字符串，常见的使用姿势 set, get, mset, mget （设置kv，或者获取value） setnx （当不存在时，设置value) 此外，允许存一个整形的数在redis中，并提供了 incr, decr 实现加减，从而支持计数的场景 b. Listvalue是一个双向列表，允许重复，有序，常见的使用姿势 lpush （在左边添加元素), lpop, rpush, rpop lrange (获取指定位置的元素) 可用于存放用户的关系列表，消息队列等 c. set集合，相比较于list而言，不允许出现重复的元素，常见使用姿势 sadd,spop（移除并随机返回一个元素）,smembers（返回所有的元素）,sunion（sunion key1 key2 返回所有给定集合的并集） d. zset （排序集合)一个排序的结合，比如可以用来做排行榜，常见的使用姿势 zadd,zrange,zrem,zcard 1ZADD key score1 member1 [score2 member2] e. hashHash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。 hget,hset,hgetall,hdel（删除）,hlen(数量) 3. redis如何支持并发可以将这个问题与原子性，事务性联合起来一起进行说明，首先我们知道redis是单进程模式，所以在服务端而言，是天生不存在并发问题，也没有锁的竞争之类的，那么原子性就很好说了，命令都是单进程顺序执行，保证了原子操作；其次就是事物的支持，简单来讲就是强制将一些执行命令，串行起来运行，从而实现一个伪事物的特性 那么并发如何支持呢？可以支持吗？ 从redis服务端出发，单进程模式可以说是并不支持并发的，当然也有一些辅助手段，可以来实现并发功能 客户端的并发支持，对于redis客户端，可以通过连接池的相关手段，辅助synchronized和lock来实现并发访问redis的支持 redis搭建集群，借助分区，从而实现并发支持 4. redis回收进程如何工作，采用的什么算法？redis中采用两种算法进行内存回收， 引用计数， LRU（最近最久未使用） a. 引用计数引用计数，去掉内存中不再引用的对象，以及运行一个定时任务serverCron去掉内存中已经过期的对象占用的空间 b. LRU当内存空间不够后，淘汰内存中的某些对象，有下面几种策略： 将设置了过期时间的数据集合中，选择最久未使用的数据释放 从数据集（设置过期和没有设置的）中选择最久未使用的数据释放 从设置过期时间数据集中，随机选择数据进行释放 从数据集中随机选择数据释放 从设置过期时间的数据集中，选择将要过期的数据 不删除任意数据，内存不够时，直接返回错误（默认的策略） 4. 大量数据插入 Redis 大量数据插入 有些时候，Redis实例需要装载大量用户在短时间内产生的数据，数以百万计的keys需要被快速的创建，这就是所说的大量数据插入 借助redis-cli 的 pipe mode模式来执行 一个case如下： 12341. 将命令封装到 cmd.txt 文件中2. 执行cat cmd.txt | redis-cli --pipe 输出类似 123All data transferred. Waiting for the last reply...Last reply received from server.errors: 0, replies: 1000000 5. redis分区 Redis 分区 分区就是讲数据分散存储到多个redis实例中，每个实例中可能只保存key的一个子集 优点 存储量更大 提高吞吐量 安全性更高 缺点 多个key操作支持不友好（跨实例的多key可能并不支持） 增加和删除容量比较复杂 分区类型 范围分区：根据某个条件进行范围分区，如key有个唯一表示id，根据id在(0,10000), （10001,20000）来分散到不同的实例 hash分区：根据key进行hash映射，分散到不同的实例中 这个分区可以和db的分库分表做一个简单的类比，其中 范围分区类似于根据冷热数据进行分库分表 hash分区类似于根据id进行散列分库分表 6. redis持久化数据和缓存怎么扩容？a. 持久化 redis的持久化和缓存机制 redis支持数据持久化，既断线后也不用担心数据丢失，常见的有两种持久化手段 快照方式Snapshot 默认的持久化方式，将内存中的数据以快照方式写入到二进制文件中，默认文件名为dump.rdb，通过配置来设置redis在n秒内如果超过m个key被修改自动做快照，配置如下 12save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存 说明： 每次进行快照持久化，都是讲内存中的所有数据都写到磁盘中，因此若出现频繁的快照持久化，会造成严重的磁盘IO 隔一段时间之后，做一次快照，因此意外down掉，可能导致最后一次的快照没有备份成功，导致数据丢失 AOF方式(Append only file) 在使用 aof 持久化方式时,redis 会将每一个收到的写命令都通过 write 函数追加到文件中(默认是 appendonly.aof)。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 简单来讲，就是将执行的命令记录在文件中，当出现问题时，重新执行记录命令的文件即可，类似于数据库中事物的操作中roll back日志的方式 说明： 由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。 不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机， appendonly yes //启用 aof 持久化方式 appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证完全的持久化 appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中 appendfsync no //完全依赖 os，性能最好,持久化没保证 此外就是保存命令的文件中，记录有所的命令，但是实际恢复时，可能只需要重做最新的几个命令而已 redis 提供了 bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。 7，常见的性能问题及优化手段针对这个问题，在实际生产环境中，遇到最大问题有下面两个 网络IO引起的性能瓶颈 redis集群抖动引起的性能开销 分别对上面的问题原因进行分析，并给出相应的解决方案 a. 网络IO问题当qps较大时，网络IO会成为redis的一个瓶颈，特别是当存储的数据非常大时，格外明显 假设一个kv对占用空间为64K，那么1000的qps可能占用64M的网络IO（这里简单考虑输出IO），对百M网卡而言，可能直接导致服务的qps上限不会超过2000了 此外还有一个问题就是TCP重传时，数据量大时，对网络IO的影响也是格外严重的 所以一般在生产环境下，会对redis的value长度进行限制，避免过大；其次就是list的个数问题，特别是获取时，尽量不要一次获取太多 第二个解决方案是从业务上进行隔离，每个业务有自己的独立的redis集群，尽量不要与其他的业务公用，否则由于redis的单进程模式，其他业务的耗时操作也会影响你的业务 b. redis集群抖动问题什么场景可能到只redis集群的抖动呢？就我个人遇到的情况，有以下几个可能 服务器本身的load过高，可能引起内存回收不及时导致的抖动 基于快照或AOF的持久化过于频繁，导致的大量磁盘IO tcp重传导致的客户端监控上体现为抖动 常见的一些扩展方案： 分区，增加redis实例 根据数据的重要程度，设置合理的备份策略 master最好不做持久化工作，放在某个slave上进行备份 为了主从复制效率，master和slave最好放在同一个局域网 尽量避免在压力很大的主库上增加从库 8. redis与消息队列首先声明redis并不太适合做消息队列，这种事情应该交给更专业的kafaka, rabbitmq等来做 如果硬是要用redis来做，常见的有两种方式 a. 基于发布/订阅模型基于redis的pub/sub来实现，一种非持久化的消息机制，消息发布者与订阅者要求同时在线，否则一旦订阅者离线之后，在重连之前，这段时间的消息无法被重新加载 消息发布者Provider： 1publish xxxKey message 消息订阅者Consumer: 1subscribe xxxKey 特点： 支持一个生产者对应多个消费者 支持集群 使用简单 缺点： 不安全，consumer挂掉后会丢消息，没有ack机制 不支持多个客户端消费同一个消息的场景 b. 基于list这个可以算是一种简单的消息使用思路，producer负责往List中塞数据；consumer负责从list中获取数据 消息发布者Provider： 1lpush xxxKey message 消息订阅者Consumer: 12345# 非阻塞方式lpop xxxKey# 阻塞获取方式 0表示一直等待有消息，&gt;0表示等待多少s后，超时blpop xxxKey 0 9. redis与分布式锁 推荐参考Redis实现分布式锁相关注意事项 首先声明一点，没有百分百完美的分布式锁，一般针对那种严格性不是特别特别特别有要求的场景下，大多数没有明显漏洞的分布式方案都是ok的 常见的思路： setnx 尝试获取锁，设置成功表示获取到了锁； 设置失败，没有获取锁 判断是否过期，是则循环再次尝试获取锁，直到成功 过期，getset再次设置锁，判断是否获取成功 失败，则重新进入尝试获取锁的逻辑 获取锁之后执行业务，最后释放锁（请注意只能释放自己持有的锁，不要把别人的锁给释放了） 如何判断过期呢？ value包含时间戳信息，获取锁失败时，取出value 判断是否过期 若过期，则借助getset来设置新的锁 这个思路在并发环境下，因为getset可能到只写入脏数据，详情可以参考上面的博文，因此另一种方式是直接在设置锁的时候，指定失效时间，这样过期之后，就可以直接释放掉锁，避免再次尝试获取锁setnx时出现问题 III。 其他参考 redis命令 面试中关于redis的问题 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"缓存","slug":"工作/面试/缓存","permalink":"https://zbang.online/hexblog/categories/工作/面试/缓存/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"},{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/tags/Redis/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"缓存","slug":"工作/面试/缓存","permalink":"https://zbang.online/hexblog/categories/工作/面试/缓存/"}]},{"title":"redis安装","slug":"redis安装","date":"2018-04-24T02:19:51.000Z","updated":"2018-04-26T11:59:29.006Z","comments":true,"path":"2018/04/24/redis安装/","link":"","permalink":"https://zbang.online/hexblog/2018/04/24/redis安装/","excerpt":"I. redis安装centos安装并后台启动redis记录过程","text":"I. redis安装centos安装并后台启动redis记录过程 安装redis命令，比较简单 1yum install redis 后台启动redis方式： 123456789101112# 设置redis.conf文件，开启后台启动vim /etc/redis.conf## 找到 daemonize no 这一行## 修改成yes，并保存daemonize yes## 启动redisredis-server /etc/redis.conf 查看redis启动是否正常 12# 查看进程号ps -ef | grep redis 客户端连接测试 12345redis-cli&gt; set test 123&gt; get test&gt; expire test II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"redis","slug":"redis","permalink":"https://zbang.online/hexblog/tags/redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"18年4月18日离杭小记","slug":"18年4月18日离杭小记","date":"2018-04-18T06:41:40.000Z","updated":"2018-04-18T06:49:21.267Z","comments":true,"path":"2018/04/18/18年4月18日离杭小记/","link":"","permalink":"https://zbang.online/hexblog/2018/04/18/18年4月18日离杭小记/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;从15年7月1日到18年4月18日，恍惚之间，来杭州已经度过1023天，将近三年的时光，有过满含激情充满朝气的时候，也有过浑浑噩噩每天无所事事的时候，这里是迈入社会的第一站，拉开了一段新的旅程序幕，于此驻足三年，却收益余生. &nbsp;&nbsp;&nbsp;&nbsp;这几天杭州的天气不错，阳光明媚，虽然能见度不怎么样，坐在蘑菇街大厦的11层，望向窗外，远处依然是雾蒙蒙的，没有蓝蓝的天，也看不到飘零的云，但就这么看着，也觉得有别样的风景。杭州，最忆是西湖。曾在古诗文中无数次憧憬着的人间天堂，依稀记得初次到西湖前的画面。粼粼的湖光、和煦的风，两条横插湖中的苏堤、白堤，却让我感受到完全不一样的风景。从没有想过，西湖会是这样的场景；和印象中《新白娘子传奇》里的小湖、断桥、微雨和油纸伞的水墨画完全不同；带上了浓厚的现代风之后的西湖，好像也只有那千古继承的湖波和岸边的依依杨柳，才是最出的风光，也才能给人更多的古韵遐想。","text":"&nbsp;&nbsp;&nbsp;&nbsp;从15年7月1日到18年4月18日，恍惚之间，来杭州已经度过1023天，将近三年的时光，有过满含激情充满朝气的时候，也有过浑浑噩噩每天无所事事的时候，这里是迈入社会的第一站，拉开了一段新的旅程序幕，于此驻足三年，却收益余生. &nbsp;&nbsp;&nbsp;&nbsp;这几天杭州的天气不错，阳光明媚，虽然能见度不怎么样，坐在蘑菇街大厦的11层，望向窗外，远处依然是雾蒙蒙的，没有蓝蓝的天，也看不到飘零的云，但就这么看着，也觉得有别样的风景。杭州，最忆是西湖。曾在古诗文中无数次憧憬着的人间天堂，依稀记得初次到西湖前的画面。粼粼的湖光、和煦的风，两条横插湖中的苏堤、白堤，却让我感受到完全不一样的风景。从没有想过，西湖会是这样的场景；和印象中《新白娘子传奇》里的小湖、断桥、微雨和油纸伞的水墨画完全不同；带上了浓厚的现代风之后的西湖，好像也只有那千古继承的湖波和岸边的依依杨柳，才是最出的风光，也才能给人更多的古韵遐想。 &nbsp;&nbsp;&nbsp;&nbsp;前两天，收拾了下行李，发现这几年来，增加的除了体重之外，还有那些零碎的东西。当初一个背包就来到这座陌生的城市，而现在再想一两个背包离开却没那么容易。各季的衣服，一些娱乐的玩具，当时信誓旦旦买来健身结果缺在角落吃灰的器材，还有哪些九成多新的各类书籍，七七八八的对扎在一起，却是颇为可观。又那么些东西，准备就这么舍去，却没有那么干脆，好歹这孤身的岁月中，它们终究是发挥了些许作用；话说直接扔掉，过于凉薄了些，当然最主要的原因还是荷包过于羞涩了。匆匆而来总是容易，想要匆匆而去，往往并没有那么干脆。 &nbsp;&nbsp;&nbsp;&nbsp;在杭州待了三年，仔细想想，对杭州这座城市的了解，好像并不太多。玩耍的地方，总是围绕着西湖展开。一年四季的西湖景色，有嫩牙初长成的初春时节风景；也有炎炎下一池荷叶碧波摇曳的酷暑夏日；还是喜欢秋日的荫凉，微风吹拂下的粼粼湖光，在水雾中朦朦胧胧的雷峰塔和飞来峰；当然也离不开被所有人津津乐道的断桥残雪。这些年，西湖边上演绎了多少故事，又迎来送往了多少代人呢。不知以后再次踏足，会是何年岁月。西湖边上的雷峰塔，飞来峰中的灵隐寺，龙井村里盘绕的茶园，西溪湿地的芦苇飞鸟，钱塘江上的滚滚潮水，想想这些景色风光，算不上绝色秀丽，却也别有一般风光。 &nbsp;&nbsp;&nbsp;&nbsp;很多年都没有写过东西了，笔也都不大会握，稍微写一会，手就酸的不行。除了思想会僵化，这手腕看来也不甘落后。想说些什么，然而却找不到什么主题。最终只化作简简单单的几个字，“匆匆而来，流连而去” by 一灰灰 | 2018.04.18","categories":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://zbang.online/hexblog/tags/小记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}]},{"title":"Java 借助ImageMagic实现图片编辑服务","slug":"Java-借助ImageMagic实现图片编辑服务","date":"2018-04-17T08:07:08.000Z","updated":"2018-04-17T08:13:16.802Z","comments":true,"path":"2018/04/17/Java-借助ImageMagic实现图片编辑服务/","link":"","permalink":"https://zbang.online/hexblog/2018/04/17/Java-借助ImageMagic实现图片编辑服务/","excerpt":"","text":"Java 借助ImageMagic实现图片编辑服务java原生对于图片的编辑处理并没有特别友好，而且问题也有不少，那么作为一个java后端，如果要提供图片的编辑服务可以怎么办？也得想办法去支持业务需求，本片博文基于此进行展开 I. 调研首先最容易想到的就是目前是不是已经有了相关的开源库，直接用不就很high了嘛，git上搜一下 1. thumbnailator差不多四年都没有更新了，基于awt进行图片的编辑处理，目前提供了基本的图片编辑接口，开始用了一段时间，有几个绕不够去的坑，所以最后放弃了 使用姿势： 12345&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; 一个使用case: 123456BufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .size(200, 200) .rotate(90) .asBufferedImage(); 问题说明： jpg图片编辑后，输出图片变红的问题（详情参考：兼容ImageIO读取jpeg图片变红） 图片精度丢失（对于精度要求较高的场景下，直接使用Jdk的BufferedImage会丢失精度） 上面两个问题中，第二个精度丢失在某些对图片质量有要求的场景下比较严重，如果业务场景没那么将就的话，用这个库还是可以减少很多事情的，下面基于ImageMagic的接口设计，很大程度上参考了该工程的使用规范，因为使用起来（+阅读）确实特别顺畅 2. simpleimage阿里的开源库，文档极其欠缺，而且良久没有人维护，没有实际使用过，感觉属于玩票的性质（个人猜测是KPI为导向下的产物） 如果想造轮子的话，参考它的源码，某些图片的处理方案还是不错的 3. imagemagic + im4javaImageMagic/GraphicMagic 是c++的图象处理软件，很多服务基于此来搭建图片处理服务的 优点：稳定、性能高、支持接口多、开箱即用、靠谱 缺点：得提前配置环境，基本上改造不动，内部有问题也没辙 这个方法也是下面的主要讲述重点，放弃Thumbnailator选择imagemagic的原因如下： 支持更多的服务功能（比Thumbnailator多很多的接口） 没有精度丢失问题 没有图片失真问题（颜色变化，alpha值变化问题） II. 环境准备首先得安装ImageMagic环境，有不少的第三方依赖，下面提供linux和mac的安装过程 1. linux安装过程123456789101112131415161718# 依赖安装yum install libjpeg-develyum install libpng-develyum install libwebp-devel## 也可以使用源码方式安装安装jpeg 包 `wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz`安装webp 包 `wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz`安装png 包 `wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz`## 下载并安装ImageMagicwget http://www.imagemagick.org/download/ImageMagick.tar.gztar -zxvf ImageMagick.tar.gzcd ImageMagick-7.0.7-28./configure; sudo make; sudo make install 安装完毕之后，进行测试 1234567$ convert --versionVersion: ImageMagick 7.0.7-28 Q16 x86_64 2018-04-17 http://www.imagemagick.orgCopyright: © 1999-2018 ImageMagick Studio LLCLicense: http://www.imagemagick.org/script/license.phpFeatures: Cipher DPC HDRI OpenMPDelegates (built-in): fontconfig freetype jng jpeg lzma png webp x xml zlib 2. mac安装过程依赖安装 12345sudo brew install jpegsudo brew install libpngsudo brew install libwebpsudo brew install GraphicsMagicksudo brew install ImageMagick 源码安装方式与上面一致 3. 问题及修复如果安装完毕之后，可能会出现下面的问题 提示找不到png依赖: 安装：一直找不到 png的依赖，查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz 执行 convert 提示linux shared libraries 不包含某个库 临时方案：export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 永久方案： 123vi /etc/ld.so.conf在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置然后再执行/sbin/ldconf 4. 常见Convert命令imagemagic的场景使用命令如下 裁图 convert test.jpg -crop 640x960+0+0 output.jpg 旋转 convert test.jpg -rotate 90 output.jpg 缩放 convert test.jpg -resize 200x200 output.jpg 强制宽高缩放 convert test.jpg -resize 200x200! output.jpg 缩略图 convert -thumbnail 200x300 test.jpg thumb.jpg 上下翻转： convert -flip foo.png bar.png 左右翻转： convert -flop foo.png bar.png 水印： composite -gravity northwest -dissolve 100 -geometry +0+0 water.png temp.jpg out.jpg 添加边框 : convert -border 6x6 -bordercolor “#ffffff” test.jpg bord.jpg 去除边框 : convert -thumbnail 200x300 test.jpg thumb.jpg III. 接口设计与实现java调用ImageMagic的方式有两种，一个是基于命令行的，一种是基于JNI的，我们选则im4java来操作imagemagic的接口（基于命令行的操作） 目标： 对外的使用姿势尽可能如 Thumbnailtor，采用builder模式来设置参数，支持多种输入输出 1. im4java使用姿势几个简单的case，演示下如何使用im4java实现图片的操作 1234567891011121314151617181920212223242526272829303132333435363738394041IMOperation op = new IMOperation();// 裁剪op.crop(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY());// 旋转op.rotate(rotate);// 压缩op.resize(operate.getWidth(), operate.getHeight());op.quality(operate.getQuality().doubleValue()); // 精度// 翻转op.flip();// 镜像op.flop();// 水印op.geometry(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY()).composite();// 边框op.border(operate.getWidth(), operate.getHeight()).bordercolor(operate.getColor());// 原始命令方式添加op.addRawArgs(\"-resize\", \"!100x200\");// 添加原始图片地址op.addImage(sourceFilename);// 目标图片地址op.addImage(outputFilename);/** 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 */ConvertCmd convert = new ConvertCmd();convert.run(op); 2. 使用姿势在具体的设计接口之前，不妨先看一下最终的使用姿势，然后逆向的再看是如何设计的 123456789101112131415161718192021private static final String localFile = \"blogInfoV2.png\";/** * 复合操作 */@Testpublic void testOperate() &#123; BufferedImage img; try &#123; img = ImgWrapper.of(localFile) .board(10, 10, \"red\") .flip() .rotate(180) .crop(0, 0, 1200, 500) .asImg(); System.out.println(\"--- \" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 上面这个方法，演示了图片的多个操作，首先是加个红色边框，然后翻转，然后旋转180°，再裁剪输出图片 所以这个封装，肯定是使用了Builder模式了，接下来看下配置参数 3. 接口设计首先确定目前支持的几个方法：OperateType 其次就是相关的配置参数： Operate&lt;T&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136@Datapublic static class Operate&lt;T&gt; &#123; /** * 操作类型 */ private OperateType operateType; /** * 裁剪宽; 缩放宽 */ private Integer width; /** * 高 */ private Integer height; /** * 裁剪时,起始 x */ private Integer x; /** * 裁剪时,起始y */ private Integer y; /** * 旋转角度 */ private Double rotate; /** * 按照整体的缩放参数, 1 表示不变, 和裁剪一起使用 */ private Double radio; /** * 图片精度, 1 - 100 */ private Integer quality; /** * 颜色 (添加边框中的颜色; 去除图片中某颜色) */ private String color; /** * 水印图片, 可以为图片名, uri, 或者inputstream */ private T water; /** * 水印图片的类型 */ private String waterImgType; /** * 强制按照给定的参数进行压缩 */ private boolean forceScale; public boolean valid() &#123; switch (operateType) &#123; case CROP: return width != null &amp;&amp; height != null &amp;&amp; x != null &amp;&amp; y != null; case SCALE: return width != null || height != null || radio != null; case ROTATE: return rotate != null; case WATER: // 暂时不支持水印操作 return water != null; case BOARD: if (width == null) &#123; width = 3; &#125; if (height == null) &#123; height = 3; &#125; if (color == null) &#123; color = \"#ffffff\"; &#125; case FLIP: case FLOP: return true; default: return false; &#125; &#125; /** * 获取水印图片的路径 * * @return */ public String getWaterFilename() throws ImgOperateException &#123; try &#123; return FileWriteUtil.saveFile(water, waterImgType).getAbsFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;public enum OperateType &#123; /** * 裁剪 */ CROP, /** * 缩放 */ SCALE, /** * 旋转 */ ROTATE, /** * 水印 */ WATER, /** * 上下翻转 */ FLIP, /** * 水平翻转 */ FLOP, /** * 添加边框 */ BOARD;&#125; 4. Builder实现简化使用成本，因此针对图片裁剪、旋转等接口，封装了更友好的接口方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314public static class Builder&lt;T&gt; &#123; private T sourceFile; /** * 图片类型 JPEG, PNG, GIF ... * &lt;p&gt; * 默认为jpg图片 */ private String outputFormat = \"jpg\"; private List&lt;Operate&gt; operates = new ArrayList&lt;&gt;(); public Builder(T sourceFile) &#123; this.sourceFile = sourceFile; &#125; private static Builder&lt;String&gt; ofString(String str) &#123; return new Builder&lt;String&gt;(ImgWrapper.class.getClassLoader().getResource(str).getFile()); &#125; private static Builder&lt;URI&gt; ofUrl(URI url) &#123; return new Builder&lt;URI&gt;(url); &#125; private static Builder&lt;InputStream&gt; ofStream(InputStream stream) &#123; return new Builder&lt;InputStream&gt;(stream); &#125; /** * 设置输出的文件格式 * * @param format * @return */ public Builder&lt;T&gt; setOutputFormat(String format) &#123; this.outputFormat = format; return this; &#125; private void updateOutputFormat(String originType) &#123; if (this.outputFormat != null || originType == null) &#123; return; &#125; int index = originType.lastIndexOf(\".\"); if (index &lt;= 0) &#123; return; &#125; this.outputFormat = originType.substring(index + 1); &#125; /** * 缩放 * * @param width * @param height * @return */ public Builder&lt;T&gt; scale(Integer width, Integer height, Integer quality) &#123; return scale(width, height, quality, false); &#125; public Builder&lt;T&gt; scale(Integer width, Integer height, Integer quality, boolean forceScale) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.SCALE); operate.setWidth(width); operate.setHeight(height); operate.setQuality(quality); operate.setForceScale(forceScale); operates.add(operate); return this; &#125; /** * 按照比例进行缩放 * * @param radio 1.0 表示不缩放, 0.5 缩放为一半 * @return */ public Builder&lt;T&gt; scale(Double radio, Integer quality) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.SCALE); operate.setRadio(radio); operate.setQuality(quality); operates.add(operate); return this; &#125; /** * 裁剪 * * @param x * @param y * @param width * @param height * @return */ public Builder&lt;T&gt; crop(int x, int y, int width, int height) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.CROP); operate.setWidth(width); operate.setHeight(height); operate.setX(x); operate.setY(y); operates.add(operate); return this; &#125; /** * 旋转 * * @param rotate * @return */ public Builder&lt;T&gt; rotate(double rotate) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.ROTATE); operate.setRotate(rotate); operates.add(operate); return this; &#125; /** * 上下翻转 * * @return */ public Builder&lt;T&gt; flip() &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.FLIP); operates.add(operate); return this; &#125; /** * 左右翻转,即镜像 * * @return */ public Builder&lt;T&gt; flop() &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.FLOP); operates.add(operate); return this; &#125; /** * 添加边框 * * @param width 边框的宽 * @param height 边框的高 * @param color 边框的填充色 * @return */ public Builder&lt;T&gt; board(Integer width, Integer height, String color) &#123; Operate args = new Operate(); args.setOperateType(OperateType.BOARD); args.setWidth(width); args.setHeight(height); args.setColor(color); operates.add(args); return this; &#125; /** * 添加水印 * * @param water 水印的源图片 (默认为png格式) * @param x 添加到目标图片的x坐标 * @param y 添加到目标图片的y坐标 * @param &lt;U&gt; * @return */ public &lt;U&gt; Builder&lt;T&gt; water(U water, int x, int y) &#123; return water(water, \"png\", x, y); &#125; /** * 添加水印 * * @param water * @param imgType 水印图片的类型; 当传入的为inputStream时, 此参数才有意义 * @param x * @param y * @param &lt;U&gt; * @return */ public &lt;U&gt; Builder&lt;T&gt; water(U water, String imgType, int x, int y) &#123; Operate&lt;U&gt; operate = new Operate&lt;&gt;(); operate.setOperateType(OperateType.WATER); operate.setX(x); operate.setY(y); operate.setWater(water); operate.setWaterImgType(imgType); operates.add(operate); return this; &#125; /** * 执行图片处理, 并保存文件为: 源文件_out.jpg （类型由输出的图片类型决定） * * @return 保存的文件名 * @throws Exception */ public String toFile() throws Exception &#123; return toFile(null); &#125; /** * 执行图片处理,并将结果保存为指定文件名的file * * @param outputFilename 若为null, 则输出文件为 源文件_out.jpg 这种格式 * @return * @throws Exception */ public String toFile(String outputFilename) throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operates null!\"); &#125; /** * 获取原始的图片信息， 并构建输出文件名 * 1. 远程图片，则保存到临时目录下 * 2. stream， 保存到临时目录下 * 3. 本地文件 * * 输出文件都放在临时文件夹内，和原文件同名，加一个_out进行区分 **/ FileWriteUtil.FileInfo sourceFile = createFile(); if (outputFilename == null) &#123; outputFilename = FileWriteUtil.getTmpPath() + \"/\" + sourceFile.getFilename() + \"_\" + System.currentTimeMillis() + \"_out.\" + outputFormat; &#125; /** 执行图片的操作 */ if (ImgBaseOperate.operate(operates, sourceFile.getAbsFile(), outputFilename)) &#123; return outputFilename; &#125; else &#123; return null; &#125; &#125; /** * 执行图片操作,并输出字节流 * * @return * @throws Exception */ public InputStream asStream() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return new FileInputStream(new File(outputFilename)); &#125; public byte[] asBytes() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return BytesTool.file2bytes(outputFilename); &#125; public BufferedImage asImg() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return ImageIO.read(new File(outputFilename)); &#125; private FileWriteUtil.FileInfo createFile() throws Exception &#123; if (this.sourceFile instanceof String) &#123; /** 生成的文件在源文件目录下 */ updateOutputFormat((String) this.sourceFile); &#125; else if (this.sourceFile instanceof URI) &#123; /** 源文件和生成的文件都保存在临时目录下 */ String urlPath = ((URI) this.sourceFile).getPath(); updateOutputFormat(urlPath); &#125; return FileWriteUtil.saveFile(this.sourceFile, outputFormat); &#125;&#125; 参数的设置相关的比较清晰，唯一需要注意的是输出asFile()，这个里面实现了一些有意思的东西 保存原图片（将网络/二进制的原图，保存到本地） 生成临时输出文件 命令执行 上面前两个，主要是借助辅助工具 FileWriteUtil实现，与主题的关联不大，但是内部东西还是很有意思的，推荐查看： https://github.com/liuyueyi/quick-media/blob/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/FileWriteUtil.java 命令执行的封装如下(就是解析Operate参数，翻译成对应的IMOperation) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 执行图片的复合操作 * * @param operates * @param sourceFilename 原始图片名 * @param outputFilename 生成图片名 * @return * @throws ImgOperateException */public static boolean operate(List&lt;ImgWrapper.Builder.Operate&gt; operates, String sourceFilename, String outputFilename) throws ImgOperateException &#123; try &#123; IMOperation op = new IMOperation(); boolean operateTag = false; String waterFilename = null; for (ImgWrapper.Builder.Operate operate : operates) &#123; if (!operate.valid()) &#123; continue; &#125; if (operate.getOperateType() == ImgWrapper.Builder.OperateType.CROP) &#123; op.crop(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY());// if (operate.getRadio() != null &amp;&amp; Math.abs(operate.getRadio() - 1.0) &gt; 0.005) &#123;// // 需要对图片进行缩放// op.resize((int) Math.ceil(operate.getWidth() * operate.getRadio()));// &#125; operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.ROTATE) &#123; // fixme 180度旋转后裁图,会出现bug, 先这么兼容 double rotate = operate.getRotate(); if (Math.abs((rotate % 360) - 180) &lt;= 0.005) &#123; rotate += 0.01; &#125; op.rotate(rotate); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.SCALE) &#123; if (operate.getRadio() == null) &#123; if (operate.isForceScale()) &#123; // 强制根据给定的参数进行压缩时 StringBuilder builder = new StringBuilder(); builder.append(\"!\").append(operate.getWidth() == null ? \"\" : operate.getWidth()).append(\"x\"); builder.append(operate.getHeight() == null ? \"\" : operate.getHeight()); op.addRawArgs(\"-resize\", builder.toString()); &#125; else &#123; op.resize(operate.getWidth(), operate.getHeight()); &#125; &#125; else if(Math.abs(operate.getRadio() - 1) &gt; 0.005) &#123; // 对图片进行比例缩放 op.addRawArgs(\"-resize\", \"%\" + (operate.getRadio() * 100)); &#125; if (operate.getQuality() != null &amp;&amp; operate.getQuality() &gt; 0) &#123; op.quality(operate.getQuality().doubleValue()); &#125; operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.FLIP) &#123; op.flip(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.FLOP) &#123; op.flop(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.WATER &amp;&amp; waterFilename == null) &#123; // 当前只支持添加一次水印 op.geometry(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY()) .composite(); waterFilename = operate.getWaterFilename(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.BOARD) &#123; op.border(operate.getWidth(), operate.getHeight()).bordercolor(operate.getColor()); operateTag = true; &#125; &#125; if (!operateTag) &#123; throw new ImgOperateException(\"operate illegal! operates: \" + operates); &#125; op.addImage(sourceFilename); if (waterFilename != null) &#123; op.addImage(waterFilename); &#125; op.addImage(outputFilename); /** 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 */ ConvertCmd convert = new ConvertCmd(); convert.run(op); &#125; catch (IOException e) &#123; log.error(\"file read error!, e: &#123;&#125;\", e); return false; &#125; catch (InterruptedException e) &#123; log.error(\"interrupt exception! e: &#123;&#125;\", e); return false; &#125; catch (IM4JavaException e) &#123; log.error(\"im4java exception! e: &#123;&#125;\", e); return false; &#125; return true;&#125; 5. 接口封装包装一个对外使用的方式 1234567891011121314151617181920212223242526272829303132public class ImgWrapper &#123; /** * 根据本地图片进行处理 * * @param file * @return */ public static Builder&lt;String&gt; of(String file) &#123; checkForNull(file, \"Cannot specify null for input file.\"); if (file.startsWith(\"http\")) &#123; throw new IllegalArgumentException(\"file should not be URI resources! file: \" + file); &#125; return Builder.ofString(file); &#125; public static Builder&lt;URI&gt; of(URI uri) &#123; checkForNull(uri, \"Cannot specify null for input uri.\"); return Builder.ofUrl(uri); &#125; public static Builder&lt;InputStream&gt; of(InputStream inputStream) &#123; checkForNull(inputStream, \"Cannot specify null for InputStream.\"); return Builder.ofStream(inputStream); &#125; private static void checkForNull(Object o, String message) &#123; if (o == null) &#123; throw new NullPointerException(message); &#125; &#125;&#125; IV. 测试上面基本上完成了整个接口的设计与实现，接下来就是接口测试了 给出几个使用姿势演示，更多可以查看：ImgWrapperTest 123456789101112131415161718192021222324252627282930313233343536373839404142private static final String url = \"http://a.hiphotos.baidu.com/image/pic/item/14ce36d3d539b6006a6cc5d0e550352ac65cb733.jpg\";private static final String localFile = \"blogInfoV2.png\";@Testpublic void testCutImg() &#123; try &#123; // 保存到本地 ImgWrapper.of(URI.create(url)) .crop(10, 20, 500, 500) .toFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;@Testpublic void testRotateImg() &#123; try &#123; InputStream stream = FileReadUtil.getStreamByFileName(localFile); BufferedImage img = ImgWrapper.of(stream).rotate(90).asImg(); System.out.println(\"----\" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;@Testpublic void testWater() &#123; BufferedImage img; try &#123; img = ImgWrapper.of(URI.create(url)) .board(10, 10, \"red\") .water(localFile, 100, 100) .asImg(); System.out.println(\"--- \" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; V. 其他项目：GitHub: 项目：Quick-Media 源码：imagic-plugin Gitee: 项目：Quick-Media 源码：imagic-plugin 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickMedia","slug":"技术/Quick系列项目/QuickMedia","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickMedia/"}],"tags":[{"name":"ImageMagic","slug":"ImageMagic","permalink":"https://zbang.online/hexblog/tags/ImageMagic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickMedia","slug":"技术/Quick系列项目/QuickMedia","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickMedia/"}]},{"title":"CSS图片点击拷贝","slug":"CSS图片点击拷贝","date":"2018-04-16T09:24:55.000Z","updated":"2018-04-16T09:28:48.391Z","comments":true,"path":"2018/04/16/CSS图片点击拷贝/","link":"","permalink":"https://zbang.online/hexblog/2018/04/16/CSS图片点击拷贝/","excerpt":"","text":"I. CSS图片点击拷贝点击实现文本or图片的复制， 主要利用 document.execCommand(&#39;Copy&#39;)来实现 1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt;function copy2board()&#123; var Url2=document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\");&#125;function copyimg(e) &#123; var range = document.createRange(); range.selectNode(e); //selectable为下面页面中DIV中的id window.getSelection().addRange(range); document.execCommand(\"Copy\"); alert(\"复制ok\");&#125;&lt;/script&gt;&lt;textarea cols=\"20\" rows=\"10\" id=\"biao1\"&gt;用户定义的代码区域&lt;/textarea&gt;&lt;input type=\"button\" onClick=\"copy2board()\" value=\"点击复制代码\" /&gt;&lt;img src=\"http://a.hiphotos.baidu.com/image/pic/item/8326cffc1e178a82112604dffa03738da977e8b3.jpg\" width=200 height=200 onclick=\"copyimg(this)\"&gt;&lt;/img&gt; II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"拷贝","slug":"拷贝","permalink":"https://zbang.online/hexblog/tags/拷贝/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"Java面试知识要点之数据库篇二","slug":"Java面试知识要点之数据库篇二","date":"2018-04-13T10:34:40.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/04/13/Java面试知识要点之数据库篇二/","link":"","permalink":"https://zbang.online/hexblog/2018/04/13/Java面试知识要点之数据库篇二/","excerpt":"","text":"Java知识要点汇总之数据库针对网上的一些题目，根据自己的理解进行作答，从而加深理解 I. 问题列表 常见的数据库优化手段 索引的优缺点，什么字段上建立索引 数据库连接池。 durid的常用配置。 MySQL 索引使用的注意事项 说说反模式设计 说说分库与分表设计 分库与分表带来的分布式困境与应对之策 说说 SQL 优化之道 MySQL 遇到的死锁问题 存储引擎的 InnoDB 与 MyISAM 数据库索引的原理 为什么要用 B-tree 聚集索引与非聚集索引的区别 limit 20000 加载很慢怎么解决 选择合适的分布式主键方案 选择合适的数据存储方案 ObjectId 规则 聊聊 MongoDB 使用场景 倒排索引 聊聊 ElasticSearch 使用场景 II. 问题解答1. 常见的数据库优化手段一般优化手段需要结合实际的case来进行分析，大致的类型有以下几点： 数据量过大，千万级、亿级，可以考虑分库分表（有水平分库分表和垂直分库分表两种常见方式，后面详细说明） 减少跨表查询，一般来讲单表查询优化多表的联合查询，可以根据实际情况考虑是否可以将多表查询改成在主业务表中冗余一些数据，从而变成单表查询 由于写DB会加锁，因此可以考虑读写分离 搭建数据库的集群，一主多从的方式 借助explain，判断sql是否走索引，考虑在常见的查询条件中，建立必要的索引or联合索引 避免大翻页查询，注意 limit 1000, 20 实际会查找出1020条数据，但只返回最后的20条数据，看是否记录id偏移量，来避免大翻页 尽量避免排序，特别是没有建立索引的排序，多个字段联合排序，都比较消耗性能 避免出现全表扫描的sql 减少物理删除数据，改成逻辑删除（因为数据删除会涉及到索引变更，而且数据一般而言都是有价值的，物理删除后都没法恢复） 下面的节点来自网上分析结果: MySQL数据库优化的八种方式(经典必看) 选取合适的字段属性 (如char的性能由于varchar，对于性别这种就可以用char(1)来指定) 使用join代替子查询 使用联合(UNION)来代替手动创建的临时表 事务 锁表（对此存有疑问，不太理解这种方式有什么好处） 使用外键 使用索引 优化sql 2. 索引的优缺点，什么字段上建立索引索引，实际上是一种数据结构，为了加快查询定位，比如MySQL的InnoDB中索引就是B+树 a. 优点 索引查询可以避免全表扫描，查询效率更高 b. 缺点 删除、插入和修改数据时，需要建立索引，因此更慢 额外的空间开销，用于存储索引信息 c. 场景 数据量较大时，建立索引更优（几千条数据的场景下，全表扫描可能更优） 针对查询场景，根据最常见的查询条件列建立索引或者联合索引 联合索引中，最具有区分的字段放在前面 d. 字段规则此处来自: 数据库索引的优缺点及原理 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存中都需要更少的空间，处理起来更快 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂，处理起来也更耗时。 尽量避免NULL：应该指定列为NOT NULL 对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义，所以索引的建立应当更多的选取唯一性更高的字段 （说明，对此持不同的看法，性别这种放在联合索引中还是有意义的，大量数据中，直接排除一半还是有效的） 3. 数据库连接池。在正常的jdbc过程中，一个sql的执行过程大致如下： 装载驱动 建立db连接，获取会话 执行sql 关闭会话连接 也就是说在db的操作中，会出现频繁的db连接和销毁，对性能有很大影响；因此数据库连接池和线程池出现的目的一样，都是为了避免频繁的创建和销毁，以实现最大程度的复用为目的的技术手段 数据库连接池 在连接池中提前创建好一些连接，当需要执行sql时，从连接池中获取一个连接执行sql，执行完毕之后，将连接扔回连接池，以此实现复用 连接池无可用连接时（即所有连接都被其他线程持有了）：可以考虑排队策略，或者直接自己去创建一个，根据不同的数据库连接池设计规则来玩 很多连接长时间处于空闲时（即连接数大于实际请求数）：可以考虑给个生命周期的概念，超过一段时间的连接，自动回收掉 注意事项 并发问题 权限问题（如某些库只有满足某些场景才能查询等） 事务支持 合理的分配与释放，提高连接的复用度，从而降低建立新连接的开销，同时还可以加快用户的访问速度。 4. durid的常用配置。没用过，公司有一套自己的数据库中间件，个人感觉来讲，需要关系的配置应该差不多 数据库相关信息： 驱动 jdbcurl 用户名 密码 其他信息： 连接池连接核心数 连接池连接最大数 连接池队列大小 心跳检测（用于判断连接是否ok） 最大活跃连接数 5. MySQL 索引使用的注意事项推荐参考：mysql之索引的工作机制 说注意事项，就得先了解下索引的特性，不按照特性来的肯定是需要注意的了… 索引不包含null值的列（因此db中尽量不要允许列为null，优雅的原则是所有字段强制为not null，并加一个 default ‘’ 默认值） 短索引 最左匹配原则，即联合索引中，如果最左边的列不在sql的查询条件中，则不会走索引 范围查询后不走索引，针对联合索引而言，如果前面匹配的，有范围查询，则联合索引后面匹配的列将不会走索引 如 select * from table where id&gt;100 and uname=&#39;haha&#39;, 联合索引为 (id, uname), 则这个语句中，uname这个条件不会走索引 列作为函数参数或表达式的一部分时，也不走索引 常见的是 select * from table where id+1&gt;50 这个就不能走索引了 6. 说说反模式设计这个主要针对三范式而言，既然有个反字，也就说，在某些场景下，不遵循三范式可能带来较好的优势 a. 三范式根据个人理解的定义如下 第一范式： 原子性，每个列都是不可分割的最小单元 第二范式： 所有的列都与主键有关系 第三范式： 所有的列与主键直接关联 b. 反模式如我前面一篇举得几个例子，就属于反模式 某些场景下，冗余一些其他表的信息，实现将多表联合查询变成单表查询，提高性能 新增一个extra字段，用来存储一些非必要的元数据集合，可以更好的支撑复杂的业务场景，避免频繁的新增列 表中创建一个自增的无业务含义的伪主键，和业务主键区分开来（在分库分表中比较常见） 7. 说说分库与分表设计根据自己之前的实际操作，写了一篇分库分表的实操博文：生产环境分库分表的实际操作全记录 小结以下我的理解： 根据业务逻辑，设置自己逻辑分离的库 分表主要是实现大表拆分为小表 分表时需要一个分表的主键，用于路由到指定的分表 8. 分库与分表带来的分布式困境与应对之策 全局唯一业务主键 单独搞一个服务，来生成全局唯一主键 根据机器mac地址+时间戳来生成唯一主键 分布式事务 没什么太好的方法，可以通过数据对账和订正来避免问题的严重性 复杂查询（如跨表，分页，排序等） 尽量减少跨表查询 避不开时，借助搜索引擎来做（如solr，es） 9. 说说 SQL 优化之道详情可以参考： 数据库SQL优化大总结之 百万级数据库优化方案 这种问题。。。挺难说的，简单说一下常见的吧 explain查看是否走索引，尽量确保sql可以利用索引 查询条件中，左边不要有计算，如 where id+1&gt; 10 使用 &gt;= 代替 &gt; 避免大翻页查询，尽量将 limit a,b 改成 where id&gt;xxx limit b 尽量避免多个列的排序 union all 代替union，业务中进行去重 join代替子查询，避免临时表创建 列尽量不要允许为null 逻辑删除代替物理删除 连续存在的值，between代替 in 尽量不要出现 select *, 改成查具体的列 10. MySQL 遇到的死锁问题没实际接触过，举个小例子 事务1 123456-- 1select * from table where id=1 for update;-- 2select * from table where id=2 for update; 事务2 12345-- 1select * from table where id=2 for update;-- 2select * from table where id=1 for update; 事务1的sql1执行完毕，事务2的sql1执行完毕，都在等待执行sql2时 因为事务2要求获取id=2这一列的独占锁，而锁此时由事务2持有，所以阻塞等待；同样事务2请求id=1这一列的独占锁，被事务1持有，也阻塞等待 导致出现死锁 11. 存储引擎的 InnoDB 与 MyISAM参考前一篇，两者都是B+树 InnoDB MyISAM 单文件，有限制 三文件，无大小限制 支持事务 不支持事务 支持行锁表锁 只支持表锁 需要更多存储空间 可压缩 主键，要么显示指定，要么默认一个 可以么有 支持外键 不支持外键 移植不易，可用binlog，sqldump 移植方便，拷贝文件即可 12. 数据库索引的原理索引是一种数据结构，可以通过它，较快的定位到数据所在的位置，关于索引可以参考下面两个博文 数据库索引原理及优化 mysql之索引的工作机制 简单说明，常见的两种索引数据结构，hash和b树 hash索引： 通过hash值，可以迅速定位到数据所在的位置，然后直接过去查找 B树： 树的遍历姿势，查找到数据所在的位置（innodb的聚集索引叶子节点包含数据） 13. 为什么要用 B-tree二叉树，logN的查找效率 14. 聚集索引与非聚集索引的区别以InnoDB为例进行说明，聚集索引一般也就是主键索引，叶子节点为实际的数据，且叶子节点之间组成一个双向链表 非聚集索引，更多的普通的索引或唯一索引，也是B树，叶子节点为主键，会通过主键再去聚集索引中查询对应的数据 15. limit 20000 加载很慢怎么解决没什么好办法，如果可以持有偏移ID，尽量用 where id&gt;offet limit xxx 更好 16. 选择合适的分布式主键方案常见的几种方式： 根据机器Mac地址 + 时间戳生成主键 独立的主键生成服务，每次接受id请求时，根据来源IP分配一段id范围，保证不同ip的机器，持有不同的范围区间，而请求方生成的id在选定的范围内顺序递增 使用jdk的UUID生成方案 UUID.randomUUID().toString() 17. 选择合适的数据存储方案一般而言，关系数据库MySql存储引擎多半是选择 InnoDB 如果查多，写少时，也可以用 MyISAM，但现在不推荐这么干 hash索引实际用得不太多，真有这种场景推荐使用redis替换 memeory更少见了，所有的数据存在内存中，机器重启or崩溃，数据全丢 非关系型数据库： mongoDB redis、memcache 作为缓存用的场景很多 18. ObjectId 规则ObjectId是什么鬼… 19. 聊聊 MongoDB 使用场景没用过 20. 倒排索引正排索引(forward index)：从文档角度看其中的单词，表示每个文档（用文档ID标识）都含有哪些单词，以及每个单词出现了多少次（词频）及其出现位置（相对于文档首部的偏移量）。 倒排索引(inverted index，或inverted files)：从单词角度看文档，标识每个单词分别在那些文档中出现(文档ID)，以及在各自的文档中每个单词分别出现了多少次（词频）及其出现位置（相对于该文档首部的偏移量）。 简单记为： 正排索引：文档 —&gt; 单词倒 排索引：单词 —&gt; 文档 在搜索引擎中，倒排索引用得比较多 21. 聊聊 ElasticSearch 使用场景根据关键词进行搜索，比如商品搜索中，输入关键词，搜索标题中包含这些关键词的商品，就比较方便了 此外es也常用于日志分析 II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"DB","slug":"工作/面试/DB","permalink":"https://zbang.online/hexblog/categories/工作/面试/DB/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识点汇总","slug":"知识点汇总","permalink":"https://zbang.online/hexblog/tags/知识点汇总/"},{"name":"数据库","slug":"数据库","permalink":"https://zbang.online/hexblog/tags/数据库/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"DB","slug":"工作/面试/DB","permalink":"https://zbang.online/hexblog/categories/工作/面试/DB/"}]},{"title":"生产环境分库分表的实际操作全记录","slug":"生产环境分库分表的实际操作全记录","date":"2018-04-13T08:46:09.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2018/04/13/生产环境分库分表的实际操作全记录/","link":"","permalink":"https://zbang.online/hexblog/2018/04/13/生产环境分库分表的实际操作全记录/","excerpt":"一次分库分表全过程记录实际操刀过一次线上的分库分表，距离现在时间有点久了，现在想一想，发现还是有不少有意思的东西，所以来一个迟到的记录","text":"一次分库分表全过程记录实际操刀过一次线上的分库分表，距离现在时间有点久了，现在想一想，发现还是有不少有意思的东西，所以来一个迟到的记录 I. 背景分析当时主要负责商品评价这一块业务，评价信息单表存储，主要包括一些基本的评价信息，商品id，订单id，买家id和卖家id，当时DB量级已经在3-4亿了，经常出现一些慢SQL，考虑到量级的问题，所以着手分库分表 1. 分库分表首先知道分库分表一般有两种方式，水平划分和垂直划分 在具体划分，可如下 垂直分表：将大表拆分成小表，将表中一些不常用的信息拆分出去，避免跨页查询 垂直分库：根据不同的业务进行划分，每个业务有自己独立的数据库，如商品有商品库，用户有用户库，店铺有店铺库，db与db之间物理or逻辑分离 水平分表：根据表中某些数据行，定义某种映射规则，将不同的数据行分布到不同的表中（表的结构基本不变） 水平分库分表：将水平分表拆分出来的分表，放入不同的库中 2. 业务场景分析根据上面分库分表的理解，很容易得出一个期待的结果 独立的评价库，这个库里面只保存评价相关的信息 采用水平分表，将原表的数据，拆分到1024(这个分表数量可自定义)张分表中（如果拆分的较合理，则单表数据量在30-40w） 那么一个问题就是如何进行水平拆分了，而考虑这一点，则需要根据实际的场景出发，分析sql的case 商品详情的评价查询：根据商品ID进行查询 卖家管理端查询所有评价：根据卖家ID进行查询 买家评价管理：根据买家ID进行查询 订单列表的评价信息：根据订单ID进行查询 粗略可以设定两种分表方案： 方案一：上面四种场景，显然是根据商品ID查询的量最大（因为详情的流量最大），如果根据商品ID进行分表，那么一个商品的评价都在落在一个分表中，此时查询不会出现夸表，但是另外三中查询则会导致跨表；同样换成卖家ID则会导致其他三个查询会跨表 第二种方式，建立一张附表，只保存如下信息 12345rateId: 评价IDitemId: 商品IDsellerId: 卖家IDbuyerId: 买家IDorderId: 订单ID 然后根据rateId进行分库分表，这样每次查询时，先通过附表，查询到对应的评价ID，然后拿rateId到分表去获取评价信息 3. 基本信息在实际的操作之前，先给出当时的表信息（说明，数据库和表名和表结构为本文定义，与实际有差异） define desc 数据库 mysql 存储引擎 innorDB 库名 rate 表名 ItemRate 量级 3-4亿 binlog 开启binlog消息，有下游业务方通过mq方式消费db的变更 表结构类似下表，干掉了很多与主题无关的信息 12345678910111213CREATE TABLE `ItemRate` ( `id` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;评价id&apos;, `orderId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;订单id&apos;, `buyerId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;买家ID&apos;, `sellerId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;卖家ID&apos;, `itemId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;商品ID&apos;, `comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评价内容&apos;, `imgUrls` varchar(500) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;上传的图片&apos;, `created` int(11) unsigned NOT NULL DEFAULT &apos;0&apos;, `updated` int(11) unsigned NOT NULL DEFAULT &apos;0&apos;, `info` tinyint(4) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;其他信息，省略...&apos;, PRIMARY KEY `id` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&apos;评价表&apos;; II. 设计&amp;实现在实际操作之前，首先是选择如何分库分表的方案了，其次就是整个操作的步骤规划，当这两个搞定之后，在开始编码实现才是比较合适的 首先确定分4库1024张表 （组内大神的建议，合理分表规则后单表量级在10w级别，业务没有大变化时，短期内将无序再次分表） 1. 方案设计前面业务场景的分析中，就给出了两种方式，一个是根据商品ID进行分表，一个是建立一个附表然后根据rateId进行分表，首先是分表规则，我们选择最简单的方式，根据id % 1024进行取模 接下来分析下两种的优劣 a. itemID分表方案优点： 相比与下一种而言，实现简单，无需附表，也不用考虑数据不一致问题 可以支持详情评价列表复杂的排序逻辑（当时排序方案不是离线计算的，走的DB的排序方式） 性能更优，少了一张附表的过渡 缺点： 非itemId查询会跨表 hash不均，导致单表量较多（比如可能出现某些爆款商品就有几十万的评价） b. rateId分表方案优点： 支持前面的几种查询场景，不过需要先查询出rateId 单表数据量分布均匀 缺点： 复杂的查询条件支持不友好，特别是排序，过滤等依赖到一些评价信息的场景 插入和更新时，都需要同步更新附表，这个保证复杂性更高（即要满足多表的事务，需要自己实现失败回滚） 每次查询都需要先通过附表查询rateIds，效率更低（公司内的数据库中间件不允许join查询） c. 方案选择通过实际分析，选择了根据itemId进行分表的方案，理由如下： 业务逻辑简单，后续维护也方便 线上的sql中，95%以上都是根据itemId进行查询 上层有一层根据solr的搜索，因此根据buyerId,sellerId,orderId 可以走搜索，不需进行db的多表联合查询，且性能ok 附表虽然结构简单，但是单表最终的数据量依然可能很大，在亿级已上性能怎样也不好保证 因此，最终选择的方式是： 1234567db ： Rate000 ~ Rate003, table ： ItemRate0000 ~ ItemRaet1023其中映射规则：tableIndex = itemId % 1024 ---&gt; 分表名 如 ItemRate0122dbIndex = itemId % 1024 / 256 ---&gt; 分库名 如 Rate001 2. 步骤计划整个迁移的步骤，有两种方式，一个是双写方案： 方案一：采用双写 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 线上开始双写（即新增一条评价时，即写入就得表，也写入新的表） 全量将旧表数据导入到新表数据 线上读流量切换到新表，验证是否有问题 所有关注旧表binlog的业务，全部迁移到关注新表的binlog（这里需要dba支持，因为新表有1024张，不可能关注1024个topic，这里需要dba提供binlog的整合，不在本文重点，此处略过） 关闭双写，所有写直接切到新表 删除旧代码 方案二：基于db的binlog实现的异步同步方式 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 开启增量，将某个时刻开始之后所有更新的数据，通过异步方式增量同步到新表 开始全量，将之前的数据全部导入到新表 线上读切新表，验证服务是否有问题 所有关注旧表binlog业务，全部迁移到关注新表binlog 线上切写到新表 增量完毕后，关闭增量 删除旧代码 两种方案本质上没有太大的区别，其中第一种双写，需要自己来保障双写成功；而后面增量的方式，一般DBA这边会有较好的方案来实现增量同步 额外说一点, 在实际的场景中，推动接听旧表binlog的业务方迁移是一件不可控的操作（因为啥原因大家都懂得），所以当时实际的情况是切到新表后，还会进行反向同步，即将新表的数据又重新的写入到旧表中，因此这种场景要求方案二中，切写到新表时，需要先停写一段时间，等待增量同步完毕之后，关闭增量，然后开启反向同步脚本，然后再切写 因为停写，对业务会有影响，所以当时采取第一种方案，因为反向同步不再本文重点，所以如果不考虑反向同步的情况，上面两种方式没有什么区别 3. 注意事项 全量迁移，如果dba没有提供相关工具的话，就只能自己写了，当时是找了一台机器，部署了个服务利用jdbcTemplate来扫表，实现全量数据插入 双写时，需要注意，如果双写失败应该怎么办 数据对账比较有必要 III. 小结1. 分库分表 一般而言，当量级达到qw时，就该考虑分库分表了，不同的业务有自己独立的库 根据表中某些列进行分表，将大表数据拆分到分表中 大表拆分为小表 2. 一般实现步骤 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 线上开始双写 全量将旧表数据导入到新表数据 线上读流量切换到新表，验证是否有问题 关闭双写，所有写直接切到新表 删除旧代码 IV. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"分库分表","slug":"工作/分库分表","permalink":"https://zbang.online/hexblog/categories/工作/分库分表/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"https://zbang.online/hexblog/tags/分库分表/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"分库分表","slug":"工作/分库分表","permalink":"https://zbang.online/hexblog/categories/工作/分库分表/"}]},{"title":"Java面试知识要点之数据库篇一","slug":"Java面试知识要点之数据库篇一","date":"2018-04-13T02:57:17.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/04/13/Java面试知识要点之数据库篇一/","link":"","permalink":"https://zbang.online/hexblog/2018/04/13/Java面试知识要点之数据库篇一/","excerpt":"Java知识要点汇总之数据库针对网上的一些题目，根据自己的理解进行作答，从而加深理解","text":"Java知识要点汇总之数据库针对网上的一些题目，根据自己的理解进行作答，从而加深理解 I. 问题列表问题1： 事务四大特性（ACID）原子性、一致性、隔离性、持久性？ 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？ MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？ MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？ 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？ 什么是临时表，临时表什么时候删除? MySQL B+Tree索引和Hash索引的区别？ 聚集索引和非聚集索引区别？ 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？ 非关系型数据库和关系型数据库区别，优势比较？ 数据库三范式，根据某个场景设计数据表？ 数据库的读写分离、主从复制，主从复制分析的 7 个问题？ 使用explain优化sql和索引？ MySQL慢查询怎么解决？ 什么是 内连接、外连接、交叉连接、笛卡尔积等？ mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？ varchar和char的使用场景？ mysql 高并发环境解决方案？ 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？ 问题2： 常见的数据库优化手段 索引的优缺点，什么字段上建立索引 数据库连接池。 durid的常用配置。 MySQL 索引使用的注意事项 说说反模式设计 说说分库与分表设计 分库与分表带来的分布式困境与应对之策 说说 SQL 优化之道 MySQL 遇到的死锁问题 存储引擎的 InnoDB 与 MyISAM 数据库索引的原理 为什么要用 B-tree 聚集索引与非聚集索引的区别 limit 20000 加载很慢怎么解决 选择合适的分布式主键方案 选择合适的数据存储方案 ObjectId 规则 聊聊 MongoDB 使用场景 倒排索引 聊聊 ElasticSearch 使用场景 II. 问题解答1. 事务四大特性（ACID）原子性、一致性、隔离性、持久性？首先这个问题需要了解什么是事务，然后才能更好的分析四个特性 事务 简单来说就是一组sql，要么全部执行，要么全部不执行 原子性 一个事务要么保证其中的操作要么全部执行，要么全部不执行 一致性 要求数据从一个一致性状态达到另一个一致性状态 隔离性 一个事务未执行完毕，通常保证其他的session无法获取这个事务执行结果 持久性 一旦事务提交，那么这个结果就会保存下来，即便系统崩溃，数据也不会丢失 2. 事务的并发？事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别？事务的并发主要指在分布式环境下多个事务同时执行的情况，事务隔离级别有四个，mysql默认为RR级别 a. read uncommited（RU）未提交读，最低的一个隔离级别，一个事务可以获取到另一个事务未提交的结果 可能导致脏读 b. read commited (RC)提交读， 确保一个事务如果没有全部执行完毕，另外的事务无法获取这个事务的执行结果 解决了脏读 可能出现幻读 c. repeatable read (RR)可重复读，这里就需要理解什么是重复读了 重复读：指一个事务的执行过程中，一个sql不管执行多少次，返回的都是相同的结果 RR与RC的区别就是解决了幻读的问题，也就是说一个事务T1在执行过程中，如果另一个事务T2修改了相同的数据DataA，对T1而言，不管查询多少次DataA，获取到的结果都是一样的（也就是之前的那一条记录） d. serializable最强的隔离级别，通过给事务中每次读取的行加读锁，写加写锁，保证不出现幻读，但是会导致大量的锁竞争 3. MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？当前mysql的默认引擎为InnoDB， 相比较与MyISAM 而言，最主要的就是支持事务、行锁，在删除、更新、插入场景较多的情况下，由于MyISAM，而仅查询较多的场景下，后者更优 两者对比可参考：MySQL存储引擎中的MyISAM和InnoDB区别详解 对比 innoDB myisam 存储结构 表结构，索引，数据存于同一数据文件，有上限 三个文件，表结构，数据文件，索引文件，无上限 存储空间 需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可被压缩，存储空间较小 移植性，备份恢复 基于binlog或sqldump进行移植，数据量大时，不太方便 直接拷贝文件即可 事务特性 支持 不支持 自增特性 自增必然加索引，唯一性要求，联合索引时，要求放最前面 可建立联合索引，不必须是首位 表锁 行锁表锁页锁 只支持表锁 主键 没指定时，默认生成一个 允许不设置主键和索引 表行 需要全表扫描 记录了总行数，直接返回 curd 更新删除场景下更优 读取和插入场景下更优 外健 支持 不支持 说明 两者的底层存储结构都是B+树，最明显的区别是InnoDB的聚簇索引叶子节点就是数据，而MyIsam的叶子节点为数据的地址 现在基本上都是用innodb，myISAM已经不太适用了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低 MEMORY存储引擎 它使用存储在内存中的内容来创建表，而且数据全部放在内存中，默认使用hash索引，因此在查询时效率更高，当然也就存在hash索引本身的缺陷了 此外就是数据在内存中，安全性不高，机器down掉之后，数据都丢了，基本上不怎么用 真有这种需求场景，个人感觉redis/memcache可能更加合适 4. MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景？见上面的分析，简单而言 InnoDB: 支持事务，支持行锁，表锁 MyISAM: 不支持事务，只支持表锁 5. 查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序？1select * from table where xxx group by xx having xxx order by xxx limit xxx from：选中查询的表 where：过滤条件 group by：对上面过滤条件的数据进行分组 having: 对分组的数据进行过滤 order by：对上面的结果进行排序 limit：对排序的结果，截取对应分页的指定个数数据 from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。 6. 什么是临时表，临时表什么时候删除?临时表只在当前连接可见，当连接关闭后，mysql会自动删除并释放空间 创建方式，类似创建表，只是需要加一个 TEMPORARY 关键字 123456CREATE TEMPORARY TABLE tmp_table ( NAME VARCHAR (10) NOT NULL, time date NOT NULL);select * from tmp_table; 也可以手动删除 1drop temporary table if exists tmp_table; 7. MySQL B+Tree索引和Hash索引的区别？首先从命名上可以很容易区分一点，一个是通过二叉树遍历来查询数据；一个则是基于hash值进行定位，所以有一些很明显的区别 hash索引 hash索引只能用于精确查询，也就是支持 =, in, &lt;&gt;； 不能使用范围查询 hash索引不支持排序 hash索引对组合索引的情况，不支持部分索引的列进行查询，因为hash值的计算会用到所有完整的列进行计算，只用其中部分列，无法计算获得hash值 hash碰撞比较频繁时，性能退化严重； B+Tree索引 支持范围查询，支持 =, &gt;, &lt;, &lt;&gt;, in, not in 等各种查询条件 支持排序，支持分组，支持部分索引 非叶子节点存放key和下一层的地址，数据存放在叶子节点上，且叶子与叶子之间维持一个链表 mysql中，只有heap/memory引擎显示支持hash索引，常见的innoDO采用的b+树索引，他们两的区别比较明显 hash索引更加适合精确的查询; B+树除了精确查询之外，对于范围查询，模糊查询(like语句)，部分索引的情况更加友好 hash索引不支持排序的场景；b+树因为叶子节点的链表结构，支持排序 hash索引在hash碰撞严重时，性能就会有波动；而B+树则相对较稳 8. 聚集索引和非聚集索引区别？聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致 聚集索引 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。 聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序 非聚集索引 非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致， 两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。 非聚集索引层次多，不会造成数据重排。 9. 有哪些锁（乐观锁悲观锁），select 时怎么加排它锁？数据库中我们常说的有读锁，写锁，行锁，表锁，gaplock, next key lock 读锁：读锁允许多个连接同时读取相同的资源，但有写资源的链接则会被阻塞 写锁：同一时刻，只允许有一个连接访问和操作资源 行锁：表示锁住的是某些行记录 表锁：表示整个表都被锁住了，不允许请求这个表上的读锁和写锁 gaplock: 主要是为了解决重复读问题，不允许插入满足相同条件的数据 next key lock: 锁住一个范围，如 (where id&gt;10 and id&lt;20，则不允许插入id在10,20之间的行) mysql的mvvc策略，使常见的select * from table为拷贝读，不加锁 select * from table lock in share mode; 加读锁 select * from table for update; 加写锁 下面回到题中说的乐观锁和悲观所 乐观锁 在多线程中经常出现这个概念，特别是CAS，DB中的乐观锁也差不多这个概念，其表示先尝试去执行事务，在执行过程中，发现有其他的事务也修改了数据，则事务回滚 简单来说，就是不加锁，先尝试去操作，如果操作成功，则over；如果失败，则回滚 一般会借助一个version来区分当前事务操作的数据版本，并将version作为sql的定位条件；每次修改，version都会+1 因此，当本事务在执行修改时，如果其他事务修改了数据，则db中version值将不会匹配当前事务的查询条件，因此修改失败，此时需要在业务逻辑中，触发回滚 悲观锁 悲观锁，则表示在操作之前，先获取锁，那么其他的事务操作同样的数据，就会有锁的竞争，一般使用 select for update来使用悲观锁 对比 乐观锁和悲观锁是实际业务开放中常见的两个技术手段，其中悲观所mysql层面上支持了，而乐观锁一般是由业务方自己来实现；根据不同的应用场景进行选择 响应速度：如果需要非常高的响应速度，显然乐观锁更加合适（因为不加锁，要么成功，要么回滚） 冲突频率：如果冲突频率较高，则推荐使用悲观锁（冲突太高，那么乐观锁的失败率就高，需要业务上做较多的重试逻辑） 重试代价：重试代价如果特别大，则采用悲观锁 10. 非关系型数据库和关系型数据库区别，优势比较？非关系型数据库 kv键值结构 扩展性方便 性能高 关系型数据库 支持复杂查询 支持事务特性 11. 数据库三范式，根据某个场景设计数据表？三范式，实际生产环境中，并不一定严格按照这个来做，简单的说一下三个定义 第一范式：每个元素是最小不可分割的 第二范式：每列数据都与主键有关联 第三范式：每列与主键是直接关联的，而非间接关联 谈一下个人理解，在实际的生产环境中，打破三个范式的场景还是比较多的，需知跨表的查询肯定是没有单表的查询性能优越，因此一些表中经常会冗余一些可能并不是直接关联的数据 实例分析 如电商的一个评价表的设计： 评价信息的显示中，经常会显示评价对应的订单快照信息（购买时的商品sku信息，如尺码，颜色等），而这些信息又都是不可修改的 按照第三范式，订单快照肯定是与评价非直接关联的，所以不应该丢在表中，而是在展示时，额外从订单表中查询；但在实际环境中，更常见是将快照直接冗余到评价表中，这样就避免了跨表查询 评价的表记录中，我们可能会关系提交评价时的一些附属信息（如评价的渠道，app版本，设备id等），而这些信息单独的放在一张表中，成本又太大；如果在评价表中创建很多这样的列，又得不偿失（因为这些数据可能随时增加or减少）；因此一个手段是： 在评价表中，创建一个字段 extraInfo, 设置为text(或varchar)类型，将所有的附属信息按照某种结构（如json）塞进去 上面这种方式在实际生产环境中比较常见，多这么个字段，以后随着业务发展，需要新增数据类型时，也避免了频繁的新增列了 明显不符合第一范式的要求 12. 数据库的读写分离、主从复制，主从复制分析的 7 个问题？一般来讲，单机上的数据库，再怎么牛也有个性能瓶颈，所以常见的是搞多个数据库，搭建一个集群，其中一个数据库设置为主库，其他的设置为从库 一般的使用场景： 数据库的新增，更新 &gt;&gt; 操作主库 &gt;&gt;&gt;&gt; 主库更新之后，同步到从库 数据库的查询 &gt;&gt; 查询从库 a. 问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？slave库通常不进行写操作，不然就会出现不一致的问题；简单来讲就是写操作是主库；读操作是从库 b. 问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？实际的环境中，读的操作往往是远大于写操作的，读写分离，可以较少锁开销竞争导致性能开销 其次，如果master跪了，还可以选择一个slave重新设置为master，这样就减轻故障严重性 c. 问题3：主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库很常见的一个问题，到底选择哪个呢？ 就是个负载均衡的问题，传说中的路由就上线了，常见的是轮询、hash映射、权重等手段 d. 问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？设置备份 e. 问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？发n次，分别发给其他的n个slave 一个问题随知而来，对master的性能负担加重了，所以实际的场景中，再选择一个slaveA，master发送的事件只发一次，给slaveA，然后由slaveA发送n-1次给剩余的slave，这样就可以减少master的性能开销了 f. 问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。 g. 问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢其实很多问题都是可以通过堆钱堆机器来解决，一个非常好的解决方案： 机械硬盘换固态硬盘 （性能会极大提高，缺点就是贵） 言归正传，当数据量非常大时，分库分表是最好的选择 水平分表 垂直分表 13. 使用explain优化sql和索引？explain 关键词，可以很好的用于查询sql是否走索引，对慢sql的分析有很好的帮助，用法也比较简单，在sql最前面加上explain即可 14. MySQL慢查询怎么解决？ slow_query_log 慢查询开启状态。 slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。 long_query_time 查询超过多少秒才记录。 实际上要具体问题具体分析，常见的优化手段 没走索引时看是否可以有必要加索引 优化sql写法，比如 !=, or, 范围查询，排序等，看实际场景是否能优化 15. 什么是 内连接、外连接、交叉连接、笛卡尔积等？主要是指跨表查询时，怎么返回数据的场景 内连接：只返回满足条件的数据 左外链接：返回左表所有的数据 + 右表中满足条件的数据 右外链接：返回坐标符合条件的数据 + 右表中所有的数据 全外链接：包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。 交叉链接：生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配 一个实际的case进行分析，两张表 userA, userB，两者数据如下 123456789101112131415select * from userA;+----+-----------+----------+---------+| id | username | password | address |+----+-----------+----------+---------+| 4 | 一灰 | 1 | 杭州 || 5 | 一灰灰 | 2 | 西湖 |+----+-----------+----------+---------+select * from userB;+----+-----------+------+| id | uname | pwd |+----+-----------+------+| 4 | 一灰灰 | a || 5 | 二灰 | b |+----+-----------+------+ a. 内连接方式– 语法：select 表1 inner join 表2 on 查询条件 12345678select * from userA a inner join userB b on a.username=b.uname;-- 输出-- +----+-----------+----------+---------+----+-----------+------+-- | id | username | password | address | id | uname | pwd |-- +----+-----------+----------+---------+----+-----------+------+-- | 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a |-- +----+-----------+----------+---------+----+-----------+------+ b. 左外连接– 语法：select 表1 left join 表2 on 查询条件 注意下面的返回，左表的数据都返回了 12345678select * from userA a left join userB b on a.username=b.uname;+----+-----------+----------+---------+------+-----------+------+| id | username | password | address | id | uname | pwd |+----+-----------+----------+---------+------+-----------+------+| 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || 4 | 一灰 | 1 | 杭州 | NULL | NULL | NULL |+----+-----------+----------+---------+------+-----------+------+ c. 右外链接– 语法：select 表1 right join 表2 on 查询条件 12345678select * from userA a right join userB b on a.username=b.uname;+------+-----------+----------+---------+----+-----------+------+| id | username | password | address | id | uname | pwd |+------+-----------+----------+---------+----+-----------+------+| 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || NULL | NULL | NULL | NULL | 5 | 二灰 | b |+------+-----------+----------+---------+----+-----------+------+ d. 全外链接– 语法：select 表1 full join 表2 on 查询条件 mysql不支持full join，会抛语法错误，可以借助left join 和 right join 来实现 1234567891011121314151617181920212223242526select * from userA a left join userB b on a.username=b.uname union select * from userA a right join userB b on a.username=b.uname;+------+-----------+----------+---------+------+-----------+------+| id | username | password | address | id | uname | pwd |+------+-----------+----------+---------+------+-----------+------+| 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || 4 | 一灰 | 1 | 杭州 | NULL | NULL | NULL || NULL | NULL | NULL | NULL | 5 | 二灰 | b |+------+-----------+----------+---------+------+-----------+------+-- 因为union会去重，所以更体检的是直接使用union all， 然后业务中去重select * from userA a left join userB b on a.username=b.uname union all select * from userA a right join userB b on a.username=b.uname;+------+-----------+----------+---------+------+-----------+------+| id | username | password | address | id | uname | pwd |+------+-----------+----------+---------+------+-----------+------+| 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || 4 | 一灰 | 1 | 杭州 | NULL | NULL | NULL || 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || NULL | NULL | NULL | NULL | 5 | 二灰 | b |+------+-----------+----------+---------+------+-----------+------+ e. 交叉连接（笛卡儿积）– 语法： cross join 123456789101112131415161718192021select * from userA a cross join userB b;+----+-----------+----------+---------+----+-----------+------+| id | username | password | address | id | uname | pwd |+----+-----------+----------+---------+----+-----------+------+| 4 | 一灰 | 1 | 杭州 | 4 | 一灰灰 | a || 5 | 一灰灰 | 2 | 西湖 | 4 | 一灰灰 | a || 4 | 一灰 | 1 | 杭州 | 5 | 二灰 | b || 5 | 一灰灰 | 2 | 西湖 | 5 | 二灰 | b |+----+-----------+----------+---------+----+-----------+------+-- 带上比较条件时, 不等则可以有笛卡儿积的组合，如果相等，则就和内连接select * from userA a cross join userB b on a.username&lt;&gt;b.uname;+----+-----------+----------+---------+----+-----------+------+| id | username | password | address | id | uname | pwd |+----+-----------+----------+---------+----+-----------+------+| 4 | 一灰 | 1 | 杭州 | 4 | 一灰灰 | a || 4 | 一灰 | 1 | 杭州 | 5 | 二灰 | b || 5 | 一灰灰 | 2 | 西湖 | 5 | 二灰 | b | 16. mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决？ 页锁 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 表锁 不会出现死锁 场景：表结构修改，非索引的全表写 行锁 会出现死锁 场景：某些具体列的写操作 17. varchar和char的使用场景？char的长度是不可变的，而varchar的长度是可变的 char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找 char长度固定，因此实际塞入数据小于指定长度时，会由空格填充；获取数据时，会trim掉空格 char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。 varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。 18. mysql 高并发环境解决方案？MySQL 高并发环境解决方案 分库 分表 分布式 增加二级缓存。。。。。需求分析：互联网单位 每天大量数据读取，写入，并发性高。 现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。 集群方案：解决DB宕机带来的单点DB不能访问问题。 读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。 19. 数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）？a. undo log在操作数据之前，将记录之前的数据持久化在undo log中，然后进行修改，如果出现问题，则根据undo log中记录的备份数据，恢复到事务开始之前的状态 流程演示： 12345678A.事务开始.B.记录A=1到undo log.C.修改A=3.D.记录B=2到undo log.E.修改B=4.F.将undo log写到磁盘。G.将数据写到磁盘。H.事务提交 重点步骤： 在操作数据之前，记录备份数据到undo log（否则拿不到之前的数据） 在事务提交之前，undo log持久化，接着数据更新到数据库 出现错误或者接受到rollback命令时，根据undo log进行备份恢复 缺点： 要去在undo log持久化之前，并没有直接操作数据库中的记录，相反操作的只是内存中拷贝，避免在undo log没有持久化时，系统崩溃导致无法恢复 会出现大量的磁盘io b. redo log相比较与undo log记录之前的记录，redo log记录新数据的备份，在数据提交之前，持久化redo log即可，不需要写到db 流程演示： 123456789A.事务开始.B.记录A=1到undo log.C.修改A=3.D.记录A=3到redo log.E.记录B=2到undo log.F.修改B=4.G.记录B=4到redo log.H.将redo log写入磁盘。I.事务提交 分析： 事务提交后，数据更新db成功前崩溃，可以通过redo log更新新的数据 在redo log写入磁盘之前崩溃，即没有提交事务就崩溃了，也就不需要恢复（认为这次是不合法的数据操作，此时DB中数据也没有变动） 缺点： 同样有io写磁盘的问题 20. 问题II见下一篇III. 其他参考 20个数据库常见面试题讲解 数据库面试题(开发者必看) 相关博文 mysql基本语法学习小结 mysql之索引的工作机制 mysql之锁与事务详解 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"DB","slug":"工作/面试/DB","permalink":"https://zbang.online/hexblog/categories/工作/面试/DB/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识点汇总","slug":"知识点汇总","permalink":"https://zbang.online/hexblog/tags/知识点汇总/"},{"name":"数据库","slug":"数据库","permalink":"https://zbang.online/hexblog/tags/数据库/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"DB","slug":"工作/面试/DB","permalink":"https://zbang.online/hexblog/categories/工作/面试/DB/"}]},{"title":"Mybatis框架学习之使用篇二：标签语法","slug":"Mybatis框架学习之使用篇二：标签语法","date":"2018-04-11T03:43:14.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/11/Mybatis框架学习之使用篇二：标签语法/","link":"","permalink":"https://zbang.online/hexblog/2018/04/11/Mybatis框架学习之使用篇二：标签语法/","excerpt":"Mybatis框架学习之使用篇二：标签语法常用标签的使用姿势小结及参数绑定的三种方式 select update delete insert choose, when, otherwise if bind foreach trim set where","text":"Mybatis框架学习之使用篇二：标签语法常用标签的使用姿势小结及参数绑定的三种方式 select update delete insert choose, when, otherwise if bind foreach trim set where I. 结构标签xml中，一般常见的写法如下 123&lt;select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.String\" &gt; selext * from xxx where ...&lt;/select&gt; 1. 结构说明分析上面的demo，三个参数比较重要 id：与dao层接口中定义的方法对应，不允许出现相同id的case resultMap: 出参 resultType: 出参类型 parameterType：传参类型 2. sql片段定义一般我们查询时，大多不建议直接使用 select * 的方式，而是具体的写上查询的列，然后一个问题就来了，每个查询都得写上一遍，不仅麻烦，对于后续表结构标定时，需要改的地方要多，所以就有了sql片段定义 ：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性 实际case 123456789101112131415&lt;sql id=\"poetryEntity\"&gt; id, title, author, content, `explain`, `type`, `tag`, `theme`, `is_deleted` as isDeleted, UNIX_TIMESTAMP(`created_at`) as created, UNIX_TIMESTAMP(`updated_at`) as updated&lt;/sql&gt;&lt;!-- 引用方式 --&gt;&lt;select id=\"queryPoetryById\" parameterType=\"long\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id=#&#123;id&#125;&lt;/select&gt; 3. 常见标签1234- &lt;select&gt; 表示这是一个查询sql- &lt;update&gt; 更新sql- &lt;delete&gt; 删除sql- &lt;insert&gt; 插入sql II. 内部标签1. where通常sql中，所有的where都可以被&lt;where&gt;替换，而这个标签的主要作用是为了防止sql可能出现的异常状况，如以下几种case a. case1 无查询条件1234select * from table where&lt;if test=\"id != null\"&gt; id = #&#123;id&#125;&lt;/if&gt; 当id不存在时，导致上面的sql被解析为 select * from table where, 显然这是一个非法sql b. case2 最前or最后的连接条件1234567select * from table where&lt;if test='id != null'&gt; id = #&#123;id&#125;&lt;/if&gt;&lt;if test='uname != null'&gt; and uname=#&#123;uname&#125;&lt;/if&gt; 当id不存在，uname存在时，上面的sql被解析为 select * from table where and uname=#{uname, 显然也是非法sql 所以，这种场景下，用&lt;where&gt;标签优势就很明显了，在解析时，会根据实际的sql，来决定是否有where，是否去掉前面和后面非法的and/or c. trim标签除了直接使用where标签之外，更常见的一个就是标签了， prefix：前缀 suffix：后缀 prefixOverrides：忽略第一个指定分隔符 suffixOverrides：会略最后一个分隔符 1234567891011121314&lt;select id=\"user\" parameterType=\"user\" resultType=\"User\"&gt; select * from user &lt;trim prefix=\"WHERE\" prefixoverride=\"and | or\"&gt; &lt;if test=\"id!=null and id!=''\"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"name!=null and name!=''\"&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=\"gender!=null and gender!=''\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 2. foreach用于循环的场景，如常见的 xxx in (xxx, xxx) ，通常就是foreach来使用 collection：迭代的参数，一般是个列表or数组，值一般直接为参数名 index： 迭代过程中，元素的别称 open： 开始符号 如( close: 结束符号，如) separator：分割符号 一个实际case如下 接口为： 1List&lt;PoetryEntity&gt; queryPoetryByIds(@Param(\"ids\") List&lt;Long&gt; ids); 对应的sql为 123456789101112&lt;select id=\"queryPoetryByIds\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id IN &lt;foreach collection=\"ids\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; limit 500&lt;/select&gt; 3. Choose选择标签，类似java中的switch，一旦其中一个条件匹配，整个choose块结束 一个xml如下 1234567891011121314151617181920&lt;select id=\"getUserList_choose\" resultMap=\"resultMap_user\" parameterType=\"com.yiibai.pojo.User\"&gt; SELECT * FROM User u &lt;where&gt; &lt;choose&gt; &lt;when test=\"username !=null \"&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/when &gt; &lt;when test=\"sex != null and sex != '' \"&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/when &gt; &lt;when test=\"birthday != null \"&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/when &gt; &lt;otherwise&gt; limit 10 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; mybatis的这个选择，基本上和我们的switch语句一样， 对应关系如下 1234567&lt;choose&gt; ---- switch&lt;when&gt;&lt;/when&gt; ---- case cond1&lt;when&gt;&lt;/when&gt; ---- case cond2&lt;otherwise&gt;&lt;/otherwise&gt; ---- default&lt;/choose&gt; 4. if条件判断，在拼装sql时，最常见的就是为了防止传入null的参数，导致拼出一个业务逻辑有问题的sql，用if标签就很有用了 使用姿势也比较简单了，主要是内部的test条件判断 123&lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125;&lt;/if&gt; 5. set标签更新的时候使用，同样是为了解决拼装成的sql中，最前面or最后面的英文逗号 1234567891011121314&lt;update id=\"userUpdate\" parameterType=\"user\"&gt; update user &lt;set&gt; &lt;if test=\"id!=null and id!=''\"&gt; id=#&#123;id&#125;, &lt;/if&gt; &lt;if test=\"name!=null and name!=''\"&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=\"gender!=null and gender!=''\"&gt; gender=#&#123;gender&#125;, &lt;/if&gt; &lt;/set&gt;&lt;/update&gt; 6. bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文 比如对于like查询，需要在参数的前面or后面加上 %， 就可以这么玩： 123456789&lt;select id=\"queryPoetryByContent\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; &lt;bind name=\"pattern\" value=\"'%' + content + '%'\" /&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where content LIKE #&#123;pattern&#125; limit 10&lt;/select&gt; 上面的也可以使用concat来做，如下 12345678&lt;select id=\"queryPoetryByContent\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where content LIKE CONCAT(CONCAT('%', #&#123;content&#125;), '%') limit 10&lt;/select&gt; III. 参数替换dao层的参数，是如何传入到xml中的sql语句的呢？ 1. map传递dao层接口参数为map，xml中可以直接通过map中的key，来绑定参数 1public User selectUser(Map paramMap); 假设传入的参数为两个，uname, password 对应的xml为 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;uname，jdbcType=VARCHAR&#125; and password=#&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; 2. 参数位置替换这种是直接根据参数的索引位置来绑定， {0} 表示第一个参数， {1} 表示第二个参数 1public User selectUser(String uname, String password); 对应的xml 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;0&#125; and password=#&#123;1&#125;&lt;/select&gt; 3. 注解指定方式通过 @Param注解，直接指定name，在sql中即可通过name方式引用 1public User selectUser(@Param(\"uname\") String uname, @Param(\"password\") String password); 对应的sql为 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;uname，jdbcType=VARCHAR&#125; and password=#&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; 4. $#区别使用#传入参数是，sql语句解析是会加上””, 比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是 select * from table where name = &quot;小李&quot;，就是会当成字符串来解析 因此在动态排序时，比如 order by column，这个时候务必要用${},因为如果你使用了#{} 区别 #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号 $将传入的数据直接显示生成在sql中 #方式能够很大程度防止sql注入 $方式无法防止Sql注入 $方式一般用于传入数据库对象，例如传入表名，列名 简单来说，两者区别： $ 是sql替换，直接拼成一条可执行sql； # 是参数替换 IV. 其他项目工程 study-demo 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zbang.online/hexblog/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}]},{"title":"Mybatis框架学习之使用篇一：基本环境","slug":"Mybatis框架学习之使用篇一：基本环境","date":"2018-04-11T03:39:10.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/11/Mybatis框架学习之使用篇一：基本环境/","link":"","permalink":"https://zbang.online/hexblog/2018/04/11/Mybatis框架学习之使用篇一：基本环境/","excerpt":"Mybatis框架学习之使用篇主要介绍如何使用mybatis，来实现db的增删改查，通常mybatis一般是结合spring来使用，因此我们也不脱离这个大环境 主要内容将包括以下： 环境配置相关 Dao文件与xml的映射（接口绑定有两种，xml和注解方式，这里以xml方式进行说明） 增删改查的写法 常用命令 choose, if, set, …. #，$两种方式的区别","text":"Mybatis框架学习之使用篇主要介绍如何使用mybatis，来实现db的增删改查，通常mybatis一般是结合spring来使用，因此我们也不脱离这个大环境 主要内容将包括以下： 环境配置相关 Dao文件与xml的映射（接口绑定有两种，xml和注解方式，这里以xml方式进行说明） 增删改查的写法 常用命令 choose, if, set, …. #，$两种方式的区别 I. 前提准备在开始之前，先得准备好对应的环境，首先建立一个可有效运行的环境 依赖配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- mybatis 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 依赖相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单测相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 这里采用druid来进行数据源的管理，目前仅作为一个使用工具，不深入探究 接下来就是xml的配置，如我们常见的jdbc链接相关的配置信息，一个demo如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"filters\" value=\"stat\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;property name=\"minIdle\" value=\"1\"/&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;property name=\"validationQuery\" value=\"SELECT 'x'\"/&gt; &lt;property name=\"testWhileIdle\" value=\"true\"/&gt; &lt;property name=\"testOnBorrow\" value=\"false\"/&gt; &lt;property name=\"testOnReturn\" value=\"false\"/&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\"/&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"50\"/&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定mapper文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- 指定扫描dao --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.git.hui.demo.mybatis\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意上面的三个bean，一个dataSource, 主要配置一些db链接相关的参数，一个sqlSessionFactory, 属于bean工厂，用于创建一些Sql会话，里面一个非常重要的参数就是指定 mapperLocations 最终一个就是指定扫描dao的路径，这个不能忘，否则会发现无法注入dao II. 一个实例以一个实际的例子，演示dao与mapper文件的映射关系，以及调用姿势，首先定义DB实体类对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Datapublic class PoetryEntity implements Serializable &#123; private static final long serialVersionUID = 4888857290009801223L; private Long id; /** * 作者名 */ private String author; /** * 标题 */ private String title; /** * 内容 */ private String content; /** * 解释 */ private String explain; /** * 诗词的类型 0 成语，1 唐前诗词 */ private Integer type; /** * 标记，对应诗词的朝代 */ private Integer tag; /** * 诗词的题材，七言，五言等 */ private String theme; private Integer isDeleted; private Integer created; private Integer updated;&#125; dao文件 1234public interface PoetryDao &#123; PoetryEntity queryPoetryById(@Param(\"id\") Long id);&#125; 对应的xml文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.git.hui.demo.mybatis.mapper.PoetryDao\"&gt; &lt;sql id=\"poetryEntity\"&gt; id, title, author, content, `explain`, `type`, `tag`, `theme`, `is_deleted` as isDeleted, UNIX_TIMESTAMP(`created_at`) as created, UNIX_TIMESTAMP(`updated_at`) as updated &lt;/sql&gt; &lt;select id=\"queryPoetryById\" parameterType=\"long\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试case 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath*:spring/*.xml\")public class PoetryDaoTest &#123; @Autowired private PoetryDao poetryDao; @Test public void testGet() &#123; PoetryEntity entity = poetryDao.queryPoetryById(3L); System.out.println(\"query result: &#123;&#125;\" + entity); &#125;&#125; 看到上面自然就有一个疑问，定义的Dao接口，是如何和xml文件关联起来的呢？ 注意xml中的namespace，为dao的全限定名 注意xml中的sql标签中的id，与dao层定义的接口名完全一致 大胆的猜测一下，整个过程应该如下： mybatis通过前面配置文件指定的mapperLocations，扫描指定路径下的所有xml文件（即写sql逻辑的xml） MapperScannerConfigurer 这个bean定义了哪些属于Dao层接口 对所有的dao接口，根据动态代理的方式，生成一个Proxy类，由这个proxy类，将dao接口的方法与xml中定义的sql标签关联起来 dao接口的访问，实际由代理类执行，将xml定义的规则映射为对应的sql，然后交由底层封装好的jdbc来执行 实际上大致流程也是这样，从上面的描述，一个问题很容易抛出 dao层接口，不支持重载（因为会导致dao层接口与xml中的关联不上的问题） III. 其他项目工程 study-demo 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zbang.online/hexblog/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}]},{"title":"Java实现邮件发送","slug":"Java实现邮件发送","date":"2018-04-10T02:43:42.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/10/Java实现邮件发送/","link":"","permalink":"https://zbang.online/hexblog/2018/04/10/Java实现邮件发送/","excerpt":"Java实现邮件发送在日常工作中，通过邮件或短信做报警或者信息推送的场景还是挺多的，而java中，常用的就是JavaMail来做这个事情了，到网上搜索了一把，发现apache有个commons email 的开源包，现在借助它来尝鲜一把","text":"Java实现邮件发送在日常工作中，通过邮件或短信做报警或者信息推送的场景还是挺多的，而java中，常用的就是JavaMail来做这个事情了，到网上搜索了一把，发现apache有个commons email 的开源包，现在借助它来尝鲜一把 简单使用添加pom依赖: 123456&lt;!--email 客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 查看使用帮助: http://commons.apache.org/proper/commons-email/userguide.html 1. 简单使用case1234567891011121314151617181920@Testpublic void testEmailSend() &#123; try &#123; Email email = new SimpleEmail(); email.setHostName(\"smtp.163.com\"); email.setSmtpPort(25); email.setAuthenticator(new DefaultAuthenticator(\"userName\", \"accessToken\")); email.setSSLOnConnect(true); email.setFrom(\"xhhuiblog@163.com\"); email.setCharset(\"utf-8\"); email.addTo(\"bangzewu@126.com\"); email.setSubject(\"邮件标题\"); email.setMsg(\"邮件内容\"); String ans = email.send(); System.out.println(ans); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 从实际的使用来看，还是比较简单的，设置一些必要的参数（host，端口，认证信息，fromEmail, toEmail, title, content） 额外需要注意的一点是，为了中文正常显示，请指定charset 2. html使用姿势更加常见的邮件发送是带有格式的，且有可能有附件，所以我们通常用的更多的是下面的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private String template = \"&lt;html&gt;&lt;meta charset=utf-8&gt;\\n\" + \"\\n\" + \"&lt;style&gt;\\n\" + \"div.card &#123;\\n\" + \" background-color:white; \\n\" + \" box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\\n\" + \" text-align: center;\\n\" + \"&#125;\\n\" + \"\\n\" + \"div.header &#123;\\n\" + \" background-color: #4CAF50;\\n\" + \" box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);\\n\" + \" color: white;\\n\" + \" padding: 10px;\\n\" + \" font-size: 40px;\\n\" + \"&#125;\\n\" + \"\\n\" + \"div.container &#123;\\n\" + \" padding: 10px;\\n\" + \"&#125;\\n\" + \"&lt;/style&gt;\\n\" + \"\\n\" + \"&lt;div class=\\\"card\\\"&gt;\\n\" + \" &lt;div class=\\\"header\\\"&gt;\\n\" + \" &lt;h1&gt;星期一&lt;/h1&gt;\\n\" + \" &lt;/div&gt;\\n\" + \"\\n\" + \" &lt;div class=\\\"container\\\"&gt;\\n\" + \" &lt;p&gt;2016.04.10&lt;/p&gt;\\n\" + \" &lt;/div&gt;\\n\" + \"&lt;/div&gt;\\n\" + \"&lt;/html&gt;\";@Testpublic void testHtmlEmailSend() &#123; try &#123; // Create the attachment EmailAttachment attachment = new EmailAttachment(); attachment.setURL(new URL(\"http://s11.mogucdn.com/mlcdn/c45406/180410_256l2egkgj3lfdkjkbf41b1i09l3f_1280x1280.jpg\")); attachment.setDisposition(EmailAttachment.ATTACHMENT); attachment.setDescription(\"公众号\"); attachment.setName(\"logo.jpg\"); HtmlEmail email = new HtmlEmail(); email.setCharset(\"UTF-8\"); email.setHostName(\"smtp.163.com\"); email.setSmtpPort(25); email.setAuthenticator(new DefaultAuthenticator(\"username\", \"token\")); email.setSSLOnConnect(true); email.setFrom(\"xhhuiblog@163.com\"); email.setSubject(\"TestMail\"); // 添加附件 email.attach(attachment); // set the html message email.setHtmlMsg(template); // set the alternative message email.setTextMsg(\"Your email client does not support HTML messages\"); email.addTo(\"bangzewu@126.com\"); String ans = email.send(); System.out.println(ans); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 邮件结果如下: II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Email","slug":"Email","permalink":"https://zbang.online/hexblog/tags/Email/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"基于ForkJoin构建一个简单易用的并发组件","slug":"基于ForkJoin构建一个简单易用的并发组件","date":"2018-04-09T02:03:04.000Z","updated":"2018-04-09T02:15:04.862Z","comments":true,"path":"2018/04/09/基于ForkJoin构建一个简单易用的并发组件/","link":"","permalink":"https://zbang.online/hexblog/2018/04/09/基于ForkJoin构建一个简单易用的并发组件/","excerpt":"基于ForkJoin构建一个简单易用的并发组件在实际的业务开发中，需要用到并发编程的知识，实际使用线程池来异步执行任务的场景并不是特别多，而且一般真的遇到了需要并发使用的时候，可能更加常见的就是直接实现Runnable/Callable接口，丢到Thread中执行了；或者更高级一点，定义一个线程池，扔进去执行；本片博文，将从另一个角度，借助JDK提供的ForkJoin，来设计一个简单易用的并发框架","text":"基于ForkJoin构建一个简单易用的并发组件在实际的业务开发中，需要用到并发编程的知识，实际使用线程池来异步执行任务的场景并不是特别多，而且一般真的遇到了需要并发使用的时候，可能更加常见的就是直接实现Runnable/Callable接口，丢到Thread中执行了；或者更高级一点，定义一个线程池，扔进去执行；本片博文，将从另一个角度，借助JDK提供的ForkJoin，来设计一个简单易用的并发框架 I. 背景实际项目中，使用并发的一个case就是商品详情页的展示了，一个详情页的展示，除了基本的商品数据之外，还有销量，地址，评价，推荐，店铺信息，装饰信息等，用一段伪代码来描述拼装整个详情数据的过程 12345678910111213141516171819// 获取商品基本信息ItemInfo itemInfo = itemService.getInfo(itemId);// 获取销量int sellCount = sellService.getSellCount(itemId);// 获取评价信息RateInfo rateInfo = rateService.getRateInfo(itemId);// 获取店铺信息ShopInfo shopInfo = shopService.getShopInfo(shopId);// 获取装饰信息DecorateInfo decoreateInfo = decorateService.getDecorateInfo(itemId);// 获取推荐商品RecommandInfo recommandInfo = recommandService.getRecommand(itemId); 如果是正常的执行过程，那么就是上面的6个调用，串行的执行下来，假设每个服务的rt是10ms，那么光是这里六个服务执行下来，耗时就&gt;60ms了， 但从业务角度出发，上面6个服务调用，彼此之间没有什么关联，即一个服务的调用，并不依赖另一个服务返回的结果，她们完全可以并发执行，这样六个服务执行下来，耗时就是六个服务中耗时最久的一个了，可能也就10ms多一点了 两个一对比，发现这种场景下，使用并发的优势非常明显了，接下来的问题是，我们希望以最简单的方式，将上面的代码改成并发的 II. 设计与实现以上面的case为例，如果我们采用线程池的方式，可以怎么实现呢？ 1. 线程池方式因为线程池方式不是重点，所以就简单的演示以下，可以怎么实现，以及实现之后的效果如何 123456789101112131415161718192021// 1. 创建线程池ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"service-pool\"), new ThreadPoolExecutor.CallerRunsPolicy());// 2. 将服务调用，封装到线程任务中执行Future&lt;ItemInfo&gt; itemFuture = alarmExecutorService.submit(new Callable&lt;ItemInfo&gt;() &#123; @Override public ItemInfo call() throws Exception &#123; return itemService.getInfo(itemId); &#125;&#125;);// ... 其他的服务依次类推// 3. 获取数据ItemInfo = itemFutre.get(); // 阻塞，直到返回 上面这个实现可以说是一个非常清晰明了的实现方式了，我们接下来看一下，用Fork/Join框架可以怎么玩，又会有什么好处 2. ForkJoin方式首先可能需要简单的介绍下，这是个什么东西，Fork/Join框架是Java7提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架 简单来说，就是讲一个复杂的任务，拆分成很多小任务，并发去执行的机制，任务与任务的执行，可能并不会独占线程，采用了一种名为工作窃取的手段，详情可以参考 ForkJoin 学习使用笔记 借助ForkJoin的方式，又可以怎么支持上面的场景呢？一个简单的方案如下 1234567891011121314// 1. 创建池ForkJoinPool pool = new ForkJoinPool(10);// 2. 创建任务并提交ForkJoinTask&lt;ItemInfo&gt; future = joinPool.submit(new RecursiveTask&lt;ItemInfo&gt;() &#123; public ItemInfo compute() &#123; return itemService.getItemInfo(itemId); &#125;&#125;);// 3. 获取结果future.join(); 这样一对比，两者之间并没有什么区别，而且也没有用到传说中的任务拆解 3. 进阶如何能够充分的利用ForkJoin的任务拆解的思想来解决问题呢？ 将上面的实例，我们稍微变通一下，将整个详情页的数据返回，看做是一个任务，对于内部的服务调用，根据不同的应用提供放，再进行任务划分，假设可以变成如下的层次结构 从上图可以看出，前面的服务调用，还可以继续划分，比如我们常见的商品信息，就可以区分为基本商品信息，sku信息，库存信息，而这三个又是可以并发执行的，也就是说从，借助forjoin的任务拆解，我们完全可以做到更细粒度的并发场景 那么现在的目标就是，如何实现上面这个任务拆分的场景需求，而且还希望对既有的代码改动不太大，关键还在于写出来后，得容易看懂+维护（这点其实很重要，笔者接触过一个封装得特别好，导致业务交接的维护成本太大，以及排查问题难度飙升的情况） 4. 实现a. 设计思路首先是定义一个最基本的执行单元，也就是封装具体的业务逻辑，也就是我们常说的Task（最终的效果也就是一个一个的task进行执行任务） 因为考虑到任务的拆解的情况，所以我们需要一个特殊的task，这个task可以是多个task的集合（也就是大任务，先称为bigTask） 然后就是使用时，所有的task都封装在一个bigTask中，直接丢给forkJoinPool来执行（支持同步获取结果的invoke调用方式和异步获取结果的execute方式） 那么，核心就在与如何设计这个BigTask了，以及在执行时，将bigTask拆解成更细粒度的bigTask或者task，并最终将所有的task执行结果合并起来并返回 b. 实现基本task接口 1234567891011121314/** * Created by yihui on 2018/4/8. */public interface IDataLoader&lt;T&gt; &#123; /** * 具体的业务逻辑，放在这个方法里面执行，将返回的结果，封装到context内 * * @param context */ void load(T context);&#125; 一个抽象的实现类，继承forkjoin的RecuriAction，这个就对应上我们前面定义的基本Task了 123456789101112131415161718192021222324252627public abstract class AbstractDataLoader&lt;T&gt; extends RecursiveAction implements IDataLoader &#123; // 这里就是用来保存返回的结果，由业务防自己在实现的load()方法中写入数据 protected T context; public AbstractDataLoader(T context) &#123; this.context = context; &#125; public void compute() &#123; load(context); &#125; /** * 获取执行后的结果，强制等待执行完毕 * @return */ public T getContext() &#123; this.join(); return context; &#125; public void setContext(T context) &#123; this.context = context; &#125;&#125; 然后就是BigTask的实现了，也比较简单，内部维持一个List 12345678910111213141516171819202122232425262728293031323334353637383940public class DefaultForkJoinDataLoader&lt;T&gt; extends AbstractDataLoader&lt;T&gt; &#123; /** * 待执行的任务列表 */ private List&lt;AbstractDataLoader&gt; taskList; public DefaultForkJoinDataLoader(T context) &#123; super(context); taskList = new ArrayList&lt;&gt;(); &#125; public DefaultForkJoinDataLoader&lt;T&gt; addTask(IDataLoader dataLoader) &#123; taskList.add(new AbstractDataLoader(this.context) &#123; @Override public void load(Object context) &#123; dataLoader.load(context); &#125; &#125;); return this; &#125; // 注意这里，借助fork对任务进行了拆解 @Override public void load(Object context) &#123; this.taskList.forEach(ForkJoinTask::fork); &#125; /** * 获取执行后的结果 * @return */ public T getContext() &#123; this.taskList.forEach(ForkJoinTask::join); return this.context; &#125;&#125; 接下来就是比较简单的线程池的设计了，因为我们需要提供同步获取结果，和异步获取结果的两种姿势，所以对ForkJoinPool需要做个扩展 123456789101112131415161718192021222324public class ExtendForkJoinPool extends ForkJoinPool &#123; public ExtendForkJoinPool() &#123; &#125; public ExtendForkJoinPool(int parallelism) &#123; super(parallelism); &#125; public ExtendForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, Thread.UncaughtExceptionHandler handler, boolean asyncMode) &#123; super(parallelism, factory, handler, asyncMode); &#125; // 同步阻塞调用时，需要对每个task执行join，确保执行完毕 public &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task) &#123; if (task instanceof AbstractDataLoader) &#123; super.invoke(task); return (T) ((AbstractDataLoader) task).getContext(); &#125; else &#123; return super.invoke(task); &#125; &#125;&#125; 然后就是创建Pool的工厂类，没什么特别的了 123456789101112131415161718192021222324252627282930313233public class ForkJoinPoolFactory &#123; private int parallelism; private ExtendForkJoinPool forkJoinPool; public ForkJoinPoolFactory() &#123; this(Runtime.getRuntime().availableProcessors() * 16); &#125; public ForkJoinPoolFactory(int parallelism) &#123; this.parallelism = parallelism; forkJoinPool = new ExtendForkJoinPool(parallelism); &#125; public ExtendForkJoinPool getObject() &#123; return this.forkJoinPool; &#125; public int getParallelism() &#123; return parallelism; &#125; public void setParallelism(int parallelism) &#123; this.parallelism = parallelism; &#125; public void destroy() throws Exception &#123; this.forkJoinPool.shutdown(); &#125;&#125; 到此，整个基本上算是完了，每个类都很简单，就那么点东西，接下来就是需要看怎么用了 III. 测试验证先来一个简单的case，演示下，应该怎么用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 @Datastatic class Context &#123; public int addAns; public int mulAns; public String concatAns; public Map&lt;String, Object&gt; ans = new ConcurrentHashMap&lt;&gt;();&#125;@Testpublic void testForkJoinFramework() &#123; ForkJoinPool forkJoinPool = new ForkJoinPoolFactory().getObject(); Context context = new Context(); DefaultForkJoinDataLoader&lt;Context&gt; loader = new DefaultForkJoinDataLoader&lt;&gt;(context); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.addAns = 100; System.out.println(\"add thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.mulAns = 50; System.out.println(\"mul thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.concatAns = \"hell world\"; System.out.println(\"concat thread: \" + Thread.currentThread()); &#125; &#125;); DefaultForkJoinDataLoader&lt;Context&gt; subTask = new DefaultForkJoinDataLoader&lt;&gt;(context); subTask.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; System.out.println(\"sub thread1: \" + Thread.currentThread() + \" | now: \" + System.currentTimeMillis()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.ans.put(Thread.currentThread().getName(), System.currentTimeMillis()); &#125; &#125;); subTask.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; System.out.println(\"sub thread2: \" + Thread.currentThread() + \" | now: \" + System.currentTimeMillis()); context.ans.put(Thread.currentThread().getName(), System.currentTimeMillis()); &#125; &#125;); loader.addTask(subTask); long start = System.currentTimeMillis(); System.out.println(\"------- start: \" + start); // 提交任务，同步阻塞调用方式 forkJoinPool.invoke(loader); System.out.println(\"------- end: \" + (System.currentTimeMillis() - start)); // 输出返回结果，要求3s后输出，所有的结果都设置完毕 System.out.println(\"the ans: \" + context);&#125; 使用起来就比较简单了，简单的四步骤即可： 创建Pool 指定保存结果的容器类ContextHolder 创建任务 创建根任务 new DefaultForkJoinDataLoader&lt;&gt;(context); 添加子任务 提交 上面这个实现中，对于需要将Task进行再次拆分，会变得非常简单，看下上面的输出 12345678------- start: 1523200221827add thread: Thread[ForkJoinPool-1-worker-50,5,main]concat thread: Thread[ForkJoinPool-1-worker-36,5,main]sub thread2: Thread[ForkJoinPool-1-worker-29,5,main] | now: 1523200222000sub thread1: Thread[ForkJoinPool-1-worker-36,5,main] | now: 1523200222000mul thread: Thread[ForkJoinPool-1-worker-43,5,main]------- end: 3176the ans: ForJoinTest.Context(addAns=100, mulAns=50, concatAns=hell world, ans=&#123;ForkJoinPool-1-worker-36=1523200222204, ForkJoinPool-1-worker-29=1523200222000&#125;) 首先是各个子任务执行的线程输出可以看出确实是不同线程执行的任务（并发） 3s后，输出结果，即invoke之后，会阻塞直到所有的任务执行完毕 subTask进行了任务拆解，两个子任务的执行时间相同，但是一个sleep，另一个则不受影响（子任务也是并行执行） 对于希望异步执行的情况，也比较简单了，仅仅是在提交任务的地方，稍微改动一下即可，然后在需要获取数据的时候，通过loader来获取结果即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Testpublic void testForkJoinFramework2() &#123; ForkJoinPool forkJoinPool = new ForkJoinPoolFactory().getObject(); Context context = new Context(); DefaultForkJoinDataLoader&lt;Context&gt; loader = new DefaultForkJoinDataLoader&lt;&gt;(context); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.addAns = 100; System.out.println(\"add thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.mulAns = 50; System.out.println(\"mul thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.concatAns = \"hell world\"; System.out.println(\"concat thread: \" + Thread.currentThread()); &#125; &#125;); long start = System.currentTimeMillis(); System.out.println(\"------- start: \" + start); // 如果暂时不关心返回结果，可以采用execute方式，异步执行 forkJoinPool.execute(loader); // .... 这里可以做其他的事情 此时，不会阻塞，addAns不会被设置 System.out.println(\"context is: \" + context); System.out.println(\"------- then: \" + (System.currentTimeMillis() - start)); loader.getContext(); // 主动调用这个，表示会等待所有任务执行完毕后，才继续下去 System.out.println(\"context is: \" + context); System.out.println(\"------- end: \" + (System.currentTimeMillis() - start));&#125; IV. 其他源码相关源码可在git上查看，主要在Quick-Alarm项目中 QuickAlarm 并发相关代码 个人博客： 一灰灰Blog个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://zbang.online/hexblog/tags/ForkJoin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"Css实战训练之图片点击放大","slug":"Css实战训练之图片点击放大","date":"2018-04-01T09:10:09.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/01/Css实战训练之图片点击放大/","link":"","permalink":"https://zbang.online/hexblog/2018/04/01/Css实战训练之图片点击放大/","excerpt":"Css实战训练之图片点击放大I. 背景非常常见的一个功能了，一般网站上显示的都是缩略图，等你点击缩略图之后，会在一个弹框中显示放大的图片 那么这个功能是怎么实现的呢? 正好学习了下css的基础知识，现在可以来实际的操作一把","text":"Css实战训练之图片点击放大I. 背景非常常见的一个功能了，一般网站上显示的都是缩略图，等你点击缩略图之后，会在一个弹框中显示放大的图片 那么这个功能是怎么实现的呢? 正好学习了下css的基础知识，现在可以来实际的操作一把 1. 思路首先对页面的结构进行拆分： 有一个弹窗，在弹窗中显示大图；且弹窗默认是隐藏的 主页面上可以放置很多图片，并添加点击事件 点击之后，弹窗显示，并展示大图 大图点击以下后，关闭弹窗 II. 实现根据上面的描述，我们先来实现一个基础版本的，先写HTML 1234567891011121314151617&lt;body&gt;&lt;!-- 先来实现弹窗 --&gt;&lt;div class='modal' id='modal'&gt; &lt;img id='bgImg' /&gt;&lt;/div&gt;&lt;!-- 下面则是主页内容，先只给几个图片 --&gt;&lt;div&gt; &lt;img class='thum-img' src='http://f.hiphotos.baidu.com/image/pic/item/80cb39dbb6fd5266cdb2ba16a718972bd4073612.jpg' /&gt;&lt;/div&gt;&lt;/body&gt; 然后就是添加对应的样式，要求modal默认是隐藏的，所以如下（为了可以较好的区分弹窗，所以加了背景色和边框） 12345678910111213141516171819202122232425262728&lt;style&gt;.modal &#123; display: none; margin: auto; width: 80%; height: 80%; background-color: rgb(0, 0, 0, 0.89); z-index: 1; border: 1px solid rgb(255,255,255,1);&#125;.modal&gt;img &#123; display: block; margin: auto; padding: 10%; max-width: 60%; max-height: 60%;&#125;.thum-img &#123; width: 200px; height: 200px; margin: auto; display: block; padding: 40px;&#125;&lt;/style&gt; 接下来就是点击显示大图的逻辑了，借助js来实现， 12345678910111213&lt;script&gt; var modal = document.getElementById('modal'); var bgImg = document.getElementById('bgImg'); var thumImg = document.getElementById('thumImg'); thumImg.onclick = function() &#123; modal.style.display = 'block'; bgImg.src = this.src; &#125; bgImg.onclick = function() &#123; modal.style.display = 'none'; &#125;&lt;/script&gt; 将上面的实现，组装成一个html之后，直接测试查看，演示效果如下 虽然说上面的实现了我们预期的结果，但是有几点却不太满意 不是我们预期的弹窗效果，原图被挤下去了 弹窗中如果有个放大的动画效果就更好了（正好可以用到之前学习的animation） 对于图强中有很多图片时，点击放大怎么做 III. 进阶首先是希望是真的弹窗，不影响既有的布局，则通常是设置position来做到, 如我们可以在modal外面再加一层，变成 12345&lt;div style='position:fixed'&gt; &lt;div class='modal' id='modal'&gt; &lt;img id='bgImg' /&gt; &lt;/div&gt;&lt;/div&gt; 其次就是弹窗的样式太丑，我们可以借助之前学习的边框阴影来实现美观的弹出效果， 改成图片全部填充背景 背景颜色去掉，加上阴影，加上白色边框 修改后的css如下 1234567891011121314151617181920.modal &#123; display: none; margin: auto; padding-top: 5%; width: 50%; height: 80%; z-index: 1; background-color: white;&#125;.modal img &#123; display: block; padding: 10px; margin: auto; max-width: 100%; max-height: 100%; box-shadow: 0 2px 6px rgb(0, 0, 0, 0.2), 0 10px 20px rgb(0, 0, 0, 0.2); border-radius: 12px; border: 1px solid white;&#125; 接下来考虑添加动画，加上一个放大的效果 123456789@keyframes zoom &#123; from &#123;transform: scale(0.1)&#125; to &#123;transform: scale(1)&#125;&#125;.modal img &#123; animation-name: zoom; animation-duration: 0.6s;&#125; 接下来看演示效果如下 接下来就是需要把这个变成通用的方案，支持多重图片的方式了，这个则主要是图片点击事件的修改了，将上面写死的地方，稍微变通一下即可 IV. 源码最后给出所有的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt; &lt;title&gt;小灰灰css学习笔记&lt;/title&gt; &lt;style&gt;.modal &#123; display: none; position:fixed; width:100%; height:100%; background-color:rgb(0,0,0,0.65)&#125;.modal-container &#123; margin: auto; padding-top: 5%; width: 50%; height: 80%; z-index: 1;&#125;.modal img &#123; animation-name: zoom; animation-duration: 0.6s; display: block; padding: 10px; margin: auto; max-width: 100%; max-height: 100%; box-shadow: 0 2px 6px rgb(0, 0, 0, 0.2), 0 10px 20px rgb(0, 0, 0, 0.2); border-radius: 12px; border: 1px solid white;&#125;@keyframes zoom &#123; from &#123;transform: scale(0.1)&#125; to &#123;transform: scale(1)&#125;&#125;.thum-img &#123; float: left; width: 200px; height: 200px; margin: auto; display: block; padding: 40px;&#125;&lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;!-- 先来实现弹窗 --&gt;&lt;div class='modal' id='modal'&gt;&lt;div class='modal-container'&gt; &lt;img id='bgImg' /&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 下面则是主页内容，先只给几个图片 --&gt;&lt;div&gt; &lt;img onclick='showBgImg(this)' class='thum-img' src='http://f.hiphotos.baidu.com/image/pic/item/80cb39dbb6fd5266cdb2ba16a718972bd4073612.jpg' /&gt; &lt;img class='thum-img' src='http://a.hiphotos.baidu.com/image/pic/item/e61190ef76c6a7ef5e886d03f1faaf51f3de666d.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='http://g.hiphotos.baidu.com/image/pic/item/730e0cf3d7ca7bcb747b4a5cb2096b63f624a845.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='http://c.hiphotos.baidu.com/image/pic/item/b21c8701a18b87d6657856e70c0828381f30fd14.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png' onclick='showBgImg(this)'/&gt;&lt;/div&gt;&lt;script&gt; var modal = document.getElementById('modal'); var bgImg = document.getElementById('bgImg'); function showBgImg(e) &#123; modal.style.display = 'block'; bgImg.src = e.src; &#125; bgImg.onclick = function() &#123; modal.style.display = 'none'; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; V. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zbang.online/hexblog/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"Css学习手册之基本篇","slug":"Css学习手册之基本篇","date":"2018-04-01T01:29:21.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/01/Css学习手册之基本篇/","link":"","permalink":"https://zbang.online/hexblog/2018/04/01/Css学习手册之基本篇/","excerpt":"Css学习手册之基本篇每次写前端都是一个痛苦的过程，总是静不下来，彻底的研究下前端的技术，导致每次套页面都是直接采用一些封装好的控件，而有时对这些样式不满意时，又得百度一下该怎么用，低效且不愉快，强制自己好好的学习下基本功","text":"Css学习手册之基本篇每次写前端都是一个痛苦的过程，总是静不下来，彻底的研究下前端的技术，导致每次套页面都是直接采用一些封装好的控件，而有时对这些样式不满意时，又得百度一下该怎么用，低效且不愉快，强制自己好好的学习下基本功 I. 基本使用姿势0. 几种css使用姿势主要有下面三个使用姿势，其中优先级为 c &gt; b &gt; a a.直接引入css文件 b.在html中，直接写css: c.在标签中直接写css 123456789101112131415&lt;!-- 方式 a --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;!-- 方式 b --&gt;&lt;style&gt;p &#123; color: red&#125;&lt;/style&gt;&lt;!-- 方式 c --&gt;&lt;div style=\"color:red; font-size:12pt\"&gt;dd&lt;/div&gt; 对于标签的样式定义，特别是在引入css文件时，发现一个标签可能多重命中方式，有通过id进行设置的，有class设置的，也有标签设置的，他们之间的优先级是: 12341. 内联样式表的权值最高 1000；2. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 1. css使用方式a. 基本使用在实际的使用中，经常出现的定义class, 根据id或者直接对标签，来指定css属性 123456789101112131415161718&lt;style&gt;&lt;!-- 直接通过标签名 + &#123;&#125; 方式来确定标签对应的属性 --&gt;p &#123; background-color: yellow;&#125;&lt;!-- 通过id来确定css样式: # + id + &#123;&#125; --&gt;#tabId &#123; background-color: red;&#125;&lt;!-- 通过定义class方式: . + className + &#123;&#125;--&gt;.clzName &#123; background-color: blue;&#125;&lt;/style&gt; 上面是基本的使用姿势，往往我们经常会遇到组合的方式，如希望 设置: div标签内部的 p 标签中的文本颜色等，常见组合有四种 b. 后代选择器 （空格分割）如上面的case， div 标签内部所有的p标签中文本，都设置为红色 12345678910111213&lt;style&gt;div p &#123; color: red&#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt; &lt;p&gt; 红色的文本内容 &lt;/p&gt; &lt;/span&gt; &lt;hr/&gt; &lt;p&gt; 红色的文本内容 &lt;/p&gt;&lt;/div&gt; c. 子元素选择器 (&gt;号分割)这个相比较与后代选择器，区别就是子元素只匹配直接关联的子元素（也就是中间不能有嵌套） 12345678910111213&lt;style&gt;div &gt; span &#123; color: red&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt; &lt;span&gt; 默认黑色的文本内容 &lt;/span&gt; &lt;/p&gt; &lt;hr/&gt; &lt;span&gt; 红色的文本内容 &lt;/span&gt;&lt;/div&gt; d. 相邻兄弟 (+号分割)可选择紧接在另一元素后的元素，且二者有相同父元素 1234567891011121314&lt;style&gt;div+p&#123; background-color:yellow;&#125;&lt;/style&gt;&lt;p&gt;(默认黑色的内容).&lt;/p&gt;&lt;div&gt;&lt;h2&gt;My name is Donald&lt;/h2&gt;&lt;p&gt;I live in Duckburg.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt; e. 普通兄弟 (~号分割)后续兄弟选择器选取所有指定元素之后的兄弟元素。 12345678910111213141516&lt;style&gt;div+p&#123; background-color:yellow;&#125;&lt;/style&gt;&lt;p&gt;(默认黑色的内容).&lt;/p&gt;&lt;div&gt;&lt;h2&gt;My name is Donald&lt;/h2&gt;&lt;p&gt;I live in Duckburg.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt;&lt;span&gt;默认黑色&lt;/span&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt; 2. 背景属性 background-color: 背景色 background-image: 背景图 background-repeat: 背景图重复的方式( no-repeat 不重复； repea-xt 水平重复; repeat-y 垂直重复) background-position: 背景的位置 ( left, top, center, right, bottom，可以组合使用) 支持简写方式: 123body &#123; background: #ffffff url('img_tree.png') no-repeat right top;&#125; 3. 文本属性 color: 设置颜色 direction: 文本方向 (ltr 左到右； rtl 右到左; inherit 从父元素继承) letter-spacing: 字符间距 text-align: 文本对齐方式 (left, center, right) line-height: 行高 text-decoration: 修饰 （none 标准； underline 下划线; overline 上划线; line-through 删除线; blink 闪烁） text-indent: 首行缩进 text-shadow: 阴影 text-transform: 控制字母 (capitalize 首字母大写; uppercase 全大写； lowercase 全小写) vertical-align：垂直对其 white-space: 设置元素中空白的处理方式 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 标签。 5. 字体属性 font-size: 字体大小 16px == 1em font-family: 字体系列 Serif: 字符在行的末端拥有额外的装饰 Sans-serif: 这些字体在末端没有额外的装饰 Monospace: 所有的等宽字符具有相同的宽度 font-style: 字体样式 italic 浏览器会显示一个斜体的字体样式。 oblique 浏览器会显示一个倾斜的字体样式。 inherit 规定应该从父元素继承字体样式。 6. 链接 a:link {color:#000000;} / 未访问链接/ a:visited {color:#00FF00;} / 已访问链接 / a:hover {color:#FF00FF;} / 鼠标移动到链接上 / a:active {color:#0000FF;} / 鼠标点击时 / 注意： a:hover 必须在 a:link 和 a:visited 之后，需要严格按顺序才能看到效果。 注意： a:active 必须在 a:hover 之后。 7. 列表在html中，列表主要是 : li, ul, ol 等 默认 ol 是以数字排序； ul 是以符号排序； li 为列表内的元素标签 用的较多的属性 list-style-type: 设置列表项标志的类型。 none 无标记。 disc 默认。标记是实心圆。 circle 标记是空心圆。 square 标记是实心方块。 decimal 标记是数字。 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。) upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。) lower-greek 小写希腊字母(alpha, beta, gamma, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式(an, ban, gan, 等。) cjk-ideographic 简单的表意数字 hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名） katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名） hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名） katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） list-style-image: 用图片作为列表的前置，如 ( url(‘sqpurple.gif’);) list-style-position: （outside, inside）感觉不出太大的差别 8. box模型 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 主要是用来控制一个标签和其他标签的位置，比如两个标签之间做间隔区分等，比较有用 padding与margin的区别 a. Margin 外边距主要是标签与周边的距离设置 margin-top:100px; margin-right:50px; margin-bottom:100px; margin-left:50px; b. padding 内边距定义元素边框与元素内容之间的空间 padding-top:25px; padding-bottom:25px; padding-right:50px; padding-left:50px; c. border 边框这个有些时候还是挺有用的，设置一个标签四周的边框，一般可以设置线粗细，样式，颜色等 border-width : 线的粗细 border-style dotted: dotted:定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 border-color: 边框的颜色 一个非常有意思的点是，边框支持分别设置上下左右四个线的形式，如只设置一个左右有颜色的 12345&lt;div&gt; &lt;p style=\"border-left-style:dashed; border-left-color:red; border-right-style:solid;\"&gt; 只有左右边框的情况&lt;/p&gt;&lt;/div&gt; d. outline 边缘轮廓outline主要作用在border上，绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 outline-color outline-style none dotted: dotted:定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 outline-width 从实际体验来讲，这个和border的效果差不多 9. 尺寸这个主要就是用来控制标签的宽高等相关尺寸的属性，常见的设置如下 width: 定宽 height: 定高 min-width: 最小宽 max-width: 最大宽 min-height: 最小高 max-height: 最大高 line-height: 行高 10. 显示控制标签的显示隐藏等 display属性设置一个元素应如何显示 visibility属性指定一个元素应可见还是隐藏 a. displaynone可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 块元素是一个元素，占用了全部宽度，在前后都是换行 内联元素只需要必要的宽度，不强制换行。 1234567891011121314151617181920211. 块级元素(block)特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;2. 内联元素(inline)特性：和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，就是里面文字或图片的大小;3. 块级元素主要有： address , blockquote , center , dir , div , dl , fieldset , form , h1 , h2 , h3 , h4 , h5 , h6 , hr , isindex , menu , noframes , noscript , ol , p , pre , table , ul , li4. 内联元素主要有：a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span , strike , strong , sub , sup ,textarea , tt , u , var5. 可变元素(根据上下文关系确定该元素是块元素还是内联元素)：applet ,button ,del ,iframe , ins ,map ,object , script b. visibilityhidden可以隐藏某个元素,但隐藏的元素仍需占用与未隐藏之前一样的空间,也就是说，该元素虽然被隐藏了，但仍然会影响布局。 11. 定位 positionposition 属性指定了元素的定位类型。在使用top, bottom, left, right之前，一般需要先确定position属性，明确具体的定位方式 static 默认值，即没有定位，元素出现在正常的流中 静态定位的元素不会受到 top, bottom, left, right影响。 relative 元素的位置相对于浏览器窗口是固定位置 即窗口是滚动的它也不会移动，常用来做悬浮按钮 fixed 相对定位元素的定位是相对其正常位置。 absolute 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 如一个测试 1234567891011121314&lt;style&gt;h2&#123; position:absolute; left:100px; top:150px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;这是一个绝对定位了的标题&lt;/h2&gt;&lt;p&gt;用绝对定位,一个元素可以放在页面上的任何位置。标题下面放置距离左边的页面100 px和距离页面的顶部150 px的元素。.&lt;/p&gt;&lt;/body&gt; 注意 当多个元素在同一个位置时，就会出现重叠的问题，特别是relative这种场景，在网页右下角添加悬浮窗时，经常会出现遮盖的问题，这时可以用 z-index 属性来指定覆盖顺序，越大，则越上面 12. float 浮动CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 往往是用于图像，但它在布局时一样非常有用。 元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 如果图像是右浮动，下面的文本流将环绕在它左边 如果你把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻 12345678&lt;!-- 注意多个浮动的图片时，缩小浏览器窗口大小，布局会发生改变 --&gt;.thumbnail &#123; float:left; width:110px; height:90px; margin:5px;&#125; 13. 水平 &amp; 垂直对齐 css实现对齐方式 根据前面学习到的几个属性(text-align, margin, position)等来实现各种标签的对齐方式 text-align: left, right, center 通常是对于文本的对其方式，比如一个标签块内文本是如何对齐的，靠左，靠右还是居中 margin: auto 标签的对齐方式，如希望一个div标签水平居中，就可以这么玩 图片需要居中对齐，采用这种方案 (注意 在img使用时，一般需要指定 display:block;margin:auto，这样才会生效) 一个case如下 1234567&lt;div style=\"width:200px; border: 3px solid blue; padding: 4px\"&gt; &lt;div style=\"width:50%; border:3px solid red; margin: auto; padding: 20px\"&gt; 这是一个测试标签居中对其的示例 &lt;/div&gt;&lt;/div&gt;&lt;br/&gt;&lt;div style=\"width:200px; border: 3px solid blue; padding: 4px\"&gt; &lt;div style=\"width:50%; border:3px solid red; text-align: center; padding: 20px\"&gt; 这是一个测试标签内文本居中对齐的示例 &lt;/div&gt;&lt;/div&gt; II. CSS3高阶用法1. 边框 border前面介绍了边框的设置，主要还是线条类型，粗细以及颜色，现在则可以扩展，设置圆角、阴影，边框图 border-radius: 2px (四周圆角) 一个值： 四个圆角值相同 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 border-image: url(border.png) 30 30 round; （边框由图来替代） border-image-source 用于指定要用于绘制边框的图像的位置 border-image-slice 图像边界向内偏移 border-image-width 图像边界的宽度 border-image-outset 用于指定在边框外部绘制 border-image-area 的量 border-image-repeat 设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。 box-shadow: 10px 10px 2px #bbbbbb (设置阴影) h-shadow 必需的。水平阴影的位置。允许负值 v-shadow 必需的。垂直阴影的位置。允许负值 blur 可选。模糊距离 spread 可选。阴影的大小 color 可选。阴影的颜色 一个实例，捷足 box-shadow 给图片加上一个白色背景边框 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;#boxshadow &#123; position: relative; &lt;!-- 添加边框阴影 --&gt; -moz-box-shadow: 1px 2px 4px rgba(0, 0, 0,0.5); -webkit-box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); padding: 10px; background: white;&#125;/* Make the image fit the box */#boxshadow img &#123; width: 100%; border: 1px solid #8a4419; border-style: inset;&#125;#boxshadow::after &#123; content: ''; position: absolute; z-index: -1; /* hide shadow behind image */ -webkit-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); width: 70%; left: 15%; /* one half of the remaining 30% */ height: 20%; bottom: 0;&#125;&lt;/style&gt;&lt;div id=\"boxshadow\"&gt; &lt;img src=\"https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png\" alt=\"Norway\"&gt;&lt;/div&gt; 2. 文本除了前面说的文本颜色，大小，decorate, transform等之外，这里额外的加了一些特性 a. text-shadow5px 5px 5px #FF0000; 阴影，参数说明同 box-shadow b. text-overflow文字逸出时，怎么办（ 配合overflow:hidden，将逸出的隐藏掉） clip： 修剪文本 ellipsis: 用省略号代替逸出的文本 string: 用给出的字符串代替 一个实例： 123456789101112&lt;style&gt;div.ov &#123; width: 120px; white-space:nowrap; border: 1px solid black; overflow:hidden; text-overflow:ellipsis&#125;&lt;/style&gt;&lt;div class=\"ov\"&gt; 这是一个会移除的文本&lt;/div&gt; c. word-wrap &amp; word-breakword-wrap 文本太长时，换行的策略 normal 只在允许的断字点换行 break-word 在长单词或 URL 地址内部进行换行。 还有一个主要针对英文单词的换行策略 word-break normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 d. 字体@Font-face 指定特殊的字体 一般的使用姿势如下: 1234567891011121314&lt;style&gt; @font-face&#123; &lt;!-- 字体命名 --&gt; font-family: myFirstFont; &lt;!-- 指定字体文件路径 --&gt; src: url(sansation_light.woff);&#125; div&#123; font-family:myFirstFont;&#125;&lt;/style&gt; 3. 动画a. transform实现转换，最常见的就是旋转一定角度了 translate(x, y): 根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate(30deg): 表示顺时针渲染30° scale(2,3): 表示x轴扩大2倍，y抽扩大3倍 skew(30deg,20deg): X轴(水平方向)倾斜30°；Y轴(垂直方向)倾斜20° matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功 b. transition过渡，配合上面的transform可以实现旋转or放大的动画效果 如一个case，在鼠标放上去时，放大且旋转360° 12345678910111213141516171819&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; -webkit-transition: width 2s, height 2s, -webkit-transform 2s; /* For Safari 3.1 to 6.0 */ transition: width 2s, height 2s, transform 2s, background 2s;&#125;div:hover &#123; width: 200px; height: 200px; background:blue; -webkit-transform: rotate(360deg); /* Chrome, Safari, Opera */ transform: rotate(360deg);&#125;&lt;/style&gt;&lt;div&gt;鼠标移动到 div 元素上，查看过渡效果。&lt;/div&gt; c. 动画通过 @keyframes 来创建动画的效果，通过 animation 来使用动画 一个实例 12345678910111213141516171819202122232425262728293031&lt;style&gt; div&#123; width:100px; height:100px; background:red; position:relative; animation:myfirst 5s; -webkit-animation:myfirst 5s; /* Safari and Chrome */&#125;@keyframes myfirst&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;div&gt;哈哈&lt;/div&gt; 4. 图片支持图片圆角设置 border-radius: 8px; 自由缩放： max-width: 100%; height: auto; filter：滤镜 详细参数: filter参数 III. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zbang.online/hexblog/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"mysql之锁与事务详解","slug":"mysql之锁与事务详解","date":"2018-03-23T07:16:21.000Z","updated":"2018-04-11T03:48:34.956Z","comments":true,"path":"2018/03/23/mysql之锁与事务详解/","link":"","permalink":"https://zbang.online/hexblog/2018/03/23/mysql之锁与事务详解/","excerpt":"Mysql之锁与事务平时的业务中，顶多也就是写写简单的sql，连事务都用的少，对锁这一块的了解就更加欠缺了，之前一个大神分享了下mysql的事务隔离级别，感觉挺有意思的，正好发现一个很棒的博文，然后也收集了一些相关知识，正好来学习下，mysql中锁与事务的神秘面纱，主要内容包括 共享锁和排它锁的区别以及适合范围 mysql的表锁和行锁的区别 怎么判断一个sql是否执行了锁，执行的是表锁还是行锁 事务是什么，怎么用 事务的特性ACID 事务的隔离级别 (RU, RC, RR, SER) 如何查看mysql使用的隔离级别","text":"Mysql之锁与事务平时的业务中，顶多也就是写写简单的sql，连事务都用的少，对锁这一块的了解就更加欠缺了，之前一个大神分享了下mysql的事务隔离级别，感觉挺有意思的，正好发现一个很棒的博文，然后也收集了一些相关知识，正好来学习下，mysql中锁与事务的神秘面纱，主要内容包括 共享锁和排它锁的区别以及适合范围 mysql的表锁和行锁的区别 怎么判断一个sql是否执行了锁，执行的是表锁还是行锁 事务是什么，怎么用 事务的特性ACID 事务的隔离级别 (RU, RC, RR, SER) 如何查看mysql使用的隔离级别 I. 锁在学习多线程时，我们也经常会遇到锁这个东西，那个时候谈的比较多的是乐观锁和悲观锁，那这两种锁和DB中常说的共享锁和独占锁有什么区别呢？先给出我们已知的乐观锁和悲观锁定义 乐观锁：多线程中的CAS就是一种乐观锁，实际上不加锁，先尝试去执行，如果失败则重试（或者根据失败策略进行处理） 悲观锁：上锁，一次只能有一个线程访问，其他的都只能等待 1. 共享锁和排它锁a. 共享锁突出在共享这个关键词上，顾名思义，表示这个锁可以多人共享，一般又可以称为读锁(S锁) 在DB中，读锁表示所有的读取数据的小伙伴都不会被锁阻塞，可以放心大胆的获取数据，专业一点的说法就是同一时刻，允许多个连接并发的读取同一资源 b. 排它锁排它，表示当某个人持有这个锁之后，其他的人再来竞争锁就会失败，只能等待锁释放， 又称为写锁(X锁) 在DB中，写锁表示同一时刻，只能有一个小伙伴操作，其他的不管是读还是写，都得排队，专业说法是写锁会阻塞其他的读锁或写锁请求，确保同一时刻只能有一个连接可以写入资源，并防止其他连接读取或者写资源 c. gapLock 和 next key lock next key lock 主要是范围匹配的场景下，会锁某一个范围区间 gapLock 主要用来锁边界 如下面的case（说明，columnA是非唯一索引，RR隔离级别） where columnA between 10 and 30, next key lock 确保不会在10, 30 之内插入新的数据行 where columnA = 10, gap lock 确保不会再次插入一个columnA=10的行 2. 表锁和行锁对于DB的操作，通常会出现两种情况，一个是锁表，一个锁行 表锁：表示整个表被某一个连接占用了写锁，导致其他连接的读锁或者写锁都会阻塞；影响整个表的读写 行锁：表示表中某些行被某个连接占用了写锁，但是其他行，依然可以被其他的连接请求读锁、写锁；仅影响被锁的那些行数据 那么一个问题就来了，什么sql会导致行锁，什么会导致写锁？甚至我们如何判断一个sql是否会请求锁，请求的是读锁还是写锁呢？ 3. 如何使用锁上面一节抛出了问题，那么现在就是来看下如何使用和分析锁了，首先我们是我们最常见的几个sql select update delete insert 其中很容易得出的结论是 update, delete, insert 三个涉及到写锁；而且这种操作绝大部分的场景是操作具体的某些行（想想为什么?），所以更常见的是行锁 select读操作则有点特殊 a. select分析MVCC(multiple-version-concurrency-control）是个行级锁的变种，它在普通读情况下避免了加锁操作，因此开销更低。即下面这个没有读锁也没有写锁 快照读，不加锁 1select * from table ... 当前读，select 语句可以指定读锁和写锁，如下 12345-- 读锁select * from table lock in share mode;-- 写锁select * from table for update; 说明，insert, update, delete 也是当前读，理由如下： 1.update和delete操作流程分解： 首先通过where条件查询到第一个满足的记录，并加锁 对这条记录进行更新，再读取下一条记录 对记录更新，继续读下一条直到完毕 2.insert操作流程分解： unique key 冲突检测，会有一个当前读 无冲突时，插入 b. sql实例分析12345--- SQL1：select * from t1 where id = 10;--- SQL2：delete from t1 where id = 10; 在分析上面的sql之前，需要明确几个前提： id是否为主键（id是否有索引） 系统的隔离级别（隔离级别是什么东西可以先看下下文介绍） 分别说明: case1: 主键+RC级别 sql1不加锁，MySQL是使用多版本并发控制的，读不加锁 sql2加写锁（即X锁），只锁 id=10这一行 case2: 唯一索引+rc级别 sql2加写锁，如下图的case，就两把锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录 case3: id非唯一索引+RC sql2加写锁，如下图的case，会有四个写锁 case4: 无索引+RC sql2分析：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上写锁(X锁)。 但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省 case5: 主键+RR 加锁同case1 case6: 唯一索引+RR 加锁同case2 case7: 非唯一索引+RR RR级别不允许出现幻读，简单来说，在加锁的过程中，不允许在新增or修改满足条件的记录 即下图中，除了图三中类似的x锁之外，还会新增一个gap锁，这个gap锁主要确保那几个位置上不能插入新的记录 case8: 无索引+RR 在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作 case9: Serializable级别 sql2: Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致 SQL1: 在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC II. 事务事务可谓是db中非常重要的一个知识点了，接下来我们的目标就是弄懂什么是事务，怎么使用事务，以及事务与锁之间的关联是怎样的 说明：本文的分析主要是以mysql的innordb存储引擎为标准 1. 定义事务就是一组原子性的sql，或者说一个独立的工作单元。 事务就是说，要么mysql引擎会全部执行这一组sql语句，要么全部都不执行（比如其中一条语句失败的话）。 2. ACID特性a. A:atomiciy 原子性一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。 b. C:consistency一致性数据必须保证从一种一致性的状态转换为另一种一致性状态。 c. I:isolation 隔离性在一个事务未执行完毕时，通常会保证其他Session 无法看到这个事务的执行结果 d. D:durability 持久性事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失 3. 隔离级别前面在分析锁的sql时，就提到了隔离级别，通常有四种： RU, RC, RR, Serializable 在说明这个之前，先了解几个概念 a. 基本概念 脏读：读取到一个事务未提交的数据，因为这个事务最终无法保证一定执行成功，那么读取到的数据就无法保证一定准确 不可重复读：简单来说就是在一个事务中读取的数据可能产生变化，同样的sql，在一个事务中执行多次，可能得到不同的结果 幻读：会话T1事务中执行一次查询，然后会话T2新插入一行记录，这行记录恰好可以满足T1所使用的查询的条件。然后T1又使用相同 的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行 加锁读：select * from table ... 的执行是否加了读锁 (这个可以参考上面的sql加锁分析） b. RU: Read Uncommited 未提交读事务中的修改，即使没有提交，对其他会话也是可见的，即表示可能出现脏读，一般数据库都不采用这种方案 c. RC: Read Commited 提交读这个隔离级别保证了一个事务如果没有完全成功（commit执行完），事务中的操作对其他会话是不可见的，避免了脏读的可能 但是可能出现不可重复度的情况，举例说明： 会话T1, 执行查询 select * from where id=1，第一次返回一个结果 会话T2, 执行修改 update table set updated=xxx where id=1 并提交 会话T1，再次执行查询 select * from where id=1，这次返回的结果中update字段就和前面的不一样了 实际的生产环境中，这个级别用的比较多，特意查了下公司的db隔离级别就是这个 一个RC级别的演示过程： 会话1，开启事务，查询 会话2，开启事务，更新DB，提交事务 会话1，再次查询，提交事务 从下面的实际演示结果可以知道，会话1，同一个sql，两次执行的结果不同 相关的sql代码如下: 12345678910111213141516171819202122232425262728293031-- 设置会话隔离级别set session transaction ioslation read commited;-- 查看当前会话隔离级别select @@tx_isolation;-- 会话1的操作start transaction;select * from newuser where userId=1;-- 会话2开始操作start transaction;select * from newuser where userId=1;update newuser set updated=1521786092 where userId=1;select * from newuser where userId=1;commit;-- 再次进入会话1，同样执行上次的sql，对比两次输出结果select * from newuser where userId=1;-- 注意观察，会话1，前后两次这个sql的输出结果，特别是updated字段-- 正常情况会如上面的demo图，会发生改变-- 关闭会话commit;-- 再次查询select * from newuser where userId=1; d. RR: Repeatable Read 可重复度一个事务中多次执行统一读SQL,返回结果一样。 这个隔离级别解决了脏读的问题，幻读问题 实例演示解决脏读的过程(将上面的过程同样来一次） 发现不管会话1同一个sql，返回的结果都是相同的 e. Serializable 可串行化最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是会导致大量超时以及锁争用问题。 f. 常用命令 查看当前会话隔离级别: select @@tx_isolation 查看系统当前隔离级别: select @@global.tx_isolation 设置当前会话隔离级别: set session transaction isolation level read committed; 设置系统当前隔离级别: set global transaction isolation level read committed; 命令行， 开始事务: start transactioin; 提交: commit; 4. 使用姿势前面演示事务隔离级别的时候，给出的实例就演示了事务的使用姿势，一般作为三步骤： 开始事务 start transaction; 执行你的业务sql 提交事务 commit; 我们现在演示以下一个事务中，读锁、写锁对另一个事务的影响 a. 读锁的影响我们采用mysql默认的RR级别进行测试，userId为主键 1234567891011121314151617-- 会话1start transaction;select * from newuser where userId=1 lock in share mode;-- 转入会话2start transaction;select * from newuser where userId=1; -- 会输出select * from newuser where userId=1 lock in share mode; -- 会输出update newuser set updated=1521787137 where userId=1; -- 会挂起-- 转入会话1-- 提交, 此时观察会话2的写是否完成commit;-- 转入会话2commit; 实际执行演示: b. 写锁的影响1234567891011121314151617-- 会话1start transaction;select * from newuser where userId=1 for update;-- 转入会话2start transaction;select * from newuser where userId=1; -- 会输出select * from newuser where userId=1 lock in share mode; -- 会挂住-- update newuser set updated=1521787137 where userId=1; -- 会挂住-- 转入会话1-- 提交, 此时观察会话2的写是否完成commit;-- 转入会话2commit; 实际执行演示: c. 小结 读锁，会阻塞其他请求写锁的sql执行 写锁，会阻塞其他读锁和写锁的sql执行 事务只有在提交之后，才会释放锁 额外注意，上面事务在提交之后才会释放锁，因此如果两个事务循环依赖锁时，可能发生死锁 III. 小结锁和事务可谓是db中非常重要的知识点了，在我们实际的编码过程中（一般针对mysql, innordb存储引擎，rr隔离级别），做出下面的一些总结 1. sql分析 select * from table where xxx; （读快照，一般不加锁） select * from table where xxx lock in share mode; (读锁，会阻塞其他的写锁请求，但其他的读锁请求没有影响） select * from table where xxx for update; (写锁，会阻塞其他的读写请求） update tableName set xxx (写锁） insert （写锁） delete （写锁） 2. 事务简单来讲，事务就是一组sql，要么全部执行成功，要么全部失败 四个特性： A(原子性)C(一致性)I(隔离性)D (持久性) 四种隔离级别：(mysql 默认采用的是RR级别) 隔离级别 脏读 不可重复读 幻读 加锁读 read uncommited 可能 可能 可能 无 read commited 不可能 可能 可能 无 repeatable read 不可能 不可能 不可能 无 serializable 不可能 不可能 不可能 有 使用姿势： 12345start transaction;-- xxx 具体的sqlcommit; IV. 其他参考 深入理解Mysql——锁、事务与并发控制 MySQL 加锁处理分析 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"},{"name":"锁","slug":"锁","permalink":"https://zbang.online/hexblog/tags/锁/"},{"name":"事务","slug":"事务","permalink":"https://zbang.online/hexblog/tags/事务/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"mysql之索引的工作机制","slug":"mysql之索引的工作机制","date":"2018-03-22T04:26:49.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/03/22/mysql之索引的工作机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/22/mysql之索引的工作机制/","excerpt":"mysql之高性能索引当db的量达到一定数量级之后，每次进行全表扫描效率就会很低，因此一个常见的方案是建立一些必要的索引作为优化手段，那么问题就来了： 那么什么是索引呢？ 索引的实现原理是怎样的？ 我们通常说的聚集索引，非聚集索引的区别是什么？ 如何创建和使用索引呢？","text":"mysql之高性能索引当db的量达到一定数量级之后，每次进行全表扫描效率就会很低，因此一个常见的方案是建立一些必要的索引作为优化手段，那么问题就来了： 那么什么是索引呢？ 索引的实现原理是怎样的？ 我们通常说的聚集索引，非聚集索引的区别是什么？ 如何创建和使用索引呢？ I. 索引介绍MySQL官方对索引的定义为：索引是帮助MySQL高效获取数据的数据结构。简而言之,索引是数据结构 1. 几种树的结构a. B+树单来说就是一种为磁盘或者其他存储设备而设计的一种平衡二叉树,在B+tree中所有记录都按照key的大小存放在叶子结点上，各叶子结点直接用指针连接 b. 二叉树二叉树的规则是父节点大于左孩子节点，小于右孩子节点 c. 平衡二叉树首先是一个二叉树，但是要求任意一个节点的左右孩子节点的高度差不大于1 d. B树首先是一个平衡二叉树，但是又要求每个叶子节点到根节点的距离相等 那么B树和B+树的区别是什么呢？ B+树的叶子节点可以包含一个指针，指向另一个叶子节点 B+树键值的拷贝存在非叶子节点；键值+记录存储在叶子节点 2. InnoDB引擎之B+树mysql的InnnoDB引擎采用的B+树，只有叶子节点存储对应的数据列，有以下好处 叶子结点通常包含较多的记录，具有较高的扇出性(可理解为每个节点对应的下层节点较多)，因此树的高度较低(3~4)，而树的高度也决定了磁盘IO的次数，从而影响了数据库的性能。一般情况下，IO次数与树的高度是一致的 对于组合索引，B+tree索引是按照索引列名(从左到右的顺序)进行顺序排序的，因此可以将随机IO转换为顺序IO提升IO效率;并且可以支持order by \\group等排序需求;适合范围查询 3. hash索引hash索引，相比较于B树而言，不需要从根节点到叶子节点的遍历，可以一次定位到位置，查询效率更高，但缺点也很明显 仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询 因为是通过hash值进行计算，所以只能精确查询，hash值是没什么规律的，不能保证顺序和原来一致，所以范围查询不行 无法进行排序 原因同上 不支持部分索引 hash值的计算，是根据完整的几个索引列计算，如果少了其中一个乃至几个，这个hash值就没法计算了 hash碰撞 4. 聚集索引与非聚集索引a. 聚集索引InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，非叶子节点存放&lt;key,address&gt;，address就是下一层的地址 聚簇索引的结构图: b. 非聚集索引非聚簇索引，叶子节点上的data是主键(即聚簇索引的主键，所以聚簇索引的key，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证 非聚簇索引结构图： 从非聚集索引的结构上，可以看出这种场景下的定位流程： 先通过非聚集索引，定位到对应的叶子节点，找到对应的主键 根据上面找到的主键，在聚集索引中，定位到对应的叶子节点（获取数据） 5. 索引的优点 避免全表扫描（当走不到索引时，就只能一个一个的去匹配；如果走索引，则可以根据B树来定位） 使用索引可以帮助服务器避免排序或者临时表 （叶子节点上的指针，可以有效的支持范围查询；此外叶子节点本身就是根据key进行排序的） 索引将随机IO变成顺序IO 6. 适用范围索引并不是适用于任何情况。对于中型、大型表适用。对于小型表全表扫描更高效。而对于特大型表，考虑”分区”技术 II. 索引的使用原则一般我们在创建表的时候，需要指定primary key, 这样就可以确定聚集索引了，那么如何添加非聚集索引呢？ 1. 索引的几个语法创建索引 12345-- 创建索引create index `idx_img` on newuser(`img`);-- 查看show create table newuser\\G; 输出 1234567891011121314151617181920212223show create table newuser\\G*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`), KEY `idx_img` (`img`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 另一种常见的添加索引方式 1234alter table newuser add index `idx_extra_img`(`isDeleted`, `img`);-- 查看索引show index from newuser; 输出结果 123456789101112+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| newuser | 0 | PRIMARY | 1 | userId | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_username | 1 | username | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_nickname | 1 | nickname | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_email | 1 | email | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_phone | 1 | phone | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_img | 1 | img | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_extra_img | 1 | isDeleted | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_extra_img | 2 | img | A | 3 | NULL | NULL | YES | BTREE | | |+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 删除索引 12345drop index `idx_extra_img` on newuser;drop index `idx_img` on newuser;-- 查看索引show index from newuser; 输出 12345678910show index from newuser;+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| newuser | 0 | PRIMARY | 1 | userId | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_username | 1 | username | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_nickname | 1 | nickname | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_email | 1 | email | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_phone | 1 | phone | A | 3 | NULL | NULL | | BTREE | | |+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 强制走索引的一种方式 语法： select * from table force index(索引) where xxx 1234567891011121314explain select * from newuser force index(PRIMARY) where userId not in (3, 2, 5);-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | range | PRIMARY | PRIMARY | 8 | NULL | 4 | Using where |-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+explain select * from newuser where userId not in (3, 2, 5);-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | PRIMARY | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ 2. 索引使用规则当一个表内有多个索引时，如何判断自己的sql是否走到了索引，走的是哪个索引呢？ 可以通过 explain 关键字来进行辅助判断，当然在实际写sql时，我们也有必要了解下索引匹配的规则，避免设置了一些冗余的索引，或者写出一些走不到索引的sql 测试的表结构如下 12345678910111213141516171819*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname_email_phone` (`nickname`,`email`,`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 a. 最左前缀匹配原则这个主要是针对多列非聚簇索引而言，比如有下面这个索引idx_nickname_email_phone(nickname, email, phone), nickname 定义在email的前面，那么下面这几个语句对应的情况是 1234567891011121314151617181920212223-- 走索引explain select * from newuser where nickname='小灰灰' and email='greywolf@xxx.com';-- 1. 匹配nickname，可以走索引explain select * from newuser where nickname='小灰灰';-- 输出:-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- | 1 | SIMPLE | newuser | ref | idx_nickname_email | idx_nickname_email | 92 | const | 1 | Using index condition |-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- 2. 虽然匹配了email, 但是不满足最左匹配，不走索引explain select * from newuser where email='greywolf@xxx.com';-- 输出-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | NULL | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ b. 无法跳过某个列使用后续索引列即对索引idx_nickname_email_phone(nickname, email, phone), 如果你的sql中，只有 nickname 和 phone, 那么phone走不到索引，因为不能跳过中间的email走索引 c. 范围查询后的列无法使用索引如 &gt;, &lt;, between, like这种就是范围查询，下面的sql中，email 和phone都无法走到索引，因为nickname使用了范围查询 1select * from newuser where nickname like '小灰%' and email='greywolf@xxx.com' and phone=15971112301 limit 10; d. 列作为函数参数或表达式的一部分12345678910-- 走不到索引explain select * from newuser where userId+1=2 limit 1;-- 输出-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | NULL | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ 3. 索引缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 4. 注意事项 索引不会包含有NULL值的列 使用短索引 索引列排序 MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引 like语句操作 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引 不要在列上进行运算 select * from users where YEAR(adddate)&lt;2007; 尽量不使用NOT IN和&lt;&gt;操作 5. sql使用策略a. 使用一个sql代替多个sql通常建议是使用一个sql来替代多个sql的查询 当然若sql执行效率很低，或者出现delete等导致锁表的操作时，也可以采用多个sql，避免阻塞其他sql b. 分解关联查询将关联join尽量放在应用中来做，尽量执行小而简单的的sql 分解后的sql简单，利于使用mysql缓存 执行分解后的sql，减少锁竞争 更好的扩展性和维护性（sql简单） 关联sql使用的是内嵌循环算法nestloop，而应用中可以使用hashmap等结构处理数据，效率更高 c. count count(*) 统计的是行数 count(列名) 统计的是列不为null的数量 d. limit limit offset, size; 分页查询，会查询出 offset + size 条数据，获取最后的size条数据 如 limit 1000, 20 则会查询出满足条件的1020条数据，然后将最后的20个返回，所以尽量避免大翻页查询 e. union需要将where、order by、limit 这些限制放入到每个子查询，才能重分提升效率。另外如非必须，尽量使用Union all，因为union会给每个子查询的临时表加入distinct，对每个临时表做唯一性检查，效率较差。 6. mysql使用查询a. 查看索引123-- 单位为GBSELECT CONCAT(ROUND(SUM(index_length)/(1024*1024*1024), 6), ' GB') AS 'Total Index Size'FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; b. 查看表空间12SELECT CONCAT(ROUND(SUM(data_length)/(1024*1024*1024), 6), ' GB') AS 'Total Data Size' FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; c. 查看数据库中所有表的信息1234567SELECT CONCAT(table_schema,'.',table_name) AS 'Table Name', table_rows AS 'Number of Rows', CONCAT(ROUND(data_length/(1024*1024*1024),6),' G') AS 'Data Size', CONCAT(ROUND(index_length/(1024*1024*1024),6),' G') AS 'Index Size' , CONCAT(ROUND((data_length+index_length)/(1024*1024*1024),6),' G') AS'Total' FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; IV. 其他参考 深入理解Mysql——高性能索引与高性能SQL 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"},{"name":"索引","slug":"索引","permalink":"https://zbang.online/hexblog/tags/索引/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"mysql基本语法学习小结","slug":"mysql基本语法学习小结","date":"2018-03-22T01:29:58.000Z","updated":"2018-04-11T03:48:34.956Z","comments":true,"path":"2018/03/22/mysql基本语法学习小结/","link":"","permalink":"https://zbang.online/hexblog/2018/03/22/mysql基本语法学习小结/","excerpt":"本篇将主要集中在mysql的使用上，包括如何创建标，如何进行insert,update,select,delete，以及一些常见的sql中关键字的使用姿势","text":"本篇将主要集中在mysql的使用上，包括如何创建标，如何进行insert,update,select,delete，以及一些常见的sql中关键字的使用姿势 I. 数据库管理相关首先是从结构上知晓，一般的关系型数据库，先创建database(数据库), 然后可以在database中创建多个table(表) 通常，在业务稍微大一点的公司而言，不会把所有的数据都放在一个database中，相反会根据不同的业务，创建不同的database，然后在各自的database中维护自己的表，好处就是不会相互影响，后续扩容也方便 1. 创建database1create database test 2. 切换databasae1user test 3. 删除database1drop databse test 4. 显示所有数据库1show databases II. 表相关主要的操作都是针对表来的，因为数据就是挂在这个下面的 1. 创建表12345678910111213141516171819CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='自定义表' 创建表的规则还是比较简单的，一般语法是： 123456create table tableName( 列名 + 列类型 + NOT NULL(可选，表示这个字段不能为空) + DEFAULT '' (可选，表示默认填充的数据) + COMMENT (后面加上这一列的注释), ... PRIMARY KEY (`id`), // 这个指定主键 KEY `idx_firstId` (`name`) // 这个是指定索引) ENGINE=InnoDB (指定存储引擎) AUTO_INCREMENT=1 （自增开始值） DEFAULT CHARSET=utf8 （默认编码） COMMENT='自定义表'; 需要注意一点，一个表的设计时，最好不要让某一列可以为null，而且良好的习惯是加上DEFALUT默认值，加上列的注释（特别是type的取值固定为1,2,3,4时，尽量在说明中写上每个值的含义） 2. 显示表信息如果我们是在控制台中来上mysql进行相关操作时，非常常见的一个命令就是如何查看表的数据结构，有几个命令 1desc table_name; 输出格式如下: 1234567891011121314151617+-----------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+---------------------+------+-----+---------+----------------+| userId | bigint(20) | NO | PRI | NULL | auto_increment || username | varchar(30) | YES | MUL | | || nickname | varchar(30) | NO | MUL | | || password | varchar(50) | YES | | | || address | text | YES | | NULL | || email | varchar(50) | NO | MUL | | || phone | bigint(20) | NO | MUL | 0 | || img | varchar(100) | YES | | | || extra | text | YES | | NULL | || isDeleted | tinyint(1) unsigned | NO | | 0 | || created | int(11) | NO | | NULL | || updated | int(11) | NO | | NULL | |+-----------+---------------------+------+-----+---------+----------------+12 rows in set (0.00 sec) 如果我希望获取这个表的建表语句，方便直接创建表，也可以用下面的命令 1show create table tableName\\G 输出如下 12345678910111213141516171819202122*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf81 row in set (0.00 sec) 3. 修改表重命名表名 1rename table `oldTableName` to `newTableName` 新加字段 12-- 修改类型alter table newuser add newcol varchar(10) not null default '' comment '新加的列'; 修改列 123456-- 修改类型alter table newuser modify newcol text not null;-- 修改名alter table newuser change `newcol` `newcol2` text; 删除列 1alter table newuser drop newcol2; 删除表 1drop table newuser; 4. 增删改查对DB的操作，基本上就四种了，增删改查，甚至绝大多数的业务都可以用简单的db的增删改查来实现 a. 插入一条数据1234-- insert into table_name(`列名`, `列名`) values('插入值', '插入值');insert into newuser(`username`, `nickname`, `password`, `address`, `email`, `phone`, `img`, `extra`, `isDeleted`, `created`, `updated`) values('insert', 'insert', 'insert', 'test', 'test@test.com', 123, 'img', '', 0, 1521638764, 1521638764); b. 查询数据select用于查询，先给出一个最基本的，下面再详细说明 1select * from newuser where username='insert' limit 1; 上面表示查询 username为insert的记录，输出结果(也就是刚才插入的那一条数据) 12345+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| userId | username | nickname | password | address | email | phone | img | extra | isDeleted | created | updated |+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| 3 | insert | insert | insert | test | test@test.com | 123 | img | | 0 | 1521638764 | 1521638764 |+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+ c. 修改数据将之前插入的记录中，nickname 修改成 ‘newNickName’, 借助 update set 语法实现 12345update newuser set nickname='newNickName' where userId=3;-- 再次查询验证select * from newuser where username='insert' limit 1; 输出结果 12345+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| userId | username | nickname | password | address | email | phone | img | extra | isDeleted | created | updated |+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| 3 | insert | newNickName | insert | test | test@test.com | 123 | img | | 0 | 1521638764 | 1521638764 |+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+ d. 将刚才的数据删掉说明，在实际的生产环境中，一般很少物理删除（即执行delete将记录彻底抹掉），更多的是采用逻辑删除的方案（至少还有恢复的可能，而且数据都是宝贵的，虽然大部分时候我们都没有去挖掘，但保存着总比丢掉好） 物理删除的语法比较简单，但是需要额外小心，一不小心删错了，说不准就得卷铺盖滚蛋了 1234567delete from newuser where userId=3 limit 1;-- 再次查询验证select * from newuser where username='insert' limit 1;-- 输出： Empty set (0.00 sec) III. 玩出花的查询语句1. 基本查询写sql而言，最常见的，也是最复杂的就是写各种查询了，根据各种不同的条件查询检索结果，大概可以区分以下几种 简单查询：知道确切的检索条件 where xxx=xxx 相等的判断 where xxx&lt;&gt;xxx 不等的判断 where id in (xxx, xxx, xxx) 满足集合的判断 where xxx=xxx and yyy=yyy 条件同时满足 where xxx=xxx or yyy=yyy 条件满足一个即可 where id&gt;10 or id&lt;5 范围判断 &gt;, &lt;, &gt;=, &lt;= where name is null 判空 is null, =’’, 非空 is not null, &lt;&gt;’’ 模糊查询: like 语法， %:替代任意个字符 _:替代一个字符 如: select userId,username from newuser where username like &#39;%灰%&#39;; 输出: 123456+--------+-----------+| userId | username |+--------+-----------+| 1 | 大灰狼 || 2 | 小灰灰 |+--------+-----------+ 条件限制 where 1=1 limit 10; 限制最多查询出来的条数 where 1=1 limit 1, 2; 分页查询 group by username; 分组 order by userId desc; 排序： desc倒排，asc 正排 select distinct(nickname) from xxx; 去重 having count(*) &gt; 2; 分组之后再筛选 执行计算 update phone=phone+1 limit 1; 直接实现数值计算 count(*) 统计总数 sum() 统计和 max() 最大值 min() 最小值 avg() 平均值 常用函数 abs() 返回绝对值 bin() 返回二进制 oct() 返回八进制， hex() 返回十六进制 exp() 返回e的n次方 greatest(x1, x2... xn) least(x1, x2, ...n) 返回最大最小 ln(x) 返回x的自然对数 log(x, y) mod(x, y) 返回x%y的模（余数） rand() 返回0-1内的随机值 floor(x) 反后小于x的最大整数 ceiling(x) 返回大于x的最小整数 round(x, y) 返回x的四舍五入的有y位小数的值 turncate(x,y) 截断为y位小数 sign(x) sqrt(x) 平方根 concat(s1, s2...) 字符串拼接 left(str, x) str的左x个字符 right(str, x) length(str) 返回字符串的长度 trim(str) 去掉空格 from_unixtime 将时间戳转日期 更多参考：MySQL常用函数 123456789select username,from_unixtime(created) from newuser limit 1;--- 下面为输出-- +-----------+------------------------+-- | username | from_unixtime(created) |-- +-----------+------------------------+-- | 大灰狼 | 2016-09-25 00:00:00 |-- +-----------+------------------------+ 2. 跨表查询当设计到查询多张表的结果时，往往是比较麻烦的 简单的多表查询方式 1select col1, col2 from table1, table2 where table1.col1 = table2.col2 limit 10; 主要就是利用两个表中的关联的列进行联合查询，也就是说，当查询涉及到多表时，那么这些表肯定是有沟通的桥梁的（一般是某一张表的主键是另一张表的某一列） 举个小例子，查询商品评价数为1的商品（假设评价是一张表，商品也是一张表），那么关联的主键就是商品ID了 如果是分开查询，那么应该是 1234567-- 查询出评价总数为1的10条评价select * from Rate group by itemId having count(*) =1 limit 10;-- 查询对应的商品信息, 上面的结果就是下面()中的内容select * from Item where itemId in (xxx, xxx); 那么换成一条sql，可以怎么写？ 简单的嵌套方案：（有点像是硬把多条语句写成一条） 12select * from Item where itemId in (select itemId from Rate group by itemId having count(*)=1 limit 10); 一般多表查询可划分为: a.交叉连接查询需求:查询员工及其部门名称 123SELECT employee.name,dept.nameFROM employee,dept; b.内连接查询(使用最多)多表查询的步骤: 1)确定查询哪些表2)确定查询哪些字段3)确定连接条件(规则:条件=表数量-1) 123SELECT employee.name,dept.nameFROM employee,deptWHERE employee.deptId=dept.id; 另一种语法 1234SELECT e.name,d.name FROM employee e INNER JOIN dept d ON e.deptId=d.id; c.左外连接查询(左表数据全部显示，如果右边不满足，则显示null)需求:查询部门及其部门的员工 1234SELECT d.name,e.name FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; d.右外连接查询(右表数据全部显示，如果左边不满足，则显示null)1234SELECT d.name,e.nameFROM employee eRIGHT OUTER JOIN dept dON e.deptId=d.id; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"常用Alfred工具","slug":"常用Alfred插件","date":"2018-03-19T02:14:32.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Alfred插件/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Alfred插件/","excerpt":"","text":"I. Alfred工具alfred可以说是mac上必备的一个app了，可以极大的提高工作效率，再加上它支持自定义实现各种扩展，完全可以满足大部分的需求场景了 1. 安装首先下载安装包，推荐一个神奇的网站，下载各种mac的破解软件，工具下载链接: http://xclient.info/s/alfred.html 破解方式： 点击下载包里面的keygen 点击patch，会打开目录，选择alfred，点击激活 重启alfred即可 2. 几个插件下载包内直接包含了所有的流程和源码，也没什么好具体说的，下载完毕之后双击即可 a. 日期与时间戳点击下载：time.alfredworkflow demo: b. md5点击下载: md5.alfredworkflow demo: c. url编码点击下载: URL编码.alfredworkflow demo: d. 分库分表点击下载: table.alfredworkflow demo: II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"常用Popclip工具","slug":"常用Popclip工具","date":"2018-03-19T01:50:57.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Popclip工具/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Popclip工具/","excerpt":"","text":"I. PopClip工具PopClip是mac上的一个工具集，最大的特点就是扩展，复制一段文本，然后根据你的需求写插件，把赋值的文本作为输出，做一些你想干的事 基于PopClip，也写了一些小工具，主要是php写的，写插件的教程还是比较简单的，一个配置文件Config.plist和一个脚本文件xxx.php即可 1. 实现一个插件流程以JSON格式序列化为demo进行演示，如何从0到1创建一个popclip插件，先看一下最终的成品 一个插件的文件比较简单，主要有两个 Config.plist 具体的脚本文件 a. 配置文件下面是一个实际的配置，里面指定了两个脚本： 第一个是 json2str.php，这个脚本实现将json转换为单行字符串，在插件上显示的名字就是 JsonStr, 采用的php编写实现 第二个是 str2json.php 需要注意的是里面正则规则，这个主要是用来表示当你划中一段文本之后，是否会出现这个插件的规则（比如时间戳和日期的相互转换，只有选中纯数字时，才支持时间戳转日期） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Actions&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;After&lt;/key&gt; &lt;string&gt;paste-result&lt;/string&gt; &lt;key&gt;Regular Expression&lt;/key&gt; &lt;!-- 正则匹配规则，*号表示任意选中的内容都会激活这个插件 --&gt; &lt;string&gt;*&lt;/string&gt; &lt;key&gt;Script Interpreter&lt;/key&gt; &lt;string&gt;/usr/bin/php&lt;/string&gt; &lt;key&gt;Shell Script File&lt;/key&gt; &lt;!-- 执行具体逻辑的脚本名 --&gt; &lt;string&gt;json2str.php&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;!-- 插件的name --&gt; &lt;string&gt;JsonStr&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;After&lt;/key&gt; &lt;string&gt;paste-result&lt;/string&gt; &lt;key&gt;Regular Expression&lt;/key&gt; &lt;string&gt;*&lt;/string&gt; &lt;key&gt;Script Interpreter&lt;/key&gt; &lt;string&gt;/usr/bin/php&lt;/string&gt; &lt;key&gt;Shell Script File&lt;/key&gt; &lt;string&gt;str2json.php&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;string&gt;StrJson&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;Extension Description&lt;/key&gt; &lt;!-- 描述 --&gt; &lt;string&gt;remove json space or stringfy json str&lt;/string&gt; &lt;key&gt;Extension Name&lt;/key&gt; &lt;string&gt;JSON&lt;/string&gt; &lt;key&gt;Credits&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;Link&lt;/key&gt; &lt;string&gt;mailto:bangzewu@126.com&lt;/string&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Json序列化&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;Extension Identifier&lt;/key&gt; &lt;string&gt;popclip.extension.json-covert&lt;/string&gt; &lt;key&gt;Required Software Version&lt;/key&gt; &lt;integer&gt;695&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt; b. 脚本文件这个里面就是写具体的业务逻辑，一般是将粘贴板中的内容作为输入，然后进行一段业务逻辑，然后输出到粘贴板内 如str2json.php 12345678&lt;?php$input=getenv(\"POPCLIP_TEXT\");if(empty($input)) &#123; echo ''; &#125; else &#123; $param = json_decode($input); echo json_encode($param, JSON_UNESCAPED_UNICODE|JSON_PRETTY_PRINT|JSON_UNESCAPED_SLASHES);&#125; 注意第一行，获取输入 $input=getenv(&quot;POPCLIP_TEXT&quot;);, 不同的脚本有不同的获取方式 输出就比较简单了，传统的输出方法，会重写到粘贴板内 echo &#39;xxx&#39;; c. 打包上面完成之后，就是打包安装了，流程如下： 新建一个文件夹，后缀为.popclipext，将.plist和脚本文件拷贝到新的文件夹下 压缩： zip -r xxx.popclipextz xxx.popclipext/ 双击上面生成的文件，确认安装即可 说明： 上面新建的文件夹，一定要以.popclipext结尾 2. 我的插件a. base64编码作用：实现base64编码解码 源码地址: base64 demo: b. 日期&amp;时间戳作用：实现日期和时间戳的相互转换 源码地址： date demo: c. unicode字符转中文源码 : unicode d. json格式化源码: json e. url编码解码源码: url II. 其他工程地址所有的插件都可以访问： PopClip 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"常用Chrome工具","slug":"常用Chrome工具","date":"2018-03-19T01:47:47.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Chrome工具/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Chrome工具/","excerpt":"","text":"I. Chrome常用插件记录下使用到的Chrome插件，有些挺有意思的东西 1. Website IP在网页的右下角(or左下角)显示当前网页的服务器IP，用来判断当前的系统的工作环境非常有用，特别是在线下、预发和生产环境的切换时，判断host是否切换的时候 2. Adblock Plus拦截小广告 3. Adkill and Media download拦截视频广告，我常逛的优酷，腾讯视频，爱奇艺，芒果的视频广告都被可以被吃掉，节省两分钟的等待时间 4. GitCodeTree码云提供的gitee，侧边栏提供一个直接查看代码的树状结构 5. JSON Editor写json的插件 6. Json Handlerjson结构化，针对请求直接返回json串的场景用起来比较爽，除了结构化输出之外，还可以修改json串内容，个人感觉比JSONView好用 7. Octotreegithub源码视图工具，和前面的 GitCodeTree 差不多 8. Postman模拟各种http请求 9. Vimium以vim的方式操作浏览器页面，实现真正的无鼠标全键盘操作 10. 二维码(QR码)生成器(QR Code Generator)当前网页生成一个二维码，方便手机打开 11. 捕捉网页截图 - FireShot网页截图工具，可以截长图文，但是在网页特别长时，截取失败，有些时候用起来还可以 12. 掘金覆盖默认的新打开标签页，显示一些有意思的git项目和掘金上的优秀博文 13. Encoder(自定义实现)自己写的一个插件，主要是为了提供一些常见的转换， 源码&amp;下载地址: Chrome-Coder 时间戳和日期的相互转换 url编码解码 base64编码解码 unicode编码解码 14. Chrome-ImgRender自己写的插件，源码&amp;下载地址: Chrome-ImgRender 选择网页中的dom结构，输出图片的小工具，使用演示如： II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"Java面试知识要点之IO篇","slug":"Java面试知识要点之IO篇","date":"2018-03-18T14:16:34.000Z","updated":"2018-04-26T11:59:29.004Z","comments":true,"path":"2018/03/18/Java面试知识要点之IO篇/","link":"","permalink":"https://zbang.online/hexblog/2018/03/18/Java面试知识要点之IO篇/","excerpt":"Java知识要点汇总之IO篇主要集中在IO相关的问题汇总，这一块的东西感觉理解得很不透彻，很多东西写起来都没有干货，后面有必要好好的再深入几次，反复的看下，最好是能拜读下Netty源码","text":"Java知识要点汇总之IO篇主要集中在IO相关的问题汇总，这一块的东西感觉理解得很不透彻，很多东西写起来都没有干货，后面有必要好好的再深入几次，反复的看下，最好是能拜读下Netty源码 I. 题解1. 什么是比特(Bit),什么是字节(Byte),什么是字符(Char),它们长度是多少,各有什么区别比特：基本的二进制单位，01 字节：8个比特表示一个字节，计算机操作数据的最小单位 字符：2个字节 2. 什么是流,按照传输的单位,分成哪两种流：读写数据的一种方式，流是单向的，可以区分为InputStream 和 OutputStream，分别表示输入输出流 代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对象 一般将流区分为 字节流：InputStream, OutputStream 字符流：Reader, Writer 根据流向可以区分为： 输入流： InputStream, Reader 输出流： OutputStream, Writer 根据使用可以区分为： 介质流（直接与数据原交互）: FileInputStream, ByteArrayInputStream, StringBufferedReader 转换流： InputStreamReader, OutputStreamWriter 装饰流： BufferedReader, DataInputStream, ObjectInputStream, 3. 如果我要对字节流进行大量的从硬盘读取,要用那个流,为什么使用 BufferedInputStream, 缓冲流，减少频繁的磁盘读写，每次读写都是操作缓冲区间，在执行flush或者关闭流时，才会落盘 4. 如果我要打印出不同类型的数据到数据源,那么最适合的流是那个流,为什么PrintStream 用于打印 5. 怎么样把输出字节流转换成输出字符流1new InputStreamReader(new FileInputStream(new File())); 6. 把包括基本类型在内的数据和字符串按顺序输出到数据源，或者按照顺序从数据源读入，一般用哪两个流DataInputStream / DataOutputStream 7. 把一个对象写入数据源或者从一个数据源读出来,用哪两个流ObjectInputStream / ObjectOutputStream 8. 什么叫对象序列化，什么是反序列化，实现对象序列化需要做哪些工作 序列化：将对象以二进制的方式输出 反序列化：读取二进制的信息，转换为对象 一般要求：对象实现Serializable接口，对于不需要输出的变量用transient修饰 9. 在实现序列化接口是时候一般要生成一个serialVersionUID字段,它叫做什么,一般有什么用版本号，要保持版本号的一致 来进行序列化， 为了防止序列化出错 10. 流一般需要不需要关闭,如果关闭的话在用什么方法,一般要在那个代码块里面关闭比较好，处理流是怎么关闭的，如果有多个流互相调用传入是怎么关闭的流一旦打开就必须关闭，使用close方法放入finally语句块中（finally 语句一定会执行）调用的处理流就关闭处理流多个流互相调用只关闭最外层的流 说明上面的内容主要来自 java IO流面试总结，对其中的部分内容不敢沟通，特别是里面的选择题，就不记录了 IO/NIO相关1. 流与缓冲IO面向流的操作，一次一个字节的处理数据；流属于单向，可分为输入流和输出流 NIO面向缓冲的操作，可以将数据读取（or写入）到一块缓冲区域，而缓冲上的读写是可以同时存在的，最终通过控制缓冲区域的数据落盘实现读写磁盘操作 2. 阻塞与非阻塞阻塞IO：表示当读取or写入数据时，若数据没有准备好，则用户线程被阻塞，释放CPU资源，直到数据准备完毕 非阻塞IO：当读取or写入数据时，即便数据没有准备好，也会返回一个标识，这是用户可以做自己的事情，然后在轮询判断数据是否准备好，等待准备完毕之后，再执行读写磁盘 传统的IO是阻塞的，即在调用read()/write()时，可能阻塞用户线程 NIO是非阻塞的，基于多路复用IO模型实现，在未获取数据之前，可以去干其他的事情 3. 使用场景NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。 IO : 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。 NIO : 而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。 4. 引用一个例子 以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。 nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。 当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。 III. IO模型1. 五种基本IO模型 阻塞IO 非阻塞IO 多路复用IO 信号驱动IO 异步IO 2. 什么是多路复用I/O多路复用主要解决传统I/O单线程阻塞的问题。它通过单线程管理多个FD，当监听的FD有状态变化的时候的，调用回调函数，通知用户已经准备完毕。用户收到通知，就可以进行IO操作了。这种机制大大的提高了系统的吞吐量。I/O多路复用的目的是为了更充分的利用CPU资源 3. NIO的几个角色 Channel：管道，连接数据源，配合Buffer进行操作，支持读写，支持异步 Buffer：缓冲区，读写数据优先写在这个里面 Selector：监控多个管道，基于数据源的读写事件，轮询管道，实现数据与Buffer之间的交互 IV. 其他参考 java IO流面试总结 深入理解Java中的IO 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"Java学习之NIO相关","slug":"Java学习之NIO相关","date":"2018-03-18T12:54:24.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/18/Java学习之NIO相关/","link":"","permalink":"https://zbang.online/hexblog/2018/03/18/Java学习之NIO相关/","excerpt":"Java NIO学习小结前面一篇主要学习了下IO的流式操作，接下来就是重头戏了，NIO，又称为New IO 当然也是得抱着问题来学习这个东西了，希望可以通过本文，可以学习到： 什么是NIO NIO相比较与IO有什么特点 同步，非同步，阻塞，非阻塞是什么鬼 几种IO模型","text":"Java NIO学习小结前面一篇主要学习了下IO的流式操作，接下来就是重头戏了，NIO，又称为New IO 当然也是得抱着问题来学习这个东西了，希望可以通过本文，可以学习到： 什么是NIO NIO相比较与IO有什么特点 同步，非同步，阻塞，非阻塞是什么鬼 几种IO模型 I. 基本概念首先理解下什么是同步IO,非同步IO，什么是阻塞IO，非阻塞IO，它们两对的主要区别是什么；其次就是五种IO模型 1. 同步/非同步IOa. 同步IO同步，主要是多个线程的执行中，对彼此的执行结果有依赖，即某个线程的执行，必须要求他依赖的线程二执行完毕 同步IO，表示在发起IO操作之后，如果数据没有准备就绪，就需要用户线程轮询的去询问是否准备好，只有准备好之后，将数据从内核拷贝到用户线程 b. 异步IO异步，指多个任务可以并发的执行，他们比吃执行结果，是否执行完毕对其他都没有影响 异步IO，用户线程发起IO操作，该用户线程可以继续执行其他的事情；剩下的数据是否准备完毕，准备完毕之后从内核拷贝到用户都有内核自动完成 c. 区别同步IO和异步IO的主要区别就在于： 用户线程发起IO操作之后，是否可以干其他的事情（同步IO需要轮询判断数据是否准备就绪；异步IO不需关心） 数据从内核拷贝到用户线程 同步IO会阻塞用户线程；异步IO不会 2. 阻塞/非阻塞IO阻塞IO阻塞，指在执行过程中，没有获得预期的结果，就一直阻塞等待获取到结果 阻塞IO，在发起IO请求之后，若数据没有准备好，就一直阻塞等待数据准备完毕 非阻塞IO非阻塞，表示在执行过程中，若某个条件未满足，则直接返回个标识，它继续去干其他的事情 非阻塞IO，在发起IO请求之后，若数据没有准备好，就返回一个对应标识，它继续干其他的事情 3. 五种IO模型a. 阻塞IO模型最传统的IO模型，在读写数据时，未准备就绪，则阻塞用户线程，释放CPU资源，当数据准备就绪之后，内核将数据拷贝到用户线程，用户线程取消阻塞状态 b. 非阻塞IO模型在读写数据时，直接返回结果，如果没有准备好，则自己实现逻辑，轮询的去判断是否准备就绪 当准备完毕之后，再次轮组发起IO请求，就可以将数据拷贝到用户线程 这个过程中，虽然没有释放CPU资源，但是轮询的判断是非常消耗性能的 c. 多路复用IO模型Java NIO实际上就是多路复用IO。 在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用 在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。 d. 信号驱动IO模型在发起IO请求时，注册一个信号驱动钩子，然后自己干自己的事情 当数据准备就绪之后，发送一个信号给用户线程，然后用户线程执行自己注册的钩子，在内部实现真实的IO操作 e. 异步IO模型异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了 说明 前面四种都属于同步IO（在内核进行数据拷贝都会引起用户线程阻塞），只有最后一个是异步IO 异步IO和信号驱动IO的主要区别在于具体的数据处理上 II. NIO为了解决传统IO的阻塞问题引入的，主要原理如下: 一个专门的线程来处理所有的 IO 事件，并负责分发 事件驱动机制 线程通讯通过 wait/notify 等方式通讯，较少线程切换 1. 基础知识NIO新定义了三个基本角色：Channel, Buffer, Selector a. Channel类似IO中的流，但又有不同 支持读写（而流是单向的） 与Buffer进行交互（即写入到buffer，从buffer中读取） 支持异步 常见的Channel有四种 FileChannel ： 文件，不支持非阻塞方式 DatagramChannel：UDP网络数据 SocketChannel：TCP读写网络数据 ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 b. Buffer缓冲区，主要有8种: ByteBuffer CharBuffer FloatBuffer DoubleBuffer IntBuffer ShortBuffer LongBuffer MappedByteBuffer 管道的读写是需要借助Buffer来实现的，一般buffer的读写流程： 创建Buffer ByteBuffer buf = ByteBuffer.allocate(48); 写入数据到Buffer 从Channel写到Buffer: channel.read(buf); 直接塞入buffer: buf.put(12); flip() 切换读写模式 将写模式切换到读模式 从Buffer读取数据 从Buffer读数据到Channel：channel.write(buf); 直接读取数据: buf.get() 清空缓存区：clear() 或 compact() clear 清空，但是数据并未清除，会覆盖 compact 将所有未读的数据拷贝到Buffer起始处 额外方法： Buffer.rewind() 将position设回0，所以你可以重读Buffer中的所有数据 limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等） Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用 Buffer.reset()方法，恢复到Buffer.mark()标记时的position c. selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件 创建 Selector selector = Selector.open(); 注册通道 设置通道为非阻塞 channel.configureBlocking(false); 注册: SelectionKey key = channel.register(selector,Selectionkey.OP_READ); 监听事件 selector.select();当注册的事件到达时，方法返回；否则,该方法会一直阻塞 迭代：selector.selectedKeys().iterator() 获取通道: SelectionKey#channel 通过缓冲区读写数据 III. NIO与IO对比1. Java NIO提供了与标准IO不同的IO工作方式： Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。 Selectors（选择器）：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 2. 使用场景NIO 优势在于一个线程管理多个通道；但是数据的处理将会变得复杂； 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种； 传统IO 适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的 如果需要管理同时打开不太多的连接，这些连接会发送大量的数据； 3. 区别 IO是面向流的，NIO是面向缓冲区的 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方； NIO则能前后移动流中的数据，因为是面向缓冲区的 IO流是阻塞的，NIO流是不阻塞的 Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 选择器 Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道 这些通道里已经有可以处理的输入，或者选择已准备写入的通道 这种选择机制，使得一个单独的线程很容易来管理多个通道。 IV. 其他参考 Java NIO：浅析I/O模型 Java NIO原理图文分析及代码实现 Java NIO系列教程（一） Java NIO 概述 Java NIO 与 IO之间的区别 JAVA IO 以及 NIO 理解 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://zbang.online/hexblog/tags/IO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}]},{"title":"Java学习之IO相关","slug":"Java学习之IO相关","date":"2018-03-18T07:19:55.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/18/Java学习之IO相关/","link":"","permalink":"https://zbang.online/hexblog/2018/03/18/Java学习之IO相关/","excerpt":"Java IO学习小结IO操作算是java的一个基本知识点了，比如我们常见的网络IO，文件读写等，而且这一块基本上大家并不会频繁的来操作，大多会用一些封装得好用的工具来代替，某些时候真的需要做的时候，基本上也很难一下子很顺利的写完 本篇将主要集中在： 几种IO分类 字节IO和字符IO的转换 装饰类IO是什么 序列化的实现机制","text":"Java IO学习小结IO操作算是java的一个基本知识点了，比如我们常见的网络IO，文件读写等，而且这一块基本上大家并不会频繁的来操作，大多会用一些封装得好用的工具来代替，某些时候真的需要做的时候，基本上也很难一下子很顺利的写完 本篇将主要集中在： 几种IO分类 字节IO和字符IO的转换 装饰类IO是什么 序列化的实现机制 I. IO分类Java中的IO操作，一般都是基于流进行，以输入输出流进行分类可以分为 字节流：InputStream, OutputStream 字符流：Reader, Writer 从数据源进行分类，又可以区分为： 文件读写： FileInputStream, FileOutputStream，FileReader 字符串流： StringBufferInputStream， StringReader 数组流： ByteArrayInputStream 网络： Socket 从去向分析，就是输入流和输出流： 输入流： xxxInputStream, xxxReader 输出流: xxxOutputStream, xxxWriter II. IO流的基本知识点IO操作，最主要的一点就是需要清晰如何使用了，一般来讲，网络或文件读写，都是基于字节进行交互的，但实际上为了能友好的读取或写入信息，一般都是字符方式，由字符到字节之间则需要一个编码规则的映射 所有，很简单就可以知晓，这里至少有三种不同应用场景的类和一种设计模式 字节流 字符流 字节映射字符流 （适配器模式） 1. 基本使用以常见的文件读写为例进行说明，一般的读写操作是啥样的 123456789101112131415161718@Testpublic void testPrintFile() throws IOException &#123; String fileName = \"/tmp/test.d\"; File file = new File(fileName); InputStream input = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(input, Charset.forName(\"utf-8\")); BufferedReader bufferedReader = new BufferedReader(reader); String ans = bufferedReader.readLine(); while (ans !=null ) &#123; System.out.println(ans); ans = bufferedReader.readLine(); &#125; bufferedReader.close(); reader.close(); input.close();&#125; 上面的流程基本上就下面五步： 创建一个File对象 包装为IO流： new FileInputStream(new File(&quot;test.d&quot;)) 字节流转换为字符流: new InputStreamReader(input, Charset.forName(&quot;utf-8&quot;)) 字符流使用缓冲修饰，支持读一行 关闭流 基本上上面这个套路是比较适合常见的IO操作的，那么为什么是这么个流程呢？这个流程中又有些什么有意思的东西呢？ 2. IO流使用姿势分析 声明：下面这一段纯属个人理解，如有不误，请不吝指正 对操作系统而言（网络传输也一样），他们关心的是一个字节一个字节的行为，所以与它们打交道，就需要遵循他们的规则来办事，使用字节来操作，所以最开始我们都是采用字节流来定义与数据源的交互规则 然而字节流虽好，但是所有的数据最终都是为人服务的，而由于客观原因，不同的国家有不同的语言，为了面向人类的友好，出现了字符这个东西，所以一般我们的操作也更多的是基于字符进行操作 上面这两个出现之后，一个自然而然的东西–&gt;InputStreamReader就出现了，作为字节和字符转换的桥梁 上面这三个可算是一个基本的操作流程了，可以满足我们的输入输出需求，但依然不是特别友好，比如一个一个字符的操作不友好啊，比如我希望过滤某些东西，或者做其他的一些辅助操作之类的，因此就出现了各种装饰流，主要就是提供一些服务方法，增强接口的易用性 简单的使用姿势流图： 123456graph TDA(数据源)--&gt;B(字节流InputStream/OutputStream)B--&gt;C[InputStreamReader/OutputStreamWriter]C--&gt;D[Reader/Writer]D--&gt;E[装饰流]E--&gt;F(关闭) 3. 常见IO类a. 基本介质流与提供读写数据的数据源打交道的流 FileInputStream : 数据源为文件 ByteArrayInputStream: 数据源为byte数组 StringBufferInputStream: StringBuffer作为数据源，已废弃 PipedInputStream：管道，多线程协作使用 使用姿势 123456789101112// 数组byte[] bytes = new byte[]&#123;'a', 'b', 'c', '1', '2'&#125;;ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);int a = 0;while((a = byteArrayInputStream.read()) != -1) &#123; System.out.print(a + \" \");&#125;byteArrayInputStream.close();// 输出: 97 98 99 49 50// StringBufferInputStream 已经被废弃 b. 字节字符转换两个: InputStreamReader OutputStreamWriter 使用姿势也比较简单，标准的适配器模式，用构造方法传参即可，下面给出一个demo，结合上面的，实现将数组流的数据写入的文件(说明，下面的实现更多的是为了演示这种用法，实际编码中有较大的优化空间) 123456789101112131415byte[] bytes = new byte[]&#123;'a', 'b', 'c', '1', '2'&#125;;ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);File file = new File(\"/tmp/test.d\");OutputStream out = new FileOutputStream(file);Writer writer = new OutputStreamWriter(out);int a = 0;while((a = byteArrayInputStream.read()) != -1) &#123; writer.write(a);&#125;writer.flush();writer.close();byteArrayInputStream.close(); c. 装饰流主要是基于装饰模式，对IO流，增强一些操作方法，最明显的是特征是他们继承自 FilterInputStream，比如我们最常用的BufferedInputStream 和 DataInputStream 基本数据类型读写流: DataInputStream 8中基本类型的读入写出流，没什么好说的 缓存流： BufferedInputStream 为了提升性能引入，避免频繁的磁盘读写 对象流: ObjectInputStream 虽然没有继承自FilterInputStream，依然把它作为装饰流，后面单独说 这里面有必要好好的说到以下 BufferedInputStream，缓冲流的底层原理是什么，又有什么好处，为什么会引入这个？ API解释：在创建 BufferedInputStream时，会创建一个内部缓冲区数组。在读取流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。 也就是说，Buffered类初始化时会创建一个较大的byte数组，一次性从底层输入流中读取多个字节来填充byte数组，当程序读取一个或多个字节时，可直接从byte数组中获取，当内存中的byte读取完后，会再次用底层输入流填充缓冲区数组。 以文件读写为例，在实际的落盘和读取过程，这个是加锁阻塞的操作，如果每次都只读1个字节，在大量的读写情况下，这个性能就很脆了 加上这个缓冲之后呢？在一次加锁的过程中，尽量多的读取数据，放在本地内存，这样即便是在使用的地方一个一个的获取，也不会与其他的任务产生竞争，所有有效的提高了效率 III. 序列化在平常的工作中，基本上离不开序列化了，比如web应用中，最常见的基于JSON的数据结构交互，就算是一种JSON序列化方式；当然我们这里谈的序列化主要是JDK原生的方式 1. 背景出现序列化需求的背景比较清晰，我们希望某些对象可以更方便的共享，如即便程序over了，它们可以以某种方式存在（比如写在一个临时文件中），如RPC中传参和返回等 使用时注意事项 一个类需要序列化，需要实现 Serializable 这个空接口，会告知编译器对它进行特殊处理 一个友好的习惯是，在可序列化的类中，定义一个 static final long serialVersionUID transient变量可标识出来不被序列化的字段 2. 实现给出一个使用case 1234567891011121314151617181920212223242526272829303132333435363738394041public static class Demo implements Serializable &#123; private String name; private Integer age; private boolean isBoy; private transient String ignore; public Demo(String name, Integer age, boolean isBoy, String ignore) &#123; this.name = name; this.age = age; this.isBoy = isBoy; this.ignore = ignore; &#125; @Override public String toString() &#123; return \"Demo&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", isBoy=\" + isBoy + \", ignore='\" + ignore + '\\'' + '&#125;'; &#125;&#125;@Testpublic void testObjStream() throws IOException, ClassNotFoundException &#123; Demo demo = new Demo(\"测试\", 123, true, \"忽略的一段文本\"); // 将对象写入到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"/tmp/out.t\")); oos.writeObject(demo); oos.flush(); oos.close(); System.out.println(\"-------- over ----------\"); // 从文件读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"/tmp/out.t\")); Object obj = ois.readObject(); System.out.println(\"反序列化: \" + obj + \" \\n类型：\" + obj.getClass().getSimpleName());&#125; 输出结果 123-------- over ----------反序列化: Demo&#123;name=&apos;测试&apos;, age=123, isBoy=true, ignore=&apos;null&apos;&#125; 类型：Demo 对应的文本内容 IV. 小结io可以说是java中最基本的操作方式了，jdk本身设计是比较优雅的，从上面简单的学习就看到了两种设计模式：适配器+装饰器 提到IO，就不能跳过NIO，特别是在实际的工作中，用得非常多的网络交互，现在基本上是Netty占据主流，这个里面又是有不少东西可以学习的，放在下一篇，下面简单回顾下IO流的认知与使用 1. 流分类： 字节流： InputStream , OutputStream 字符流： Reader, Writer 2. 从设计角度分类 介质流：直接与数据源打交道 FileInputStream, StringBufferInputStream(已经不用，改StringBufferReader), ByteArrayInputStream （网络传输的二进制流，基本就是这个） 转换: 字节流和字符流的转换 InputStreamReader, OutputStreamWriter 装饰流: BufferedInputStream, DataInputStream, ObjectInputStream 3. 序列化和反序列化序列化是指将对象输出为二进制流的过程，反序列化则是指将二进制流反序列化为对象的过程 一般序列化的对象需要实现Serializable接口，内部不需要序列化的对象，用transient关键字进行声明 4. IO基本使用姿势介质流与数据源进行交互 –&gt; 转换流包装为字符流 –&gt; 装饰流进行实际操作 –&gt; 关闭流 以文件读写为例: 12345BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"test.txt\"), Chaset.forName(\"utf-8\")));String ans = reader.readLine();reader.close(); IV. 其他参考： 深入理解Java中的IO Java IO完全总结（转载） 编程语言的基础——搞定JavaIO 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://zbang.online/hexblog/tags/IO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}]},{"title":"Java面试要点汇总之jvm篇","slug":"Java面试要点汇总之jvm篇","date":"2018-03-16T07:35:21.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/03/16/Java面试要点汇总之jvm篇/","link":"","permalink":"https://zbang.online/hexblog/2018/03/16/Java面试要点汇总之jvm篇/","excerpt":"","text":"Java知识要点汇总之JVM篇JVM相关知识点，对于我这种纯业务开发而言，很少接触到，因此对于什么类加载机制，内存结构，垃圾回收算法，收集器，一些jvm调优命令，gc日志的分析之类的就比较生疏和蒙逼了，甚至说，对于写一个自定义类加载器，来实现一些动态代码的编译加载都不会。。。 总感觉白瞎了这三年的工作了，so，还是要追求下技术深度的 I. 知识点回顾1. JVM的内存结构。简单划分，可以区分为四块： 堆 + 运行时方法区 + 栈 + 程序计数器 针对是否线程共有进行划分： 线程私有: 程序计数器， 栈线程公用：堆，运行时方法区 1.程序计数器 执行当前线程执行的字节码行号指示器，用于控制程序的运行 2.栈 jvm虚拟机栈 描述java方法执行时的内存模型，每个方法执行时，都就有一个对应的栈帧 存储局部变量表 操作栈 返回出口 动态链接 本地方法栈 JNI本地方法运行时，相关的内存信息，基本等同于上一个 3. 方法区 类加载时，就会在方法区内存储class对应的数据结构，此外还会保留类的静态属性，常量池，以及一些即时编译代码 一般来讲，方法区内的内存不怎么会被回收，只有类卸载的时候，才会回收掉对应的空间，而实际场景下，有类卸载这种case的，可不常见 4. 堆一般来说，这个就是最大的存储空间，实际存储对象，也就是new出来的对象，都在这里，这里也垃圾回收的重头戏 现代的垃圾收集器如CMS，采用分代的思想，将堆区分为： Young区（年轻代） Edge区 Sruvivor区 Old区（年老代） 2. JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。首先知道栈是方法调用和方法执行时的数据结构，也就是说栈的工作过程，应该是指方法调用，到方法执行完毕，退出到调用方，这个流程中，栈内数据的分配，回收的情况 首先根据栈的数据结构来进行分析 a. 局部变量表内部存储方法参数和局部变量，在编译阶段即可确定大小 b. 操作栈在实际的运行中，方法内部又可能依赖其他的方法，这样在实际执行的过程中，就形成了一个栈的情况，栈顶的表示正在用的，这样就比较容易实现运行方法的切换 c. 动态链接将符号引用替换为直接引用 d. 返回出口当执行异常或出现return语句时，会退出方法，返回结果，而返回主要包括： 恢复上层方法的局部变量表和操作数栈 将返回值压入调用者栈帧的操作数栈 调整 PC 计数器的值以指向方法调用指令后面的一条指令 简单描述一个方法调用过程中，jvm栈的变化： 方法调用 -&gt; 生成一个栈帧（局部变量表、操作数帧和帧数据区） -&gt; 压栈 -&gt; 返回（出栈，下一个栈顶为下一个运行的方法，因此恢复其相关数据），将结果压入调用者栈帧 jvm栈和本地方法栈大致相同，区别是一个调用java方法，一个是本地JNI方法执行 3. JVM的栈中引用如何和堆中的对象产生关联。通过new创建的对象是在堆内，而使用的地方只是保存这个对象在堆分配空间的引用地址 4. 可以了解一下逃逸分析技术。 参考: JVM的逃逸技术介绍 什么是逃逸 ？ java中每个对象都有一个定的作用域，理论上一个对象在一个代码块中创建，也应该在这个代码块内回收，若过一个对象存活范围更久，超过了这个代码块的范围，这个就表示逃逸 很简单我们可以想到的就是方法的返回，在方法内部创建一个对象，然后返回，这种情况就是逃逸了，被称为方法逃逸 还有一个就是多线程共享变量，一个线程创建静态变量，另一个线程也可以访问，这就是线程逃逸 那么逃逸分析有什么必要呢？ 比如我们知道一个对象不可能发生逃逸，那么完全可以将对象创建放在栈内，方法访问完毕，随栈一起回收掉，这样就可以有效的减少gc回收 多线程环境下，若能确定一个对象不可能逃逸（没有并发问题时）也就没有必要进行同步（加锁） 标量替换：标量即基本类型，平时定义的类称为聚合量，标量替换即表示将聚合量替换为多个标量；当对象不可能逃逸时，且可以标量替换时，就可以这么干，减少对象的创建和回收过程 根据理解简单说以下逃逸分析： 首先明确逃逸指一个对象的生命周期，超出了他的定义范围；通常我们熟知的有方法逃逸（创建一个对象，并返回给其他地方使用）和线程逃逸（一个线程创建对象供其他对象使用） 通过逃逸分析，针对不可能发生逃逸的对象，则可以进行较多的优化 在栈内创建对象，避免堆内的gc 不用同步，因为可确保并发安全 标量替换，减少对象的创建和销毁 5. GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势。a. 算法 标记-清除算法 标记出可回收的， 一次干掉 缺点：大量碎片 复制算法 一分为二，将活着的丢到另一边 缺点：空间少一半，长久活着的对象频繁复制 标记-整理算法 将活着的移动到一端，然后将边界之外的都干掉 分代 根据对象存活特性区分年轻代+年老代 b. CMS目标是最小减少停顿 标记（停顿） 并发标记 再标记（停顿） 并发清除 cms在年轻代选择标记-清除算法，所以会产生碎片 cpu资源敏感（cpu数量 + 3 ） / 4 浮动垃圾：在并发清除阶段产生的垃圾，只能下次进行回收 c. G1 初始标记：停顿 并发标记 最终标记：停顿 筛选回收：停顿 6. 标记清除和标记整理算法的理解以及优缺点。a. 标记-清除首先是标记对象，然后一次将可回收的都干掉 碎片 b. 标记-整理将获得对象，往一边移动，然后干掉边界之外的对象 针对长久存活的对象比较合适 但是很快就跪的就不然，两边复制也是消耗性能的 7. eden survivor区的比例，为什么是这个比例，eden survivor的工作过程。8：1：1，为什么是这个比例？ 大名鼎鼎的二八原则，经验统计，80%的对象是朝生夕死的，所以有这么个比例设置，当然完全可以通过jvm参数来修改 简单说一下对象在 eden, survivor之间流动的过程： 对象创建在eden区（不考虑大对象等其他情况） 当eden区存储空间不够时，触发minorGC(此时明确一点，两个survivor中s0有对象，s1为空) minorGC: 将eden内存活的对象，s0中存活的对象，赋值到s1区 minorGC执行完毕之后，edgen，so区清空，s1区内存放存活的数据 上面考虑的是s1能放下这些存或对象的情况，如果放不下呢（这里jvm有个阈值）？则需要将survivor区的对象塞入old区，old区也塞不下，则进行fullgc 8. JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型。从GC ROOTS 开始，进行可达性分析，可到达的，表示存活 root: 虚拟机栈 方法区静态属性 常量 本地方法栈 9. 强软弱虚引用的区别以及GC对他们执行怎样的操作。强引用：直接通过new对象创建在堆内的对象 软引用：当内存空间不够时，会被ko掉 弱引用：不管内存空间够不够，只要一个对象只有弱引用，就ko掉 虚引用：不决定回收，当只有虚引用时，随时都可能被ko掉 虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中 10. Java是否可以GC直接内存。问题没看明白 11. Java类加载的过程。类加载的过程主要是指将class的二进制流加载到内存，在运行时方法区分配数据结构，在堆内创建对象，然后初始化静态属性等过程，主要区分以下几部 1234567graph LRA(加载)--&gt;B(验证)B--&gt;C(准备)C--&gt;D(解析)D--&gt;E(初始化)E--&gt;F(使用)F--&gt;G(卸载) 加载：指将class文件读取到内存，在方法区创建对应数据结构，在堆内创建class对象，这个对象可以用来操作方法区内的数据结构 连接： 验证：格式验证，元数据验证，字节码验证，符号引用验证 准备：为静态变量准备空间，零值初始化 解析：符号引用转直接引用 初始化：静态变量赋值 使用：开始愉快的玩耍 卸载：从方法区卸载，干掉class对象 12.双亲委派模型的过程以及优势。双亲委托：加载类，优先让父类来尝试加载，只有父类加载失败才会交给自己来加载 全盘负责：类加载器会负责这个类以及它父类的加载 缓存机制：先看是否已经加载过，没有才尝试加载 双亲委托的优点： 避免重复加载，防止出现多份相同的字节码 安全（系统类不会被随意篡改） 13. 常用的JVM调优参数。一般来说，作为业务开发，很少会涉及到这个参数的调整，而且大多数参数都是运维这边来统一设置的一个经验值，对我们而言，也是有必要去了解以下的 gc日志输出 类加载监控（加载类顺序） 堆大小分配 栈大小分配 还有一个常用的就是一些监控命令 jps ：获取进程号 jstat：用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jinfo：实时查看和调整虚拟机运行参数 jmap：生成heap dump jstack：生成java虚拟机当前时刻的线程快照 14. dump文件的分析。15. Java有没有主动触发GC的方式（没有）。通过 System.gc() 可以建议回收内存，但是并不一定会执行 II. 其他问题来自 一个两年Java的面试总结 知识点参考 关于Jvm知识看这一篇就够了 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识点汇总","slug":"知识点汇总","permalink":"https://zbang.online/hexblog/tags/知识点汇总/"},{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"JVM学习之垃圾回收机制","slug":"JVM学习之垃圾回收机制","date":"2018-03-15T12:18:44.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/15/JVM学习之垃圾回收机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/JVM学习之垃圾回收机制/","excerpt":"","text":"JVM学习之垃圾回收机制jvm的垃圾回收算法，除了我们熟悉的引用计数判断对象是否活着之外，其他还有那些有意思的东西呢？ 总是听到的年轻代年老代又是啥？ 传说中的YoungGC(MinorGC) 和 FullGC的时机是什么，又干了些啥？ I. 对象存活判断垃圾回收，回收的都是那些不在使用的对象（也就是没有存活的对象），因此怎么判断对象是否存活，就显得比较重要了 对这个映像最深刻的就是引用计数方式，一个对象被使用了，计数就+1；不用了，技术就-1；当计数为0的时候，就表示对象没人用了，简单粗暴，然而实际的情况中，大都不用这个方式，因为无法解决对象相互循环引用的问题 目前更多的是采用gc root可达性分析，简单来讲就是从一个根节点往下走，走的轨迹上所有的对象，都表示是存活的；也就是说，所有游离在这个之外的对象，都是需要回收的 那么什么是GC ROOT呢 ？ 虚拟机栈内引用的对象 方法区静态属性引用的对象 方法区常量引用的对象 本地方法栈中JNI引用的对象 II. 垃圾回收算法回收，主要指的是将堆和运行时方法区内没有存活的对象干掉；而通常我们所说的垃圾回收，则主要针对的就是堆内的回收 1. 标记-清除算法简单理解：根据可达性扫一遍，有用的对象打个标记；剩下来一次大清理，将没有标记的都ko掉 说明 看书和博文时，常感觉标记，是将需要回收的对象标记出来，但仔细想了下，从实现成本来讲，根据可达性分析对象是否存活，顺带的直接将存活的打个标记，比将所有没存活的上面打上标记要来的简单，而且这也能算是标记出需要回收的对象 缺点 缺点很明显，会出现大量的碎片空间 2. 复制算法将存储空间一分为二，每次回收就是将这一边的存活对象搬移到另一边 缺点 空间少了一半 对于存活时间比较久的对象，需要频繁的来回搬迁 3. 标记-压缩算法（或标记-整理算法）为了节省空间，这个的策略是将所有存活的对象，往某一边界进行复制，等复制完毕之后，将辩解之外的对象都ko掉 4. 分代收集算法分代收集，实际来说就是综合其他算法的优良特性，结合实际应用场景来处理 将存活时间久，占用空间大的对象，放在老年代 其他的对象可以放在年轻代 也就是说： 老年代中，基本上是老而弥坚的对象，更加适合标记-整理算法，移到一边之后，由于经常活着，也就避免了频繁的复制了 新生代中，常是一些朝生夕死的对象，可能用了一次就可以ko，因此可以采用复制算法，标记-清除也是ok的 分代的主要思想就是根据不同的情况，给予不同的策略 III. 简单说下垃圾收集器收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现 1. Serial收集串行收集器，也就是程序跑一会，停下，让我们的回收线程（只有一个）来实现垃圾回收 新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩 2. ParNew收集上面的多线程版本 新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 3. Parallel收集类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例； 新生代复制算法、老年代标记-压缩 4. Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供 5. CMS收集器这个是比较常用的，有必要好好了解下 Concurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标记-清除算法 a 步骤 初始标记：标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记：进行 GC Roots Tracing的过程 重新标记：为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除：并发干掉被回收的问题 初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 b. 优缺点优点：并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6. G1收集器传说中是最先进的收集器。。。。 用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合 a. 步骤 标记阶段：初始标记，会停顿，触发minorgc Root Region Scanning: 程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在minorGC之前完成 并发标记：若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)；并发执行，可能被minorgc打断 再标记：再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)，停顿 复制-整理：并发干掉死亡对象，G1将回收区域的存活对象拷贝到新区域 IV. GC分析这个日志主要针对的是CMS收集器的分析，因为我接触的应用，服务器上就是选择的这个… 看一张神奇的图 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区之间发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无需等Age达到阈值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC V. 小结1. 怎么判断对象是否存活两种方式，引用计数和可达性分析 引用计数: 循环依赖问题，没啥用 可达性：从gc roots出发，可达的都是存活的 2. 几种回收算法对比 算法 简述 缺点 标记-清除 标记对象，统一清楚可回收对象 大量碎片 复制算法 内存一分为二，将存活的移动到另一边 存活久的对象，频繁复制；空间变小 标记-整理 存活对象往一边界拷贝，边界外的都干掉 对于生命周期特别短的不太合适 分代 年轻代 + 年老代，不同代选用不同算法 - 3. CMS和G1阶段对比cms主要区分四个步骤： 标记：停顿 并发标记 重新标记：停顿，重新处理并发过程中新标记的对象 并发清除：并发回收 g1，从结构上而言，划分为一个个独立区域(region)，采用标记-整理算法，避免碎皮空间 4. 简述内存分配和回收基于CMS进行说明 优先分配edge区（不够则触发gc） 大对象，分配在old区 存活时间久的塞入old区 动态时间判断（某个age对象总和大于Survivor一半，则塞入old区） 分配担保（进入old区，但是old区空间不够的策略，决定是否触发gc） VI. 其他参考 jvm系列(三):java GC算法 垃圾收集器 JVM调优工具介绍 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://zbang.online/hexblog/tags/垃圾回收/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"熔断Hystrix使用尝鲜","slug":"熔断Hystrix使用尝鲜","date":"2018-03-15T04:13:15.000Z","updated":"2018-04-02T07:43:56.852Z","comments":true,"path":"2018/03/15/熔断Hystrix使用尝鲜/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/熔断Hystrix使用尝鲜/","excerpt":"","text":"熔断Hystrix使用尝鲜当服务有较多外部依赖时，如果其中某个服务的不可用，导致整个集群会受到影响（比如超时，导致大量的请求被阻塞，从而导致外部请求无法进来），这种情况下采用hystrix就很有用了 出于这个目的，了解了下hystrix框架，下面记录下，框架尝新的历程 I. 原理探究通过官网和相关博文，可以简单的说一下这个工作机制，大致流程如下 首先是请求过来 -&gt; 判断熔断器是否开 -&gt; 服务调用 -&gt; 异常则走fallback，失败计数+1 -&gt; 结束 下面是主流程图 12345678910graph LR A(请求)--&gt;B&#123;熔断器是否已开&#125; B --&gt; | 熔断 | D[fallback逻辑] B --&gt; | 未熔断 | E[线程池/Semphore] E --&gt; F&#123;线程池满/无可用信号量&#125; F --&gt; | yes | D F --&gt; | no | G&#123;创建线程执行/本线程运行&#125; G --&gt; | yes | I(结束) G --&gt; | no | D D --&gt; I(结束) 熔断机制主要提供了两种，一个是基于线程池的隔离方式来做；还有一个则是根据信号量的抢占来做 线程池方式 ： 支持异步，支持超时设置，支持限流 信号量方式 ： 本线程执行，无异步，无超时，支持限流，消耗更小 基本上有上面这个简单的概念之后，开始进入我们的使用测试流程 II. 使用尝鲜1. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt; &lt;version&gt;1.5.12&lt;/version&gt;&lt;/dependency&gt; 2. 简单使用从官方文档来看，支持两种Command方式，一个是基于观察者模式的ObserverCommand, 一个是基本的Command，先用简单的看以下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class HystrixConfigTest extends HystrixCommand&lt;String&gt; &#123; private final String name; public HystrixConfigTest(String name, boolean ans) &#123;// 注意的是同一个任务， super(Setter.withGroupKey(// CommandGroup是每个命令最少配置的必选参数，在不指定ThreadPoolKey的情况下，字面值用于对不同依赖的线程池/信号区分 HystrixCommandGroupKey.Factory.asKey(\"CircuitBreakerTestGroup\"))// 每个CommandKey代表一个依赖抽象,相同的依赖要使用相同的CommandKey名称。依赖隔离的根本就是对相同CommandKey的依赖做隔离. .andCommandKey(HystrixCommandKey.Factory.asKey(\"CircuitBreakerTestKey_\" + ans))// 当对同一业务依赖做隔离时使用CommandGroup做区分,但是对同一依赖的不同远程调用如(一个是redis 一个是http),可以使用HystrixThreadPoolKey做隔离区分 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(\"CircuitBreakerTest_\" + ans)) .andThreadPoolPropertiesDefaults( // 配置线程池 HystrixThreadPoolProperties.Setter() .withCoreSize(12) // 配置线程池里的线程数，设置足够多线程，以防未熔断却打满threadpool ) .andCommandPropertiesDefaults( // 配置熔断器 HystrixCommandProperties.Setter() .withCircuitBreakerEnabled(true) .withCircuitBreakerRequestVolumeThreshold(3) .withCircuitBreakerErrorThresholdPercentage(80)// .withCircuitBreakerForceOpen(true) // 置为true时，所有请求都将被拒绝，直接到fallback// .withCircuitBreakerForceClosed(true) // 置为true时，将忽略错误// .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE) // 信号量隔离 .withExecutionIsolationSemaphoreMaxConcurrentRequests(20) .withExecutionTimeoutEnabled(true) .withExecutionTimeoutInMilliseconds(200) .withCircuitBreakerSleepWindowInMilliseconds(1000) //熔断器打开到关闭的时间窗长度// .withExecutionTimeoutInMilliseconds(5000) ) ); this.name = name; &#125; @Override protected String run() throws Exception &#123; System.out.println(\"running run():\" + name + \" thread: \" + Thread.currentThread().getName()); int num = Integer.valueOf(name); if (num % 2 == 0 &amp;&amp; num &lt; 10) &#123; // 直接返回 return name; &#125; else if (num &lt; 40) &#123; Thread.sleep(300); return \"sleep+\"+ name; &#125; else &#123; // 无限循环模拟超时 return name; &#125; &#125;//// @Override// protected String getFallback() &#123;// Throwable t = this.getExecutionException();// if(t instanceof HystrixRuntimeException) &#123;// System.out.println(Thread.currentThread() + \" --&gt; \" + ((HystrixRuntimeException) t).getFailureType());// &#125; else if (t instanceof HystrixTimeoutException) &#123;// System.out.println(t.getCause());// &#125; else &#123;// t.printStackTrace();// &#125;// System.out.println(Thread.currentThread() + \" --&gt; ----------over------------\");// return \"CircuitBreaker fallback: \" + name;// &#125; public static class UnitTest &#123; @Test public void testSynchronous() throws IOException, InterruptedException &#123; for (int i = 0; i &lt; 50; i++) &#123; if (i == 41) &#123; Thread.sleep(2000); &#125; try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute()); &#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\"); &#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause()); &#125; &#125; System.out.println(\"------开始打印现有线程---------\"); Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces(); for (Thread thread : map.keySet()) &#123; System.out.println(\"---&gt;name--&gt;\" + thread.getName()); &#125; System.out.println(\"thread num: \" + map.size()); System.in.read(); &#125; &#125;&#125; 使用起来还是比较简单的，一般步骤如下： 继承 HsytrixCommand 类 重载构造方法，内部需要指定各种配置 实现run方法，这个里面主要执行熔断监控的方法 写上面的代码比较简单，但是有几个地方不太好处理 配置项的具体含义，又是怎么生效的？ 某些异常不进入熔断逻辑怎么办？ 监控数据如何获取？ 如何模拟各种不同的case（超时？服务异常？熔断已开启？线程池满？无可用信号量？半熔断的重试？） 3. 实测理解根据上面那一段代码的删删改改，貌似理解了以下几个点，不知道对误 a. 配置相关 groupKey 用于区分线程池和信号量，即一个group对应一个 commandKey 很重要，这个是用于区分业务 简单来讲，group类似提供服务的app，command则对应app提供的service，一个app可以有多个service，这里就是将一个app的所有请求都放在一个线程池（or共享一个信号量） 开启熔断机制，指定触发熔断的最小请求数（10s内），指定打开熔断的条件（失败率） 设置熔断策略（线程池or信号量） 设置重试时间（默认熔断开启后5s，放几个请求进去，看服务是否恢复） 设置线程池大小，设置信号量大小，设置队列大小 设置超时时间，设置允许超时设置 b. 使用相关run方法是核心执行服务调用，如果需要某些服务不统计到熔断的失败率（比如因为调用姿势不对导致服务内部的异常抛上来了，但是服务本身是正常的），这个时候，就需要包装下调用逻辑，将不需要的异常包装到 HystrixBadRequestException 类里 如 12345678910111213@Overrideprotected String run() &#123; try &#123; return func.apply(route, parameterDescs); &#125; catch (Exception e) &#123; if (exceptionExcept(e)) &#123; // 如果是不关注的异常case， 不进入熔断逻辑 throw new HystrixBadRequestException(\"unexpected exception!\", e); &#125; else &#123; throw e; &#125; &#125;&#125; c. 如何获取失败的原因当发生失败时，hystrix会把原生的异常包装到 HystrixRuntimeException 这个类里，所以我们可以在调用的地方如下处理 1234567try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute());&#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\");&#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause());&#125; 当定义了fallback逻辑时，异常则不会抛到具体的调用方，所以在 fallback 方法内，则有必要获取对应的异常信息 12// 获取异常信息Throwable t = this.getExecutionException(); 然后下一步就是需要获取对应的异常原因了，通过FailureType来表明失败的根源 1((HystrixRuntimeException) t).getFailureType() d.如何获取统计信息hystrix自己提供了一套监控插件，基本上公司内都会有自己的监控统计信息，因此需要对这个数据进行和自定义，目前还没看到可以如何优雅的处理这些统计信息 4. 小结主要是看了下这个东西可以怎么玩，整个用下来的感觉就是，设计的比较有意思，但是配置参数太多，很多都没有完全摸透 其次就是一些特殊的case（如监控，报警，特殊情况过滤）需要处理时，用起来并不是很顺手，主要问题还是没有理解清楚这个框架的内部工作机制的问题 III. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"hystrix","slug":"hystrix","permalink":"https://zbang.online/hexblog/tags/hystrix/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"JVM学习之内存结构","slug":"JVM学习之内存结构","date":"2018-03-13T08:00:31.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/13/JVM学习之内存结构/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之内存结构/","excerpt":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了","text":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了 I. 内存布局 简单来讲，内存可以划分为三块： 堆 最大的一块区域，创建的对象都在这个上面 方法区 加载类时对应的类信息，常量，静态变量 栈 虚拟机栈和本地方法栈，存储线程相关的信息 II. 分区详解1. 堆区所有线程共享，虚拟机启动时创建，存放对象实例 垃圾回收，主要就是针对堆区而言，一般划分为年轻代，年老代 Young区：Edge + From Survivor + To Sruvivor (8：1：1) Old区 对象开始在Young区，一般内存回收时，会有标记整理，就涉及到两个Survivor区的转移，对象存的时间够久之后，就会将对象塞入Old区 2. 方法区所有线程共享，存储JVM加载的类信息，常量，静态变量，即使编译代码 3. 程序计数器当前线程所执行的字节码的行号指示器，线程私有 字节码解释器，就是来改变这个计数器来选择下一条要执行的命令 4. Java虚拟机栈线程私有，描述java方法执行的内存模型，它的生命周期与线程相同 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表（所占用空间，编译期间分配完成） 编译期可知的各种基本数据类型 对象引用 returnAddress类型（指向了一条字节码指令的地址） 操作栈 动态链接 方法出口 当栈深大于允许的高度时，会抛出StackOverflowError，常见于递归调用异常的情况 当无法申请到足够的空间时，会抛出OutOfMemoryError 5. 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务 III. 其他参考: JVM内存结构 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"内存结构","slug":"内存结构","permalink":"https://zbang.online/hexblog/tags/内存结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JVM学习之Java类的加载机制","slug":"JVM学习之Java类的加载机制","date":"2018-03-13T06:26:40.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/13/JVM学习之Java类的加载机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之Java类的加载机制/","excerpt":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制","text":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制 I. 什么是类的加载简单来讲，类加载就是将class文件中的二进制，读取到内存中，解析其中定义的数据结构，然后在运行时方法区创建对应的数据结构，在堆内创建对应的class对象，而这个class对象，就是封装了对应的数据结构，和相关数据的访问操作方法； 上面的这一段简述中，却包含以下几个点： 1. 加载哪里的class文件？第一步就是要明确的获取到对应的class文件了，jvm支持以下几个case中获取 本地系统 从网络上获取 从数据库(or缓存等第三方存储)中获取 从jar，zip包获取（比如我们依赖的第三方jar，大部分都是这种方式了） 源码编译获取（如我们常用的Groovy脚本，源码方式存在，由GroovyEngine加载时就是源码编译成class文件之后由jvm加载的） 2. 数据结构将class文件加载到内存后，一是在堆内创建class对象，一是在运行时方法区内创建对应的数据结构，具体的数据结构主要应该是类型信息 类的方法代码，变量名，方法名，访问权限，返回值等 类(静态)变量也存储在方法区 这一块有必要在jvm的内存分配中详细的研究下，每个存储区间到底干嘛用的，内部存写啥，先留一个坑位 3. class对象class对象是在堆内创建，反射机制就是主要利用它来实现，通过class对象基本可以完全的操作这个类（包括创建对象，访问成员，调用方法） II. 类加载过程类加载过程主要包括： 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载 用一张图来表示整个过程，且会带上每个过程主要干嘛用的 1. 加载加载作为类加载的第一个过程，主要就是将class文件代表的二进制，加载到内存中 获取class对应的二进制流（可以从任何能获取到的地方读取对应的二进制流） 将二进制流的静态存储结构转换为方法区的运行时数据结构 在堆内创建class对象 上面的三个过程中，最灵活的就是获取二进制的过程，可以按照你的实际场景，从各种地方捞出数据 2. 验证主要是验证class文件是否合法，有没有被篡改等，属于连接的一个过程 文件格式验证：魔数校验，jdk版本校验 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 3. 准备简单来说就是准备好静态变量的存储空间，并设置默认值，属于连接的一个过程 正式为类分配内存 为类变量设置默认的初始化值（不执行实际的赋值语句，这里专指基本类型的零值，对象的null） 对static final 变量赋与代码中实际的值 4. 解析简单来讲就是将常量池内的符号引用替换成实际引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，同样属于连接的一个过程 符号引用：是一组符号来描述目标，可以是任何字面量 直接引用：是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 5. 初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化 准备阶段为类变量赋上了默认值，这里则主要是初始化代码中的赋值，一般而言根据实际定义的顺序进行初始化 a. 初始化步骤 若类没有被加载连接，则优先加载 若父类没有被初始化，则优先初始化父类 执行类的初始化语句（直接赋值，静态代码块） b. 初始化的时机 new创建一个对象时 访问或修改类的静态变量，执行静态方法 反射调用 子类被使用 jvm启动时指定 6. 卸载简单来说就是用完了，收拾线程的过程 程序执行完成 异常 系统层面错误 System.exit() III. 类加载器可以理解为类加载器就是用来加载类的工具，同一个类被不同的类加载器加载之后，也认为他们是不同的 四种类加载器：自定义类加载器，应用类加载器，扩展类加载器，启动类加载器 1. 启动类加载器(BootStrap ClassLoader)源头，根，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的 2. 扩展类加载器（Extension ClassLoader）该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器 3. 应用类加载器（Application ClassLoader）该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 4. 自定义类加载器（User ClassLoader）自己实现的继承ClassLoader的加载器，可以按照自己的意愿，从某些地方加载类 5.类加载机制 全盘负责 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托 先尝试让父类加载器来加载，当父类做不到时，再自己来做 缓存机制 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 6.类的加载类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 加载class到内存，并执行static块 3、通过ClassLoader.loadClass()方法动态加载 只加载class文件到jvm，在class.newInstance()时，执行static块 IV. 双亲委托双亲委托，就是来了一个类加载，先扔给上面去处理，层层上传，只有上面处理不了时，才自己来决定 有啥好处？ 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 说明：双亲委托机制是可以被破坏的 V. 其他参考: java类的加载机制 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://zbang.online/hexblog/tags/ClassLoader/"},{"name":"双亲委托","slug":"双亲委托","permalink":"https://zbang.online/hexblog/tags/双亲委托/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"Java面试要点汇总之线程基础篇二","slug":"Java面试要点汇总之线程基础篇二","date":"2018-03-12T14:07:40.000Z","updated":"2018-04-26T11:59:29.006Z","comments":true,"path":"2018/03/12/Java面试要点汇总之线程基础篇二/","link":"","permalink":"https://zbang.online/hexblog/2018/03/12/Java面试要点汇总之线程基础篇二/","excerpt":"多线程知识点汇总二I. 简介创建线程，线程池创建，Thread的几个常用方法，线程协作，中断，内存模型，线程安全以及锁","text":"多线程知识点汇总二I. 简介创建线程，线程池创建，Thread的几个常用方法，线程协作，中断，内存模型，线程安全以及锁 II. 知识要点1. 创建线程 实现 Runnable 接口 实现 Callable 接口 继承 Thread 类 实现接口 vs 继承 Thread 2. 线程池 通过构造方法创建 借助Executors创建 3. Thread的几个方法 sleep() 休眠一段时间，释放cpu等资源，但不会释放线程持有的锁 yield() 让线程重新回到就绪状态重新抢占cpu，不会释放锁 join() 等待线程执行完毕 setDeamon 守护线程，后台提供服务 当没有用户线程，只有守护线程，程序会终止；但只要有用户线程，就不会结束 4. 线程之间的协作1. 线程通信 wait 结合 notify 可以实现线程通信 CountDownLatch可以实现线程通信（如要求一组线程执行完毕之后再执行另外的任务） CyclicBarrier多个线程到达一个零界点之后，才能继续下去，可重复使用 Semphore信号，控制可执行的线程数量 Exchanger可以实现两个线程之间的数据交互 公用变量配合volatile,锁，也可以实现线程之间的数据共享 2. 线程同步2.1 synchronized 同步代码块，要求同一时刻只能有一个线程访问 2.2 Lock 通过锁的竞争，确保持有锁的线程才可以执行，其他尝试获取锁的线程阻塞 2.3 BlockingQueue 阻塞队列，内部利用了lock，condition来实现进队出队的阻塞场景 5. 结束线程1. 阻塞 wait 方法调用，只有notify方法调用后才会被唤醒，会释放持有的锁 sleep方法调用，阻塞一段时间后进入就绪状态，不会释放锁 IO阻塞 尝试获取其他锁被阻塞 2. 中断使用 interrupt() 方法来中断某个线程 Object.wait(), Thread.join() 和 Thread.sleep() 三种方法在收到中断请求的时候会清除中断状态，并抛出 InterruptedException。 不可中断的阻塞 不能中断 I/O 阻塞和 synchronized 锁阻塞。 Executor 的中断操作 Executor 避免对 Thread 对象的直接操作，但是使用 interrupt() 方法必须持有 Thread 对象。Executor 使用 shutdownNow() 方法来中断所有它里面的所有线程，shutdownNow() 方法会发送 interrupt() 调用给所有线程。 如果只想中断一个线程，那么使用 Executor 的 submit() 而不是 executor() 来启动线程，就可以持有线程的上下文。submit() 将返回一个泛型 Futrue，可以在它之上调用 cancel()，如果将 true 传递给 cancel()，那么它将会发送 interrupt() 调用给特定的线程。 检查中断 通过中断的方法来终止线程，需要线程进入阻塞状态才能终止。如果编写的 run() 方法循环条件为 true，但是该线程不发生阻塞，那么线程就永远无法终止。 interrupt() 方法会设置中断状态，可以通过 interrupted() 方法来检查中断状，从而判断一个线程是否已经被中断。 interrupted() 方法在检查完中断状态之后会清除中断状态，这样做是为了确保一次中断操作只会产生一次影响。 6. 线程状态转变就绪 -&gt; 运行 -&gt; 阻塞 -&gt; 就绪 -&gt; 运行 -&gt; 结束 7. 线程释放锁和不释放锁的场景a. 不释放锁 线程执行同步代码块或同步方法时，程序调用Thread.sleep(Long l)、Thread.yield()方法暂停当前线程的执行 线程执行同步代码块时，其它线程调用该线程suspend()方法将该线程挂起，该线程不会释放锁（同步监视器） 尽量避免使用suspend()和resume()来控制线程 b. 释放锁 当前线程的同步方法、同步代码块执行结束 当前线程的同步方法、同步代码块遇到break、return终止该代码块、该方法的继续执行 当前线程的同步方法、同步代码块中出现了未处理Error和Exception，导致异常结束 当前线程在同步方法、同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁 III. 线程安全1. Java 语言中的线程安全1.1 不可变如果类是不可变的如String, 那么它就是线程安全的 1.2 绝对线程安全任何场景下都是线程安全的，则表示绝对线程安全，注意Vector这种不是绝对安全，如 12345678910111213// Thread1for(int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i);&#125;// Thread2for(int i = 0; i &lt; vector.size(); i++) &#123; vector.get(i);&#125;// 当两个线程都进入循环内部，且i为最后一个时，假设前面线程1的删除元素先执行，那么后面哪个就会跑数组越界的异常 1.3 相对线程安全相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措 1.4 线程兼容线程本身是非安全的，但可以在使用处通过加上一些同步手段来实现线程安全 1.5 线程对立线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。 2. 线程安全的实现方法2.1 互斥同步 synchronized lock 2.2 非阻塞同步 CAS 2.3 无同步方案 threadlocal IV. 锁优化 自旋锁与自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 V. 多线程开发良好的实践 给线程命名。 最小化同步范围。 优先使用 volatile。 尽可能使用更高层次的并发工具而非 wait 和 notify() 来实现线程通信，如 BlockingQueue, Semeaphore。 多用并发容器，少用同步容器，并发容器比同步容器的可扩展性更好。 考虑使用线程池。 最低限度的使用同步和锁，缩小临界区。因此相对于同步方法，同步块会更好。 VI. 其他参考 Java并发 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"},{"name":"多线程","slug":"多线程","permalink":"https://zbang.online/hexblog/tags/多线程/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"Chrome插件之DomToImage实现","slug":"Chrome插件之DomToImage实现","date":"2018-03-12T11:08:09.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/12/Chrome插件之DomToImage实现/","link":"","permalink":"https://zbang.online/hexblog/2018/03/12/Chrome插件之DomToImage实现/","excerpt":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片","text":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片 1. 实现 主要借助开源包: dom-to-image来实现 基本实现原理： 在网页中插入一段html代码，然后绑定上点击事件，核心逻辑如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(\"body\").append('&lt;div id=\"rendFloatDom\" class=\"NYwishes\"&gt;' + '&lt;div id=\"expandInputBtn\" class=\"send\"&gt;&lt;div class=\"send-btn\" style=\"float:right\"&gt;&lt;a onclick=\"document.getElementById(\\'expandInputBtn\\').style.display=\\'none\\';document.getElementById(\\'showRenderImgDiv\\').style.display=\\'block\\';\"&gt;展开&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;' + '&lt;div class=\"send\" id=\"showRenderImgDiv\" style=\"display:none\"&gt;' + '&lt;div class=\"input\"&gt;&lt;input id=\"choose-id\" name=\"content\" type=\"text\" placeholder=\"cid: | id: + 标签\" &gt;&lt;/div&gt;' + '&lt;div class=\"send-btn\" &gt;&lt;a id=\"RenderImgBtn\"&gt;渲染&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;' + '');function doRender() &#123; var chooseVal = document.getElementById('choose-id').value; var node; if(chooseVal.startsWith('cid:')) &#123; chooseVal = chooseVal.substring(4); node = document.getElementsByClassName(chooseVal)[0]; &#125; else &#123; if(chooseVal.startsWith(\"id:\")) &#123; chooseVal = chooseVal.substring(3); &#125; if (\"\" == chooseVal) &#123; return; &#125; node = document.getElementById(chooseVal); &#125; if(node == null || typeof(node) == undefined) &#123; alert(\"没有选中的dom结构\"); return; &#125; domtoimage.toPng(node) .then(function (dataUrl) &#123; var url = dataUrl; window.open().document.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;渲染图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\\'text-align:center\\'&gt;&lt;a download=\"out.png\" href=\"' + url + '\"&gt;&lt;img src=\"' + url + '\" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;) .catch(function (error) &#123;&#125;);&#125;$(\"#choose-id\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; doRender(); &#125;&#125;);$('#RenderImgBtn').click(function() &#123; doRender();&#125;); 2. 使用演示 II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zbang.online/hexblog/tags/Chrome/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}]},{"title":"Java面试要点汇总之泛型篇","slug":"Java面试要点汇总之泛型篇","date":"2018-03-11T13:54:52.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/03/11/Java面试要点汇总之泛型篇/","link":"","permalink":"https://zbang.online/hexblog/2018/03/11/Java面试要点汇总之泛型篇/","excerpt":"Java基础知识要点汇总Basic之泛型泛型在java的容器中被广泛使用，且一般我们的项目中也会较多的使用到泛型，那么什么是泛型呢？泛型又有什么特点，可以怎么用","text":"Java基础知识要点汇总Basic之泛型泛型在java的容器中被广泛使用，且一般我们的项目中也会较多的使用到泛型，那么什么是泛型呢？泛型又有什么特点，可以怎么用 I. 泛型自问自答1. 什么是泛型, 有什么好处a. 泛型平时我们使用容器的过程中，经常会接触到泛型，主要是用了一个占位符来替代实际的类型参数，在实际使用时可以通过具体的类型来替换 简单来说，就是将类型参数化 b. 好处 类型安全 通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上验证类型假设。 消除强制类型转换 潜在的性能提升 2. 泛型如何工作，类型擦除是什么 参考： 泛型的内部原理：类型擦除以及类型擦除带来的问题 java的泛型是通过类型擦除来工作的 123Class a1 = new ArrayList&lt;Integer&gt;().getClass();Class a2 = new ArrayList&lt;String&gt;().getClass();System.out.println(a1 == a2); 上面这段代码输出true，表示在运行过程中任何和类型有关的信息都会被擦除，所以容器类的信息会被擦除为ArrayList类型 a. 什么是类型擦除Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会在编译器在编译的时候去掉。这个过程就称为类型擦除 即： 代码中定义的List和List等类型，在编译后都会编程List b. 实际使用时为啥还是有类型的限制如 List 在调用add()方法时，既然类型参数已经被擦除了，为什么只能接受String类呢？ 因为java编译器是先检查代码中泛型的类型，然后再进行擦除，再进行编译，也就是在编译之前进行了类型检查 b. 为什么泛型是由类型擦除来实现 检查泛型的使用，类型擦除，编译阶段确定正常使用 兼容老的没有泛型的版本 运行时自动类型转换 3. 泛型的限定通配符和非限定通配符a. 限定通配符 &lt;? extends AAA&gt; 实际参数类型必须是AAA的子类 &lt;? siper AAA&gt; 实际参数类型必须是AAA的父类 b. 非限定通配符 &lt;?&gt; 任意类型 &lt;T&gt; 同上 4. 如何使用一个case 1234public &lt;T&gt; T getFunc(T t) &#123; // ...&#125; 5. 利用泛型实现LRU缓存最近被使用（LRU）缓存，LinkedHashMap就实现了这个功能 思路如下： 每个缓存对象都有个访问计数 当需要回收时，将计数最小的那个干掉 借助LinkedHashMap实现 LinkedHashMap自身已经实现了顺序存储，默认情况下是按照元素的添加顺序存储，也可以启用按照访问顺序存储，即最近读取的数据放在最前面，最早读取的数据放在最后面，然后它还有一个判断是否删除最老数据的方法，默认是返回false，即不删除数据，我们使用LinkedHashMap实现LRU缓存的方法就是对LinkedHashMap实现简单的扩展，扩展方式有两种，一种是inheritance，一种是delegation，具体使用什么方式看个人喜好 6. 可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？不能，类型转换失败 7. Array中可以用泛型吗?不能，数组要求确定的类型，用List来替换 8. 如何阻止Java中的类型未检查的警告?加上注解：@SupperWarning(&quot;unchecked&quot;) II. 其他参考 10 道 Java 泛型面试题 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"},{"name":"泛型","slug":"泛型","permalink":"https://zbang.online/hexblog/tags/泛型/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"Java面试要点汇总之线程基础篇","slug":"Java面试要点汇总之线程基础篇一","date":"2018-03-11T08:07:40.000Z","updated":"2018-04-26T11:59:29.006Z","comments":true,"path":"2018/03/11/Java面试要点汇总之线程基础篇一/","link":"","permalink":"https://zbang.online/hexblog/2018/03/11/Java面试要点汇总之线程基础篇一/","excerpt":"I. 基础篇线程相关主要是并发相关的问题汇总，包括一些辅助工具 Synchronized, Lock, CountDownLatch, CyclicBarrier, Semaphore, Exchanger, CAS, AQS, volatile 以及线程、线程池相关知识点，比较重要的就是悲观锁、乐观锁的区别，各自的优劣性等","text":"I. 基础篇线程相关主要是并发相关的问题汇总，包括一些辅助工具 Synchronized, Lock, CountDownLatch, CyclicBarrier, Semaphore, Exchanger, CAS, AQS, volatile 以及线程、线程池相关知识点，比较重要的就是悲观锁、乐观锁的区别，各自的优劣性等 0. 创建线程的方式及实现 创建线程作为并发的第一步，可以参考： Java并发学习之四种线程创建方式的实现与对比 从大的方面来看，一般有两种方式来创建线程 实现 Callable, Runnable 接口 继承 Thread类来实现 实现接口方式 Callable ：一般是有返回结构的方式，配合 FutrueTask 来使用 Runnable ：比较常见的一种case了，无序关注返回 继承Thread 注意到 Thread实际上也是实现Runnable接口，所以当然也是可以直接通过继承Thread来实现 对比 实际上上面两种方式并没有实质的区别，在使用方面来将实现接口的方式，最终的调度需要借助 Thread#start() 来运行线程（当然也可以提交线程池） 此外，从表现形式来看，通过线程池创建线程，通过Timer &amp; TimerTask创建计划线程也算是创建线程的不同手段 1. sleep() 、join（）、yield（）有什么区别 Java并发学习之线程状态及Thread常用方法详解 sleep方法睡眠一段时间，不会释放线程持有的锁 让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会 join方法等待线程执行完毕 yield方法暂停当前正在执行的线程对象，让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会 2. 说说 CountDownLatch 原理 同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待 参考博文： Java并发学习之CountDownLatch实现原理及使用姿势 这个主要用在多个线程协同工作的场景 某个线程执行完毕之后，调用countDown方法实现计数-1 调用CountDownLatch#await方法的线程，为期望计数为0之后才开始执行的线程 当CountDownLatch设置的计数state大于0时，会将调用线程塞入阻塞AQS队列 当计数==0时，所有被阻塞的线程会被唤醒 内部主要是借助AQS来实现线程的阻塞唤醒 3. 说说 CyclicBarrier 原理 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活 参考: Java并发包中CyclicBarrier的工作原理、使用示例 CyclicBarrier默认的构造方法是CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞 线程进入屏障通过CyclicBarrier的await()方法 实现原理： 在CyclicBarrier的内部定义了一个Lock对象， 每当一个线程调用CyclicBarrier的await方法时，将剩余拦截的线程数减1， 然后判断剩余拦截数是否为0， 如果不是，进入Lock对象的条件队列等待。 如果是，执行barrierAction对象的Runnable方法（在创建CyclicBarrier的时候指定的线程）， 然后将锁的条件队列中的所有线程放入锁等待队列中， 这些线程会依次的获取锁、释放锁，接着先从await方法返回，再从CyclicBarrier的await方法中返回 4. 说说 CountDownLatch 与 CyclicBarrier 区别适用场景有所不同： CountDownLatch: 主要用于在某一组线程执行完毕之前，莫个（或某几个）线程一直处于等待状态 CyclicBarrier: 同样用于多线程的同步，但更多的是让多个线程达到某一个临界点之前，都处于等待状态；多个都达到之后，可以各自干各自的事情了 举个例子加以说明： case1: 一个班20个人去坐大巴去春游，要求所有人都到了集合点之后，才能出发 这个case看着更适用于CyclicBarrier，但如果我们换一个角度来，把每个人都集合点看做一个线程，把做大巴出发看做另一个线程，上面的case就转变成了当所有人集合完毕（一组线程执行完毕），大巴开始出发（开始执行另一个线程） case2: 多个侦探玩一个解密游戏，规则是只有三个侦探报名之后，才能开始他们各自的解密环节 这种场景很明显用CyclicBarrier就比较清晰了，每个侦探的解密看成一个线程，每次报名就调用CyclicBarrier#await，那么屏障就是要三个人报名完毕，才能各自进行自己的解密环节 那么用CountDownLatch可以么？当然也可以在报名之后计数-1，然后调用await进行等待，一样可以实现合格逻辑 简单来说，一个是通过-1来实现，一个是通过+1 是否可重用 CountDownLatch 是无法重用的，减到0就完了 CyclicBarrier可以重用，即一轮条件达成之后；可以接着来下一轮 5. 说说 Semaphore 原理 Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可 参考: Java并发包中Semaphore的工作原理、源码分析及使用示例 主要通过AQS来实现线程管理，内部state值表示允许访问的线程数 state == 0 时，其他线程将无法获取许可 state &gt; 0 则线程可正常执行 在创建Semaphore对象的时候还可以指定它的公平性。一般常用非公平的信号量，非公平信号量是指在获取许可时先尝试获取许可，而不必关心是否已有需要获取许可的线程位于等待队列中，如果获取失败，才会入列。而公平的信号量在获取许可时首先要查看等待队列中是否已有线程，如果有则入列。 使用场景 主要用在资源受限的情况，比如办公司只有三个打印机，每个人的电脑都可以连接答应机打印东西，那么就可以用Semaphore来做了，打印机被占用(acquire)之后，计数-1，当计数到0的时候就不能用了，而当打印机使用完毕之后释放掉(release)那么计数可以+1，其他的人又可以来使用了 6. 说说 Exchanger 原理 Exchanger（交换者）是一个用于线程间协作的工具类。 并发工具类（四）两个线程进行数据交换的Exchanger Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。 这两个线程通过exchange方法交换数据， 如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange 当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方 说明 只能在两个线程之间进行数据交换 在Exchanger中，如果一个线程已经到达了exchanger节点时，对于它的伙伴节点的情况有三种： 如果它的伙伴节点在该线程到达之前已经调用了exchanger方法，则它会唤醒它的伙伴然后进行数据交换，得到各自数据返回。 如果它的伙伴节点还没有到达交换点，则该线程将会被挂起，等待它的伙伴节点到达被唤醒，完成数据交换。 如果当前线程被中断了则抛出异常，或者等待超时了，则抛出超时异常。 （待深入） 7. ThreadLocal 原理分析 线程本地变量，每个线程保存变量的副本，对副本的改动，对其他的线程而言是透明的（即隔离的） Java并发学习之ThreadLocal使用及原理介绍 内部有一个HashMap，其中key为当前线程，value为存入的线程本地变量，从而实现多线程之间的数据隔离 这个比较适合的是使用链路比较长的应用场景，如web服务的用户身份信息，就可以保存在 ThreadLocal 中，在用户发起请求的完整链路中，任何地方都可以通过它获取用户信息，优点是 不用将用户信息层层透传 不会出现数据串掉的问题 在使用ThreadLocal的时候，需要注意的是用完之后主动销毁存储的变量，避免线程池中线程复用，导致数据脏掉 8. 讲讲线程池的实现原理 Java并发学习之线程池ThreadPoolExecutor的小结 线程池主要就是为了实现线程复用，减少频繁的线程创建、销毁带来的性能开销 在说明实现原理之前有必要了解下其主要的几个参数： 核心线程数：没有任务时，线程池中允许存在的最小空闲线程数 最大工作线程数：线程池中允许出现的最大工作线程数量 最大存活时间：空闲线程最多存货的时间 任务队列：工作线程数超过核心线程数时，新来的任务就放入这个队列中 线程创建工厂：创建线程的工厂类，可以在里面设置工作线程名，设置守护线程，设置异常处理方式等 拒绝策略：当线程池中工作线程达到上线，队列已满时，新任务的处理策略 从上面的几个参数也可以大致的推出线程池的工作原理： 提交任务，若核心线程数未达标，则直接创建线程执行 若核心线程已满，则塞入任务队列 若任务队列满，则创建新线程执行任务 若线程数达到上限，则根据拒绝策略来执行 9. 线程池的几种方式 直接通过构造方法创建 借助 Executors来创建jdk定义的几种线程池: 固定大小线程池，缓存线程池，调度线程池，单线程池等 10. 线程的生命周期 创建线程 -&gt; 就绪状态 -&gt; 运行状态 运行状态 -&gt; 阻塞状态 -&gt; 就绪状态 -&gt; 运行状态 运行状态 -&gt; 结束状态 对应的图如下 11. AQS的原理 AbstractQueuedSynchronizer抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch Java并发之AQS详解 维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列） 一般来讲，通过state的计数来表示是否为锁定状态，如ReentrantLock中当state为0，表示没有线程持有锁，这个时候如果有人来获取锁则会成功，然后可以做自己的事情；当持有锁之后，其他线程再尝试获取锁，就会失败，塞入队列中，并阻塞 II. 线程安全问题1. volatile 实现原理 Java并发学习之Volatile及内存模型探究 主要作用 变量修改对多线程可见性 防止指令重排 实现原理每个线程有一个自己的缓存空间，持有保存在内存中的变量的一个副本，所以某个线程修改自己变量时，其他线程持有的副本不一定会同步修改，因此就容易出现不一致的问题 所以这个关键词要干的一件事就是当发生修改时，保证其他线程持有的副本也会同步更新 指令重排可能带来什么问题？一个明显的case 线程A进行初始化 12Object con = new XXX();int init = true; 线程B执行 123if(init) &#123; con.xxx();&#125; 如果指令重排，导致init先赋值完成，而con后赋值，那么线程B的执行就会抛出一个npe 2. synchronize 实现原理 同步关键字 Java并发学习之synchronized使用小结 可以用来修饰方法，代码块，主要是强制多线程在访问这些方法or代码块时，串行操作（即同一时刻，只能有一个线程执行） 底层实现主要也是依赖锁来确保同步，简单来说就是一个线程访问synchronized修饰的方法or代码块之后，就获取到了锁，在执行完毕之前，其他线程无法获取到这个锁，因此会阻塞 jdk为了提高性能，设计了锁的进阶 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁 简单来讲，单线程时，使用偏向锁，如果这个时候，又来了一个线程访问这个代码块，那么就要升级为轻量锁，如果这个线程在访问代码块同时，又来了一个线程来访问这个代码块，那么就要升级为重量锁了 3. lock, condition, ReentrantLock 的说明 锁，可重入锁，条件 参考：Java并发学习之ReentrantLock的工作原理及使用姿势 lock（锁），简单来讲，当某个线程持有锁之后，在释放锁之前，其他的人尝试获取锁会被阻塞 ReentrantLock可重入锁。jdk中ReentrantLock是唯一实现了Lock接口的类，可重入的意思是一个线程拥有锁之后，可以再次获取锁 Condition 可以由ReentrantLock进行生成，通常与Lock配合使用，用于多个线程之间的协同（如一个线程A的执行，依赖线程B执行的结果，就可以通过Condition来做处理） 4. synchronized 与 lock 的区别 参考 https://www.cnblogs.com/iyyy/p/7993788.html 一个是关键字，用来修饰代码块或者方法；而lock则是锁对象 synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁 synchronized会自动释放锁，lock则需要主动释放锁 synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题 简单来讲就是lock使用起来更加灵活，配置或扩展更加方便，而synchronized则偏向于简单的同步场景 5. CAS 乐观锁 compareAndSet比较并设置 CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 简单来讲，就是在实际更新之前，判断内存值是否发生过修改（即与我们预期的待修改值A是否相同），若过没有则修改它，否则不处理 上面这个判断有漏洞，因为cas是乐观锁，即在比较并修改的过程中，其他线程也可以修改这个值，所以直接通过判断内存值V是否等于预期值A，可能导致ABA问题 6. 乐观锁的业务场景及实现方式 独占锁：是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 乐观锁：每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止 7. ABA 问题 Java CAS 和ABA问题 首先得知道什么是ABA问题了，举例说明 线程1准备用CAS将变量的值由A替换为B，在此之前，线程2将变量的值由A替换为C，又由C替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题 一般来讲，会借助一个递增的版本来避免出现ABA问题，比如每次修改的时候，版本值都+1，那么在cas的时候，除了判断内存值和预期是否相同之外，还判断一下版本是否相同 jdk中提供AtomicStampedReference来提供基于时间戳的版本方案，避免ABA问题 III. 问题补充1.Java实现多线程有哪几种方式。上面已有，简单来讲就是实现Runnable/Callable接口或者集成Thread类 2.Callable和Future的了解。实现Callable接口主要是针对有返回结果的场景，线程运行后返回一个Future包装的对象，通过这个包装对象获取线程的返回 Futrure#get 获取返回对象，如果尚没有返回则会阻塞 Future#cancel 取消任务(当然如果线程不允许中断，则并不会有用) 通常他们是配合起来一起使用，特别是当提交的任务耗时较长时，可以先执行后续不依赖返回的代码，然后在需要使用返回结果的地方调用Futrue#get来获取结果，提高性能 3.线程池的参数有哪些，在线程池创建一个线程的过程。参数说明件上文 线程池中，提交一个任务，首先会看核心工作线程是否已满，若没有，则根据线程创建工厂来创建一个线程来执行任务；如果核心工作线程满了，则塞入任务队列，等待工作线程空闲后从任务队列中后去任务来执行；当任务队列已满，则判断工作线程数是否达到上限，没有时创建一个工作线程来执行任务；否则采用拒绝策略的方案执行 4.volitile关键字的作用，原理。见上文，主要两个作用 变量的修改对气态线程可见 禁止指令重排 5.synchronized关键字的用法，优缺点。修饰方法，静态方法，代码块，静态代码块，同一个线程允许多次访问被修饰的代码，在访问期间，其他线程都无法访问（会被阻塞）；访问完毕之后，自动释放锁，其他线程可以尝试竞争获取锁 优点：使用简单 缺点：不够灵活 6.Lock接口有哪些实现类，使用场景是什么。ReentrantLock 可重入锁 对灵活性要求更高的，有更多特定需求的场景，或者锁竞争比较激烈的场景，使用lock更加合适 7.可重入锁的用处及实现原理，CopyOnWrite的过程，读写锁，分段锁（ConcurrentHashMap中的segment）。ReentrantLock 可重入锁借助AQS实现，当线程持有锁之后，其他线程在尝试获取锁时，会阻塞 用于多线程之间的协同工作，比 synchronized 更加灵活，阻塞队列中就用到了这个 CopyOnWrite 过程这个比较合适的case就是CopyOnWriteArrayList了，读不加锁，写时加锁 在修改链表时，加锁，然后拷贝一份原来的数据，在拷贝上进行修改，修改完毕之后，替换原来的数据 读过程不加锁，因此读操作时，获取的是读的那一时刻获取到的数据，在这个时间点之后发生了修改，读的依然是原来的数据 锁分段比如jdk1.7的ConcurrentHashMap就是采用的锁分段机制，将一个大数组分为一个个的Segment，每个Segment都有自己独立的锁，因此对不同的Segment进行操作，不会引起锁的竞争 读数据是不加锁： 每个节点HashEntry除了value不是final的，其它值都是final的 即只能在链表头添加数据 在put时，在链表头插入；在remove时需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点 为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁 8.悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决。悲观锁：synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁 乐观锁：每次不加锁，假设没有冲突去完成某项操作，如果因为冲突失败就重试，直到成功为止 CAS就是采用的乐观锁机制，比较内存值和预期值是否相等，是则替换；会导致ABA问题 通常ABA问题，需要借助一个递增的版本来辅助判断，详情见上文 9.ABC三个线程如何保证顺序执行。通过Thread#join方法可以保证顺序执行，最简单的方式就是a.join之后，在启动b线程，待b.join之后在启动c线程，这样就强制顺序性了 上面的缺点也明显，并发强制编程了串行，这样的话采用并发的优势就么有了 通常三个线程的协同工作，大多是内部有相互依赖，用lock结合condition来实现同步是更优雅的方式，每个线程维持一个状态，根据状态的值借助condition的wait和notify方法来控制阻塞执行就会好一点了 10.线程的状态都有哪些。详情参考上文 启动 就绪 运行 阻塞 结束 11.sleep和wait的区别。 sleep睡眠一段时间，会释放cpu等资源，但是不会释放持有的锁，过一段时间后继续执行 wait会释放cpu资源，锁也释放，等待notify方法唤醒，必须放在 synchronized 代码块内 12.notify和notifyall的区别。 notify只会唤醒一个被阻塞线程 notifyall会唤醒所有被阻塞的线程 说明：对notifyall而言最终执行的线程也有可能只有一个，比如被阻塞的线程都在抢在同一把锁，最终也只会有一个线程成功获取并执行，其他的再次进入阻塞 13.ThreadLocal的了解，实现原理。线程本地变量，可以用来保存线程内的共享变量，方便在该线程执行的上下文中获取这些基本信息 内部是维持一个HashMap， key为当前线程对象，value为线程变量，因此实现了线程之间数据的隔离 需要注意的一个点就是使用完毕之后，不要忘记主动回收变量 IV. 其他知识要点来自: Java面试通关要点汇总集 一个两年Java的面试总结 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"},{"name":"多线程","slug":"多线程","permalink":"https://zbang.online/hexblog/tags/多线程/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"Java面试要点汇总之容器基础篇","slug":"Java面试要点汇总之容器基础篇","date":"2018-03-09T08:09:26.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/03/09/Java面试要点汇总之容器基础篇/","link":"","permalink":"https://zbang.online/hexblog/2018/03/09/Java面试要点汇总之容器基础篇/","excerpt":"I. 容器基础篇汇集容器相关问题，并根据自己的理解，给出相关答案","text":"I. 容器基础篇汇集容器相关问题，并根据自己的理解，给出相关答案 1. List, Set, Map区别这三个基本上是java中经常会用到的容器了，从命名上基本上也可以判断出他们的区别了 List: 列表 有序 允许包含重复的成员 可以塞null Set：集合 无序 无重复的成员 可以塞null Map：表 kv数据结构 key不允许重复 HashMap的key可以为null； 但HashTable, ConcurrentHashMap的kv都不允许为null 2. JDK队列划分Queue 队列，根据不同的使用姿势，一般可以划分为： 非阻塞队列 ArrayDeque 数组双向队列 PrioritiQueue 优先级队列 ConcurrentLinkedQueue 基于链表的并发安全队列 阻塞队列 DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口） ArrayBlockingQueue, （基于数组的并发阻塞队列） LinkedBlockingQueue, （基于链表的FIFO阻塞队列） LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列） PriorityBlockingQueue, （带优先级的无界阻塞队列） SynchronousQueue （并发同步阻塞队列） 根据线程安全可以划分 线程安全队列 非线程安全队列 根据是否有界可以划分 有界队列 无界队列 3. Arraylist 与 LinkedList 区别 可以参考之前写的博文 Java容器篇小结之List自问自答 JDK容器学习之List: CopyOnWriteArrayList,ArrayList,LinkedList对比 两个都是链表的具体实现，但是底层数据结构不同，因此导致两者的应用场景有较多的区别 ArrayList 底层数据结构为数组 随机访问效率时间复杂度 O(1) 末尾插入or删除元素性能较高 中间插入或删除，会导致数组的拷贝 此外说一句： 初始数组长度为10 扩容逻辑为：增加一半，或者增加到恰好可以装下所有数据 LinkedList 底层数据结构为链表 插入或删除性能较高，不会出现数据拷贝 随机访问需要遍历链表 直接用之前博文的对比表格，更加清晰 说明 ArrayList LinkedList 存储结构 随机访问 根据数组索引定位，耗时 O(1) 从链表头or链表尾遍历，耗时O(n) 新增数据 列表个数超过数组容量，则数组扩容，出现数组拷贝 定位到插入位置，新增一个节点插入链表中 是否扩容逻辑 插入超过上限扩容 1. 增加原来空间大小的一半 2. 若仍塞不下，则扩充到填满 无扩容逻辑 应用场景 1. 适合随机访问 2. 随机插入or删除导致数组拷贝 3. 末尾插入，较友好 1. 随机访问性能差，适合遍历场景 2. 随机插入or删除，先遍历获取位置，然后插入or删除 3. 链表头尾插入友好 4. ArrayList 与 Vector 区别最主要的区别就是是否并发安全了 ArrayList: 非并发安全 Vector: 所有方法加锁，强制并发访问为串行，从而实现并发安全 5. Vector 与 CopyOnWriteArrayList 区别两者都是并发安全的链表，只是底层实现机制不同；目前基本不推荐在并发环境中使用Vector Vector 通过在访问方法加Synchronized关键字，来强制同步，从而实现并发安全 导致读写链表都需要竞争，因此效率较低 CopyOnWrinteArrayList 读不加锁 写加锁，才用拷贝覆盖的方式实现，修拷贝一份原来的列表，然后在拷贝上面进行修改，完毕之后覆盖原来的列表即可 遍历和读取都是基于访问时刻列表中的数组进行的；在执行过程中，链表发生修改不会影响遍历和读取的结果（即此时访问的依然是原数组内容） 6. HashMap , Hashtable 和 ConcurrentHashMap的区别 HashMap 线程不安全 HashTable 线程安全，访问方法加 Synchronized 强制同步实现 ConcurrentHashMap 线程安全，基于锁分段机制实现 详情可以参考前一篇 7. HashSet 和 HashMap 区别这就是Set和Map的区别了，一个是集合，一个是KV数据结构 8. HashMap 的工作原理及代码实现底层数据结构为 数组 + 链表 （jdk8+ 链表可以转为红黑树，避免hashMap退化为链表的极端场景） 数组长度为 2的n次幂 通过新增一个元素来看工作原理： 塞入一个数据，计算hash值，对数组长度取模映射到数组中的位置 若该位置为空，则直接塞入进去即可 若该位置非空，则判断两者的key是否相同，以判断是覆盖还是出现hash碰撞 覆盖场景直接替换value值； hash碰撞时，以这个元素为链表头，遍历所有链表元素，如果与所有的元素都不同，则将这个元素挂在链表尾 默认初始化数组长度为16，因此会有扩容逻辑 当触发扩容时，通常扩充为原来的一半（如果还是塞不下，则扩充到恰好可以装下的长度，这个长度依然要满足2的n次幂） 扩容后需要数据迁移（依然是按照hash值与新的长度进行求余来判定新的位置） 9. ConcurrentHashMap 的工作原理及代码实现比较复杂，1.7版本和1.8版本的实现有些区别，以传统的锁分段简单说明： ConcurrentHashMap: 读无锁保证线程安全的原因： 12345每个节点HashEntry除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。remove操作要注意一个问题：如果某个读操作在删除时已经定位到了旧的链表上，那么此操作仍然将能读到数据，只不过读取到的是旧数据而已，这在多线程里面是没有问题的。 锁分段机制： 123采用Segment + HashEntry的方式进行实现每个Segment拥有独立的锁，因此segment的操作不会阻塞其他segment的修改 说明 jdk1.7 和 jdk1.8中实现有很大的不同，后续可以详解一下 一篇参考：谈谈ConcurrentHashMap1.7和1.8的不同实现 10. 有序的Map某写场景下我们需要排序的Map，通常选择 LinkedHashMap LinkedHashMap额外持有一个双向链表，维护插入节点的顺序 TreeMapTreeMap数据结构是红黑树，左孩子 &lt; 根 &lt; 右孩子 所以按照树的中序遍历方式进行扫描，即先获取树的左孩子，然后是根，最后是右孩子 支持自定义顺序 场景选择 有自己的排序需求场景的，可以使用TreeMap 根据塞入Map的先后顺序进行排序的，可以使用 LinkedHashMap I. 其他知识要点 Java面试通关要点汇总集 一个两年Java的面试总结 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"},{"name":"容器","slug":"容器","permalink":"https://zbang.online/hexblog/tags/容器/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"Java面试要点汇总之Basic基础篇","slug":"Java面试要点汇总之Basic基础篇","date":"2018-03-08T15:04:10.000Z","updated":"2018-04-26T11:59:29.005Z","comments":true,"path":"2018/03/08/Java面试要点汇总之Basic基础篇/","link":"","permalink":"https://zbang.online/hexblog/2018/03/08/Java面试要点汇总之Basic基础篇/","excerpt":"I. 基础篇java基础知识汇总小结","text":"I. 基础篇java基础知识汇总小结 1. 面向对象的特征 这个主要就是：面向对象的三个基本特征和五项基本原则 三个基本特征 封装 简单来讲就是将所有的东西都封装成了类class，在java环境中，一切事务皆为对象，将事务的属性和属性的操作都放在类中，通过类来访问和操作这些属性 继承 即让某个对象可以拥有另一个对象属性和方法的机制； java中是单继承方式，即只能继承一个父类，但是可以实现多个接口；继承的类将拥有并可以直接访问父类的所有非prive属性和方法 多态 是指一个类实例的相同方法在不同情形有不同的表现； 简单来说，就是代码中通过 AClass#xxxMethod 方式调用一个方法，但具体的实现中，可以是AClass的子类BClass#xxxMethod 或者 CClass#xxxMethod被执行 五项基本原则 直接要说出五个原则，还不太容易，这些原则在编码多了之后，自然而然的会融入自己的编程习惯中 单一职责原则 一个类只干一件事情 开放封闭原则 扩展性方面应该是开放的而在更改性方面应该是封闭 替换原则 子类应当可以替换父类并出现在父类能够出现的任何地方 依赖原则 具体依赖抽象，上层依赖下层；如父类要依赖子类中的一个方法时，可以在父类中定义一个抽象方法，然后让子类来实现，避免直接依赖子类方式 接口分离原则 模块与模块之间的依赖通过接口方式，而不应该用具体的实现类，减少耦合 2. final, finally, finalize 的区别一句话概括如下： final 通常用来修饰class, 类成员属性，方法，表示不可继承，or不可修改； finally 与 try {} catch() 联合使用，finally中的代码总是会执行 finalize 用于垃圾回收，类似c++中的析构函数 接下来分别进行细说 a.final 修饰类，表示这个类不能被继承，如 java.lang.String 内存分配：保存在方法区。 修饰属性，表示这个属性为常量，不允许被修改了 直接赋值，构造函数赋值，或是初始化块赋值 内存分配：常量池 修饰方法，这个方法不能被子类的给覆盖掉 内存分配：保存在方法区，并且可以被函数代码直接替换，而不用等到执行时再决定具体是那个函数（即没有多态，因为不允许被覆盖） b.finally通常配和 try, catch 捕获异常来结合使用，表示finally中的代码块必然会被执行 一个需要注意的是，尽量不要在finally中用return语句返回，因为会吃掉 catch 代码块中上抛的异常 c.finalize finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于： ① 清理本地对象(通过JNI创建的对象)； ② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法 说明 Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行 finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的 finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为) 3. int 和 Integer 有什么区别简单来讲，这个就是基本类型和封装类型之前的区别了 基本类型：存数值，int默认为0，不能放在容器内 封装类型：存引用，Integer默认为null，可以放在容器类 这里面需要注意的一点是整型的缓存机制 123456789101112131415@Testpublic void testI() &#123; Integer i1 = 10; Integer i2 = 10; System.out.println(i1 == i2); i1 = 1000; i2 = 1000; System.out.println(i1 == i2); i1 = 10; System.out.println(i1 == 10);&#125; 输出结果 123truefalsetrue 上面的原因就涉及到了整型缓存机制，主要是 Integer#valueOf 将基本类型提升为包装类型的逻辑上了 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 这个缓存范围默认为 : [-128, 127] 对此，需要注意的对象判断是否相同尽量用 equals 方法 4. 重载和重写的区别重写 覆盖父类中的方法，签名和父类的一致 作用域可以提升，如父类的为protected,子类的可以设置为public 重载 方法名一致，参数不同（参数类型，参数个数）表示重载 仅返回结果相同，方法名和参数相同时，是不允许的 仅作用域不同，其他相同也是不允许的 说明： 重写是子类对父类的一种行为；而重载则不然，可以是本类中也可以是父类子类中定义相同方法名，根据不同参数来提供不同功能的机制，主要是简化调用方的使用成本 5. 抽象类和接口有什么区别类和接口的最主要区别： 类只能单继承，但可以实现多个接口 接口 接口中定义的方法都是public, 属性都是 public static final 一般接口中没有实现，（jdk1.8+之后提供了default关键字，允许接口中有方法实现） 无构造方法 抽象类 abstract 修饰 Class 类中用 abstract修饰的方法可以没有实现 抽象类中可以没有abstract方法 抽象类其他行为和普通类一致 6. 说说反射的用途及实现反射：在运行时，获取类的基本信息 之前写过一个博文: JDK学习之反射的使用姿势一览 用途： 1234在运行时构造任意一个类的对象。在运行时判断任意一个对象所属的类。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法 7. 说说自定义注解的场景及实现通过 @interface来创建一个自定义注解，一般而言自定义注解上，至少会包含下面两个注解 12@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE) 注解用得场景比较多了，比如spring容器中就存在大量的注解，通过注解可以给类or方法增强一些方法或属性或标识，如spring中的带有@Component注解的类，表示被spring容器托管的bean对象，可以直接通过 @Autowired 或 @Resource 注解来依赖注入其他的对象中进行使用 通过反射可以获取类（or其他）上定义的注解，然后执行相应的业务 8. HTTP 请求的 GET 与 POST 方式的区别 参考: get&amp;post区别 GET &amp; POST 为最常见的http的两种请求方式，一般来讲get作为请求数据用得较多，post则更多作为提交表单 GET请求 get请求参数，会拼接在url参数上 请求可以缓存，放在收藏夹内 url长度根据浏览器及服务器的不同而有不同限制 不应该在url参数中加上敏感数据 POST请求 post请求参数不会在url参数上，通过浏览器的debug模式可以在Request Payload中看到参数 post参数尽量也不要包含敏感数据 请求不能缓存，即刷新后，参数会丢掉 不能保存收藏夹 长度根据不同服务器有不同的限制 （如tomcat默认post表单大小由 &lt;Connector maxPostSize=&quot;512000&quot;/&gt;来配置，单位为B） 9. session 与 cookie 区别 参考: session和cookie介绍 HTTP是一种无状态的协议，为了分辨链接是谁发起的，就需要我们自己去解决这个问题。不然有些情况下即使是同一个网站我们每打开一个页面也都要登录一下。而Session和Cookie就是为解决这个问题而提出来的两个机制。 Cookie Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器，是一种在客户端保持状态的方案 Session Session是存在服务器的一种用来存放用户数据的类Hash结构。 区别 session 在服务器端，cookie 在客户端（浏览器） session 在服务器存储的位置可以由自己来选择，一般不选择内存（分布式不通用） 通常用session来进行用户身份验证 cookie中保存一个SessionID，发起请求时，带上cookie；此时服务器解析cookie根据sessionId获取对应的session，以此可以做一些验证 （sessionId当然也可以不放在cookie，方案完全可以自己定义） 因此，维持一个会话的核心就是客户端的唯一标识，即 session id 10. session 分布式处理简单来说，就是后端服务部署在多台机器上时，session如何共享的问题，常见的手段 session存在服务器上 通过nginx路由代理，确保每个用户路由到同一台机器 这样不需要session同步 缺点：单点故障问题，通用性小 通过某种机制实现服务器的同步 如采用消息机制(Kafka、RabbitMQ、RocketMQ) 来实现session的同步 缺点：实现起来繁琐，如果某台机器同步失败，对业务有影响 session存在其他地方 存DB，存缓存(redis, memecache) 在获取时，统一从这里查即可 这个也是最常见的方式了 放在客户端 在cookie里面保存用户信息，用户请求时，都带上这个 缺点：安全隐患，一般都不这么玩 11. JDBC 流程1.向DriverManager类注册驱动数据库驱动程序， 1Class.forName( \"com.somejdbcvendor.TheirJdbcDriver\" ); 2.调用DriverManager.getConnection方法， 通过JDBC URL，用户名，密码取得数据库连接的Connection对象。 1234Connection conn = DriverManager.getConnection( \"jdbc:somejdbcvendor:other data needed by some jdbc vendor\", //URL \"myLogin\", // 用户名 \"myPassword\" ); // 密码 3.获取Connection后，便可以通过createStatement创建Statement用以执行SQL语句。下面是一个插入（INSERT）的例子： 12Statement stmt = conn.createStatement();stmt.executeUpdate( \"INSERT INTO MyTable( name ) VALUES ( 'my name' ) \" ); 4.有时候会得到查询结果，比如select，得到查询结果，查询（SELECT）的结果存放于结果集（ResultSet）中。 1ResultSet rs = stmt.executeQuery( \"SELECT * FROM MyTable\" ); 5.关闭数据库语句，关闭数据库连接。 12rs.close();stmt.close(); 题外话，个人感觉基本上都不怎么会直接使用jdbc来操作数据库了，通常都会借助一些框架mybaits或者hibernate来做，所以这块的流程多半是不怎么用的，而实际上就我个人而言，问这种问题，真挺没意思的。 12. MVC 设计思想 13. equals 与 == 的区别判断对象是否相等，通常来讲对象判断是否相等多用 equals() 方法，基本对象判断是否相等用 == 但是判断对象是否为同一个对象，则只能用 == 即： equals : 判断两个对象的值是否相同 == : 判断两个对象的内存地址是否相同，即是否为同一个对象 II. 基础篇-21. HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。 参考 JDK容器学习之HashMap (二) ： 读写逻辑详解 扩容逻辑 当添加元素后，数组的长度超过阈值，实现扩容 初始容量为16，阈值为12 计算新的数组长度，并初始化 新的长度为原来的长度 * 2 新的阈值为：新的长度 * loadFactor; loadFactory 一般为 0.75 将原来的数据迁移到新的数组 (hash值与新的长度进行计算确定是否需要后移） 原位置不变 原位置 + 原数组长度 HashMap说明 hashmap 的底层结构为数组，长度一般为2的n次方 计算hash值与数组长度求余，得到element在数组中的位置 如果位置已经被占了，则将element挂在以这个位置上元素为链表头的链未 jdk8中当链表长度超过阈值时，会将链表转为红黑树 从上面的说明中，可以知道为什么将数组长度设置为2的n次方，因为2的n次幂与hash值进行求余，可以直接用位运算来做，提高性能 1hash &amp; (2^n - 1) 2. HashMap，HashTable，ConcurrentHashMap的区别。 详细可以参考我之前的博文: JDK容器学习之Map: HashMap,TreeMap,LinkedHashMap对比 Java容器篇小结之Map自问自答 简单来讲 HashMap与另外两个的主要区别就是非线程安全 HashTable 的线程安全是通过 synchronized 来保障，对所有方法强制同步 ConcurrentHashMap 在采用了锁分段机制实现线程安全 每个segment都有独立锁，因此对这个segment的操作，不会导致其他的分段的写阻塞 所有读操作无锁 3. 极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的。ConcurrentHashMap 性能更优，因为HashTable采用synchronized强制所有方法同步访问，因此并发下的读写都会强制变成串行操作，而 ConcurrentHashMap 采用锁分段机制，且读无锁，因此读写性能更高 ConcurrentHashMap: 读无锁保证线程安全的原因： 12345每个节点HashEntry除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。remove操作要注意一个问题：如果某个读操作在删除时已经定位到了旧的链表上，那么此操作仍然将能读到数据，只不过读取到的是旧数据而已，这在多线程里面是没有问题的。 锁分段机制： 123采用Segment + HashEntry的方式进行实现每个Segment拥有独立的锁，因此segment的操作不会阻塞其他segment的修改 说明 jdk1.7 和 jdk1.8中实现有很大的不同，后续可以详解一下 一篇参考：谈谈ConcurrentHashMap1.7和1.8的不同实现 4. HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么。并发修改时，抛异常： 即在遍历map的同时，另一个线程修改会导致遍历的线程抛异常 无法及时获取修改值： 侥幸修改内部元素值，而没有引发异常，但也会出现修改后的值对其他线程不是立即可见的问题 5. java中四种修饰符的限制范围。四种修饰符： private : 仅内部可用 默认 : 内部和同一个包路径下可访问 protected: 内部，子类可访问，同一包路径 public: 所有都可以访问 6. Object类中的方法。Object类是java中所有类的父类，是一切事务的源头，类似盘古开天辟地的那个蛋，没有它就没有整个java世界 内部方法： 1. getClass()获取类基本信息，常用于反射里面 2. hashCode() 该方法用来返回其所在对象的物理地址（哈希码值），常会和equals方法同时重写，确保相等的两个对象拥有相等的.hashCode 3. equals() 用于判断两个对象是否”相等” 如果没有覆盖这个方法时，判断两个对象是否相等就是判断这两个对象是否指向同一个物理地址，即是否为同一个对象，等价 == 4. toString()该方法在打印对象时被调用，将对象信息变为字符串返回，默认输出对象地址。 5. wait() notify() 主要用于Java的多线程机制 在使用的时候要求在synchronize语句中使用 wait()用于让当前线程失去操作权限，当前线程进入等待序列 notify()用于随机通知一个持有对象的锁的线程获取操作权限 6. clone() Java学习之深拷贝浅拷贝及对象拷贝的两种方式 对象拷贝，默认是浅拷贝一份自身的引用 7. 接口和抽象类的区别，注意JDK8的接口可以有实现。参考上文 8. 动态代理的两种方式，以及区别。 参考博文: 动手实现MVC: 3. AOP实现准备篇动态代理 不太确定两种到底指的什么，从个人猜测来将这个问题应该是趋向于问jdk支持的动态代理和cglib的动态代理两种方式 jdk动态代理 要求被代理的类必须实现于某个接口 自定义类SelfInvcoation实现 InvocationHandler接口，在invoke方法内实现代理逻辑 使用处，创建一个SelfInvcoation实例，将被代理类传入进去 利用Proxy.newProxyInstance创建一个代理类（这个类是接口的子类） 直接操作代理类即可 cglib动态代理 不要求被代理类必须实现于某个接口 创建代理类 CglibProxy 实现 MethodInterceptor接口，内部实现代理逻辑 创建代理工厂 CglibProxyFactory，内部（通过Enhancer）实现创建代理类的逻辑 使用处，通过代理工厂生成代理类 直接操作代理类即可 9. Java序列化的方式。要求序列化的类要求实现 Serialize 接口，内部一般会指定一个 SerializeID jdk主要通过 ObjectInputStream, ObjectOutputStream 来实现bean的序列化 一般来讲，直接用jdk的序列化方式的比较少，一般都会采用一些第三方框架，比如我自己常接触的json序列化或者相关的框架： gson fastjson Protocol Buffer kryo Jackson 10. 传值和传引用的区别，Java是怎么样的，有没有传值引用。传引用和传值的主要区别是，传引用case中，直接修改引用内部的属性，会修改原对象本身；传值时，修改内部属性不会影响原对象 传值：方法调用时，实际参数把它的值的副本传递给对应的形式参数 传引用：方法调用时，实际参数的引用(地址，而不是参数的值)被传递给方法中相对应的形式参数，函数接收的是原始值的内存地址 对Java而言，所有的参数传递实际上都是传值，不管参数是基本类型还是引用类型，都是传值，区别在与 基本类型：直接传递数值 引用类型：传递引用的地址 因此对参数本身的修改，如给引用参数赋新的值，并不会影响原来的对象 11. 一个ArrayList在循环过程中删除，会不会出问题，为什么。一般来讲不涉及到并发场景时，不会有问题，但也不绝对，如下面这种使用姿势就会导致数组越界了 1234567int len = list.size();for(int i = 0; i &lt; len; i++) &#123; System.out.println(list.get(i)); if ( i == 1) &#123; list.remove(i); &#125;&#125; 如果可以确保不会出现并发问题，一般推荐使用迭代器的方式来删除元素 12. @transactional注解在什么情况下会失效，为什么。产生这种问题的情况挺多的，也不知道具体想问什么 注解放在非public方法上就会失效，因为代理切不到 没有开启注解配置 没有扫描对应的包 使用姿势不对… 13. Java的四种引用，强弱软虚，用到的场景a. 强引用一般最常见的引用方式，就是强引用，存在应用，则不会被垃圾回收器回收 b. 软引用描述有用但非必须的对象，当内存不够时，会被回收掉 c. 弱引用当一个对象只有弱引用时，不管内存空间够不够，都回收掉 d. 虚引用虚引用并不会决定对象的生命周期，对象只有虚引用时，任何时候都可能被回收掉 e. 虚引用与软引用区别：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中 III. 其他知识要点来自: Java面试通关要点汇总集 一个两年Java的面试总结 Java面试通关要点汇总集(基础篇之基本功，非原作者) 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://zbang.online/hexblog/tags/面试/"},{"name":"知识汇总","slug":"知识汇总","permalink":"https://zbang.online/hexblog/tags/知识汇总/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"面试","slug":"工作/面试","permalink":"https://zbang.online/hexblog/categories/工作/面试/"},{"name":"Java","slug":"工作/面试/Java","permalink":"https://zbang.online/hexblog/categories/工作/面试/Java/"}]},{"title":"JQuery 实战笔记一","slug":"JQuery-实战笔记一","date":"2018-03-08T14:58:26.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/08/JQuery-实战笔记一/","link":"","permalink":"https://zbang.online/hexblog/2018/03/08/JQuery-实战笔记一/","excerpt":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应","text":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应 1. jquery控制div标签的显示隐藏123&lt;div id=\"queryExtend\"&gt; &lt;label&gt; hah &lt;/label&gt;&lt;/div jquery的用法, 判断是否隐藏，是则显示；否则隐藏 1234567function showQueryCondition() &#123; if($('#queryExtend').is(\":hidden\")) &#123; $('#queryExtend').show(); &#125; else &#123; $('#queryExtend').hide(); &#125;&#125; 2. 时间戳转日期1234// 获取当前时间戳var ns = Date.parse(new Date())/1000;var timestamp4 = new Date(parseInt(nS) * 1000);return timestamp4.toLocaleDateString().replace(/\\//g, \"/\") + \" \" + timestamp4.toTimeString().substr(0, 8); 3. 获取radio群的值123456789101112&lt;div class=\"col-md-10 input-group input-group-lg\"&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"1\" checked/&gt; &amp;nbsp;&amp;nbsp; 默认 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"2\"/&gt; &amp;nbsp;&amp;nbsp; 查主库 &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"3\"/&gt; &amp;nbsp;&amp;nbsp; 查从库 &lt;/div&gt;&lt;/div&gt; 对应的jquery获取选中值 1var queryDB = $(\"input[name='queryType']:checked\").val(); 4. 动态修改placeholder值1$('#itemId').attr('placeholder', '请输入商品ID '); 5. 判断字符串是否为数字类型123456var str = \"37\";var n = Number(str);if (!isNaN(n))&#123; alert(\"是数字\");&#125; 6. tab标签页的实现12345678910111213141516171819202122232425262728293031323334&lt;ul id=\"myTab\" class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#home\" data-toggle=\"tab\"&gt; 菜鸟教程 &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#ios\" data-toggle=\"tab\"&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" id=\"myTabDrop1\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Java &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"myTabDrop1\"&gt; &lt;li&gt;&lt;a href=\"#jmeter\" tabindex=\"-1\" data-toggle=\"tab\"&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#ejb\" tabindex=\"-1\" data-toggle=\"tab\"&gt;ejb&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"home\"&gt; &lt;p&gt;菜鸟教程是一个提供最新的web技术站点，本站免费提供了建站相关的技术文档，帮助广大web技术爱好者快速入门并建立自己的网站。菜鸟先飞早入行——学的不仅是技术，更是梦想。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ios\"&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"jmeter\"&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ejb\"&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 借助bootstrap，主要点 myTab 标签表示的导航内容 href 指向的本标签对应的内容 myTagContent 对应的标签页内容 id 与 导航的锚点对应 class=&quot;tab-pane fade in active&quot; 表示生效的标签内容 class=&quot;tab-pane fade&quot; 未激活的标签属性 7. 标签点击事件1$('#btn').click(function()&#123;&#125;); 8. jquery跳转链接12345678910// 本页面直接打开urlwindow.location.href=url;// 新标签页打开urlwindow.open(url, \"_blank\")// 在demo窗口打开urlwindow.open(url, \"demo\"); 9. jquery 修改图片url1$('#img').attr(\"src\", newImgUrl); 10. 图片加边框1&lt;image id=\"data\" style=\"border:1px solid #b5b3b3;\"/&gt; 11. 实现一个可检索的table在一个bootstrap项目中，必要的 jquery, bootstrap.min.js需要依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"wrapper\"&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"ibox float-e-margins\"&gt; &lt;div class=\"ibox-content\"&gt; &lt;input type=\"text\" class=\"form-control input-sm m-b-xs\" id=\"filter\" placeholder=\"Search in table\"&gt; &lt;table class=\"footable table table-stripped\" data-page-size=\"8\" data-filter=#filter&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Rendering engine&lt;/th&gt; &lt;th&gt;Browser&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Platform(s)&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Engine version&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;CSS grade&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=\"gradeX\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 4.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;4&lt;/td&gt; &lt;td class=\"center\"&gt;X&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"gradeC\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 5.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;5&lt;/td&gt; &lt;td class=\"center\"&gt;C&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt; &lt;ul class=\"pagination pull-right\"&gt;&lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"http://s11.mogucdn.com/mlcdn/c45406/1512464758975_footable.all.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function() &#123; $('.footable').footable(); $('.footable2').footable(); &#125;);&lt;/script&gt; 12. 表格内容固定1&lt;td style=\"word-break:break-all;width:20%\"&gt;dc:650|tp:1|ci:700004593373|st:1481299200|mk:9|ws:1480694400|et:1481558399|nm:活动价|&lt;/td&gt; 13. input回车响应12345678910111213141516171819202122232425262728293031323334353637383940414243444546$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 2.方法2$('#applyCertNum').on('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 3.方法3$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == \"13\") &#123; alert('你输入的内容为2：' + $('#applyCertNum').val()); &#125; &#125;);4.方法4$(\"#applyCertNum\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; alert(\"12345....\"); &#125; &#125;); html中直接加入 1onkeydown=\"if(event.keyCode==13) &#123;queryAppAuthList();&#125;\" II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"},{"name":"Jquery","slug":"Jquery","permalink":"https://zbang.online/hexblog/tags/Jquery/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}]},{"title":"Java并发学习之线程池ThreadPoolExecutor的小结","slug":"Java并发学习之线程池ThreadPoolExecutor的小结","date":"2018-03-06T09:33:54.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","link":"","permalink":"https://zbang.online/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","excerpt":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制","text":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制 I. 什么是线程池1. 通俗讲解我们先举一个小例子来说一下什么是线程池，以及线程池的工作方式 首先在看一下线程池中提交一个任务的流程图 下面就是实际的case：基本上大家都去过银行，我们就以到银行的柜台上办理业务的流程来说明线程池，我们先假设这里有一个xx银行（这里是广告位，待租😉），总共有8个柜台，平时只开放4个柜台，大厅内总共有20个座位。 那么来一个办理业务的，如果开放的四个柜台上，有空的，直接上去办理业务即可 如果四个柜台都在处理业务了，那么办理业务则需要取一个号，到大厅的座位上等着叫号 如果大厅坐满了，银行经理决定开放所有的柜台，那么新来办理的人直接到新的柜台上处理 如果所有柜台都在处理，且大厅也满了，这个时候就告诉新来办理业务的现在已经满载了，你们到xxx地的银行去办理吧（或者回家等下午再来好了） 从流程上的对比来看，就很相似了，虽然实际上银行可不会因为人的太多来新增开放柜台的数量，下面简单的将上面的case映射到线程池的成员上 4个开放柜台 ： 对应线程池的corePoolSize(核心工作线程数) 8个总柜台：对应线程池的maximumPoolSize(最大工作线程数) 20个座位：对应线程池的workQueue(任务队列) 所以线程池中提交一个任务时，优先看核心工作线程数是否已满，未满时，直接创建线程执行；已满，则丢入队列；如果队列也满了，则判断工作线程数是否超过最大数，没有则直接创建线程执行；否则直接“丢弃”这个任务了 （注意这个丢弃不是真的丢弃，其处理策略可以由你自己定义） 上面是基本流程，并没有涉及到工作线程的回收，线程池的状态（比如银行是否打烊了），任务的执行策略等 2. 线程池说明线程池是一种多线程的处理机制，主要是为了减少线程的频繁创建和销毁，从而提升系统效率 使用线程池优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 线程池组成类定义： java.util.concurrent.ThreadPoolExecutor 构造 1234567891011121314151617181920212223// 线程池构造方法public ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 存活时间 TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, // 排队队列 ThreadFactory threadFactory, // 创建线程的工作类 RejectedExecutionHandler handler) // 线程数满，队列满时具体任务策略&#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; II. 线程池使用1. 构造参数详解构造参数较多，创建一个线程池，当然首先得搞清楚这些参数是干嘛用的 参数 含义 说明 corePoolSize 核心工作线程数 没有任务时，线程池中允许存在的最小空闲线程数 工作线程数 &lt; corePoolSize时，提交任务创建工作线程来执行任务 maximumPoolSize 最大工作线程数 线程池中允许出现的最大工作线程数量 当队列满 &amp;&amp; 工作线程数 &lt; maximumPoolSize时，新的队列将创建线程来执行； 如果队列没有边界，那么这个参数没有意义 workQueue 任务队列 保存待执行任务的阻塞队列； 当 (工作线程数 &gt;= corePoolSize) &amp;&amp; (任务数 &lt; 任务队列长度)时，任务会offer()入队等待 keepAliveTime 工作线程最大空闲时间 当线程数 &gt; corePoolSize时，这个参数表示空闲线程存活时间； 超时的空闲线程，会被回收掉，直到线程数==corePoolSzie; 当allowCoreThreadTimeOut=true时，则超时的核心工作线程也会被回收 unit 时间单位 keepAliveTime的时间单位 threadFactory 线程创建工厂 创建线程的工厂类，可以在这里指定创建线程的name，设置守护线程，异常case处理等 handler 饱和策略执行器 线程池和队列都已满时，新提交任务的处理策略 默认是Abort(直抛Reject异常)，包括Discard(LIFO规则丢弃)、DiscardOldest(LRU规则丢弃) 以及 CallerRuns(调用者线程执行)，允许自定义执行器 2. 线程池的创建直接调用构造方法创建最直观的方式，直接构造方法new一个 1234567891011121314151617181920212223242526272829303132333435// 报警线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"test-thread\"), new ThreadPoolExecutor.CallerRunsPolicy()); // 线程创建工厂，主要设置为非守护线程，指定线程名，设置优先级// 关于这个工厂类，推荐看netty的实现public class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; public DefaultThreadFactory(String poolName) &#123; if (null == poolName) &#123; poolName = \"pool\"; &#125; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = poolName + poolNumber.getAndIncrement() + \"-thread-\"; &#125; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 利用 Executors创建jdk1.5+ 中提供了 java.util.concurrent.Executors 来创建常见的集中线程池方式 关于各种线程池的说明可以参考: Java并发学习之玩转线程池 固定大小线程池 123456// 创建一个固定大小的线程池public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 工作窃取线程池 123456public static ExecutorService newWorkStealingPool(int parallelism) &#123; return new ForkJoinPool (parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 创建单线程池 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 缓存线程池 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 定时任务线程池 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 不可配置线程池 12345public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123; if (executor == null) throw new NullPointerException(); return new DelegatedExecutorService(executor);&#125; 3. 提交任务execute: 提交无须返回值的任务 submit(Runnable): 适用于提交需要返回值的任务 相比较于上面的，区别是这个会返回一个 Future 对象，通过调用future.get()可以获取线程的返回值， 其中这个方程是线程阻塞的，直到返回了结果之后，才会继续执行下去 4. 关闭线程池shutdown(): 有序地关闭线程池，已提交的任务会被执行(包含正在执行和任务队列中的)，但会拒绝新任务 shutdownNow(): 立即(尝试)停止执行所有任务(包含正在执行和任务队列中的)，并返回待执行任务列表 III. 线程池实现原理1. 线程池状态线程池状态流程如下： RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED 每个状态含义 1234567891011121314//高3位111，低29位为0 该状态下线程池会接收新提交任务和执行队列任务private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//高3位000，低29位为0 该状态下线程池不再接收新任务，但还会继续执行队列任务private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//高3位001，低29位为0 该状态下线程池不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务private static final int STOP = 1 &lt;&lt; COUNT_BITS;//高3位010，低29位为0 该状态下线程池的所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated()private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//高3位011，低29位为0 该状态下表明线程池terminated()方法已经调用完成private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 2. 任务提交逻辑最开始的流图就说明了任务提交后的流程，针对流程块也就不继续细说，只提一个注意点 若实际工作线程数workers&lt;核心工作线程数corePoolSize，则创建新工作线程来执行新任务execute(Runable) 若实际工作线程数workers&gt;=核心工作线程数corePoolSize(核心工作线程们都在执行任务)且任务队列workQueue未满，则将任务加入到任务队列workQueue中 若任务队列workQueue已满，则创建新工作线程来执行任务execute() 若实际工作线程数workers&gt;=最大工作线程数maximumPoolSize(所有线程都在执行任务)，此时任务数已饱和，需要根据饱和拒绝策略rejectedExecutionHandler执行相对应的饱和拒绝操作 线程池的总体设计是基于性能考虑，尽可能避免获取全局锁： 由于创建新线程时都需要获取全局锁，因此步骤1和步骤3必须加锁 为了避免多次获取全局锁(性能伸缩瓶颈)，当实际工作线程数&gt;=核心工作线程数时，之后会执行步骤2(入队时无须获取全局锁) 线程池内线程回收策略 若实际工作线程数workers&gt;核心工作线程数corePoolSize，回收空闲时间超过keepAliveTime的空闲的非核心线程(减少工作线程数直到&lt;=核心工作线程数即可) 若设置allowCoreThreadTimeOut为true时，则超过keepAliveTime的空闲的核心工作线程也会被回收 3. 任务执行说明，下面两段代码解析来自转载： 并发番@ThreadPoolExecutor execute() - 提交任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 1.若实际工作线程数 &lt; 核心工作线程数，会尝试创建一个工作线程去执行该 * 任务，即该command会作为该线程的第一个任务，即第一个firstTask * * 2.若任务入队成功，仍需要执行双重校验，原因有两点： * - 第一个是去确认是否需要新建一个工作线程，因为可能存在 * 在上次检查后已经死亡died的工作线程 * - 第二个是可能在进入该方法后线程池被关闭了， * 比如执行shutdown() * 因此需要再次检查state状态，并分别处理以上两种情况： * - 若线程池中已无可用工作线程了，则需要新建一个工作线程 * - 若线程池已被关闭，则需要回滚入队列(若有必要) * * 3.若任务入队失败(比如队列已满)，则需要新建一个工作线程； * - 若新建线程失败，说明线程池已停止或者已饱和，必须执行拒绝策略 */public void execute(Runnable command) &#123; //新任务不允许为空，空则抛出NPE if (command == null) throw new NullPointerException(); // ctl 为线程池状态控制器，用于保证线程池状态和工作线程数 // 低29位为工作线程数量，高3位为线程池状态 int c = ctl.get(); /** * case1：当实际工作线程数 &lt; 核心工作线程数时 * 执行方案：会创建一个新的工作线程去执行该任务 * 注意：此时即使有其他空闲的工作线程也还是会新增工作线程， * 直到达到核心工作线程数为止 */ if (workerCountOf(c) &lt; corePoolSize) &#123; /** * 新增工作线程，true表示要对比的是核心工作线程数 * 一旦新增成功就开始执行当前任务 * 期间也会通过自旋获取队列任务进行执行 */ if (addWorker(command, true)) return; /** * 需要重新获取控制器状态，说明新增线程失败 * 线程失败的原因可能有两种： * - 1.线程池已被关闭，非RUNNING状态的线程池是不允许接收新任务的 * - 2.并发时，假如都通过了workerCountOf(c) &lt; corePoolSize校验，但其他线程 * 可能会在addWorker前先创建出线程，导致workerCountOf(c) &gt;= corePoolSize， * 即实际工作线程数 &gt;= 核心工作线程数，此时需要进入case2 */ c = ctl.get(); &#125; /** * case2：当实际工作线程数&gt;=核心线程数时，新提交任务需要入队 * 执行方案：一旦入队成功，仍需要处理线程池状态突变和工作线程死亡的情况 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //双重校验 int recheck = ctl.get(); /** * recheck的目的是为了防止线程池状态的突变 - 即被关闭 * 一旦线程池非RUNNING状态时，除了从队列中移除该任务(回滚)外 * 还需要执行任务拒绝策略处理新提交的任务 */ if (!isRunning(recheck) &amp;&amp; remove(command)) //执行任务拒绝策略 reject(command); /** * 若线程池还是RUNNING状态 或 * 队列移除失败(可能正好被一个工作线程拿到处理了) * 此时需要确保至少有一个工作线程还可以干活 * 补充一句：之所有无须与核心工作线程数或最大线程数相比，而只是比较0的原因是 * 只要保证有一个工作线程可以干活就行，它会自动去获取任务 */ else if (workerCountOf(recheck) == 0) /** * 若工作线程都已死亡，需要新增一个工作线程去干活 * 死亡原因可能是线程超时或者异常等等复杂情况 * * 第一个参数为null指的是传入一个空任务， * 目的是创建一个新工作线程去处理队列中的剩余任务 * 第二个参数为false目的是提示可以扩容到最大工作线程数 */ addWorker(null, false); &#125; /** * case3：一旦线程池被关闭 或者 新任务入队失败(队列已满) * 执行方案：会尝试创建一个新的工作线程，并允许扩容到最大工作线程数 * 注意：一旦创建失败，比如超过最大工作线程数，需要执行任务拒绝策略 */ else if (!addWorker(command, false)) //执行任务拒绝策略 reject(command);&#125; 上面的代码虽然非常少，但是逻辑还是比较多的，创建线程是根据 addWorker方法来实现的，其主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/** * 新增工作线程需要遵守线程池控制状态规定和边界限制 * * @param core core为true时允许扩容到核心工作线程数，否则为最大工作线程数 * @return 新增成功返回true，失败返回false */private boolean addWorker(Runnable firstTask, boolean core) &#123; //重试标签 retry: /*** * 外部自旋 -&gt; 目的是确认是否能够新增工作线程 * 允许新增线程的条件有两个： * 1.满足线程池状态条件 -&gt; 条件一 * 2.实际工作线程满足数量边界条件 -&gt; 条件二 * 不满足条件时会直接返回false，表示新增工作线程失败 */ for (;;) &#123; //读取原子控制量 - 包含workerCount(实际工作线程数)和runState(线程池状态) int c = ctl.get(); //读取线程池状态 int rs = runStateOf(c); /** * 条件一.判断是否满足线程池状态条件 * 1.只有两种情况允许新增线程： * 1.1 线程池状态==RUNNING * 1.2 线程池状态==SHUTDOWN且firstTask为null同时队列非空 * * 2.线程池状态&gt;=SHUTDOWN时不允许接收新任务，具体如下： * 2.1 线程池状态&gt;SHUTDOWN，即为STOP、TIDYING、TERMINATED * 2.2 线程池状态==SHUTDOWN，但firstTask非空 * 2.3 线程池状态==SHUTDOWN且firstTask为空，但队列为空 * 补充：针对1.2、2.2、2.3的情况具体请参加后面的\"小问答\"环节 */ if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; /*** * 内部自旋 -&gt; 条件二.判断实际工作线程数是否满足数量边界条件 * -数量边界条件满足会对尝试workerCount实现CAS自增，否则新增失败 * -当CAS失败时会再次重新判断是否满足新增条件： * 1.若此期间线程池状态突变(被关闭)，重新判断线程池状态条件和数量边界条件 * 2.若此期间线程池状态一致，则只需重新判断数量边界条件 */ for (;;) &#123; //读取实际工作线程数 int wc = workerCountOf(c); /** * 新增工作线程会因两种实际工作线程数超标情况而失败： * 1.实际工作线程数 &gt;= 最大容量 * 2.实际工作线程数 &gt; 工作线程比较边界数(当前最大扩容数) * -若core = true，比较边界数 = 核心工作线程数 * -若core = false，比较边界数 = 最大工作线程数 */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; /** * 实际工作线程计数CAS自增: * 1.一旦成功直接退出整个retry循环，表明新增条件都满足 * 2.因并发竞争导致CAS更新失败的原因有三种: * 2.1 线程池刚好已新增一个工作线程 * -&gt; 计数增加，只需重新判断数量边界条件 * 2.2 刚好其他工作线程运行期发生错误或因超时被回收 * -&gt; 计数减少，只需重新判断数量边界条件 * 2.3 刚好线程池被关闭 * -&gt; 计数减少，工作线程被回收， * 需重新判断线程池状态条件和数量边界条件 */ if (compareAndIncrementWorkerCount(c)) break retry; //重新读取原子控制量 -&gt; 原因是在此期间可能线程池被关闭了 c = ctl.get(); /** * 快速检测是否发生线程池状态突变 * 1.若状态突变，重新判断线程池状态条件和数量边界条件 * 2.若状态一致，则只需重新判断数量边界条件 */ if (runStateOf(c) != rs) continue retry; &#125; &#125; /** * 这里是addWorker方法的一个分割线 * 前面的代码的作用是决定了线程池接受还是拒绝新增工作线程 * 后面的代码的作用是真正开始新增工作线程并封装成Worker接着执行后续操作 * PS:虽然笔者觉得这个方法其实可以拆分成两个方法的(在break retry的位置) */ //记录新增的工作线程是否开始工作 boolean workerStarted = false; //记录新增的worker是否成功添加到workers集合中 boolean workerAdded = false; Worker w = null; try &#123; //将新提交的任务和当前线程封装成一个Worker w = new Worker(firstTask); //获取新创建的实际工作线程 final Thread t = w.thread; /** * 检测是否有可执行任务的线程，即是否成功创建了新的工作线程 * 1.若存在，则选择执行任务 * 2.若不存在，则需要执行addWorkerFailed()方法 */ if (t != null) &#123; /** * 新增工作线程需要加全局锁 * 目的是为了确保安全更新workers集合和largestPoolSize */ final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; /** * 获得全局锁后，需再次检测当前线程池状态 * 原因在于预防两种非法情况： * 1.线程工厂创建线程失败 * 2.在锁被获取之前，线程池就被关闭了 */ int rs = runStateOf(ctl.get()); /** * 只有两种情况是允许添加work进入works集合的 * 也只有进入workers集合后才是真正的工作线程，并开始执行任务 * 1.线程池状态为RUNNING(即rs&lt;SHUTDOWN) * 2.线程池状态为SHUTDOWN且传入一个空任务 * (理由参见：小问答之快速检测线程池状态?) */ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; /** * 若线程处于活动状态时，说明线程已启动，需要立即抛出\"线程状态非法异常\" * 原因是线程是在后面才被start的，已被start的不允许再被添加到workers集合中 * 换句话说该方法新增线程时，而线程是新的，本身应该是初始状态(new) * 可能出现的场景：自定义线程工厂newThread有可能会提前启动线程 */ if (t.isAlive()) throw new IllegalThreadStateException(); //由于加锁，所以可以放心的加入集合 workers.add(w); int s = workers.size(); //更新最大工作线程数，由于持有锁，所以无需CAS if (s &gt; largestPoolSize) largestPoolSize = s; //确认新建的worker已被添加到workers集合中 workerAdded = true; &#125; &#125; finally &#123; //千万不要忘记主动解锁 mainLock.unlock(); &#125; /** * 一旦新建工作线程被加入工作线程集合中，就意味着其可以开始干活了 * 有心的您肯定发现在线程start之前已经释放锁了 * 原因在于一旦workerAdded为true时，说明锁的目的已经达到 * 根据最小化锁作用域的原则，线程执行任务无须加锁，这是种优化 * 也希望您在使用锁时尽量保证锁的作用域最小化 */ if (workerAdded) &#123; /** * 启动线程，开始干活啦 * 若您看过笔者的\"并发番@Thread一文通\"肯定知道start()后， * 一旦线程初始化完成便会立即调用run()方法 */ t.start(); //确认该工作线程开始干活了 workerStarted = true; &#125; &#125; &#125; finally &#123; //若新建工作线程失败或新建工作线程后没有成功执行，需要做新增失败处理 if (!workerStarted) addWorkerFailed(w); &#125; //返回结果表明新建的工作线程是否已启动执行 return workerStarted;&#125; 小问：快速检测线程状态时，情况1.2、2.1、2.3的意义是什么？ 小答：在阐明这个问题之前，我们先明确两个知识点： 新增Worker的目的是处理任务，任务来源分初始任务和队列任务(即剩余的待处理任务) 线程池在非RUNNING状态下是不允许接收新任务的，换句话说您都要下班了，难道还想接新需求？ 针对2.1 - &gt; 线程池状态==SHUTDOWN，但firstTask！= null，不允许新增Worker当线程池状态为SHUTDOWN时，由于不允许接收新任务，因此一旦firstTask！= null需要直接拒绝 针对2.2 - &gt; 线程池状态==SHUTDOWN，且firstTask == null， 但队列为空， 不允许新增Worker当firstTask为null时，说明调用addWorker()目的不是为了处理新增任务那么其目的应该是为了处理剩余任务，即队列中的任务，而一旦队列为空，那也没必要新增Worker了 针对1.2 - &gt; 若线程池状态==SHUTDOWN，必须满足firstTask为null且队列非空，才允许新增Worker当线程池状态为SHUTDOWN时(调用shutdown())，此时不允许接收新任务，因此firstTask必须为null但需要处理剩余任务，因此队列必须非空，否则新增的工作线程就无任务可做，那就没意义了结论：传入一个空任务的目的是为了新增工作线程去处理任务队列中的剩余任务 3. Worker类详解worker包装了任务的调度，用于封装工作线程和任务并管理工作线程的中断状态等功能 由于工作线程和worker实例是一对一的关系，因为可以简单的理解工作线程等价于worker，尤其是谈及数量时，比如创建工作线程实际上就是创建一个worker 线程在线程池执行任务的工作流程： 工作线程开始执行前，需先对worker加锁，任务完成解锁 任务执行前后分别执行beforeExecute()和afterExecute()方法 执行中遇到异常会向外抛出，线程是否死亡取决于您对于异常的处理 每个任务执行完后，当前工作线程任务完成数自增，同时会循环调用getTask()从任务队列中反复获取任务并执行，无任务可执行时线程会阻塞在该方法上 当工作线程因各种理由退出时，会执行processWorkerExit()回收线程(核心是将该worker从workers集合中移除，注意之前worker已经退出任务循环，因此已经不再做工了，从集合移除后就方便gc了) 问：worker中断如何控制的 当工作线程真正开始执行之前，不允许被中断 当工作线程正在执行任务时，不允许被中断 当工作线程正等待从任务队列中获取任务getTask()时才能被中断 调用interruptIdleWorkers()中断空闲线程时必须先获得worker锁 问：为什么Worker不被设计成可重入锁？ 由于在动态控制方法中可能会中断线程，比如调用interruptIdleWorkers()，由此该方法在执行interrupt()之前会调用worker.tryLock()，若此时允许重入，就会导致线程被意外中断，这跟当工作线程正在执行任务时，不允许被中断准则是相违背的 IV. 问题解答1. 如何创建线程池直接根据构造方法创建 12345java.util.concurrent.ThreadPoolExecutor#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt;, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler) 利用 Executors 创建线程池 12345678910111213java.util.concurrent.Executors#newFixedThreadPool(int)java.util.concurrent.Executors#newWorkStealingPool(int)java.util.concurrent.Executors#newSingleThreadExecutor()java.util.concurrent.Executors#newCachedThreadPool()java.util.concurrent.Executors#newSingleThreadScheduledExecutor()java.util.concurrent.Executors#newScheduledThreadPool(int)java.util.concurrent.Executors#unconfigurableExecutorService 2. 线程池的适用场景优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 如何使用线程池创建线程池，提交任务 execute 适用于提交没有返回结果的任务 submit 适用于提交有返回结果的任务， 返回一个Futrure的包装类 4. 线程池实现原理 &amp; 任务提交后的流程在实现原理中会穿插上任务提交后的流程，所以就放在一起了 首先从提交一个任务开始： 首先判断工作线程数是否小于核心工作线程数，是则直接创建工作线程执行 否，则将任务丢入任务队列中 若任务队列已满，且工作线程数 &lt; 最大工作线程数，则直接创建工作线程执行任务 若队列满，且工作线程数达到最大值，则采用拒绝任务策略 其中上面的任务进队or创建线程执行，都需要关注线程池的状态，每个状态对应的原则 状态 说明 限制 RUNNING 运行状态 线程池会接收新提交任务和执行队列任务 SHUTDOWN 关闭状态 线程池不再接收新任务，但还会继续执行队列任务 STOP 停止状态 不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务 TIDYING 整理状态 所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated() TERMINATED 终止状态 线程池terminated()方法已经调用完成 接着上面，工作线程执行完毕之后，会尝试从任务队列中获取任务来执行，如果队列为空，则阻塞；此时工作线程空闲 根据工作线程的回收机制 允许回收核心工作线程时，将所有空闲时间大于keepAliveTime的线程回收掉 不允许回收核心工作线程，回收空闲时间大于keepAliveTime的线程，知道工作线程数量为核心工作线程数 5. 异常状况处理submit()异常处理 异常会保存在Future对象的ExecutionException中，可以在调用get()使用try-catch方式捕获，有N个任务有异常就会抛出来N个异常，但不会终止当前工作线程 单独设置UncaughtExceptionHandler没卵用，但结合(3)使用就有效 允许在submit()方法内部用try-catch捕获该异常，同样不会终止当前线程 若想在内部处理异常，还可以重写afterExecute()方法， execute()异常处理 默认会在execute()方法内部直接抛出异常，注意这不会中断线程池运行，但会终止当前工作线程，并重新创建新的工作线程执行该任务 允许在execute()方法内部用try-catch捕获该异常，好处是不会终止当前线程并重新创建一个新的线程了 重写afterExecute()方法 还可以设置UncaughtExceptionHandler 一个实例如下: 1234567891011ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 2, 3, TimeUnit.SECONDS, new LinkedBlockingQueue(), //我们自定义一个线程工厂和重写线程的setUncaughtExceptionHandler方法 new ThreadFactory() &#123; final AtomicInteger threadNumber = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; Thread thread = new Thread(Thread.currentThread().getThreadGroup(), r, \"thread-\" + (threadNumber.getAndIncrement())); thread.setUncaughtExceptionHandler((t,e) -&gt; System.out.println(e)); return thread; &#125;&#125;); 6. 线程池关闭关闭线程池主要有两种方式，两者的区别是： shutdown() : 队列剩余任务全部执行完毕再终止 shutdownNow() : 放弃执行队列剩余任务，但会将它们返回 两者的共性在于： 正在执行中的任务会继续执行，不会被终止或放弃 新提交的任务会被直接拒绝 V. 其他参考 Java-线程池专题（什么是线程池，如何使用，为什么要用） 并发番@ThreadPoolExecutor 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"https://zbang.online/hexblog/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"7. 报警系统QuickAlarm之默认报警规则扩展","slug":"报警系统QuickAlarm之默认报警规则扩展","date":"2018-03-05T04:25:00.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","link":"","permalink":"https://zbang.online/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","excerpt":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度","text":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度 I. 配置文件的扩展先看一下原有的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;&#125; 我们希望是能够支持多重报警方式同时选中，那么上面的配置中， threshold中只定义了一个阀值参数显然是不合适的，主要问题在于 单一阀值，不允许不同报警方式存在交叉 两个报警方式的threshold值相等时，选中的具体是哪个不可预期 所以我们的目标是将上面的参数中，新增一个指定上限的值max 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"ZZZ\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"max\": 27, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 9, \"max\": 14, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; 向上面这般改动之后，相当于每个报警方式都可以定义自己的区间，因此允许多重报警方式存在区间的交叉，计数在交叉区间即表示选中这多重方式 II. 扩展的实现支持从配置文件的变动来看，改动很小，只是新增一个参数而已，且这个参数不是必填的，那么对应的do应该为 123456789101112131415161718192021222324public class BasicAlarmThreshold &#123; private String level; /** * 启用定义的报警方式的阀值下限， * * 当报警计数 count &gt;= min * - max 非null, count &lt; max 则选择本报警方式; * count &gt;= max 则不选择本报警方式 * - max 为null（即表示为定义时）， * 则max赋值为:恰好大于 min 的 &#123;@link BasicAlarmThreshold#threshold&#125;值 * */ private int threshold; /** * 报警上限值，注意这是包装类型，允许为null */ private Integer max; private List&lt;String&gt; users;&#125; 然后顺带着，优化一把我们的映射规则，将配置规则的DO对象，映射为业务对象 主要的映射规则如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 将配置项转换为业务DO对象, 会做一些兼容, 保证 level. min, max, users, thresholds 都不会为null * * @param basicAlarmConfig * @return */private static AlarmConfig parse2BizConfig(BasicAlarmConfig basicAlarmConfig) &#123; if (basicAlarmConfig.getUsers() == null || basicAlarmConfig.getUsers().isEmpty()) &#123; // 如果没有填写用户, 则直接抛弃 return null; &#125; AlarmConfig alarmConfig = new AlarmConfig(); // 如果配置的报警类型是异常的, 则下面会兼容一把，设置为 NONE, 避免因为配置的原因导致系统异常 alarmConfig.setExecutor(SimpleExecuteFactory.getExecute(basicAlarmConfig.getLevel())); alarmConfig.setAutoIncEmergency(basicAlarmConfig.isAutoIncEmergency()); // 报警用户, 要求用户必须存在 alarmConfig.setUsers(basicAlarmConfig.getUsers()); // 报警上限, 如果用户没有填写，采用默认的（因为短信报警按条数要钱, 没必要一直无上限的报） alarmConfig.setMaxLimit(basicAlarmConfig.getMax() == null ? AlarmConfig.DEFAULT_MAX_NUM : basicAlarmConfig.getMax()); // 报警下限, 如果用户没有填写, 采用默认的最小值0 alarmConfig.setMinLimit(basicAlarmConfig.getMin() == null ? AlarmConfig.DEFAULT_MIN_NUM : basicAlarmConfig.getMin()); // 获取配置中的阀值列表，并排序 List&lt;BasicAlarmThreshold&gt; basicAlarmThresholdList = basicAlarmConfig.getThreshold(); if(basicAlarmThresholdList == null) &#123; basicAlarmThresholdList = Collections.emptyList(); &#125; basicAlarmThresholdList.sort(Comparator.comparingInt(BasicAlarmThreshold::getThreshold)); List&lt;AlarmThreshold&gt; alarmThresholdList = new ArrayList&lt;&gt;(basicAlarmThresholdList.size() + 2); AlarmThreshold tmpAlarmThreshold; BasicAlarmThreshold tmpBasicAlarmThreshold; boolean containDefaultExecute = false; for (int i = 0; i &lt; basicAlarmThresholdList.size(); i++) &#123; tmpBasicAlarmThreshold = basicAlarmThresholdList.get(i); tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(SimpleExecuteFactory.getExecute(tmpBasicAlarmThreshold.getLevel())); tmpAlarmThreshold.setUsers(tmpBasicAlarmThreshold.getUsers()); tmpAlarmThreshold.setMin(tmpBasicAlarmThreshold.getThreshold()); if (tmpBasicAlarmThreshold.getMax() == null || tmpBasicAlarmThreshold.getMax() &lt;= tmpBasicAlarmThreshold.getThreshold()) &#123; if (i == basicAlarmThresholdList.size() - 1) &#123; // 最后一个，则使用默认的上限阀值 tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); &#125; else &#123; tmpAlarmThreshold.setMax(basicAlarmThresholdList.get(i + 1).getThreshold()); &#125; &#125; else &#123; tmpAlarmThreshold.setMax(tmpBasicAlarmThreshold.getMax()); &#125; if (!containDefaultExecute) &#123; containDefaultExecute = tmpBasicAlarmThreshold.getLevel().equals(basicAlarmConfig.getLevel()); &#125; alarmThresholdList.add(tmpAlarmThreshold); &#125; int thresholdSize = alarmThresholdList.size(); if (thresholdSize == 0) &#123; // 没有配置阀值列表，直接使用默认 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; else if (!containDefaultExecute) &#123; // 不包含时默认时，补全 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmThresholdList.get(0).getMin()); alarmThresholdList.add(0, tmpAlarmThreshold); if (alarmThresholdList.get(thresholdSize).getMax() &lt; alarmConfig.getMaxLimit()) &#123; tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmThresholdList.get(thresholdSize).getMax()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; &#125; alarmConfig.setAlarmThreshold(alarmThresholdList); return alarmConfig;&#125; 在映射为业务对象的逻辑中，直接保障了AlarmThreshold列表中的顺序为最终的需求顺序，映射规则为 123456789101112131415161718192021222324252627/** * 如果配置的basicAlarmThresholdList列表中包含默认的报警方式 * - 则报警方式完全按照basicAlarmThresholdList的定义来 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Log, min=6 &#125;, &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=6, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - count : [6, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * * 如果不包含默认报警方式 * - 则需要补全最外层定义的Min-Max区间中的空余位 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=5, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125;, &#123; Log, min=26, max=30 &#125; * - count : [5, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * - count : [26, 30) Log * * * 上面改造后，很容易得知，支持多重报警方式同时工作，即当技术为14，15 时，同时发起WeiXin和SMS报警 */ 相应的就可以干掉原来不太好懂的Executor选择逻辑，对应的代码为 123456789101112131415161718192021222324252627282930// com.hust.hui.alarm.core.execut.AlarmExecuteSelector#getExecutepublic static List&lt;ExecuteHelper&gt; getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return Collections.singletonList(new ExecuteHelper(alarmConfig.getExecutor(), alarmConfig.getUsers())); &#125; if (count &lt; alarmConfig.getAlarmThreshold().get(0).getMin()) &#123; // 未达到报警的下限 return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; List&lt;ExecuteHelper&gt; list = new ArrayList&lt;&gt;(); for(AlarmThreshold alarmThreshold: alarmConfig.getAlarmThreshold()) &#123; if (alarmThreshold.getMin() &lt;= count &amp;&amp; count &lt; alarmThreshold.getMax()) &#123; list.add(new ExecuteHelper(alarmThreshold.getExecutor(), alarmThreshold.getUsers())); &#125; if(alarmThreshold.getMin() &gt; count) &#123; break; &#125; &#125; return list;&#125; III. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"借助GitHub搭建属于自己的maven仓库教程","slug":"借助GitHub搭建属于自己的maven仓库教程","date":"2018-02-12T06:01:13.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","link":"","permalink":"https://zbang.online/hexblog/2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","excerpt":"","text":"I. 背景在Github上也写了不少的项目了，然后经常遇到的一个问题就是，很多自己写的项目，希望在另外一个项目中使用时，只能把这个项目下载下来，相当之不方便 因为大多数的java后端项目都是基于maven管理依赖的，所以就希望能有一个公共的maven仓库，可以把自己的项目扔进去，然后再应用就方便很多了 基于此，就有了本文这个教程了 II. 实现步骤1. github仓库建立新建一个repository的前提是有github帐号，默认看到本文的是有帐号的 首先是在github上新建一个仓库，命令随意，如我新建项目为 https://github.com/liuyueyi/maven-repository 2. 配置本地仓库本地指定一个目录，新建文件夹 maven-repository, 如我的本地配置如下 1234567891011121314## 进入目录cd /Users/yihui/GitHub## 新建目录mkdir maven-repository; cd maven-repository## 新建repository目录# 这个目录下面就是存放我们deploy的项目相关信息# 也就是说我们项目deploy指定的目录，就是这里mkdir repository## 新增一个readme文档# 保持良好的习惯，每个项目都有一个说明文档touch README.md 这个目录结构为什么是这样的？ 我们直接看maven配置中默认的目录结构，同样拷贝一份出来而已 3. 仓库关联将本地的仓库和远程的github仓库关联起来，执行的命令也比较简单了 1234git add .git commit -m 'first comit'git remote add origin https://github.com/liuyueyi/maven-repository.gitgit push -u origin master 接着就是进行分支管理了 约定将项目中的snapshot版，deploy到仓库的 snapshot分支上 约定将项目中的release版，deploy到仓库的 release分支上 master分支管理所有的版本 所以需要新创建两个分支 12345678## 创建snapshot分支git checkout -b snapshot git push origin snapshot# 也可以使用 git branch snapshot , 我通常用上面哪个，创建并切换分支## 创建release分支git checkout -b releasegit push origin release 4. 项目deploy项目的deploy，就需要主动的指定一下deploy的地址了，所以我们的deploy命令如下 12## deploy项目到本地仓库mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository 上面的命令就比较常见了，主要需要注意的是file后面的参数，根据自己前面设置的本地仓库目录来进行替换 5. deploy脚本每次进行上面一大串的命令，不太好记，特别是不同的版本deploy到不同的分支上，主动去切换分支并上传，也挺麻烦，所以就有必要写一个deploy的脚本了 由于shell实在是不太会写，所以下面的脚本只能以凑合能用来说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashif [ $# != 1 ];then echo 'deploy argument [snapshot(s for short) | release(r for short) ] needed!' exit 0fi## deploy参数，snapshot 表示快照包，简写为s， release表示正式包，简写为rarg=$1DEPLOY_PATH=/Users/yihui/GitHub/maven-repository/CURRENT_PATH=`pwd`deployFunc()&#123; br=$1 ## 快照包发布 cd $DEPLOY_PATH ## 切换对应分支 git checkout $br cd $CURRENT_PATH # 开始deploy mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository # deploy 完成,提交 cd $DEPLOY_PATH git add -am 'deploy' git push origin $br # 合并master分支 git checkout master git merge $br git commit -am 'merge' git push origin master cd $CURRENT_PATH&#125;if [ $arg = 'snapshot' ] || [ $arg = 's' ];then ## 快照包发布 deployFunc snapshotelif [ $arg = 'release' ] || [ $arg = 'r' ];then ## 正式包发布 deployFunc releaseelse echo 'argument should be snapshot(s for short) or release(r for short). like: `sh deploy.sh snapshot` or `sh deploy.sh s`'fi 将上面的脚本，考本到项目的根目录下，然后执行 12345678chmod +x deploy.sh## 发布快照包./deploy.sh s# sh deploy.sh snapshot 也可以## 发布正式包./deploy.sh r 基于此，整个步骤完成 III. 使用上面仓库的基本搭建算是ok了，然后就是使用了，maven的pom文件应该怎么配置呢？ 首先是添加仓库地址 添加仓库 如果要区分snapshot和release的话，如下配置 12345678910&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-snap&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/snapshot/repository&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-release&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/release/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 如果不care的话，直接添加下面的即可 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/master/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 仓库配置完毕之后，直接引入依赖即可，如依赖我的Quick-Alarm包，就可以添加下面的依赖配置 12345&lt;dependency&gt; &lt;groupId&gt;com.hust.hui.alarm&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Github","slug":"Github","permalink":"https://zbang.online/hexblog/tags/Github/"},{"name":"Maven","slug":"Maven","permalink":"https://zbang.online/hexblog/tags/Maven/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}]},{"title":"6. 报警系统QuickAlarm使用手册","slug":"报警系统QuickAlarm使用手册","date":"2018-02-11T10:53:33.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm使用手册/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm使用手册/","excerpt":"","text":"本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项 1. 基本使用姿势首先我们不做任何的自定义操作，全部依靠系统默认的实现，我们的使用步骤如下 1. 添加注册文件首先在项目的资源目录下，添加注册文件 alarm.properties，文件内容如下 12345678910111213## 应用名，必填appName=test## 报警规则文件所在的路径，如果采用系统默认加载方式，必填## / 开头，表示存的是绝对路径## 非/开头，表示存的是系统相对路径，一般是放在资源目录下alarmConfPath=/tmp/alarmConfig## 最大的报警类型，非必填maxAlarmType=1000## 默认报警用户，必填defaultAlarmUsers=yihui 具体存放的位置，可以参考下图，放在resources目录下（源码中，是放在测试资源目录下的） 2. 添加报警规则根据注册文件中指定的路径，设置报警规则文件，如我们的报警规则文件 内容为json串格式，支持格式化的json串解析，为了节省篇幅，下面压缩成一行，点击获取json格式化小工具 /tmp/alarmConig: 1&#123;\"default\":&#123;\"level\":\"LOG\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"LOG\",\"threshold\":5,\"users\":[\"yihui\",\"erhui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"NPE\":&#123;\"level\":\"WEIXIN\",\"autoIncEmergency\":false,\"max\":30,\"min\":0,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"3h ui\",\"4hui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"XXX,YYY\":&#123;\"level\":\"EMAIL\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"EMAIL\",\"threshold\":5,\"users\":[\"yihui@xxx.com\",\"erhui@xxx.com\"]&#125;],\"users\":[\"yihui@xxx.com\"]&#125;&#125; 3. 测试类一个简单的使用测试 123456789101112@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; II. 报警执行机器扩展前面的报警规则配置中，有WEIXIN, SMS, EMAIL的报警，但是系统只提供了两个NONE和LOG，所以我们可以看下如何自定义实现上面的三个 1. 实现IExecute接口邮件报警 123456public class EmailExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 短信报警 12345678910/** * Created by yihui on 2018/2/7. */public class SmsExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 微信报警 123456789/** * Created by yihui on 2018/2/7. */public class WeiXinExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 说明，因为没有具体的实现，所以我们直接用日志输出来模拟，所以就都继承了LogExecute, 实际使用中，可以在上面补上相应的实现代码 2. 添加SPI定义在 resources 目录下，新增 目录：META-INF/services/ 文件：com.hust.hui.alarm.core.execut.api.IExecute 文件内容为上面几个实现类的全路径 123com.hust.hui.alarm.core.test.execute.EmailExecutecom.hust.hui.alarm.core.test.execute.SmsExecutecom.hust.hui.alarm.core.test.execute.WeiXinExecute 目录结构如： 3. 测试1234567891011121314151617181920public static void main(String[] args) throws InterruptedException &#123; // 测试异常升级的case // 计数 [1 - 2] 默认报警（即无日志） （其中 &lt; 3 的是因为未达到下限, 采用的默认报警） // 计数 [3 - 4] 默认邮件报警（其中 &lt; 5 采用的默认报警, 与下面的区别是报警用户） // 计数 [5 - 9] 邮件报警 （大于5小于10根据上升规则,还是选择邮件报警） // 计数 [10 - 19] 微信报警 // 计数 [20 - 30] 短信报警 // 计数 [31 -] 默认报警 （超过上限, 不报警） for (int i = 0; i &lt; 40; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; AlarmWrapper.getInstance().sendMsg(\"YYY\", \"异常报警升级测试\"); &#125; &#125;).start(); &#125; Thread.sleep(1000 * 600);&#125; 实测输出结果如下: 1234567891011121314151617181920212223242526272818:36:28.997 [Thread-12] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 26 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-24] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 16 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-33] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 6 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-22] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 18 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-26] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-23] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 17 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-35] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 4 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-3] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 5 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-18] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 27 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-11] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 28 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-21] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 19 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-2] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 9 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-14] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 24 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-10] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 29 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-15] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 22 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-16] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 23 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 15 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-9] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 30 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-13] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 25 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-19] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 21 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-34] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 3 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-4] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 7 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:36:29.011 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-5] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 8 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-1] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 20 &gt;&gt;&gt; 异常报警升级测试 III. 报警规则加载自定义1. 实现IConfLoader接口自定义加载器，给了一个最基本的 12345678910111213141516171819202122232425262728293031323334public class SelfAlarmConfLoader implements IConfLoader &#123; @Override public RegisterInfo getRegisterInfo() &#123; RegisterInfo registerInfo = new RegisterInfo(); registerInfo.setMaxAlarmType(100); registerInfo.setDefaultAlarmUsers(\"yihui\"); registerInfo.setAppName(\"test\"); return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public int order() &#123; return 0; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; //db 查询，获取对应的配置信息 // 下面是模拟，返回一个固定的配置 AlarmConfig alarmConfig = new AlarmConfig(); alarmConfig.setAlarmLevel(\"WEIXIN\"); alarmConfig.setAutoIncEmergency(false); alarmConfig.setMinLimit(10); alarmConfig.setMaxLimit(14); alarmConfig.setUsers(Arrays.asList(\"yihui\")); alarmConfig.setAlarmThreshold(Collections.emptyList()); return alarmConfig; &#125;&#125; 2. 添加SPI配置在resources目录下新增 目录： META-INF/services 文件： com.hust.hui.alarm.core.loader.api.IConfLoader 文件内容 1com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader 3. 测试同样是上面的代码，输出结果 1234518:43:04.275 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:43:04.276 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试 4. 说明系统默认的order是10，所以如果在测试上面的第二步时，不妨把com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader#order返回值，改成大于10，这样就会走到默认的配置加载类 采用 SelfAlarmConfLoader 时，前面说的两个基础配置文件，是可以没有的，完全不会有任何影响，因为对应的注册类和报警规则，都是右这个类内部提供了 IV. 小结所有测试相关数据，均可以在测试工程中获取，请主要关注: 测试case 注册文件：alarmConfig 报警规则配置文件：alarm.properties V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"5. 报警系统QuickAlarm之频率统计及接口封装","slug":"报警系统QuickAlarm之频率统计及接口封装","date":"2018-02-11T08:59:47.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","excerpt":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦","text":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦 I. 报警频率统计1. 设计前面在解析报警规则时，就有一个count参数，用来确定具体选择什么报警执行器的核心参数，我们维护的方法也比较简单： 针对报警类型，进行计数统计，没调用一次，则计数+1 每分钟清零一次 2. 实现因为每种报警类型，都维护一个独立的计数器 定义一个map来存储对应关系 1private ConcurrentHashMap&lt;String, AtomicInteger&gt; alarmCountMap; 每分钟执行一次清零 1234567// 每分钟清零一把报警计数ScheduledExecutorService scheduleExecutorService = Executors.newScheduledThreadPool(1);scheduleExecutorService.scheduleAtFixedRate(() -&gt; &#123; for (Map.Entry&lt;String, AtomicInteger&gt; entry : alarmCountMap.entrySet()) &#123; entry.getValue().set(0); &#125;&#125;, 0, 1, TimeUnit.MINUTES); 注意上面的实现，就有什么问题？ 有没有可能因为map中的数据过大（或者gc什么原因），导致每次清零花不少的时间，而导致计数不准呢？ （先不给出回答） 计数加1操作 1234567891011121314151617/** * 线程安全的获取报警总数 并自动加1 * * @param key * @return */private int getAlarmCount(String key) &#123; if (!alarmCountMap.containsKey(key)) &#123; synchronized (this) &#123; if (!alarmCountMap.containsKey(key)) &#123; alarmCountMap.put(key, new AtomicInteger(0)); &#125; &#125; &#125; return alarmCountMap.get(key).addAndGet(1);&#125; II. 报警线程池目前也只是提供了一个非常简单的线程池实现，后面的考虑是抽象一个基于forkjoin的并发框架来处理（主要是最近接触到一个大神基于forkjoin写的并发器组件挺厉害的，所以等我研究透了，山寨一个） 123456// 报警线程池private ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"sms-sender\"), new ThreadPoolExecutor.CallerRunsPolicy()); 任务提交执行 12345678private void doSend(final ExecuteHelper executeHelper, final AlarmContent alarmContent) &#123; alarmExecutorService.execute(() -&gt; executeHelper.getIExecute().sendMsg( executeHelper.getUsers(), alarmContent.getTitle(), alarmContent.getContent()));&#125; III. 接口封装这个就没什么好说的了 123456789101112131415161718192021222324252627282930313233343536373839404142public void sendMsg(String key, String content) &#123; sendMsg(new AlarmContent(key, null, content));&#125;public void sendMsg(String key, String title, String content) &#123; sendMsg(new AlarmContent(key, title, content));&#125;/** * 1. 获取报警的配置项 * 2. 获取当前报警的次数 * 3. 选择适当的报警类型 * 4. 执行报警 * 5. 报警次数+1 * * @param alarmContent */private void sendMsg(AlarmContent alarmContent) &#123; try &#123; // get alarm config AlarmConfig alarmConfig = confLoader.getAlarmConfig(alarmContent.key); // get alarm count int count = getAlarmCount(alarmContent.key); alarmContent.setCount(count); ExecuteHelper executeHelper; if (confLoader.alarmEnable()) &#123; // get alarm execute executeHelper = AlarmExecuteSelector.getExecute(alarmConfig, count); &#125; else &#123; // 报警关闭, 则走空报警流程, 将报警信息写入日志文件 executeHelper = AlarmExecuteSelector.getDefaultExecute(); &#125; // do send msg doSend(executeHelper, alarmContent); &#125; catch (Exception e) &#123; logger.error(\"AlarmWrapper.sendMsg error! content:&#123;&#125;, e:&#123;&#125;\", alarmContent, e); &#125;&#125; 接口封装完毕之后如何使用呢？ 我们使用单例模式封装了唯一对外使用的类AlarmWrapper，使用起来也比较简单，下面就是一个测试case 12345678910111213@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; 使用起来比较简单，就那么一行即可，从这个使用也可以知道，整个初始化，就是在这个对象首次被访问时进行 构造函数内容如下: 12345678910private AlarmWrapper() &#123; // 记录每种异常的报警数 alarmCountMap = new ConcurrentHashMap&lt;&gt;(); // 加载报警配置信息 confLoader = ConfLoaderFactory.loader(); // 初始化线程池 initExecutorService();&#125; 所有如果你希望在自己的应用使用之前就加载好所有的配置，不妨提前执行一下 AlarmWrapper.getInstance() IV. 小结基于此，整个系统设计基本上完成，当然代码层面也ok了，剩下的就是使用手册了 再看一下我们的整个逻辑，基本上就是下面这个流程了 提交报警 封装报警内容（报警类型，报警主题，报警内容） 维护报警计数（每分钟计数清零，每个报警类型对应一个报警计数） 选择报警 根据报警类型选择报警规则 根据报警规则，和当前报警频率选择报警执行器 若不开启区间映射，则返回默认执行器 否则遍历所有执行器的报警频率区间，选择匹配的报警规则 执行报警 封装报警任务，提交线程池 报警执行器内部实现具体报警逻辑 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"4. 报警系统QuickAlarm之报警规则解析","slug":"报警系统QuickAlarm之报警规则解析","date":"2018-02-11T08:08:04.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之报警规则解析/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之报警规则解析/","excerpt":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器","text":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器 I. 背景知识点0. 声明在正式进入之前，有必要额外声明一下，因为目前的v1版本，没有开放报警规则的自定义，也就是说，目前只支持默认的报警规则，所以接下来的主要内容将集中在 系统默认的报警规则的解析 即基于报警频率阀值，自动选择报警执行器的规则解析 1. 报警规则如果对于报警规则，依然不是很清晰的，可以阅读一下《报警系统QuickAlarm之报警规则的设定与加载》 这里简单的进行说明，系统中默认的报警规则结构为： key为报警类型（即用户执行报警时，传进来的报警类型参数） value为具体报警规则 每个报警执行器拥有一个报警频率区间，通过报警频率映射到报警执行器的区间来选择对应的AlarmExecutor，这就是系统定义的报警规则 II. 报警规则解析通过前面的报警规则的简单说明，基本上也可以捞出报警规则的解析原则了 每种报警类型，对应一个报警规则 每个报警规则中，可以有多个报警执行器 每个报警执行器都有一个对应的报警频率的阀值 根据阀值对所有的报警执行器排序 计算报警频率，映射到哪个区间，则选择哪个报警执行器 上面是一个简单的解析规则，当然实际上和这个差不多，但有一些问题需要额外注意 只想选择一种报警方式，是否可以支持？ 多重报警方式同时调用怎么处理？（如我希望用短信提示说有问题，同时用邮件包含详细的异常堆栈） 频率限制 报警类型没有设置报警规则如何处理？ 报警规则中使用了一个未注册的报警执行器会怎样？ 1. 实现方案说明再次将报警规则类拿出来看一下 12345678910111213141516171819202122232425262728293031323334/** * 报警用户 */private List&lt;String&gt; users;/** * 报警的阀值 */private List&lt;AlarmThreshold&gt; alarmThreshold;/** * 最小的报警数 */private int minLimit;/** * 最大的报警数 */private int maxLimit;/** * 报警类型 &#123;@link IExecute#getName()&#125; */private String alarmLevel;/** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */private boolean autoIncEmergency; 针对上面的问题，逐一说明 首先是 autoIncEmergency 这个参数，如果为true，则表示可以走上面的哪个区间映射的规则；否则就全部走AlarmConfig中默认的报警类型了 minLimit : 表示发生报警的频率下限值，小于这个值就不会执行具体的报警逻辑 maxLimit : 最大的报警频率，超过了也不报警（简单的频率控制） alarmLevel: 对应的就是具体的报警类型 alarmThreshold: 这个只有在autoIncEmergency=true时，才有小，也就是我们前面说的不同的报警执行器，根据阀值区间进行排序，开启之后，遍历，判断频率是否在这个区间内，若在，则表示可以选择它了 如果不存在报警规则，则采用默认的兜底规则 若报警执行器也不存在，就直接采用系统定义的日志报警执行器 2. 实现基本上前面已经将整个逻辑都说了，所以实际的编码反而比较清晰了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 获取具体的报警执行器 * &lt;p&gt; * 1. 未开启严重等级上升时, 直接返回 * 2. 开启之后, 判断当前的计数 范围 * * @param alarmConfig 报警配置项, 内部所有的参数都不可能为null */public static ExecuteHelper getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers()); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return new ExecuteHelper(SimpleExecuteFactory. getExecute(alarmConfig.getAlarmLevel()), alarmConfig.getUsers()); &#125; // 报警等级开启上升之趋势 // 1. 获取设置的默认等级 // 2. 判断当前的报警次数, 选择对应的报警类型 // 3. 选择具体的报警类型 String defaultLevel = alarmConfig.getAlarmLevel(); String selectLevel = null; List&lt;String&gt; selectUser = alarmConfig.getUsers(); List&lt;AlarmThreshold&gt; list = alarmConfig.getAlarmThreshold(); boolean useNew = false; boolean containDefaultLevel = false; for (AlarmThreshold alarmThreshold : list) &#123; if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; containDefaultLevel = true; &#125; &#125; for (AlarmThreshold alarmThreshold : list) &#123; // 表示当前的报警等级已经赶上默认的报警等级了, 所以要选择新的报警类型 if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; useNew = true; &#125; if (count &lt; alarmThreshold.getThreshold()) &#123; break; &#125; selectLevel = alarmThreshold.getAlarmLevel(); // 选择新的报警类型时, 需要更新报警用户 selectUser = alarmThreshold.getUsers(); &#125; // 阀值列表中不包含默认报警类型，则根据新的来 if (!containDefaultLevel &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; // 如果阀值列表中包含了默认报警类型, 且已经超过默认阀值 if (useNew &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; else &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(defaultLevel), alarmConfig.getUsers()); &#125;&#125; 具体的实现基本和我们前面分析的一样，但有一个地方需要额外注意 默认报警阀值，可以直接决定是否需要报警 因此定义的其他报警方式的阀值，应该在默认的阀值区间内 当然AlarmThreshold中不包含默认报警方式时，优先选择阀值区间的报警方式 当然AlarmThreshold中包含默认报警方式时，根据新的规则做处理 （吐槽：上面这个实现有点绕，后面想办法规避下，搞得不太好理解了） 另外一个问题就是，上面的实现没有支持可以同时选择多个报警执行器的情况 因为考虑到后面肯定会对报警规则的定义和解析放开，所以先实现了一个简单的场景，具体的放在后面处理 III. 小结到这里报警规则和报警执行器之间的解析关系已确定，剩下的东西就简单了，一个维持报警频率计数，一个报警线程池，再加上一个对外接口的封装而言 基本上，到这里主要的核心逻辑已经完成，小结一下本系统中的核心设计理念 – 一切可自定义（当然目前差得有点远） 1. 报警执行器 通过SPI机制支持用户自定义扩展 要求 Executor 拥有唯一标识 因为报警执行器支持扩展，所以Executor的内部实现，完全可以由用户决定 2. 报警规则 目前报警规则只提供默认的基于频率区间的选择方案 报警规则通过报警执行器的name与之唯一对应，若对应不上，则选择默认执行器 报警规则的加载同样基于SPI，支持自定义，因此报警规则可以存在任何地方 报警规则加载器，提供一个报警规则变动的钩子(load()),若采用自定义的加载类，则确保规则变动时，主动回调这个方法 默认的报警规则加载类，是基于系统的配置文件实现，内部托管了文件的变动更新事件（使用commons-io实现） IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"3. 报警系统QuickAlarm之报警规则的设定与加载","slug":"报警系统QuickAlarm之报警规则的设定与加载","date":"2018-02-09T11:39:43.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","excerpt":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择","text":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择 I. 报警规则定义 目前针对报警规则没有给出自定义配置的入口，即完全采用了默认的方案，后续可以考虑支持适用方来自定义报警规则以及解析器，这样扩展性就更强了 首先说明下我们的设计规则，我们针对不同的AlarmExecute定义了一个优先级，我们的目标是 针对报警频率设置不同区间，每个区间对应一种报警类型 当实际调用的报警频率达到这个区间，就选择这种报警类型 同时也允许关闭根据频率选择报警器的功能，全程用一个默认 每种报警类型的用户都可以自定义 针对上面的目标，我们设计的类就比较明确了 阀值类： 1234567891011121314151617181920212223242526272829303132@Getter@Setter@ToStringpublic class AlarmThreshold implements Comparable&lt;AlarmThreshold&gt; &#123; /** * 报警类型，对应 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * 晋升此报警的阀值 */ private int threshold; /** * 对应的报警用户 */ private List&lt;String&gt; users; @Override public int compareTo(AlarmThreshold o) &#123; if (o == null) &#123; return -1; &#125; return threshold - o.getThreshold(); &#125;&#125; 配置类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Getter@Setter@ToStringpublic class AlarmConfig &#123; public static final int DEFAULT_MIN_NUM = 0; public static final int DEFAULT_MAX_NUM = 30; /** * 报警用户 */ private List&lt;String&gt; users; /** * 报警的阀值 */ private List&lt;AlarmThreshold&gt; alarmThreshold; /** * 最小的报警数 */ private int minLimit; /** * 最大的报警数 */ private int maxLimit; /** * 报警类型 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */ private boolean autoIncEmergency;&#125; 一个报警类型对应一个AlarmConfig，这样当执行报警时，就可以很容易的获取对应的规则 同样根据定义，也可以看出报警规则比较简单，直接根据阀值区间来选择 II. 报警规则加载关于如何加载报警规则，想了很久，选择把这块放开，因为我们无法确定，使用方的配置是存在什么地方的，而且使用的配置是否能和我们的设计的DO兼容也是个问题，因此干脆放手，同样是通过SPI的方式来做的 我们定义规则加载接口： IConfLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface IConfLoader &#123; /** * 加载配置到内存的操作，启动时，被调用 * * @return true 表示加载成功; false 表示加载失败 */ default boolean load() &#123; return true; &#125; /** * 排序，越小优先级越高 * &lt;p&gt; * 说明： 当系统中多个Loader存在时，会根据优先级来选择order最小的一个作为默认的Loader * * @return */ default int order() &#123; return 10; &#125; /** * 获取注册信息 * * @return */ RegisterInfo getRegisterInfo(); /** * 是否开启报警 * * @return */ boolean alarmEnable(); /** * 根据报警类型，获取对应的报警规则 * * @param alarmKey * @return */ AlarmConfig getAlarmConfig(String alarmKey);&#125; 上面的方法，可以划分为两类: 加载时使用 load 为具体的执行加载配置到内存的方法，返回true表示加载成功 order 排序 getRegisterInfo 获取基础的配置信息（包括应用名等相关配置） 业务运行时使用 alarmEnable ： 是否开启报警 （当大量报警时，可以先关闭报警，然后再查问题） getAlarmConfig：核心方法，根据报警类型，返回对应的报警规则 系统默认提供一个从配置文件中加载报警规则的方案，主要会依赖两个配置文件 alarm.properties : 初始化注册信息，内部保存 RegisterInfo 所需要的属性 alarmConfig : 保存具体的报警规则，json格式 1. 配置加载配置加载的实现逻辑，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class PropertiesConfLoader implements IConfLoader &#123; private RegisterInfo registerInfo; private Map&lt;String, AlarmConfig&gt; cacheMap; public boolean load() &#123; // 获取注册信息 registerInfo = RegisterInfoLoaderHelper.load(); if (registerInfo == null) &#123; return false; &#125; // 获取报警的配置类 File file; String path = registerInfo.getAlarmConfPath(); if (path.startsWith(\"/\")) &#123; file = new File(path); &#125; else &#123; URL url = this.getClass().getClassLoader().getResource(path); file = new File(url.getFile()); &#125; // 加载成功，才替换 cacheMap的内容； 主要是为了防止修改配置出现问题 Map&lt;String, AlarmConfig&gt; tmp = init(file); boolean ans = tmp != null; // 注册配置文件的变动 ans = ans &amp;&amp; PropertiesConfListenerHelper.registerConfChangeListener(file, this::init); if (ans) &#123; cacheMap = tmp; &#125; return ans; &#125; private Map&lt;String, AlarmConfig&gt; init(File file) &#123; try &#123; // 正常来讲，是一个完整的json串 List&lt;String&gt; list = IOUtils.readLines(new FileInputStream(file), \"utf-8\"); String config = Joiner.on(\"\").join(list); return AlarmConfParse.parseConfig(config, Splitter.on(\",\").splitToList(registerInfo.getDefaultAlarmUsers())); &#125; catch (IOException e) &#123; log.error(\"load config into cacheMap error! e: &#123;&#125;\", e); return null; &#125; &#125; @Override public RegisterInfo getRegisterInfo() &#123; return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; AlarmConfig config = cacheMap.get(alarmKey); if (config == null) &#123; return cacheMap.get(AlarmConfParse.DEFAULT_ALARM_KEY); &#125; else &#123; return config; &#125; &#125;&#125; 主要查看默认的load方法即可, alarmEnable 和 getAlarmConfig还是比较简单的，看一下就知道怎么玩的 2. RegisterInfo 加载上面的实现中，第一步就是从 alarm.properteis 文件中读取对应的配置，然后初始化 RegisterInfo对象 1234567891011@Datapublic class RegisterInfo implements Serializable &#123; // 报警规则文件的路径，系统默认加载时，必填；否则选填 private String alarmConfPath; // 最大报警类型数，非必填，默认1000 private Integer maxAlarmType; // 默认报警用户， 必须 private String defaultAlarmUsers; // 应用名， 必须 private String appName;&#125; 一个配置文件实例 1234appName=testalarmConfPath=/tmp/alarmConfigmaxAlarmType=1000defaultAlarmUsers=yihui 从配置文件中读取信息，然后初始化对象的过程就比较简单了，我这里做了一个小简化，使用反射的方式实现对象拷贝 123456789101112131415161718public static void copy(Properties source, Object dest) throws IllegalAccessException &#123; Field[] fields = dest.getClass().getDeclaredFields(); for (Field f : fields) &#123; // 不修改静态变量 if (Modifier.isStatic(f.getModifiers())) &#123; continue; &#125; f.setAccessible(true); // 值拷贝，因为不同数据类型的问题，所以需要对properties中获取的String类型转换一把 f.set(dest, parseObj(source.getProperty(f.getName()), f.getType())); &#125;&#125;// 强制类型转换private static &lt;T&gt; T parseObj(String obj, Class&lt;T&gt; clz) &#123; return ParseFuncEnum.getFunc(clz).apply(obj);&#125; 上面的实现目前比较简单，没有考虑父类的情况，没有考虑复杂的数据类型转换，目前只支持了基本类型的转换，后续可考虑抽象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public enum ParseFuncEnum &#123; INT_PARSE(Arrays.asList(int.class, Integer.class)) &#123; @Override public Function&lt;String, Integer&gt; getFunc() &#123; return Integer::valueOf; &#125; &#125;, LONG_PARSE(Arrays.asList(long.class, Long.class)) &#123; @Override public Function&lt;String, Long&gt; getFunc() &#123; return Long::valueOf; &#125; &#125;, BOOLEAN_PARSE(Arrays.asList(boolean.class, Boolean.class)) &#123; @Override public Function&lt;String, Boolean&gt; getFunc() &#123; return Boolean::valueOf; &#125; &#125;, FLOAT_PARSE(Arrays.asList(float.class, Float.class)) &#123; @Override public Function&lt;String, Float&gt; getFunc() &#123; return Float::valueOf; &#125; &#125;, DOUBLE_PARSSE(Arrays.asList(double.class, Double.class)) &#123; @Override public Function&lt;String, Double&gt; getFunc() &#123; return Double::valueOf; &#125; &#125;, SHORT_PARSE(Arrays.asList(short.class, Short.class)) &#123; @Override public Function&lt;String, Short&gt; getFunc() &#123; return Short::valueOf; &#125; &#125;, BYTE_PARSE(Arrays.asList(byte.class, Byte.class)) &#123; @Override public Function&lt;String, Byte&gt; getFunc() &#123; return Byte::valueOf; &#125; &#125;, CHAR_PARSE(Arrays.asList(char.class, Character.class)) &#123; @Override public Function&lt;String, Character&gt; getFunc() &#123; return s -&gt; s.charAt(0); &#125; &#125;, STRING_PARSE(Arrays.asList(String.class)) &#123; @Override public Function&lt;String, String&gt; getFunc() &#123; return s -&gt; s; &#125; &#125;,; private List&lt;Class&gt; clzList; public abstract &lt;T&gt; Function&lt;String, T&gt; getFunc(); private static Map&lt;Class, ParseFuncEnum&gt; map = new ConcurrentHashMap&lt;&gt;(20); static &#123; for (ParseFuncEnum enu : ParseFuncEnum.values()) &#123; for (Class clz : enu.clzList) &#123; map.put(clz, enu); &#125; &#125; &#125; ParseFuncEnum(List&lt;Class&gt; clz) &#123; this.clzList = clz; &#125; public static &lt;T&gt; Function&lt;String, T&gt; getFunc(Class&lt;T&gt; clz) &#123; return map.get(clz).getFunc(); &#125;&#125; 3. 报警规则加载注册信息加载完毕之后，就可以获取报警规则的文件地址了，因此首先是读取配置规则的内容（我们要求是JSON格式），然后反序列化即可 将json串格式配置，反序列化为 BaseAlarmConf 对象 12345678910111213141516171819202122232425262728293031323334353637private static final TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt; typeReference = new TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt;() &#123;&#125;;/** * 将json串格式的报警规则配置，映射为对应实体类 * &lt;p&gt; * 如果传如的是null, 则采用默认的兜底配置 * 如果传入的是非法的配置，直接返回null， 这样做的目的如下 * &lt;p&gt; * - 启动时，直接获知配置有问题，需要修改 * - 启动中，修改配置，此时新配置有问题，依然使用旧的配置 * * @param configs * @return */private static Map&lt;String, BasicAlarmConfig&gt; parseStrConfig2Map(String configs) &#123; Map&lt;String, BasicAlarmConfig&gt; map = null; if (configs != null) &#123; try &#123; map = JSON.parseObject(configs, typeReference); &#125; catch (Exception e) &#123; logger.error(\"ConfigWrapper.parseStrConfig2Map() init config error! configs: &#123;&#125;, e:&#123;&#125;\", configs, e); return null; &#125; &#125; if (map == null) &#123; map = new HashMap&lt;&gt;(1); &#125; if (!map.containsKey(DEFAULT_ALARM_KEY)) &#123; map.put(DEFAULT_ALARM_KEY, DEFAULT_ALARM_CONFIG); &#125; return map;&#125; 需要额外说明一下，json串并没有直接的映射我们前面定义的 AlarmConfig 对象，因为在原型版本的设计的过程中，考虑到配置与内部的使用对象，可能不是特别匹配，最初的设计中，是希望直接将AlarmConfig中的alarmLevel直接替换成 AlarmExecute 实例对象的，然而在实际实现中没有这么干…，所以看源码时，这里就有点奇怪，后面完全可以干掉这个无用的逻辑 此外，就是需要给一个默认的配置项，当报警类型匹配不到对应的报警规则时，就选择默认的了 下面是一个报警配置的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; \"default\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE\": &#123; \"level\": \"WEIXIN\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"3h ui\", \"4hui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"XXX,YYY\": &#123; \"level\": \"EMAIL\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 5, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; III. ConfLoader选择并初始化前面说明，为了确保报警规则的多样性存储与加载，我们支持用户自定义加载类，所以就会有这么个ConfLoaderFactory, 来创建系统中使用的ConfLoader 12345678910111213141516171819202122232425262728293031323334353637383940public class ConfLoaderFactory &#123; private static IConfLoader currentAlarmConfLoader; public static IConfLoader loader() &#123; if (currentAlarmConfLoader == null) &#123; synchronized (ConfLoaderFactory.class) &#123; if (currentAlarmConfLoader == null) &#123; initConfLoader(); &#125; &#125; &#125; return currentAlarmConfLoader; &#125; private static void initConfLoader() &#123; Iterator&lt;IConfLoader&gt; iterator = ServiceLoader.load(IConfLoader.class).iterator(); List&lt;IConfLoader&gt; list = new ArrayList&lt;&gt;(); // 根据优先级进行排序，选择第一个加载成功的Loader while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; list.sort(Comparator.comparingInt(IConfLoader::order)); for (IConfLoader iConfLoader : list) &#123; if (iConfLoader.load()) &#123; currentAlarmConfLoader = iConfLoader; break; &#125; &#125; if (currentAlarmConfLoader == null) &#123; throw new NoAlarmLoaderSpecifyException(\"no special alarmConfLoader selected!\"); &#125; &#125;&#125; 实现逻辑依旧采取了SPI机制，不够我们定义了一个优先级，默认从最高优先级的开始加载，加载成功之后，就选择这个东西了；否则继续加载下一个，当所有的ConfLoader加载完毕，都没有一个成功的，就抛出一个异常 IV. 小结鉴于篇幅问题，关于报警规则与报警执行器之间的关系，对应的解释器放在下一篇进行说明，简要小结一下本文内容 报警规则： 采用阀值区间方式，将报警频率与报警执行器关联起来 规则加载： 支持SPI方式注入用户加载器，默认提供基于配置文件的加载器，且优先级最低 基本上本文说的就是下面这张图的内容了 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"2. 报警系统QuickAlarm之报警执行器的设计与实现","slug":"报警系统QuickAlarm之报警执行器的设计与实现","date":"2018-02-09T11:38:59.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","excerpt":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现","text":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现 I. AlarmExecute接口定义在定义接口之前，先来根据几个问题来加深下这个概念的理解： 1. 基础知识 说一下这个报警执行器到底是干嘛的？ 执行具体的报警逻辑（感觉说了依据废话） 因此不同的报警方式，可以选择不同的实现，这个强业务关联的逻辑可以交由适用方自己来把控 多个alarmExecute之间如何区分？ 给一个类似身份证的标识，将标识与alarmExecute绑定，则可以报警规则中，用这个标识来表示对应的报警执行器 标识要求全局唯一，否则就没法找到对应的执行器 2. 接口定义根据上面的基础知识，那么很容易给出接口的定义了 123456789101112131415161718192021public interface IExecute &#123; /** * 报警的具体实现 * * @param users 报警用户，支持批量 * @param title 报警信息的title * @param msg 报警的主题信息 */ void sendMsg(List&lt;String&gt; users, String title, String msg); /** * 获取报警单元唯一标识 * * @return name 要求全局唯一 */ default String getName() &#123; return ExecuteNameGenerator.genExecuteName(this.getClass()); &#125;&#125; 第一个方法sendMsg也就是需要使用者来实现的具体执行报警代码的核心模块了，比较清晰，其中用户是列表，因此，支持同时报警给多个用户（但是报警内容都是相同的） 第二个方法getName表示获取标识，默认给了一个实现，规则如下 获取类的 SimpleName 干掉类名后面的 Execute （如果不是以这个结尾的就不需要了） 剩下的全部转大写 实例： SmsExecute -&gt; SMS; LogExecute -&gt; LOG; 3. 额外说明上面接口定义中的sendMsg中，支持给多个用户发送报警信息，如果要求每个报警信息都不同，比如最常见的是: 发送一段文本，其中通知人地方根据报警人来替换，其他的不变 当然这样的场景完全可以自己在实现中来做 传入的content作为一个话术模板 然后利用 String#format() 来实现参数代替 当然更激进一点就是，穿进来的title或者content作为一个key，然后我可以通过这个key，到其他的地方（如db，缓存等）获取报警内容，甚至我连传进来的报警人都不care，直接从其他地方来获取 简单来说，这个实现委托给用户自己实现，你完全可以随意的控制，做任何你想做的事情 II. AlarmExecute的加载1. 问题分析加载AlarmExecut，貌似没有什么特别复杂的东西，一般的思路是创建一个简单工厂类，然后实例化对应的Executor返回，（再多一点确保只有一个实例对象，加以缓存） 这样有什么问题？ 很简单的实现，但是我们需要加载用户自定义的执行器，要怎么支持呢？ 几种可行的解决手段 1. 开放一个注册接口这个可算是最容易想到的了，直接让用户把自己的Executor实例，主动的扔进来 2. 抽象工厂将前面说的简单工厂，改成抽象工厂类，让后具体的加载委托给用户自己来做 3. 借助Spring容器来加载如果所有的AlarmExecute都委托给Spring容器来管理，那么就很简单了，直接通过ApplicationContext#getBean来获取所有的执行器即可 4. SPI加载方式通过JDK的spi机制来实现（详细后面来说） 针对上面的几个手段，首先排除掉前面两个，因为不满足我们的设计目标一： 简单 （只有报警这个接口进行交互，不需要额外的接口调用） 然后也排除掉spring容器，因为我们希望这个东西，可以较独立的被引用到java工程中，后面可以看情况实现一个spring版 从使用来讲，由spring容器来托管的方式，对使用者而言，是最简单，成本最低的，因为不需要额外添加SPI配置 2. 实现我们采用SPI方式来实现加载，对于SPI是什么东西，这里不详细展看，有兴趣的童鞋可以看我之前的一个系类博文：自定义SPI框架设计 实现方式，可说是非常简单了 1234567891011121314151617181920212223242526272829303132333435363738394041public class SimpleExecuteFactory &#123; private static Map&lt;String, IExecute&gt; cacheMap; private static void loadAlarmExecute() &#123; Map&lt;String, IExecute&gt; map = new HashMap&lt;&gt;(); Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); IExecute tmp; while (iExecutes.hasNext()) &#123; tmp = iExecutes.next(); if (!map.containsKey(tmp.getName())) &#123; map.put(tmp.getName(), tmp); &#125; else &#123; throw new DuplicatedAlarmExecuteDefinedException( \"duplicated alarm execute defined!\" + \"\\n\" + \"&gt;&gt;name:\" + tmp.getName() + \"&gt;&gt;&gt;clz:\" + tmp.getClass() + \"&gt;&gt;&gt;clz:\" + map.get(tmp.getName()) ); &#125; &#125; cacheMap = map; &#125; public static IExecute getExecute(String execute) &#123; if (cacheMap == null) &#123; synchronized (SimpleExecuteFactory.class) &#123; if (cacheMap == null) &#123; loadAlarmExecute(); &#125; &#125; &#125; // 如果不存在，则降级为 LogExecute IExecute e = cacheMap.get(execute); return e == null ? cacheMap.get(LogExecute.NAME) : e; &#125;&#125; 上面对外就暴露一个方法，内部比较简单，如果传入标识对应的报警器没有，则返回一个默认的，确保不会因此挂掉 通过SPI加载所有的执行器的逻辑就一行 1Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); 然后需要关注的是循环内部，做了name的唯一性判断，不满足就直接抛出异常了 III. AlarmExecute内部实现内部提供了两个基本的报警实现，比较简单 日志报警执行器 123456789101112131415/** * 有些报警,不需要立即上报,但是希望计数, 当大量出现时, 用于升级 * &lt;p/&gt; * Created by yihui on 2017/4/28. */public class LogExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(LogExecute.class); private static final Logger logger = LoggerFactory.getLogger(\"alarm\"); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; logger.info(\"Do send msg by &#123;&#125; to user:&#123;&#125;, title: &#123;&#125;, msg: &#123;&#125;\", getName(), users, title, msg); &#125;&#125; 空报警执行器 12345678910111213/** * 空报警执行器, 什么都不干 * &lt;p&gt; * Created by yihui on 2017/5/12. */public class NoneExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(NoneExecute.class); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; &#125;&#125; IV. 小结AlarmExecute 的定义，加载以及实现规则目前都已经完成 定义：两个方法，一个执行报警方法，一个返回唯一标识方法 加载：通过SPI方式加载所有定义的alarmExecute 实现：由用户自定义实现IExecute接口，内部逻辑无任务特殊要求，只是需要确保每个executor的name唯一 整个系统的第一步已经迈出，但是有个问题就是什么时候，才会来调用 com.hust.hui.alarm.core.execut.SimpleExecuteFactory#getExecute 从而触发执行器的加载呢？ V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"1. 报警系统QuickAlarm设计总纲","slug":"报警系统QuickAlarm总纲","date":"2018-02-09T11:37:29.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm总纲/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm总纲/","excerpt":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了","text":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了 目标因此我们准备设计一个通用的报警框架 可以自由选择报警方式， 支持用户自定义报警方式拓展 支持动态的报警配置， 支持用户自定义报警规则拓展 支持报警方式自动切换规则设定 支持报警方式自定义自动切换规则拓展 设计整体来说，报警主要可以划分为三个步骤，如下： 提交报警：对外部使用者提供的接口 选择报警：根据报警相关信息，选择具体的报警执行单元 执行报警：实现具体的报警逻辑 从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展， 选择报警： 报警规则的制定 报警规则加载器 ConfLoader 报警规则变更的触发器 ConfChangeTrigger 报警规则解析器 ConfParse ： 解析文本格式报警规则为业务对象 AlarmSelector ：根据报警规则和报警类型，选择具体报警执行器 AlarmExecute 执行报警： 线程池执行（以防止影响主业务流程） AlarmExecute的动态拓展（支持用户自定义的报警器实现） 实际的报警逻辑 根据上面的拆解，在应用启动的时候，就有一些事情必须去做了 ConfLoader的选择 报警规则加载 AlarmExecute的加载（包括默认的+自定义实现的） 下图显示在应用启动时，报警规则解析的相关步骤 至于报警执行器的加载就比较简单了，如下图 因此，整个的工作流程如下图 任务拆解通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来 最直接的就是设计报警执行器AlarmExecute 定义基本接口 制定自定义扩展规则 接下来就是设计报警规则 如何加载报警规则？ 报警规则具体的定义细则 报警规则的解析：即根据报警类型来获取报警执行器 报警规则动态更新支持 报警线程池 维护报警队列 报警的计数与频率控制 封装对外使用接口 所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明 小结做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？ 用途： 支持灵活可配的报警规则，以及具体报警业务的自定义拓展 目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了 学习： 抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了 我们可以如何支持功能的动态可拓展 线程池的使用 IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"Java可以如何实现文件变动的监听","slug":"Java可以如何实现文件变动的监听","date":"2018-02-08T04:01:58.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/02/08/Java可以如何实现文件变动的监听/","link":"","permalink":"https://zbang.online/hexblog/2018/02/08/Java可以如何实现文件变动的监听/","excerpt":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？","text":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？ I. 问题描述及分析针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 Z+中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下 现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存 一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下： 如何轮询？ 如何判断文件是否修改？ 配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要…） II. 设计与实现问题抽象出来之后，对应的解决方案就比较清晰了 如何轮询 ？ –》 定时器 Timer, ScheduledExecutorService 都可以实现 如何判断文件修改？ –》根据 java.io.File#lastModified 获取文件的上次修改时间，比对即可 那么一个很简单的实现就比较容易了: 12345678910111213141516171819202122232425262728293031public class FileUpTest &#123; private long lastTime; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); // 首先文件的最近一次修改时间戳 lastTime = file.lastModified(); // 定时任务，每秒来判断一下文件是否发生变动，即判断lastModified是否改变 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); &#125; &#125; &#125;,0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？ 定时任务的执行中，如果出现了异常会怎样？ 对上面的代码稍作修改 12345678910111213141516171819202122232425262728293031323334public class FileUpTest &#123; private long lastTime; private void ttt() &#123; throw new NullPointerException(); &#125; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); lastTime = file.lastModified(); ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); ttt(); &#125; &#125; &#125;, 0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 ScheduledExecutorService 的原因了 直接查看ScheduledExecutorService的源码注释说明 If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。 所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了 对应的解决方法也比较简单，整个catch一下就好 III. 进阶版前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列 首先maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 主要是借助这个工具中的 FileAlterationObserver, FileAlterationListener, FileAlterationMonitor 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PropertiesConfListenerHelper &#123; public static boolean registerConfChangeListener(File file, Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; try &#123; // 轮询间隔 5 秒 long interval = TimeUnit.SECONDS.toMillis(5); // 因为监听是以目录为单位进行的，所以这里直接获取文件的根目录 File dir = file.getParentFile(); // 创建一个文件观察器用于过滤 FileAlterationObserver observer = new FileAlterationObserver(dir, FileFilterUtils.and(FileFilterUtils.fileFileFilter(), FileFilterUtils.nameFileFilter(file.getName()))); //设置文件变化监听器 observer.addListener(new MyFileListener(func)); FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer); monitor.start(); return true; &#125; catch (Exception e) &#123; log.error(\"register properties change listener error! e:&#123;&#125;\", e); return false; &#125; &#125; static final class MyFileListener extends FileAlterationListenerAdaptor &#123; private Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func; public MyFileListener(Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; this.func = func; &#125; @Override public void onFileChange(File file) &#123; Map&lt;String, AlarmConfig&gt; ans = func.apply(file); // 如果加载失败，打印一条日志 log.warn(\"PropertiesConfig changed! reload ans: &#123;&#125;\", ans); &#125; &#125;&#125; 针对上面的实现，简单说明几点： 这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听 如上面registerConfChangeListener方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤 第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象 一个问题，如果 func方法执行时，也抛出了异常，会怎样？ 实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常 那么简单来看一下上面的实现逻辑，直接扣出核心模块 1234567891011121314151617181920212223public void run() &#123; while(true) &#123; if(this.running) &#123; Iterator var1 = this.observers.iterator(); while(var1.hasNext()) &#123; FileAlterationObserver observer = (FileAlterationObserver)var1.next(); observer.checkAndNotify(); &#125; if(this.running) &#123; try &#123; Thread.sleep(this.interval); &#125; catch (InterruptedException var3) &#123; ; &#125; continue; &#125; &#125; return; &#125;&#125; 从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了 JDK版本jdk1.7，提供了一个WatchService，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testFileUpWather() throws IOException &#123; // 说明，这里的监听也必须是目录 Path path = Paths.get(\"/tmp\"); WatchService watcher = FileSystems.getDefault().newWatchService(); path.register(watcher, ENTRY_MODIFY); new Thread(() -&gt; &#123; try &#123; while (true) &#123; WatchKey key = watcher.take(); for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; if (event.kind() == OVERFLOW) &#123; //事件可能lost or discarded continue; &#125; Path fileName = (Path) event.context(); System.out.println(\"文件更新: \" + fileName); &#125; if (!key.reset()) &#123; // 重设WatchKey break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; IV. 小结使用Java来实现配置文件变动的监听，主要涉及到的就是两个点 如何轮询： 定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep 文件修改： File#lastModified 整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是： 千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！ 为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 @Subscribe注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明） V. 其他参考项目 项目： quick-alarm 测试类： FileUpTest.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"File","slug":"File","permalink":"https://zbang.online/hexblog/tags/File/"},{"name":"ScheduledExecutorService","slug":"ScheduledExecutorService","permalink":"https://zbang.online/hexblog/tags/ScheduledExecutorService/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Java中变量的初始化顺序","slug":"Java中变量的初始化顺序","date":"2018-02-07T04:28:12.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/02/07/Java中变量的初始化顺序/","link":"","permalink":"https://zbang.online/hexblog/2018/02/07/Java中变量的初始化顺序/","excerpt":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因","text":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因 I. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） II. 静态变量初始化顺序类初始化时，会优先初始化静态成员，那么一个类中有多个静态成员时，如何处理的？ 下面是一个使用静态成员，静态代码块，静态方法的测试类，那么下面的输出应该是怎样的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 输出如下 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 从实际的输出结果来看： 初始化的顺序比较清晰了，压根就是根据初始化代码的先后顺序来的， 且在调用静态方法时，静态方法内部的静态成员已经被初始化 那么问题来了，如果在某个静态成员初始化的时候抛出了异常，会怎样？ 那么稍稍改一下上面的代码，加一个主动抛异常的case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; private static A aError = genError(); private static A genError() &#123; System.out.println(\"gen error!\"); throw new RuntimeException();// return new A(10); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 此时输出： 12345678a init! 1b init! 2gen A: 2a init! 2b init! 1gen error!Exception in thread \"main\" java.lang.ExceptionInInitializerErrorCaused by: java.lang.RuntimeException 也就是说，初始化异常之后的代码将不会在继续执行 那么第二个问题来了，前面说到哪个问题是什么情况 最开始说到，在调用类的静态方法时，发现本该被初始化的静态成员，依然是null，从上面的分析来说，唯一的可能就是在成员变量初始化的过程中，出现了异常 那么，就有另一个问题了，初始化就报错了，这个类的静态方法还能被调用执行么（加入这个静态方法不依赖内部的静态成员）？ 将前面的 genA()方法的private去掉，改成默认的访问范围，然后下面给出一个演示： 通过这个演示，也挺有意思的，第一次访问，会抛出一个初始化异常；但是再调用一次，结果发现居然正常执行了；但是调用public方法时，每次都是抛异常 导致这个问题的原因，还有待考究，但是前面这个问题的答案，估摸着和下面差不多了（但是不敢确定，有待大神指点） 理论上类初始化失败，应该就不允许被调用了 但是某些情况下，可以绕过这个限制 III. 成员变量的初始化测试case也比较简单，把前面的代码中的static去掉即可， 输出 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 依然是根据初始化代码的先后顺序进行的 当然如果出现异常的情况，和前面的结果类似，不再赘述 IV. 小结1. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） 相同等级的初始化的先后顺序，是直接依赖代码中初始化的先后顺序 2. 初始化异常时理论上，类初始化中抛出了异常，那么这个类将无法被classLoader正确的加载，因此也无法有效的使用这个类 但是不排除某些情况下，依然强行的使用了这个类（如上面gif图中的演示），这个原理还不太清晰，也有可能是idea的debug功能有什么黑科技？ 注意 因此，请格外注意，在初始化代码中，请确保不会有抛出异常，如果无法把控，不妨新建一个init()方法来实现初始化各种状态，然后在代码中主动调用好了 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://zbang.online/hexblog/tags/JDK/"},{"name":"Initialize","slug":"Initialize","permalink":"https://zbang.online/hexblog/tags/Initialize/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"SpringMVC统一异常处理","slug":"SpringMVC统一异常处理","date":"2018-02-04T11:21:15.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/02/04/SpringMVC统一异常处理/","link":"","permalink":"https://zbang.online/hexblog/2018/02/04/SpringMVC统一异常处理/","excerpt":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题","text":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题 I. 借助@ControllerAdvice拦截异常给一个简单的demo，便可以很容易的了解这种手段如何处理了 1234567891011121314151617181920@ControllerAdvice@Slf4j@ResponseBodypublic class ActionExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public String defaultHandler(HttpServletRequest request, Exception e) &#123; log.error(\"unexpected exception! request: &#123;&#125;, params: &#123;&#125; refer: &#123;&#125;, e: &#123;&#125;\", request.getRequestURI(), request.getParameterMap(), request.getHeader(\"referer\"), e); if (StringUtils.isBlank(e.getMessage())) &#123; return ResponseWrapper.errorReturn(new Status(500, \"内部异常\")); &#125; else &#123; return ResponseWrapper.errorReturn(new Status(500, e.getMessage())); &#125; &#125;&#125; 这里主要借助两个注解来实现，ControllerAdvice 和 ExceptionHandler II. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Exception","slug":"Exception","permalink":"https://zbang.online/hexblog/tags/Exception/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":" JavaWeb三大组件之Filter学习详解","slug":"JavaWeb三大组件之Filter学习详解","date":"2018-01-26T10:02:01.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/01/26/JavaWeb三大组件之Filter学习详解/","link":"","permalink":"https://zbang.online/hexblog/2018/01/26/JavaWeb三大组件之Filter学习详解/","excerpt":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项","text":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项 I. 基本知识Filter称之为过滤器，是用来做一些拦截的任务， 在Servlet接受请求之前，做一些事情，如果不满足限定，可以拒绝进入Servlet 从上面的图，可以看出一个Filter的工作流程: 一个http请求过来之后 首先进入filter，执行相关业务逻辑 若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方 判定失败，直接返回，不需要将请求发给Servlet 通过上面的流程，可以推算使用场景： 在filter层，来获取用户的身份 可以考虑在filter层做一些常规的校验（如参数校验，referer校验等） 可以在filter层做稳定性相关的工作（如全链路打点，可以在filter层分配一个traceId；也可以在这一层做限流等） 1. 基本使用姿势要使用一个Filter，一半需要两步，实现Filter接口的自定义类，web.xml中对filter的定义 1234567891011public interface Filter &#123; public void init(FilterConfig filterConfig) throws ServletException; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public void destroy();&#125; 主要就三个方法，从命名来看， 也比较清晰，在创建Filter对象的时候，调用 init 方法 销毁Filter对象的时候，调用 destroy 方法 当请求过来之后，调用 doFilter，也就是主要的业务逻辑所在了 详细case后面再说 接下来就是xml的配置了，和Servlet类似，每自定义一个，都需要在xml中加上一个配置（挺繁琐的操作的） 123456789101112131415161718&lt;!-- 解决乱码的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置也比较简单了，一个 一个 前者定义具体的Filter，后者表示这个Filter拦截的URL （看起来和Servlet的配置规则没什么两样） II. 实例我们的实例，就拿大名鼎鼎的CharacterEncodingFilter来说明，顺带膜拜下Spring的大神的优秀源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; public CharacterEncodingFilter() &#123; &#125; public CharacterEncodingFilter(String encoding) &#123; this(encoding, false); &#125; public CharacterEncodingFilter(String encoding, boolean forceEncoding) &#123; Assert.hasLength(encoding, \"Encoding must not be empty\"); this.encoding = encoding; this.forceEncoding = forceEncoding; &#125; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; public void setForceEncoding(boolean forceEncoding) &#123; this.forceEncoding = forceEncoding; &#125; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); System.out.printl(\"servelt 执行完成，又返回filter\"); &#125;&#125; 上面的实现比较简单，主要将视线集中在 doFilterInternal 方法内部，如果要设置编码参数，则直接修改 HttpServletRequest, HttpServletResponse 两个参数，操作完成之后，执行下面这一行 1filterChain.doFilter(request, response); 注意 上面这一行执行，表示Filter层已经通过了，请求可以转发给下一个Filter或者直接传给Servlet 而下一个Filter, Servlet执行完成之后，还会继续往下走，就是上面的那一行输出，也会被调用（那一行是我加的，源码中没有） 所以，如果你不希望继续往下走，那么就简单了，不执行上面的那一行即可 疑问问题一：看了上面的源码，一个很明显的问题就是，参数怎么设置的？ 仔细看上面的源码，发现自定义Filter是继承 org.springframework.web.filter.OncePerRequestFilter 而不是直接实现的 Filter 接口，而且方法内也没有显示的实现 init()方法，所有很容易猜到是父类中实现了参数的初始化过程 具体的实现逻辑是在 org.springframework.web.filter.GenericFilterBean#init 中，同样是Spring实现的，主要代码捞出来 12345678910111213141516171819202122232425262728293031public final void init(FilterConfig filterConfig) throws ServletException &#123; Assert.notNull(filterConfig, \"FilterConfig must not be null\"); if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing filter '\" + filterConfig.getFilterName() + \"'\"); &#125; this.filterConfig = filterConfig; // Set bean properties from init parameters. try &#123; PropertyValues pvs = new FilterConfigPropertyValues(filterConfig, this.requiredProperties); BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(filterConfig.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment)); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; String msg = \"Failed to set bean properties on filter '\" + filterConfig.getFilterName() + \"': \" + ex.getMessage(); logger.error(msg, ex); throw new NestedServletException(msg, ex); &#125; // Let subclasses do whatever initialization they like. initFilterBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Filter '\" + filterConfig.getFilterName() + \"' configured successfully\"); &#125;&#125; 看上面一大串的代码，到底干了嘛？ 简单来讲，就是获取xml中配置的参数，然后填充到Filter对象中（对Srping而言，CharacterEncodingFilter就是一个bean），这个具体的逻辑和本篇关系不大，就直接跳过了 问题二：在Filter层中可以获取参数么 从doFilter的方法签名中看，既然有Request参数，那么应该是可以获取到请求参数的，那么实际验证一下 先实现一个最最最简单的Filter 123456789101112131415161718public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in filter\"); System.out.println(\"args: \" + JSON.toJSONString(request.getParameterMap())); chain.doFilter(request, response); System.out.println(\"out filter\"); &#125; @Override public void destroy() &#123; &#125;&#125; 开始测试 1curl -d 'name=Hello&amp;password=world' http://127.0.0.1:8088/123 输出如下 123in filterargs: &#123;\"name\":[\"Hello\"],\"password\":[\"world\"]&#125;out filter 注意 在Filter中获取参数时，最好不要直接使用获取请求流的方式，如果获取请求流，那么Servlet就获取不到请求参数了 问题三：多个filter的顺序怎么定 前面学习Servlet的时候，也有这个问题，一个URL被多个Servlet命中了，那么先后顺序是怎样的呢？ 精确匹配 &gt; 最长匹配 &gt; 其他模糊匹配 &gt; 没有匹配的则是404 那么Filter呢，他们的区别还是比较明显的，很多Filter都是拦截所有的请求，即很多Filter的命中规则都是一样的，那么怎么办？ 先执行带有url-pattern标签的filter，再执行带有servlet-name标签的filter 如果同为url-pattern或servlet-name，则会按照在web.xml中的声明顺序执行 测试case如下，我们定义三个Filter： TestFilter: 匹配所有路径 ATestFilter: 匹配所有路径 ServletFilter: 匹配 mvc-servlet 123456789101112131415161718192021// ATestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ATestFilter\"); chain.doFilter(request, response);&#125;// TestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in TestFilter\"); chain.doFilter(request, response);&#125;// ServletFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ServletFilter\"); chain.doFilter(request, response);&#125; 对应的xml配置如下 123456789101112131415161718192021222324252627282930&lt;filter&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ServletFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.TestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ATestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 输出结果 123in TestFilterin ATestFilterin ServletFilter III. 小结Filter 通常用于JavaWeb的过滤使用，通过doFilter方法中执行 chain.doFilter(request, response);，进入下一个Filter或者Servlet执行逻辑，当执行完成之后，依然会回到Filter这一层，继续走下去 针对上面的逻辑，Filter的常见应用场景有： 用户信息获取，身份校验 安全校验（referer校验失败，直接拒绝） 稳定性相关（限流，监控埋点，全链路日志埋点） Filter的执行顺序： url-mapping 的优先执行，其次是 servlet-mapping 同一个匹配方式（如都是url-mapping）中，根据在xml中定义的先后顺序来确定 Filter的注意事项： 正常业务，请记得一定执行 chain.doFilter(request, response)， 最后把它放在finnal块中，防止你在Filter中的代码抛异常导致进入不到后续的逻辑 在Filter中不要直接获取请求数据流（请求流被读取完之后，Servlet就get不到了!） IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Filter","slug":"Filter","permalink":"https://zbang.online/hexblog/tags/Filter/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"JavaWeb三大组件之Servlet学习","slug":"JavaWeb三大组件之Servlet学习","date":"2018-01-24T01:55:49.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/01/24/JavaWeb三大组件之Servlet学习/","link":"","permalink":"https://zbang.online/hexblog/2018/01/24/JavaWeb三大组件之Servlet学习/","excerpt":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置","text":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置 I. 基本知识点1. 什么是ServletServlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 接受请求 处理请求 完成响应 2. 怎么玩Servlet一般来讲，创建一个自定义的Servlet有两个步骤，在web.xml中配置serverlt的声明；实现Servlet接口，实现自定义的Servlet逻辑 一个简单的case如下 web.xml中，添加配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实现自定义Servlet 1234567891011public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125;&#125; 上面这个Servlet，实现了拦截 /study 下的所有请求， 然后返回一段文本，上面作为演示，具体的展开下面说明 3. Servlet接口说明上面是直接继承了HttpServlet，可能没法完全的暴露一个Servlet的具体接口有哪些，以及它的生命周期是怎样的，接下来则直接针对源头进行说明 1234567891011121314151617public interface Servlet &#123; // 初始化 public void init(ServletConfig config) throws ServletException; // 获取配置信息 public ServletConfig getServletConfig(); // 处理请求 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; // Returns information about the servlet, such as author, version, and copyright public String getServletInfo(); // 销毁 public void destroy();&#125; 五个方法，从命名也可以看出对应的生命周期 首先是创建： init() 方法被创建 创建完毕之后，请求来了，分给 service方法，执行对应的业务逻辑 最后不想玩了，就销毁掉，此时触发 destroy方法 说明 在Servlet被创建后，服务器会马上调用Servlet的void init(ServletConfig)方法。请记住， Servlet出生后马上就会调用init()方法，我们可以把一些对Servlet的初始化工作放到init方法中，今后所有分配到这个Servlet的请求，都是公用这个Servlet的 4. ServletConfig init()方法的参数 ServletConfig对象对应web.xml文件中的元素。例如你想获取当前Servlet在web.xml文件中的配置名，那么可以使用servletConfig.getServletName()方法获取 1234String getServletName()：获取Servlet在web.xml文件中的配置名称，即指定的名称； ServletContext getServletContext()：用来获取ServletContext对象，ServletContext会在后面讲解； String getInitParameter(String name)：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames()：用来获取在web.xml中配置的所有初始化参数名称； 5. ServletRequest 请求对象，可以从其中获取请求数据，请求头等 内部提供的方法挺多，通常我们最关心的有: 获取参数: javax.servlet.ServletRequest#getParameter 获取头 : javax.servlet.http.HttpServletRequest#getHeader 获取cookie: javax.servlet.http.HttpServletRequest#getCookies 获取请求 : javax.servlet.http.HttpServletRequest#getRequestURI … 还有一个比较重要的就是指定字符编码，如我们通常要求提交的参数满足utf8编码，这时就可以如下设置 12// javax.servlet.ServletRequest#setCharacterEncodingrequest.setCharacterEncoding(&quot;utf-8&quot;); 如我们最常用的一个spring的fitler，关键代码如下 123456789101112131415// org.springframework.web.filter.CharacterEncodingFilter#doFilterInternal// @Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response);&#125; 6. ServletResponse 返回对象，返回响应给调用方的结构，设置返回头 返回数据给调用方，主要就是利用这个东西了，内部提供的方法也不少，我们主要关心的其实也并不太多 设置返回头：javax.servlet.http.HttpServletResponse#setHeader 添加cookie: javax.servlet.http.HttpServletResponse#addCookie 重定向 : javax.servlet.http.HttpServletResponse#sendRedirect 异常 : javax.servlet.http.HttpServletResponse#sendError 设置ContentType: javax.servlet.ServletResponse#setContentType 设置返回流: javax.servlet.ServletResponse#getOutputStream, javax.servlet.ServletResponse#getWriter 设置编码: javax.servlet.ServletResponse#setCharacterEncoding II. 进阶1. web.xml中配置 这个配置，主要针对 Servlet 的顺序指定，URL匹配这两个问题，所以有必要研究下这个配置中的说明 通常web.xml的配置，下面两个是必须的 1234567891011121314&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.xxx.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中 servlet-mapping 指定映射的路径，满足条件的会匹配对应的Servlet，匹配规则有以下几个定义 必须 / 开头 /servlet 表示精确匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlets 不匹配 http://localhost:8088/servlet/123 不匹配 /servlet/* 表示目录匹配，所有servlet路径开头的都可以匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlet/123 匹配 http://localhost:8088/servlet/123/123 匹配 http://localhost:8088/servlets 不匹配 /*.do 表示扩展名匹配，所有以 .do 结尾的匹配 既然这个url匹配支持模糊匹配，那么问题来了，如果两个servlet都匹配了这个path路径，那么到底是哪个处理呢？ 注意到前面有个配置参数：load-on-startup 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet； 当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载 正数的值越小，启动该servlet的优先级越高 注意 这个参数是加载顺序，而不是最终的匹配顺序 那么匹配顺序的优先级是： 精确路径匹配 比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了 最长路径匹配 servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源，即匹配defaultServlet 2. 参数获取 参数获取，则主要区分get请求参数，post提交表单，上传的文件了 a. 通过 getQueryString这种获取参数的方式，只能获取url上面的参数，无法获取到post的表单内容 1String str = req.getQueryString(); b. 通过 getParameter12// 返回所有的请求参数javax.servlet.ServletRequest#getParameterMap 这种使用姿势，和我们在SpringMVC中常见的基本一致 c. 通过 getInputStream获取请求流，一般的使用姿势如下 1234InputStream stream = req.getInputStream();byte[] bytes = new byte[stream.available()];stream.read(bytes);String str = new String(bytes); 然后就需要自己对上面的请求参数进行处理了；两厢对比，常规的获取方法，直接使用 getParameter方式更加优雅 注意 通过getInputStream方式获取了请求数据之后，再通过 getParameter获取不到参数的，也好理解，请求的流，被你读取之后，其他的地方就无法获取流中的数据了 d. 获取上传的文件从请求参数中获取上传的文件，网上随意搜索了一下，发现大部分都使用apache的fileupload包， 其实处理的依然是inputstream这个请求流，只是逻辑比较复杂，粗略的翻看了一下源码，发现这一块还挺有意思的，准备单独的深入看一下 3. 数据返回返回数据，前面介绍HttpServletResponse的时候，就给出了两个方法 a. getWriter1public PrintWriter getWriter() throws IOException; b. getOutputStream1public ServletOutputStream getOutputStream() throws IOException; 下面简单说一下上面的区别 PrintWriter ServletOutputStream 字符流返回 字节流返回 需要字符编码 字节流直接返回（返回文件就很占优势了） 说明 上面两种方式互斥，只能使用其中一种case Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象 4. 返回头设置常见的请求头和返回头设置，对于servlet而言也是比较常见的，一般常见的几个设置 是否缓存，缓存时间 设置cookie 设置 corss-origin 相关，以支持跨域 设置 content-type… 而实际的使用也比较简单了，如下即可 12# javax.servlet.http.HttpServletResponse#addHeaderresponse.addHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); III. 实例测试创建一个自定义的嗯Servlet，然后拦截所有 /study 下面的请求 1234567891011121314151617public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; Map map = req.getParameterMap(); System.out.println(\"arg: \" + map); res.getWriter().append(\"success\").flush(); &#125;&#125; 对应的xml配置如下 123456789 &lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实测演示： IV. 其他参考 servlet详解(第一篇) 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zbang.online/hexblog/tags/Servlet/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"Android学习之旅1D:首屏页的开发","slug":"Android学习之旅1D-首屏页的开发","date":"2018-01-22T12:16:18.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/22/Android学习之旅1D-首屏页的开发/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/Android学习之旅1D-首屏页的开发/","excerpt":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程","text":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程 I. 前置主要copy两个开源项目 JianshuApp SUESNews 上面两个工程，第二个用到的依赖比较少，实现的基本功能也都很ok，而第一个里面则用了很多有意思的第三方框架，但是目前我看不太懂，所以第一版以SUESNews作为主要的学习目标 所以，第一版的目标是： 实现基本功能 完成主体业务逻辑 II. Splash页面开发一般来将，进入app之前，会进入一个类似首屏页的页面（比如12306的显示广告啥的），那么第一件事情就是做这个了 1. 做什么这个页面，主要显示的东西比较简单了 上边是一个图片，右上角一个倒计时 下边显示的应用信息，版本等 业务逻辑： 显示广告（😄），点击进入相应的详情页 判断是否登录，若未登录，则进入登录页 若已经登录，则进入主APP 2. 开动a. 全屏进入的首页，所以状态栏，标题啥的都不要，主要的逻辑如下 styles.xml 文件中新增 1234&lt;style name=\"AppTheme.FullScreen\"&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 其次，就是在定义的Activity中，使用对应的style AndroidManifest.xml 1234567&lt;activity android:name=\".ui.SplashActivity\" android:theme=\"@style/AppTheme.FullScreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; b. xml实现activity_splash.xml 对应的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" tools:context=\"com.yihui.yifeng.ui.SplashActivity\"&gt; &lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignBottom=\"@+id/title_text\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt; &lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:textStyle=\"bold\" tools:text=\"Copyright @2017-2018 一封 | 小灰灰技术支持\" /&gt;&lt;/RelativeLayout&gt; 运行截图如下： 上面这个布局，是直接使用可视化的拖拽的，所以操作起来挺蛋疼的，而且最终的结果也不太好，下面单独的开一节来研究下这个布局的东西了 c. Activity的实现上面是xml的配置，当然还得有对应的实体类了，大部分逻辑是直接从参考的工程中copy过来的，所以相关的动画配置，图片也是直接扣过来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SplashActivity extends Activity &#123; private ImageView mBackgroundImage; private ImageView infoBgImg; private TextView mTitleText; private TextView mVersionText; private int[] ary = new int[] &#123;R.drawable.pic_background_1, R.drawable.pic_background_2, R.drawable.pic_background_3, R.drawable.pic_background_4&#125;; private int getBgDrawable() &#123; return ary[new Random().nextInt(ary.length)]; &#125; private void initInfoBg() &#123; infoBgImg = findViewById(R.id.image_info_bg); infoBgImg.setImageDrawable(getResources().getDrawable(ary[0])); &#125; private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome); mBackgroundImage.startAnimation(animImage); animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); // 下半的提示文案信息 initInfoBg(); // 上半的广告动画 initAdBg(); &#125;&#125; todo登录状态判断，如果未登录，则应该跳转到登录页面；否则才是跳转到主页 III. 知识点小结上面只是实现了一个简单的应用开启页面，但也涉及了几个有趣的知识点，下面来深入一下 1. RelativeLayout 布局控件的位置是按照相对位置来计算的，后一个控件在什么位置依赖于前一个控件的基本位置，是布局最常用，也是最灵活的一种布局 常见的属性值 123456789101112131415161718192021222324第一类:属性值为true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中android:layout_alignParentBottom 贴紧父元素的下边缘android:layout_alignParentLeft 贴紧父元素的左边缘android:layout_alignParentRight 贴紧父元素的右边缘android:layout_alignParentTop 贴紧父元素的上边缘 第二类：属性值必须为id的引用名“@id/id-name”android:layout_below 在某元素的下方android:layout_above 在某元素的的上方android:layout_toLeftOf 在某元素的左边android:layout_toRightOf 在某元素的右边android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐第三类：属性值为具体的像素值，如30dip，40pxandroid:layout_marginBottom 离某元素底边缘的距离android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离 所以可以简单的修改一下上面的布局，相对布局的样式就两个，上面一个图，下面一个图 1234567891011121314151617181920&lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行 --&gt; android:layout_alignBottom=\"@+id/image_info_bg\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt;&lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行，确保背景图可以包含文本信息 --&gt; android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; 那么剩下的两个文本显示就可以直接指定下边距来确定位置了 123456789101112131415161718192021222324&lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt;&lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:text=\"@string/splash_copyright\" /&gt; 2. 获取组件在Activity中，先要绑定视图，然后再获取view进行相关的操作（如修改值，绑定事件等） 12345678910// Activity 的 oncreate方法中，进行初始化// 绑定视图super.onCreate(savedInstanceState);setContentView(R.layout.activity_splash);// 获取组件findViewById(R.id.image_info_bg);// 获取资源，如图片Drawable drawable = getResources().getDrawable(R.drawable.pic_background_1) 有一个非常有名的工具叫做 butterknife, 可以通过注解的方式来解决 findViewById这种频繁的调用姿势，这个放在后续的进阶版中使用 3. 设置动画开屏使用了一个图片放大的动画，持续3s，动画播放完毕之后跳转主页；所以这里有个有趣的知识点就是如何使用xml来配置动画效果，从实现来看也挺简单的 123456789101112131415161718192021222324// 解析xml配置为 Animation 对象Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome);// 设置组件的动画属性mBackgroundImage.startAnimation(animImage);// 配置监听事件animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; // 动画结束后的回调 @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;); 对应的xml配置如下 image_welcome.xml 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:fromXScale=\"1.0\" android:toXScale=\"1.3\" android:fromYScale=\"1.0\" android:toYScale=\"1.3\" android:duration=\"3000\" android:pivotY=\"50%\" android:pivotX=\"50%\" /&gt;&lt;/set&gt; 那么，我们需要实现开头说的，这个图片如果是个广告，点击时展开详情页；右上角显示一个倒计时的小控件，可以怎么处理？（看最后） 4. 页面跳转从一个Activity跳转到另一个，常见的使用姿势如下 1startActivity(new Intent(SplashActivity.this, MainActivity.class)); IV. 倒计时改进如何使用倒计时来替换前面的动画呢？最容易想到的就是用Timer或者ScheduleService来实现一个计时器，当然这是一个后端java的想法，对于Android呢，特意查了一下，发现有个 CountDownTimer 的类，专门干这个的，所以简单的改造一下 12345678910111213141516171819202122232425262728private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); mBackgroundImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 点击 Toast.makeText(SplashActivity.this, \"点击了\", Toast.LENGTH_SHORT).show(); &#125; &#125;); final TextView countDown = findViewById(R.id.splash_timedown); CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long l) &#123; countDown.setText(\"倒计时:\" + (l / 1000) + \"s\"); &#125; @Override public void onFinish() &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; &#125;; timer.start();&#125; 改造后的输出图, 注意右上角的时间，已经下面分割处，不会有前面的空白了 V. 其他额外话感觉最近不太能专心下来学习一门技术，有点浮躁了，所以决定学习下andorid，锻炼下自己，初步规划，先入门，然后接收一些有趣的第三方框架，最后再试一下kotalin Android学习第一天，总感觉这将是个漫长的过程，也不晓得最终会完成得怎么样，努力坚持吧 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/tags/Android/"},{"name":"一封","slug":"一封","permalink":"https://zbang.online/hexblog/tags/一封/"},{"name":"RelativeLayout","slug":"RelativeLayout","permalink":"https://zbang.online/hexblog/tags/RelativeLayout/"},{"name":"CountDownTimer","slug":"CountDownTimer","permalink":"https://zbang.online/hexblog/tags/CountDownTimer/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}]},{"title":"兼容ImageIO读取jpeg图片变红","slug":"兼容ImageIO读取jpeg图片变红","date":"2018-01-22T06:38:39.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/01/22/兼容ImageIO读取jpeg图片变红/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/兼容ImageIO读取jpeg图片变红/","excerpt":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case","text":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case 问题重现有问题的图片： 测试验证代码 123456789101112/** * 图片读取之后，颜色变红的测试 */@Testpublic void testLoadRedImg() throws IOException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); BufferedImage bf = ImageIO.read(u); ImageIO.write System.out.println(\"--over--\");&#125; debug截图如下： 问题兼容不实用ImageIO来加载图片，改用Toolkit来实现图片读取，然后再将读取到的图片绘制到BufferedImage对象上 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void testLoadRedImg2() throws MalformedURLException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); Image img = Toolkit.getDefaultToolkit().getImage(u); BufferedImage bf = toBufferedImage(img); System.out.println(\"eeee\");&#125;static BufferedImage toBufferedImage(Image image) &#123; if (image instanceof BufferedImage) &#123; return (BufferedImage) image; &#125; // This code ensures that all the pixels in the image are loaded image = new ImageIcon(image).getImage(); BufferedImage bimage = null; GraphicsEnvironment ge = GraphicsEnvironment .getLocalGraphicsEnvironment(); try &#123; int transparency = Transparency.OPAQUE; GraphicsDevice gs = ge.getDefaultScreenDevice(); GraphicsConfiguration gc = gs.getDefaultConfiguration(); bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency); &#125; catch (HeadlessException e) &#123; // The system does not have a screen &#125; if (bimage == null) &#123; // Create a buffered image using the default color model int type = BufferedImage.TYPE_INT_RGB; bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); &#125; // Copy image to buffered image Graphics g = bimage.createGraphics(); // Paint the image onto the buffered image g.drawImage(image, 0, 0, null); g.dispose(); return bimage;&#125; 实测验证 为什么会出现这个问题： ImageIO.read()方法读取图片时可能存在不正确处理图片ICC信息的问题，ICC为JPEG图片格式中的一种头部信息，导致渲染图片前景色时蒙上一层红色。 其他参考 Java处理某些图片红色问题 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/tags/BugFix/"},{"name":"BufferedImage","slug":"BufferedImage","permalink":"https://zbang.online/hexblog/tags/BufferedImage/"},{"name":"Jpeg","slug":"Jpeg","permalink":"https://zbang.online/hexblog/tags/Jpeg/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"Batik渲染png图片异常的bug修复","slug":"Batik渲染png图片异常的bug修复","date":"2018-01-20T12:36:56.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/20/Batik渲染png图片异常的bug修复/","link":"","permalink":"https://zbang.online/hexblog/2018/01/20/Batik渲染png图片异常的bug修复/","excerpt":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程","text":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程 I. 问题重现svg文件: 123456&lt;svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;image y=\"0\" width=\"100%\" height=\"100%\" x=\"0\" xlink:href=\"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"/&gt; &lt;!--xlink:href=\"https://s17.mogucdn.com/mlcdn/c45406/180119_46ld8kkb54d3el06hela5d61e18f5_1024x966.png\"/&gt;--&gt; &lt;!--xlink:href=\"http://avatar.csdn.net/A/8/B/3_u010889145.jpg\"/&gt;--&gt;&lt;/svg&gt; 依次测试了三个图片，两个png，一个jpg，很不幸第一个png会抛异常 输出的堆栈信息如 12345678910111213141516The URI \"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"on element &lt;image&gt; can't be opened because:PNG URL is corrupt or unsupported variant at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) at org.apache.batik.bridge.SVGImageElementBridge.buildImageGraphicsNode(SVGImageElementBridge.java:180) at org.apache.batik.bridge.SVGImageElementBridge.createGraphicsNode(SVGImageElementBridge.java:122) at org.apache.batik.bridge.GVTBuilder.buildGraphicsNode(GVTBuilder.java:213) at org.apache.batik.bridge.GVTBuilder.buildComposite(GVTBuilder.java:171) at org.apache.batik.bridge.GVTBuilder.build(GVTBuilder.java:82) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:208) at org.apache.batik.transcoder.image.ImageTranscoder.transcode(ImageTranscoder.java:92) at org.apache.batik.transcoder.XMLAbstractTranscoder.transcode(XMLAbstractTranscoder.java:142) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:156) ... II. 问题定位及分析既然出现了这个问题，那么就要去修复解决了，当然遇到这么鬼畜的问题，最常见的几个步骤： 其他人遇到过么 （问百度） – 结果度娘没有给出任何有效的建议，也没有搜到任何有用的信息 然后问谷歌，靠谱了一点，至少有些相关的主题了，但建设性的意见也没收到 外援实在找不到，只能debug查问题了 1. DEBUG的一路通过上面的堆栈信息，可以想见，debug的几个地方也和明确了，首先定位到下面这一行 1at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) 为什么这么干？因为首先得确认下这个异常是怎么抛出来的，逆向推，直接看源码，发现直接抛出异常 再往上走 1at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) 所以说因为这个if条件判断成立，导致进入了这个异常逻辑，判断的逻辑也没啥好说的，现在的关键是这个参数对象img是怎么来的 1at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) 然后就稍微清晰一点了，直接将火力放在下面的方法中 12345org.apache.batik.ext.awt.image.spi.ImageTagRegistry#readURL(java.io.InputStream, org.apache.batik.util.ParsedURL, org.apache.xmlgraphics.java2d.color.ICCColorSpaceWithIntent, boolean, boolean) 在这个方法内部，也没什么好说的，单步多调几次，就能发现异常的case是怎么来的了，省略掉中间各种单步debug的过程，下面直接进入关键链路 2. 火力全开，问题定位1org.apache.batik.ext.awt.image.codec.imageio.AbstractImageIORegistryEntry 通过上面的一路之后，发现最终的关键就是上面这个抽象类，顺带也可以看下这个抽象类的几个子类，有JPEGxxx, PNGxxx, TIFFxxx，然后问题来了，都已经有相关实现了，所以png讲道理应该是会支持的才对吧，但和实际的表现太不一样了吧，所以有必要撸一把源码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Filter handleStream(InputStream inIS, ParsedURL origURL, boolean needRawData) &#123; final DeferRable dr = new DeferRable(); final InputStream is = inIS; final String errCode; final Object [] errParam; if (origURL != null) &#123; errCode = ERR_URL_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName(), origURL&#125;; &#125; else &#123; errCode = ERR_STREAM_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName()&#125;; &#125; Thread t = new Thread() &#123; @Override public void run() &#123; Filter filt; try&#123; Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReadersByMIMEType( getMimeTypes().get(0).toString()); if (!iter.hasNext()) &#123; throw new UnsupportedOperationException( \"No image reader for \" + getFormatName() + \" available!\"); &#125; ImageReader reader = iter.next(); ImageInputStream imageIn = ImageIO.createImageInputStream(is); reader.setInput(imageIn, true); int imageIndex = 0; dr.setBounds(new Rectangle2D.Double (0, 0, reader.getWidth(imageIndex), reader.getHeight(imageIndex))); CachableRed cr; //Naive approach possibly wasting lots of memory //and ignoring the gamma correction done by PNGRed :-( //Matches the code used by the former JPEGRegistryEntry, though. BufferedImage bi = reader.read(imageIndex); cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image); filt = new RedRable(cr); &#125; catch (IOException ioe) &#123; // Something bad happened here... filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; catch (ThreadDeath td) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); dr.setSource(filt); throw td; &#125; catch (Throwable t) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; dr.setSource(filt); &#125; &#125;; t.start(); return dr;&#125; 看上面的实现是一个非常有意思的事情， 开了一个线程做事情，而且直接就返回了，相当于给了别人一个储物箱的钥匙，虽然现在储物箱是空的，但是回头我会填满的 言归正传，主要的业务逻辑就在这个线程里了，核心的几行代码就是 123456789101112// 加载图片，转为BufferedImage对象BufferedImage bi = reader.read(imageIndex);cr = GraphicsUtil.wrap(bi);// 下面实现对图片的ARGB进行修改cr = new Any2sRGBRed(cr);cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre);WritableRaster wr = (WritableRaster)cr.getData();ColorModel cm = cr.getColorModel();BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null);cr = GraphicsUtil.wrap(image);filt = new RedRable(cr); debug上面的几行代码，发现问题比较明显了，就是这个图片的转换跪了，至于为啥？ java的图片各种蛋疼至极，这里面的逻辑，真心搞不进去，so深挖到此为止 III. 兼容逻辑问题定位到了，当然就是想办法来修复了，简单来说，需要兼容的就是图片的类型转换上了，直接用原来的可能会抛异常，所以做了一个简单的兼容逻辑 12345678910111213141516if(bi.getType() == BufferedImage.TYPE_BYTE_INDEXED) &#123; BufferedImage image = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = image.createGraphics(); g2d.drawImage(bi, 0, 0, null); g2d.dispose(); cr = GraphicsUtil.wrap(image);&#125; else &#123; cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image);&#125; 再次验证，ok 注意： 一个问题来了，上面的兼容是需要修改源码的，我们可以怎么办？有几种解决方法 猥琐方法一：down下源码，修改版本，然后传到自己的私服，使用自己的vip包 猥琐方法二：把 batik-codec 工程原样拷贝到自己的项目中，就可以随意的使用改了 猥琐方法三：写一个完全相同的类（包路径完全相同），然后构造一个自定义类加载器，加载这个自己的这个兼容版本的，替换原来的（未测试，不确定是否能行） 至于我的选择，就是使用了猥琐方法二 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"https://zbang.online/hexblog/tags/Bugfix/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"batik","slug":"batik","permalink":"https://zbang.online/hexblog/tags/batik/"},{"name":"Png","slug":"Png","permalink":"https://zbang.online/hexblog/tags/Png/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"SpringMVC支持跨域的几种姿势","slug":"SpringMVC支持跨域的几种姿势","date":"2018-01-19T07:43:38.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/19/SpringMVC支持跨域的几种姿势/","link":"","permalink":"https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/","excerpt":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数","text":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数 I. Jsonp的支持jsonp的请求表现方式就是url里面会多一个参数 callback，一般如下 1callback=jQuery21105810685605043302_1516257942328 jsonp的返回与一般调用方式的返回也会有点区别，会在外面包装一层，如 1jQuery21105810685605043302_1516257942328(...); springmvc中，jsonp的支持却是比较简单了，不需要对现有的接口进行任何处理，只需要像下面这么玩即可 123456@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super(\"callback\"); &#125;&#125; 分析说明首先是利用了注解 @ControllerAdvice ， 这个注解在后面说到的统一异常处理时，也会用到，从命名也可以看出，就是为Controller添加一个切面，简单来讲，就是在直接返回数据前，对返回的结果包装一把；从实现也可以看出，主要的逻辑就在 AbstractJsonpResponseBodyAdvice 里面，所以有必要看一下这个东西是怎么支持的了 核心的代码逻辑就是 123456789101112131415161718192021222324@Overrideprotected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) &#123; HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest(); for (String name : this.jsonpQueryParamNames) &#123; String value = servletRequest.getParameter(name); if (value != null) &#123; if (!isValidJsonpQueryParam(value)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Ignoring invalid jsonp parameter value: \" + value); &#125; continue; &#125; // 下面三行是主要的逻辑 MediaType contentTypeToUse = getContentType(contentType, request, response); response.getHeaders().setContentType(contentTypeToUse); bodyContainer.setJsonpFunction(value); break; &#125; &#125;&#125; 直接看可能看不太明白究竟做了什么，写了个测试，debug下相关的参数如下 即，修改返回的 content-type 为： application/javascript 返回的Container里面设置了jsonpFunction，为请求参数的value，至于是在什么时候封装的返回结果呢？这个有待后续补全 II. 支持cors跨域 Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求 1. 背景CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否 所以问题就来了，安全如何保证？ 一般而言，为了避免夸站点攻击(csrf)，常见的手段无非： 身份校验（比如要求用户登录） token验证 ip白名单 来源referer校验 频率限制 2. 实现方式要支持csrf，也比较简单了，无非就是设置下responseHeader了, 一般需要设置以下几项 Access-Control-Allow-Origin: *; // 允许的来源 Access-Control-Allow-Methods: GET, POST, PUT, DELETE Access-Control-Allow-Credentials: true Access-Control-Allow-Headers: Content-Type Access-Control-Max-Age: 1800 //30 min 所以实现起来的方式就比较多了，一个是新增一个filter，主动设置下返回头，当然spring mvc提供了更友好的方式了 常见的几种手段如下: a. xml配置方式12345&lt;mvc:cors&gt; &lt;mvc:mapping path=\"/ajax/*\" allowed-origins=\"*\" max-age=\"3600\" /&gt;&lt;/mvc:cors&gt; b. 注解方式在controller方法上，添加下面这个注解即可 12345@CrossOrigin(origins = \"*\")@RequestMapping(value = &#123;\"xx\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)public ResponseWrapper&lt;WxBaseResponse&gt; create(HttpServletRequest httpServletRequest) &#123;&#125; c. 直接修改返回的responseHeader123response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"origin\"));response.setHeader(\"Access-Control-Allow-Methods\", \"*\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); III. 小结上面介绍了两种方式，支持起来都比较简单 jsonp: 通过ControllerAdvice拦截Controller，然后继承AbstractJsonpResponseBodyAdvice即可 cors: 通过xml配置或者直接使用 @CrossOrigin注解 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Jsonp","slug":"Jsonp","permalink":"https://zbang.online/hexblog/tags/Jsonp/"},{"name":"CORS","slug":"CORS","permalink":"https://zbang.online/hexblog/tags/CORS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"SpringMVC返回图片的几种方式","slug":"SpringMVC返回图片的几种方式","date":"2018-01-18T03:13:22.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/18/SpringMVC返回图片的几种方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/18/SpringMVC返回图片的几种方式/","excerpt":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？","text":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？ I. 返回二进制图片主要借助的是 HttpServletResponse这个对象，实现case如下 1234567891011121314@RequestMapping(value = &#123;\"/img/render\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@CrossOrigin(origins = \"*\")@ResponseBodypublic String execute(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; // img为图片的二进制流 byte[] img = xxx; httpServletResponse.setContentType(\"image/png\"); OutputStream os = httpServletResponse.getOutputStream(); os.write(img); os.flush(); os.close(); return \"success\";&#125; 注意事项 注意ContentType定义了图片类型 将二进制写入 httpServletResponse#getOutputStream 写完之后，flush(), close()请务必执行一次 II. 返回图片的几种方式封装一般来说，一个后端提供的服务接口，往往是返回json数据的居多，前面提到了直接返回图片的场景，那么常见的返回图片有哪些方式呢？ 返回图片的http地址 返回base64格式的图片 直接返回二进制的图片 其他…（我就见过上面三种，别的还真不知道） 那么我们提供的一个Controller，应该如何同时支持上面这三种使用姿势呢？ 1. bean定义因为有几种不同的返回方式，至于该选择哪一个，当然是由前端来指定了，所以，可以定义一个请求参数的bean对象 123456789101112131415161718192021222324252627282930@Datapublic class BaseRequest &#123; private static final long serialVersionUID = 1146303518394712013L; /** * 输出图片方式: * * url : http地址 （默认方式） * base64 : base64编码 * stream : 直接返回图片 * */ private String outType; /** * 返回图片的类型 * jpg | png | webp | gif */ private String mediaType; public ReturnTypeEnum returnType() &#123; return ReturnTypeEnum.getEnum(outType); &#125; public MediaTypeEnum mediaType() &#123; return MediaTypeEnum.getEnum(mediaType); &#125;&#125; 为了简化判断，定义了两个注解，一个ReturnTypeEnum, 一个 MediaTypeEnum， 当然必要性不是特别大，下面是两者的定义 12345678910111213141516171819202122232425262728293031public enum ReturnTypeEnum &#123; URL(\"url\"), STREAM(\"stream\"), BASE64(\"base\"); private String type; ReturnTypeEnum(String type) &#123; this.type = type; &#125; private static Map&lt;String, ReturnTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(3); for(ReturnTypeEnum e: ReturnTypeEnum.values()) &#123; map.put(e.type, e); &#125; &#125; public static ReturnTypeEnum getEnum(String type) &#123; if (type == null) &#123; return URL; &#125; ReturnTypeEnum e = map.get(type.toLowerCase()); return e == null ? URL : e; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@Datapublic enum MediaTypeEnum &#123; ImageJpg(\"jpg\", \"image/jpeg\", \"FFD8FF\"), ImageGif(\"gif\", \"image/gif\", \"47494638\"), ImagePng(\"png\", \"image/png\", \"89504E47\"), ImageWebp(\"webp\", \"image/webp\", \"52494646\"), private final String ext; private final String mime; private final String magic; MediaTypeEnum(String ext, String mime, String magic) &#123; this.ext = ext; this.mime = mime; this.magic = magic; &#125; private static Map&lt;String, MediaTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(4); for (MediaTypeEnum e: values()) &#123; map.put(e.getExt(), e); &#125; &#125; public static MediaTypeEnum getEnum(String type) &#123; if (type == null) &#123; return ImageJpg; &#125; MediaTypeEnum e = map.get(type.toLowerCase()); return e == null ? ImageJpg : e; &#125;&#125; 上面是请求参数封装的bean，返回当然也有一个对应的bean 1234567891011121314151617181920@Datapublic class BaseResponse &#123; /** * 返回图片的相对路径 */ private String path; /** * 返回图片的https格式 */ private String url; /** * base64格式的图片 */ private String base;&#125; 说明： 实际的项目环境中，请求参数和返回肯定不会像上面这么简单，所以可以通过继承上面的bean或者自己定义对应的格式来实现 2. 返回的封装方式既然目标明确，封装可算是这个里面最清晰的一个步骤了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void buildResponse(BaseRequest request, BaseResponse response, byte[] bytes) throws SelfError &#123; switch (request.returnType()) &#123; case URL: upload(bytes, response); break; case BASE64: base64(bytes, response); break; case STREAM: stream(bytes, request); &#125;&#125;private void upload(byte[] bytes, BaseResponse response) throws SelfError &#123; try &#123; // 上传到图片服务器，根据各自的实际情况进行替换 String path = UploadUtil.upload(bytes); if (StringUtils.isBlank(path)) &#123; // 上传失败 throw new InternalError(null); &#125; response.setPath(path); response.setUrl(CdnUtil.img(path)); &#125; catch (IOException e) &#123; // cdn异常 log.error(\"upload to cdn error! e:&#123;&#125;\", e); throw new CDNUploadError(e.getMessage()); &#125;&#125;// 返回base64private void base64(byte[] bytes, BaseResponse response) &#123; String base = Base64.getEncoder().encodeToString(bytes); response.setBase(base);&#125;// 返回二进制图片private void stream(byte[] bytes, BaseRequest request) throws SelfError &#123; try &#123; MediaTypeEnum mediaType = request.mediaType(); HttpServletResponse servletResponse = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse(); servletResponse.setContentType(mediaType.getMime()); OutputStream os = servletResponse.getOutputStream(); os.write(bytes); os.flush(); os.close(); &#125; catch (Exception e) &#123; log.error(\"general return stream img error! req: &#123;&#125;, e:&#123;&#125;\", request, e); if (StringUtils.isNotBlank(e.getMessage())) &#123; throw new InternalError(e.getMessage()); &#125; else &#123; throw new InternalError(null); &#125; &#125;&#125; 说明： 请无视上面的几个自定义异常方式，需要使用时，完全可以干掉这些自定义异常即可；这里简单说一下，为什么会在实际项目中使用这种自定义异常的方式，主要是有以下几个优点 配合全局异常捕获(ControllerAdvie)，使用起来非常方便简单 所有的异常集中处理，方便信息统计和报警 1如，在统一的地方进行异常计数，然后超过某个阀值之后，报警给负责人，这样就不需要在每个出现异常case的地方来主动埋点了 避免错误状态码的层层传递 12- 这个主要针对web服务，一般是在返回的json串中，会包含对应的错误状态码，错误信息- 而异常case是可能出现在任何地方的，为了保持这个异常信息，要么将这些数据层层传递到controller；要么就是存在ThreadLocal中；显然这两种方式都没有抛异常的使用方便 有优点当然就有缺点了： 异常方式，额外的性能开销，所以在自定义异常中，我都覆盖了下面这个方法，不要完整的堆栈 1234@Overridepublic synchronized Throwable fillInStackTrace() &#123; return this;&#125; 编码习惯问题，有些人可能就非常不喜欢这种使用方式 III. 项目相关只说不练好像没什么意思，上面的这个设计，完全体现在了我一直维护的开源项目 Quick-Media中，当然实际和上面有一些不同，毕竟与业务相关较大，有兴趣的可以参考 QuickMedia: https://github.com/liuyueyi/quick-media : BaseAction: com.hust.hui.quickmedia.web.wxapi.WxBaseAction#buildReturn IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Response","slug":"Response","permalink":"https://zbang.online/hexblog/tags/Response/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"2017年全年回顾小结","slug":"2017年全年回顾小结","date":"2018-01-17T12:23:52.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/17/2017年全年回顾小结/","link":"","permalink":"https://zbang.online/hexblog/2018/01/17/2017年全年回顾小结/","excerpt":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。","text":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。 15年开始工作，17年呢，不再是职场新人，但是说到老鸟，却也相差甚远，工作的第二个年度，总感觉有些不温不火的，仔细看看这一年，尝试了很多东西，也做了一些事情，但总的来说，依然是达不到预期。 一个比较好的坚持下去的习惯就是每周一次的锻炼，虽然是因为小团队内的要求，不达标就罚款的前提定在这，所以努力的坚持了下来，还是值得表扬的。唯一和预期不一致的就是锻炼的效果好像不太明显，比去去年，体重确实又增加了不少。从工作来，体重可算是算着工作时长线性增加，有点可怕，感觉再这么下去，就没法玩了。坚持锻炼，努力运动，健康生活，依然是18年需要去维持的事情；此外也有必要，增加下运动的类型，除了跑步、骑车，还有那么多可以去尝试的活动，有必要去探索一下。 17年，与之前那么多年，最不同的有两件事，一个是入了王者荣耀的坑、变成了一个手游爱好者；还有一个就是写博客，每周最少一篇博文。然后这一年的常态就变成了每天晚上抱着手机玩游戏，每个周末跑到公司吭哧吭哧的写博文（当然有不少时候是为了写而写，所以有些内容比较难入眼）。这两件事情，则有必要好好的谈一下了。 首先是玩游戏这个，之前不怎么玩，挺浪费时间的，而且也没有什么特别有意思的，不知道什么时候开始接触农药，期间卸载了又重装了n次，现在水平依然很烂，仔细想了想自己，对于玩游戏有个奇怪的地方，不愿意去研究，到现在玩耍了大半年，依然不知道装备怎么出，不知道铭文怎么组合，反正都是随意玩，不管什么场景，顺风逆风，都是那么一套玩法，玩来玩去也就是那一个英雄（芈月）；一起玩的小伙伴已经荣升星曜，而我依然在黄金白银徘徊，简直了。其实从这个玩游戏的状态中也可以看出，我属于那种一旦熟悉了某种事务之后，不太愿意去更改、去变动的性格（总是玩一个英雄），主动专研能力不够（不看教程，不看视频…），脾气还不错（被坑了也不骂人）,还有就是定力不足（多次卸载游戏又重装）; (再次不得不说一句，感谢温柔漂亮的美人姣，非常理性的对待我玩游戏这一点） 另一个就是写博文了，这一年的写作，感觉比我上大学之后写的东西都要多了，差不多有八九十篇的样子了，之前抽空整理了个gitbook，挂在了私人服务器上: 小灰灰博文Book。写博文的收获其实挺大的，很多时候对于一个知识点，如果不尝试着去像其他人分享，你都不知道你到底掌握到什么程度了。而且如何才能写出一个漂亮的博文，真的没那么简单，这一年看了不少，有见过写的特别漂亮的，也看过写的不知道什么鬼的东西，当然现在我自己水平也不怎么样，但对比下前后的质量，发现还是有长进的。很多东西写着写着，会忽然发现一些平时没有注意的点。在这一块，感觉最主要的就是勤于总结，善于思考了。18年，这个坚持还是得继续下去的。因为写博文，当然为了避免玩单机，开通了头条号和公众号, 下面是链接，欢迎关注 谈到公众号，就有必要说一下与之相关的小程序了，小程序大火的时候，也进来玩了一下，做了两个，一个是《古诗选》，每天会推送十条古诗，而且可以根据关键词搜索相关古诗的小程序，感觉还蛮有意思的，结果等做完之后，告诉类目不对个人开放，简直了…；然后开始做第二个了，这个纯粹是为了实例验证我之前推的一个开源项目Quick-Media，主要提供图片、二维码、音视频处理服务，目前处于非常简陋的状态，通过写着两个小程序，最大的一个感受是，对于布局和样式这一块，实在是太不敏感了。 既然说到了开源项目，那也有必要提一下了，17年的一个收获就是做了几个有意思的开源项目，虽然不怎么成功，没什么人关注，但对个人的学习和收获还是很不错的。比如 提供SPI服务的Quick-Spi:https://github.com/liuyueyi/quick-spi，通过这个项目的实现，算是理解了spi到底是个什么东西，又可以怎么去玩； Quick-Crawle爬虫框架:https://github.com/liuyueyi/quick-crawler，很久很久以前就对爬虫感兴趣了，然后就从0到1构建了一个非常简单的爬虫框架，前面说的《古诗选》的内容，就是通过这个爬虫框架从网上爬下来的，从玩票的性质来看，还不错； Quick-Media多媒体服务:https://github.com/liuyueyi/quick-media，目前算是个人最多star的项目了，里面深度的刨析了一下二维码的生成，完全可以替换二维码上各种元素，当然还有一些其他的东西，这个项目算是工作的附属品，因为实际的工作中，很多服务都是不需要的，但是偶尔我个人会对某一块比较感兴趣，所以干脆新搞了一个，把自己平时的各种想法都丢上去尝试一下； quick-doraemon，一个基于redis实现的配置中心框架:https://github.com/liuyueyi/quick-doraemon，了解阿里的Diaemond的同学大概可以猜到这个是干嘛的，做这个，纯粹是为了探究一下一个配置中心的实现，到底需要些什么东西，最关键的是，这个实现简不简单； 另外还有两个小工具包，一个是基于PopClip的 https://github.com/liuyueyi/PopClip， 一个基于Alfred的小工具集合（目前没有对外开放，主要扔在了公司内网，有较多的内部信息） 出去跑了个步，都接不下来上面写的东西了，干脆直接换个话题，谈谈生活。然而仔细想了想，好像没啥好说的，基本上就是上班，晚上加班，回家睡觉，第二天继续上班；这日子，过得有点单调啊。自勉，18年不能这么下去了，好歹也得有点业务生活，出去逛逛圈，到处走走也好过每天死宅 17年，家庭新增了两个成员，不到一岁的小朋友，老大已经会走路了，而老二则处于只晓得吃吃喝喝的状态；小外甥的成就已经远远超过他们老舅我的状态了，听我妈说两岁多我都还不会走路，也是尴尬; 多了小朋友之后，还挺不错的，最近没什么事情就喜欢在淘宝，京东上看一些小朋友的玩具，各种积木，玩具车之类的，发现还蛮有意思的，小时候没有玩过的东西，完全可以借着小朋友的名头买来自己耍，也是不错；一直都不太喜欢小孩子，总觉得难以沟通，还挺麻烦，但看着老爸老妈，每天教他们的大外甥一些东西的时候，还是蛮有趣的，陪伴与成长，如果可以的话，父母还是需要和小孩子一起 17年花了所有的积蓄，借了一些，方才勉强凑够首付，贷款了个小破房，生活艰辛，唉，啥时候房价才能平民，千年前的“安得广厦千万间，大庇天下寒士俱欢颜”放在现在，依然有效；脑子不够灵活，只能拿点死工资，得开拓下自己的思路了。 感谢@美人姣的这一路的相伴，虽然生活过得比较平淡，没有那么多的惊喜，没有那么多的浪漫，这些主要都是我的原因了，得改正，该有的小惊喜还是得有的，拓宽一下思路，改变一下习性，让生活变得有意思起来，这个需要在18年好好培养。 最后，再憧憬下18年，定个小目标，该结婚过小日子了!!! @美人姣","categories":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zbang.online/hexblog/tags/日记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}]},{"title":"胡思乱想123","slug":"胡思乱想123","date":"2018-01-15T06:10:27.000Z","updated":"2018-04-02T07:43:56.852Z","comments":true,"path":"2018/01/15/胡思乱想123/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/胡思乱想123/","excerpt":"一些异想天开的小想法","text":"一些异想天开的小想法 1. 俄罗斯方块俄罗斯方块堆积后，总会有空格留下，那么如何去填空就是个问题，从这里可以引入一个新的game思路 在一堆由方格拼成的墙面上，有很多的空个，现在需要你去填空，然后消去相同色，得分；或者拼成一排则得分或者是自由移动方块，来拼接最长的相连方块； 或者是移动，组成各种有趣的图案","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zbang.online/hexblog/tags/随笔/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}]},{"title":"基于OkHttp封装一个简单易用的http工具","slug":"基于OkHttp封装一个简单易用的http工具","date":"2018-01-15T05:15:03.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/01/15/基于OkHttp封装一个简单易用的http工具/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/基于OkHttp封装一个简单易用的http工具/","excerpt":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析","text":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析 I. 封装后测试效果一览基本上，最常见的http交互有两个，一个get请求，一个post请求，因此这里也就封装了这两种请求方式，并额外增加一个上传文件的功能，我们可以通过使用case，来看一下我们最终封装后的使用姿势 123456789101112131415161718192021222324252627282930313233343536// 简单的get请求@Testpublic void testGet() &#123; String url = \"https://zbang.online/wx/list\"; try &#123; okhttp3.Response res = HttpWrapper.of(url).get(); if (res.isSuccessful()) &#123; String ans = res.body().string(); System.out.println(\"ans : \" + ans); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @Testpublic void testUpload() &#123; String url = \"https://zbang.online/wx/qrcode/encode\"; String path = \"/Users/yihui/Desktop/img/test.jpg\"; File file = new File(path); try &#123; Response res = HttpWrapper.of(url) .file(\"image\", file.getName(), \"image/jpeg\", file) .addParam(\"content\", \"http://www.baidu.com\") .addParam(\"size\", \"400\") .upload(); if (res.isSuccessful()) &#123; String str = res.body().string(); System.out.println(\"ans: \" + str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面给出的是一个上传文件的case，实现主要是借助了builder模式，可以很简单的传递个中参数和配置，最后获取返回的结果，这样设计的好处很明显： 使用简单 阅读方便 II. 封装实现接下来进入正题，如何封装这个工具类呢，一般而言，发起http请求，需要设置请求参数，设置请求头，所以builder内部的元素可以很清晰的定义了 首先是引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt;&lt;/dependency&gt; 当然由于整个使用都比较简单，下面就直接贴出封装后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class HttpWrapper &#123; private static OkHttpClient client = new OkHttpClient(); private static final String DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\"; public static Builder of(String url) &#123; return new Builder(url); &#125; public static class Builder &#123; private String url; private Map&lt;String, String&gt; params; private List&lt;MultipartBody.Part&gt; uploadParts; Request.Builder reqBuilder; Builder(String url) &#123; this.url = url; params = new HashMap&lt;&gt;(); uploadParts = new ArrayList&lt;&gt;(); reqBuilder = new Request.Builder(); // 默认添加上user-agent addHeader(\"User-Agent\", DEFAULT_USER_AGENT); &#125; // 添加参数 public Builder addParam(String key, String value) &#123; params.put(key, value); return this; &#125; // 添加头 public Builder addHeader(String key, String value) &#123; reqBuilder.addHeader(key, value); return this; &#125; public Builder file(String key, String fileName, String fileMime, byte[] bytes) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), bytes)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, File file) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), file)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, InputStream stream) throws IOException &#123; int size = stream.available(); byte[] bytes = new byte[size]; stream.read(bytes); return file(key, fileName, fileMime, bytes); &#125; /** * 发送get请求 * * @return * @throws IOException */ public Response get() throws IOException &#123; StringBuilder urlBuilder = new StringBuilder(url); if (!params.isEmpty()) &#123; urlBuilder.append(\"?\").append(Joiner.on('&amp;').withKeyValueSeparator('=').join(params)); &#125; return client.newCall(reqBuilder.url(urlBuilder.toString()).build()).execute(); &#125; /** * post表单数据 * * @return */ public Response post() throws IOException &#123; // 创建表单 FormBody.Builder formBodyBuilder = new FormBody.Builder(); if (!params.isEmpty()) &#123; params.forEach(formBodyBuilder::add); &#125; return client.newCall(reqBuilder.url(url) .post(formBodyBuilder.build()) .build()) .execute(); &#125; /** * 文件上传 * * @return * @throws IOException */ public Response upload() throws IOException &#123; MultipartBody.Builder bodyBuilder = new MultipartBody.Builder() .setType(MultipartBody.FORM); uploadParts.forEach(bodyBuilder::addPart); // 添加参数 params.forEach(bodyBuilder::addFormDataPart); return client.newCall(reqBuilder.url(url) .post(bodyBuilder.build()) .build()) .execute(); &#125; &#125;&#125; 针对上面的实现，有几个需要注意的地方 get请求时，将参数拼装到url上（需要考虑是否要编码？） post请求时，主要借助 FormBody 来存储请求参数 文件上传时， 主要利用Part来封装上传的文件，借助 MultipartBody来包装Part和请求参数 上传文件，需要指定其 MIME（即 Content-Type, 如 image/jpeg, audio/mp3, file/txt等） 传文件的同时，也可以传递post参数，当然url参数也是可以的 III. 测试验证前面给出的是一个传文件的case，下面则给出一个提交post表单的测试用例 这个http接口主要功能是实现markdown输出图片 12345678910111213141516171819202122232425262728293031323334@Testpublic void testPost() &#123; String url = \"https://zbang.online/wx/md2img\"; String content = \"h1 header\\n\" + \"============\\n\" + \"\\n\" + \"Paragraphs are separated by a blank line.\\n\" + \"\\n\" + \"2nd paragraph. *Italic*, **bold**, and `monospace`. Itemized lists\\n\" + \"look like:\\n\" + \"\\n\" + \" * this one\\n\" + \" * that one\\n\" + \" * the other one\"; String token = \"0xdahdljk3u8eqhrjqwer90e\"; String noborder = \"true\"; try &#123; Response res = HttpWrapper.of(url) .addParam(\"content\", content) .addParam(\"token\", token) .addParam(\"noborder\", noborder) .addParam(\"type\", \"stream\") .post(); if (res.isSuccessful()) &#123; BufferedImage bf = ImageIO.read(res.body().byteStream()); System.out.println(\"over\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 测试演示 V. 其他源码相关源码可以参见： HttpWrapper.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://zbang.online/hexblog/tags/Okhttp/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"Redis实现分布式锁相关注意事项","slug":"Redis实现分布式锁相关注意事项","date":"2018-01-14T08:12:29.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/01/14/Redis实现分布式锁相关注意事项/","link":"","permalink":"https://zbang.online/hexblog/2018/01/14/Redis实现分布式锁相关注意事项/","excerpt":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题","text":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题 I. 背景知识借助redis来实现分布式锁（我们先考虑单机redis的模式），首先有必要了解下以下几点： 单线程模式 setnx : 当不存在时，设置value，并返回1； 否则返回0 getset : 设置并获取原来的值 expire : 设置失效时间 get : 获取对应的值 del : 删除 ttl : 获取key对应的剩余时间，若key没有设置过超时时间，或者压根没有这个key则返回负数（可能是-1，-2） watch/unwatch : 事务相关 II. 方案设计1. 设计思路获取锁： 调用 setnx 尝试获取锁，如果设置成功，表示获取到了锁 设置失败，此时需要判断锁是否过期 未过期，则表示获取失败；循环等待，并再次尝试获取锁 已过期，getset再次设置锁，判断是否获取了锁（根据返回的值进行判断，后面给出具体的方案） 若失败，则重新进入获取锁的逻辑 释放锁： 一个原则就是确保每个业务方释放的是自己的锁 2. getset的实现方案网上一种常见的case，主要思路如下 setnx 尝试获取锁 失败，则 get 获取锁的value （一般是 uuid_timstamp） 判断是否过期，若没有过期，则表示真的获取失败 若过期，则采用 getset设置，尝试获取锁 实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public class DistributeLock &#123; private static final Long OUT_TIME = 30L; public String tryLock(Jedis jedis, String key) &#123; while (true) &#123; String value = UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; String getsetOldVal = jedis.getSet(key, value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 jedis.set(key, getsetOldVal); &#125; &#125; &#125; public void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); &#125; &#125;&#125; 观察获取锁的逻辑，特别是获取超时锁的逻辑，很容易想到有一个问题 getSet 方法会不会导致写数据混乱的问题，简单来说就是多个线程同时判断锁超时时，执行 getSet设置锁时，最终获取锁的线程，能否保证和redis中的锁的value相同 上面的实现方式，一个混乱的case如下: 三个线程a,b,c 都进入到了锁超时的阶段 线程a, 获取原始值 oldVal, 并设置 t1 线程b, 获取线程a设置的 t1, 并重设为 t2 线程c, 获取线程b设置的 t2, 并重设为 t3 线程a，判断，并正式获取到锁 线程b，判断失败，恢复原来锁的内容为t1 线程c, 判断失败，恢复原来锁的内容为t2 问题出现了，获取锁的线程a，期望所得内容为t1, 但是实际为t2; 导致无法释放锁 实际验证 在上面的代码中，配合测试case，加上一些日志输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static String tryLock(Jedis jedis, String key) throws InterruptedException &#123; String threadName = Thread.currentThread().getName(); while (true) &#123; String value = threadName + \"_\" + UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; // 强制使所有的线程都可以到这一步 Thread.sleep(50); System.out.println(threadName + \" in getSet!\"); // 人工接入，确保t1 获取到锁， t2 获取的是t1设置的内容， t3获取的是t2设置的内容 if (\"t2\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(20); &#125; else if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; String getsetOldVal = jedis.getSet(key, value); System.out.println(threadName + \" set redis value: \" + value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 System.out.println(threadName + \" get lock!\"); if (\"t1\".equalsIgnoreCase(threadName)) &#123; // t1获取到锁，强制sleep40ms， 确保线t2,t3也进入了 getSet逻辑 Thread.sleep(40); &#125; return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 // 人肉介入，确保t2优先执行，并设置回t1设置的值, t3后执行设置的是t2设置的值 if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; else if (\"t2\".equalsIgnoreCase(threadName))&#123; Thread.sleep(20); &#125; jedis.set(key, getsetOldVal); System.out.println(threadName + \" recover redis value: \" + getsetOldVal); &#125; &#125;&#125; 测试case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testLock() throws InterruptedException &#123; // 先无视获取jedis的方式 JedisPool jedisPool = cacheWrapper.getJedisPool(0); Jedis jedis = jedisPool.getResource(); String lockKey = \"lock_test\"; String old = DistributeLock.tryLock(jedis, lockKey); System.out.println(\"old lock: \" + old); // 确保锁超时 Thread.sleep(40); // 创建三个线程 Thread t1 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t1 &gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t2 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t2\"); Thread t3 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t3 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t3\"); t1.start(); t2.start(); t3.start(); Thread.sleep(10000);&#125;; 部分输出结果: 1234567891011121314main in getSet!main set redis value: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130main get lock!old lock: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130t1 in getSet!t2 in getSet!t1 set redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t1 get lock!t3 in getSet!t2 set redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t3 set redis value: t3_9aa5d755-43b2-43bd-9a0b-2bad13fa31f6_1515643763345t2 recover redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t3 recover redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341 重点关注 t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341，表示t1线程过去了锁，但是锁的内容不是其value，即便t2去恢复，也会被t3给覆盖 如何解决上面这个问题呢？ 上面是典型的并发导致的问题，当然可以考虑从解决并发问题的角度出发来考虑，一个常见的方式就是加锁了，思路如下：（不详细展开了） 在判断超时之后，加锁 再次获取对应的值，判断是否超时，是则执行上面的操作 否则退出逻辑，继续循环 这种实现方式，会有以下的问题： getset 这个方法执行，可能导致写入脏数据 基于服务器时钟进行超时判断，要求所有服务器始终一致，否则有坑 3. expire实现方式相比于前面一种直接将value设置为时间戳，然后来比对的方法，这里则直接借助redis本身的expire方式来实现超时设置，主要实现逻辑相差无几 123456789101112131415161718192021222324252627282930313233public class DistributeExpireLock &#123; private static final Integer OUT_TIME = 3; public static String tryLock(Jedis jedis, String key) &#123; String value = UUID.randomUUID().toString(); while(true) &#123; Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 jedis.expire(key, OUT_TIME); // 主动设置超时时间为3s return value; &#125; // 获取失败，先确认下是否有设置国超是时间 // 防止锁的超时时间设置失效，导致一直竞争不到 if(jedis.ttl(key) &lt; 0) &#123; jedis.expire(key, OUT_TIME); &#125; &#125; &#125; public static void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); System.out.println(Thread.currentThread() +\" del lock success!\"); &#125; else &#123; System.out.println(Thread.currentThread() +\" del lock fail!\"); &#125; &#125;&#125; 获取锁的逻辑相比之前的，就简单很多了，接下来则需要简单的分析下，上面这种实现方式，会不会有坑呢？我们主要看一下获取锁失败的场景 如果获取锁失败 表示有其他的业务方已经获取到了锁 此时，只能等持有锁的业务方主动释放锁 判断锁是否设置了超时时间，若没有则加一个（防止设置超时时间失败导致问题） 从上面这个逻辑来看问题不大，但是有个问题，case ： 如某个业务方setnx获取到了锁，但是因为网络问题，过了很久才获取到返回，此时锁已经失效并被其他业务方获取到了，就会出现多个业务方同时持有锁的场景 III. 小结说明想基于redis实现一个相对靠谱的分布式锁，需要考虑的东西还是比较多的，而且这种锁并不太适用于业务要求特别严格的地方，如 一个线程持有锁时，如果发生gc，导致锁超时失效，但是自己又不知道，此时就会出现多个业务方同时持有锁的场景 对于锁超时的场景，需要仔细考虑，是否会出现并发问题 确保只能释放自己的锁（以防止释放了别人的锁，出现问题） 参考链接 基于Redis的分布式锁到底安全吗? 利用redis实现的分布式锁 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/tags/Redis/"},{"name":"distributeLock","slug":"distributeLock","permalink":"https://zbang.online/hexblog/tags/distributeLock/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}]},{"title":"SpringMVC之请求参数的获取方式","slug":"SpringMVC之请求参数的获取方式","date":"2018-01-04T08:48:39.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/04/SpringMVC之请求参数的获取方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/04/SpringMVC之请求参数的获取方式/","excerpt":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE","text":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE I. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的 1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了，javax.servlet.ServletRequest#getParameter 来获取对应的参数，下面各处一个实例 1234567891011@RestController@RequestMapping(path = \"webs/demo\")public class DemoController &#123; @RequestMapping(path = \"req1\") public String req1(HttpServletRequest request) &#123; String user = request.getParameter(\"user\"); String password = request.getParameter(\"password\"); return \"req1 user: \" + user + \" pwd: \" + password; &#125;&#125; 根据上面暴露的接口，我们测试的case就很简单了 12345http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog&amp;password=123456## 输出 req1 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog## 输出 req1 user: 小灰灰Blog pwd: null 说明 这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数 除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息 在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象) 12HttpServletRequest httpServletRequest = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); 2. 直接方法参数获取直接给出case, 这个方法依然是放在上面的DemoController下面的 1234@RequestMapping(path = \"req2\")public String req2(String user, String password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 请求验证 12345678910http://127.0.0.1:8080/webs/demo/req2?user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password=123456## 输出： req2 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456## 输出： req2 user: null pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;User=blog## 输出： req2 user: null pwd: 123456 注意： 上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了 方法参数名必须和url参数名完全一致（区分大小写） 顺序无关 若参数没传，则默认为null 一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况 代码稍作修改 1234@RequestMapping(path = \"req2\")public String req2(String user, int password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 实际测试 12345678910111213# case1 http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;user=blog## 输出： req2 user: blog pwd: 123456# case 2http://127.0.0.1:8080/webs/demo/req2?password2=123456&amp;user=blog## 输出: 报错, Optional int parameter 'password' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type# case 3http://127.0.0.1:8080/webs/demo/req2?password=abc&amp;user=blog## 输出：报错, \"Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"abc\"\" 结果说明 如果请求参数与方法参数类型不一致，会抛出转换异常 如果方法参数为非封装基本类型，则url参数必须存在，否则报错 3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似，case如下 12345@RequestMapping(path = \"req3\", method = RequestMethod.GET)public String req3(@RequestParam(\"user\") String username, @RequestParam(\"password\") String pwd) &#123; return \"req3 user: \" + username + \" pwd: \" + pwd;&#125; 测试case 12345678# case1 http://127.0.0.1:8080/webs/demo/req3?password=123456&amp;user=blog## 输出: req3 user: blog pwd: 123456# case2http://127.0.0.1:8080/webs/demo/req3?password=123456## 输出：报错， Required String parameter 'user' is not presen 说明 不指定注解的name或value属性时，等同于第二种使用姿势 注解的name属性或value属性，用实际的参数名来指定 controller的参数名与url参数名没有强关联（区别第二种方式） 参数类型需要保证一致（通第二种方式） 如果url参数可选，请设置require属性为false，如下1@RequestParam(name = \"user\", required = false) String username 4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单 12345678910@Datapublic static class UserDO &#123; String user; String password;&#125;@RequestMapping(path = \"req4\", method = RequestMethod.GET)public String req4(UserDO userDO) &#123; return \"req4 userDO: \" + userDO;&#125; 测试case 12345678# case1http://127.0.0.1:8080/webs/demo/req4?password=123456&amp;user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog## 输出: req4 userDO: DemoController.UserDO(user=小灰灰Blog, password=123456)# case2http://127.0.0.1:8080/webs/demo/req4?password=123456## 输出: req4 userDO: DemoController.UserDO(user=null, password=123456) 说明 定义一个bean，内部属性和请求参数对应 允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常） bean的属性，可以根据实际情况指定类型 5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩 6. Path参数Path参数，专指的是请求路径的参数，如 1http://127.0.0.1:8080/webs/demo/req4?password=123456 上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接 1https://my.oschina.net/u/566591/blog/1601400 566591 : 这个参数主要用来区分用户 1601400 : 这个参数则主要是表示对应的博文 一般path参数的获取方式如下 1234@RequestMapping(path = \"req6/&#123;user&#125;/info\")public String req6(@PathVariable(name = \"user\") String user) &#123; return \"req6 user: \" + user;&#125; 测试case 1234567891011# case1 http://127.0.0.1:8080/webs/demo/req6/blog/info?user=haha## 输出：req6 user: blog# case2http://127.0.0.1:8080/webs/demo/req6/blog?user=haha## 输出: 404# case3http://127.0.0.1:8080/webs/demo/req6/info?user=haha## 输出: 404 注意: path参数的使用，需要确保参数存在且类型匹配 path参数和url参数不会相互影响 II. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok 1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求 123456789101112# case1 curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req1\"## 输出： req1 user: 小灰灰Blog pwd: 123456# case2curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?password=123456\"## 输出：req1 user: 小灰灰Blog pwd: 12345# case3curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?user=greyBlog\"## 输出：req1 user: greyBlog pwd: null curl也可以换成js请求测试方式 1234567891011var formData = new FormData();formData.append(\"user\", \"小灰灰Blog\");$.ajax(&#123; url: 'http://127.0.0.1:8080/webs/demo/req1?password=123456', type: 'post', cache: false, data: formData, processData: false, contentType: false&#125;); 说明 对于HttpServletReuqest方式获取参数时，get和post没什么区别 若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干） 2. 方法参数获取几个测试demo如下 12345678910111213# case 1curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出： req2 user: 小灰灰Blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出：req2 user: null pwd: 123456# case 3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2?user=blog\"## 输出： req2 user: blog pwd: 123456 基本上使用姿势和get没什么区别 3. RequestParam注解方式12345678910111213# case 1curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3\"## 输出： req3 user: blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req3?user=blog\"## 输出： req3 user: blog pwd: 123456# case 3curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3?password=900\"## 输出：req3 user: blog pwd: 900,123456 注意 和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串 4. Bean方式12345678910111213## case1 curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4?password=900\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=900,123456)## case2curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=123456)## case3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=null, password=123456) 这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数 5. PathVariable这个没法玩… III. 多媒体上传参数获取 上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好 1. 实例支持1234567891011121314@RequestMapping(path = &#123;\"wx/upload\", \"wx/wx/upload\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@ResponseBodypublic String upload(HttpServletRequest request) &#123; MultipartFile file = null; if (request instanceof MultipartHttpServletRequest) &#123; file = ((MultipartHttpServletRequest) request).getFile(\"image\"); &#125; if (file == null) &#123; throw new IllegalArgumentException(\"图片不能为空!\"); &#125; return \"success\";&#125; 简单来说，主要是利用HttpServletRequest来获取上传的文件 注意： 如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常） 如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断 ((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件 IV. 小结1. 五种获取参数的姿势 方式 注意事项 HttpServletRequest获取参数 最常见通用 方法参数与请求参数同名 注意参数名统一，注意类型一致，尽量不用非包装基本类型 @RequestParam注解 同上，可注解内指定http参数名 Bean方式 定义一个bean，会将同名的http参数赋值进去，推荐 @PathVariable 注解 请求url参数 2. 传文件使用姿势使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"RequestParam","slug":"RequestParam","permalink":"https://zbang.online/hexblog/tags/RequestParam/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"jvm调优的工具介绍","slug":"jvm调优的工具介绍","date":"2018-01-03T06:18:35.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/03/jvm调优的工具介绍/","link":"","permalink":"https://zbang.online/hexblog/2018/01/03/jvm调优的工具介绍/","excerpt":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能","text":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能 jvm相关参数记录 12-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/java.hprof -XX:InitialCodeCacheSize=134217728 -XX:InitialHeapSize=4294967296 -XX:MaxDirectMemorySize=1073741824 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=268435456 -XX:MaxNewSize=2147483648 -XX:MetaspaceSize=268435456 -XX:NewSize=2147483648 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ReservedCodeCacheSize=268435456 -XX:SurvivorRatio=10 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 2. 监控工具使用tsar作为服务器性能监控工具，所以前提是先安装tsar 12345wget -O tsar.zip https://github.com/alibaba/tsar/archive/master.zip --no-check-certificateunzip tsar.zipcd tsarmakemake install 监控命令 1tsar --cpu --swap -i1 -l 说明 tsar相关可以参考： Linux系统性能监控工具介绍之-tsar II. 相关知识点简介截取几条gc日志 1234562018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs]2018-01-02T10:49:25.374+0800: 13.999: [GC (Allocation Failure) 2018-01-02T10:49:25.374+0800: 13.999: [ParNew: 1881830K-&gt;93708K(1922432K), 0.0910714 secs] 1949062K-&gt;197949K(4019584K), 0.0911833 secs] [Times: user=0.26 sys=0.01, real=0.09 secs]2018-01-02T10:55:53.013+0800: 401.639: [GC (GCLocker Initiated GC) 2018-01-02T10:55:53.013+0800: 401.639: [ParNew: 1841429K-&gt;142552K(1922432K), 0.0629031 secs] 1945670K-&gt;246793K(4019584K), 0.0630512 secs] [Times: user=0.14 sys=0.01, real=0.06 secs]2018-01-02T10:55:55.076+0800: 403.701: [GC (GCLocker Initiated GC) 2018-01-02T10:55:55.076+0800: 403.701: [ParNew: 1890281K-&gt;59983K(1922432K), 0.0661778 secs] 1994522K-&gt;201875K(4019584K), 0.0663176 secs] [Times: user=0.15 sys=0.01, real=0.07 secs]2018-01-02T11:47:25.271+0800: 3493.897: [GC (Allocation Failure) 2018-01-02T11:47:25.271+0800: 3493.897: [ParNew: 1807695K-&gt;20975K(1922432K), 0.0193077 secs] 1949587K-&gt;162867K(4019584K), 0.0195351 secs] [Times: user=0.04 sys=0.00, real=0.02 secs]2018-01-02T11:56:50.621+0800: 4059.247: [GC (GCLocker Initiated GC) 2018-01-02T11:56:50.622+0800: 4059.247: [ParNew: 1774543K-&gt;108899K(1922432K), 0.0401606 secs] 1916434K-&gt;250791K(4019584K), 0.0403586 secs] [Times: user=0.10 sys=0.00, real=0.04 secs] 1. CMS GC日志格式分析截取上面日志中的第一条，分别说明每一项是什么意思 2018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs] 2018-01-02T10:49:20.390+0800 ：发生gc的时间 9.015 - GC开始，相对JVM启动的相对时间，单位是秒 GC - 区别FullGC和MinorGC的标识，此处表示为MinorGC (Allocation Failure) - 发生gc的原因，此处表示空间不足，导致分配失败 ParNew – 收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器 1922431K-&gt;134118K – 收集前后年轻代的使用情况，未回收之前，大小为1922431K, 回收完毕之后，大小为134118K, 所以回收大小为: 1922431K - 134118K (1922432K) - 整个年轻代的容量 0.1486593 secs - 这个解释用原滋原味的解释：Duration for the collection w/o final cleanup. 1934749K-&gt;201350K - 收集前后整个堆的使用情况 (4019584K) - 整个堆的容量 0.1487460 secs – ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的花销）； [Times: user=0.78 sys=0.01, real=0.11 secs] – GC事件在不同维度的耗时，具体的用英文解释起来更加合理: user – Total CPU time that was consumed by Garbage Collector threads during this collection sys – Time spent in OS calls or waiting for system event real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount. 2. CMS简介 后端服务选用的就是CMS，那么就有必要看一下这个CMS到底是个什么东西 CMSConcurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标签-清除算法 步骤划分 初始标记 (CMS initial mark) : 标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记 (CMS concurrent mark) : 进行 GC Roots Tracing的过程 重新标记 (CMS remark) : 为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除 (CMS concurrent sweep) : 说明，初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 标记清除算法一句话描述： 标记所有需要回收的对象，在标记完成后，统一回收所有被标记的对象 常见的两个问题： 效率不高；回收后大量的碎片 3. 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区指尖发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无序等Age达到阀值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC 3. jstat 命令简介 既然问题是频繁的gc引起的，那么观察新生代，老年代对象占用空间的情况就不可避免了，所以jstat命令不得不出现了 截一个线程图 1234567$ jstat -gcutil 11573 1000 5 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 34.39 24.68 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 26.29 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 27.45 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 28.32 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 29.93 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 a. 参数说明 -gcutil ： 监视Java对状况，包括Eden区、两个survivor区，老年代，永久代等，已用空间，gc时间等 11573： java进程号 1000： 每1s刷新一次 5： 一共查询5次 b. 输出说明 S0, S1: 表示两个 survivor区 E(Eden) : 新生代Eden O(Old) : 老年代Old M(metaspace) : 元空间,本地内存， 在1.8移除了永久代改成这个 YGC : 程序运行以来，发生Minor GC(Young GC)次数 YGCT : Minor GC 总耗时（单位s) FGC : Full GC的总次数 FGCT : Full GC的总耗时 （单位s) GCT : 所有GC的总耗时 （单位s) III. 监控测试0. 准备a. 首先是获取对应的进程号12jps -ljinfo xxx 抓图 123$ jps -l30916 sun.tools.jps.Jps2909 org.apache.catalina.startup.Bootstrap b. 服务器性能监控命令12## 主要查看cpu和nginx访问的监控tsar --cpu --nginx -i1 -l 抓图: 12345678Time -----------------------cpu---------------------- ----------------------------------nginx---------------------------------Time user sys wait hirq sirq util accept handle reqs active read write wait qps rt03/01/18-11:29:37 16.54 1.50 0.00 0.00 0.00 18.05 2.00 2.00 6.00 15.00 0.00 1.00 14.00 6.00 89.5003/01/18-11:29:38 26.07 1.75 0.00 0.00 0.00 27.82 3.00 3.00 10.00 15.00 0.00 1.00 14.00 10.00 47.1003/01/18-11:29:39 19.60 1.01 0.00 0.00 0.00 20.60 4.00 4.00 11.00 15.00 0.00 1.00 14.00 11.00 37.8203/01/18-11:29:40 28.75 2.50 0.00 0.00 0.25 31.50 2.00 2.00 10.00 15.00 0.00 1.00 14.00 10.00 79.3003/01/18-11:29:41 14.07 1.51 0.00 0.00 0.00 15.58 1.00 1.00 10.00 15.00 0.00 3.00 12.00 10.00 51.3003/01/18-11:29:42 20.60 1.01 0.00 0.00 0.00 21.61 6.00 6.00 13.00 15.00 0.00 1.00 14.00 13.00 44.69 c. jvm内存的监控1jstat -gcutil 4354 1000 抓图: 123456$ jstat -gcutil 2909 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 29.03 0.00 66.34 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.37 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.50 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.54 16.34 98.57 96.32 200 6.393 0 0.000 6.393 d. 查看内存中对象的个数和大小1jmap -histo 4354 抓图 123456789101112num #instances #bytes class name---------------------------------------------- 1: 78179 181546608 [I 2: 1259 175880312 [S 3: 35915 65527520 [B 4: 242125 40558408 [C 5: 571604 13718496 java.util.concurrent.atomic.AtomicLong 6: 233282 5598768 java.lang.String 7: 55177 5296992 java.util.jar.JarFile$JarFileEntry 8: 119906 3836992 java.util.HashMap$Node 9: 33327 2932776 java.lang.reflect.Method 10: 1147 2303216 [Ljava.util.concurrent.atomic.AtomicLong; e. 压测模拟工具Jmetter 添加线程组 新增http请求 添加监听器中，结果的监控：图形结果，聚合报告，查看结果树，用表格查看结果 http请求中配置参数 协议 域名or IP + 端口号 编码: utf-8 请求方法 + 请求路径 请求参数，支持文件上传，注意编码方式 IV. 参考 Linux系统性能监控工具介绍之-tsar tsar使用说明 JVM调优——之CMS GC日志分析 jvm的GC日志分析 JVM 运行时内存使用情况监控 《深入理解JVM虚拟机》 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JDK学习之反射的使用姿势一览","slug":"JDK学习之反射的使用姿势一览","date":"2017-12-29T12:26:51.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2017/12/29/JDK学习之反射的使用姿势一览/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/JDK学习之反射的使用姿势一览/","excerpt":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景","text":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景 I. 反射定义 指程序可以访问、检测和修改它本身状态或行为的一种能力 直接说定义的话，可能并不能非常清晰的解释说明，结合作用进行描述 反射可以干什么？ 1234在运行时构造任意一个类的对象。在运行时判断任意一个对象所属的类。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法 有了上面四点，基本上你想干嘛就可以干嘛，比如我现在就有下面这个类 1234567891011121314151617181920212223242526272829public class RefectTest extends MyRefect implements IRefect &#123; private static String s1 = \"hello\"; private static int s2 = 100; private int s3 = 200; private boolean ans; protected RefectTest next; public RefectTest() &#123; &#125; public RefectTest(int s3, boolean ans, RefectTest next) &#123; this.s3 = s3; this.ans = ans; this.next = next; &#125; public RefectTest next() &#123; return next; &#125; private int count(int a, int b) &#123; return a + b; &#125;&#125; 现在我有了clz,其赋值语句为 Class clz = RefectTest.class， 那么我可以干啥？ 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 上面给出了可以干些什么，并给了对应的简单示例，引入了几个新的类Constructor, Field, Method， 下面将详细解释这三个类是什么，怎么用 II. 反射的使用努力结合实际的应用场景，给出每种利用反射的实现对应需求的使用姿势，有些场景可能并不是特别贴切，欢迎提出给合适的场景以此进行替换 1. 通过反射创建对象 这是个比较常见的场景，我在使用了自定义注解时，通常会这么晚 应用场景： 我定义了一个校验器的注解ValDot，注解中有个校验规则class对象，如下 1234567891011121314151617public interface ICheckRule &#123; boolean check(Object ... obj);&#125;public class DefaultCheckRule implements ICheckRule &#123; @Override public boolean check(Object... obj) &#123; return false; &#125;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CheckDot &#123; // 校验规则 Class&lt;? extends ICheckRule&gt; check() default DefaultCheckRule.class;&#125; 上面定义了注解和校验条件，接着进入整体，在切面中，需要获取 1234567891011121314@Aspect@Componentpublic class CheckAspect &#123; @Before(\"@annotation(checkDot)\") public void process(JoinPoint joinPoint, CheckDot checkDot) throws IllegalAccessException, InstantiationException &#123; // 注意，这里获取注解上的校验规则类，并获取实例 ICheckRule rule = checkDot.check().newInstance(); if(rule.check(joinPoint.getArgs())) &#123; throw new IllegalStateException(\"check argument error!\"); &#125; &#125;&#125; 上面是一个较好的利用反射获取实例的应用场景，想一想，如果不用反射，这个校验规则怎么传进来呢，这个时候就没那么方便了（当然也不是不可以，最简单的就是拿一个Holder持有类名到类对象的映射关系，然后在注解中传类名，也可以达到上面的效果） 还有一种场景可能就比较蛋疼了，如果一个类没有默认构造方法，通过反射就没法直接用class.newInstanace()了 Constructor构造器类 根据Class优先获取到 Constructor 对象，然后传入需要的构造参数, 测试如下 1234567891011121314151617181920212223public class ConTest &#123; private int a,b; public ConTest(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public String toString() &#123; return \"ConTest&#123;\" + \"a=\" + a + \", b=\" + b + '&#125;'; &#125; public static void main(String[] args) throws Exception &#123; Class clz = ConTest.class; // 获取对应的构造器（注意参数类型） Constructor constructor = clz.getConstructor(int.class, int.class); // 创建实例（注意参数要匹配） ConTest test = (ConTest) constructor.newInstance(10, 20); System.out.println(test.toString()); &#125;&#125; 输出 1ConTest&#123;a=10, b=20&#125; 一般常用下面四种方式获取 1234567891011// 根据参数类型获取匹配的构造器Constructor getConstructor(Class[] params)// 获取所有的Constructor[] getConstructors()// 相比较前面的，这里可以获取私有方法Constructor getDeclaredConstructor(Class[] params)// 可以获取私有方法Constructor[] getDeclaredConstructors() 2. 判断class的继承关系判断是否为基础数据类型基本类型较为特殊，所以JDK很人性化的给封装了一个方法，Class#isPrimitive 因此返回true的类型有: int long short byte char boolean 封装后的类型，返回的依然是false 附带一句，是没有null.class这种用法的 判断是否为另一个类的子类，另一个接口的实现类通常我们利用 instanceof 关键字来判断继承关系，但是这个是针对对象来的，现在给一个class，要怎么玩？ 看下面，主要就是 Class#isAssignableFrom() 的功劳了 1234567891011121314151617181920212223public class ExtendTest &#123; interface ITest &#123;&#125; abstract class ATest &#123; abstract public void print(); &#125; class TestClz extends ATest implements ITest &#123; @Override public void print() &#123; System.out.println(\"TestClz\"); &#125; &#125; public static void main(String[] args) &#123; Class clz = TestClz.class; System.out.println(ATest.class.isAssignableFrom(clz)); System.out.println(ITest.class.isAssignableFrom(clz)); &#125;&#125; 需要注意一点，父类作为调用方，子类作为参数 结合泛型时，获取泛型的实际类型泛型，又是一个有意思的功能，这里不多说，继承一个泛型基类，然后问题是如何通过反射获得泛型签名中的类型，一般会在继承或实现泛型接口时会用到它。 123456789class A&lt;T, ID&gt; &#123;&#125;class B extends A&lt;String, Integer&gt; &#123;&#125;public static void main(String[] args) &#123; System.out.println(B.class.getGenericSuperclass());&#125; 换成泛型接口呢 ? 12345678910111213interface A&lt;T, ID&gt; &#123; &#125; class B implements A&lt;String, Integer&gt; &#123; &#125;public static void main(String[] args) &#123; ParameterizedType parameterizedType = (ParameterizedType) B.class.getGenericInterfaces()[0]; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125;&#125; 3. 获取成员变量获取成员变量，主要是根据 B.class.getDeclaredFields() 来获取所有声明的变量，这个应用场景会和下面的获取方法并执行联合一起说明 1234567891011// 获取指定的公共成员变量Field getField(String name)// 获得所有公共字段Field[] getFields()// 获取指定声明的成员变量（包括prive）Field getDeclaredField(String name)// 获取所有声明的成员变量Field[] getDeclaredFields() 这个主要返回 Field对象，现在有了Field，可以做些啥？ 判断成员的修饰 Field#getModifiers() 12345678int modify = field.getModifiers();// 是否是静态变量boolean ans = Modifier.isStatic(modifier);// 是否是公共变量boolean ans = Modifier.isPublic(modifier);// 是否不可变boolean ans = Modifier.isFinal(modifier);// ... 获取成员的变量名 : field#getName() 获取成员对应的value: field#get(instance) 对于静态成员，instance可以为null 对于非静态成员，instance必须为一个实例对象 获取注解: field#getAnnotations() 这个就厉害了，hibernate的校验框架，在成员变量上加一个注解Max,就可以设置参数的最大值，其实就是通过反射获取到注解，然后进行相应的逻辑 4. 获取方法获取方法，同上面的差不多，也有四种方式 1234567891011// 根据方法名，参数类型获取公共方法Method getMethod(String name, Class[] params)// 获取所有的公共方法Method[] getMethods()// 根据方法名，参数类型，获取声明的方法（包括私有）Method getDeclaredMethod(String name, Class[] params)// 获取所有声明的方法Method[] getDeclaredMethods() 返回了一个Method类，那么这个东西又有一些什么功能？ 获取方法名 Method#getName() 获取方法所在的类 : Method#getDeclaringClass() 获取方法返回类型 : Method#getReturnType() 获取方法上的注解 : Method#getAnnotations() 执行方法 有了这个就可以做很多事情了，实例中给出说明 1234// 设置方法可访问（即私有方法也可以被调用）method.setAccessible(true);// instance为实例对象， args为传入参数method.invoke(instance, args) III. 实例DEMO通过反射的方式，实现一个 BeanUtils，实现Bean的拷贝 当一个Bean有较多的成员变量时，如果我们采用最原始的setXXX()来一次赋值的时候，一是实现比较繁琐，其次就是当Bean的字段发生变动之后，也需要同步的修改，那么我们借助反射的方式，实现一个优雅的 BeanUtils 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BeanUtils &#123; public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125; &#125; private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; // 没有匹配到，这里返回null实际上是不合适的 // 因为如果原属性为基本数据类型，赋值null为报错 throw new Exception(); &#125;&#125; IV. 小结反射的四种用途 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 使用注意事项 操作私有变量，私有方法时，先设置field.setAccessible(true);确保可访问 反射会带来额外的性能开销 可以用 Class#isAssignableFrom() 来判断类继承关系 可以用 Class#isPrimitive()判断是否为基本数据类型 可以用 Class#getGenericSuperclass() 获取泛型类型 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"https://zbang.online/hexblog/tags/Reflect/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Centos 安装hexo博客","slug":"Centos-安装hexo博客","date":"2017-12-29T10:10:43.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2017/12/29/Centos-安装hexo博客/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/Centos-安装hexo博客/","excerpt":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选","text":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选 安装步骤12345678910## 1. nodejs安装sudo yum install nodejs## 2. 安装 hexosudo npm install -g hexo-clisudo npm install## 3. 创建hexohexo init xxxnpm install 测试验证 hexo server 使用说明1. 创建一个page执行下面的命令之后，就可以创建一个menu菜单 1hexo new page about 2. 新建一个博文1hexo new 'new blog' 新建一个草稿 12345hexo new draft '草稿博文'# 启动服务，预览草稿hexo server --drafts 3. 显示简介在md文件中，某一个地方地方添加 1&lt;!-- more --&gt; 则后面的内容都不会显示在首页了 4. 启动12345## 编译hexo g## 启动一个serverhexo s 5. deploy打开 _config.yml 文件，添加配置 1234deploy: type: git repository: https://github.com/liuyueyi/blogs.git branch: master 开始发布: 1hexo d -g 说明 如果github上，访问网页时，提示js或者css 404，则需要注意下面的配置 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liuyueyi.github.io/hexblogroot: /hexblog/permalink: :year/:month/:day/:title/permalink_defaults: lang: zh-cn 其中URL，和root是关键的设置属性，root最后的/不能漏掉 如果提示git没有，则需要安装 1npm install hexo-deployer-git --save","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zbang.online/hexblog/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Nginx 路由转发配置笔记","slug":"Nginx-路由转发配置笔记","date":"2017-12-27T09:57:18.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/12/27/Nginx-路由转发配置笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/12/27/Nginx-路由转发配置笔记/","excerpt":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html）","text":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html） I. location匹配规则1. 语法123location [=|~|~*|^~|@] /uri/ &#123; ...&#125; 2. 说明从上面的语法出发，可以了解到location可以区分为三个部分，接下来一个一个的研究一下 a. PartOne: [=|~|~*|^~|@] = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 上面定义了几个不同的符号，表示不同的匹配规则，那么先后顺序呢？ =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 直接看这个可能不太好理解，写几个case实际测试一下 测试case1: 123456789101112131415location = /world &#123; return 600;&#125;location = /hello &#123; return 600;&#125;location ~ /hellowo &#123; return 602;&#125;location ^~ /hello &#123; return 601;&#125; 12345678- 请求 localhost/world 返回600- 请求 localhost/world2 localhost/test/world 返回其他- 请求 localhost/hello 返回600- 请求 localhost/hello/123 返回601- 请求 localhost/hellow 返回601- 请求 localhost/hellowo 返回601- 请求 localhost/test/hellowo 返回602- 请求 localhost/test/hello 返回其他 因此可以知道 = 是精确完整匹配, 且优秀最高 正则匹配时，如果 ~ 和 ^~ 同时匹配规则，则 ^~ 优先 ^~ 这个不会匹配请求url中后面的路径, 如上面的 /test/hello 没有匹配上 ^~ 不支持正则，和=相比，范围更广， hellowo 是可以被^~匹配，但是 = 不会匹配 ~ 路径中只要包含就可以匹配，如上面的 /test/hellowo 返回了602 测试case2: 1234567location ~ /hello &#123; return 602;&#125;location ~ /helloworld &#123; return 601;&#125; 12- 请求 localhost/world/helloworld 返回 602- 请求 localhost/helloworld 返回 602 调整一下上面的顺序之后 1234567location ~ /helloworld &#123; return 601;&#125;location ~ /hello &#123; return 602;&#125; 123- 请求 localhost/helloworld 返回601- 请求 localhost/world/helloworld 返回601- 请求 localhost/helloWorld 返回602 所以同时正则匹配时 放在前面的优先匹配 注意如果不区分大小写时，使用~* 尽量将精确匹配的放在前面 测试case3: 1234567location ^~ /hello/ &#123; return 601;&#125;location /hello/world &#123; return 602;&#125; 这种场景中，存在一个没有符号的路由规则，那么实际的测试是怎样呢？ 1234- http://localhost/hello/wor 返回601- http://localhost/hello/world 返回602- http://localhost/hello/world23 返回602- http://localhost/hello/world/123 返回602 从上面case可以看出 没有符号时，全匹配是优先于^~的 b. PartTwo: [uri]这里主要填的就是需要匹配的path路径，根据前面的符号，这里可以填写精确的path路径，也可以填正则表达式，下面则主要针对正则进行说明 123456789101112. ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的介绍&#123;n&#125; ： 重复n次&#123;n,&#125; ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 c. PartThree: {}匹配完毕之后内部定义一些列的处理动作，这个涉及到的点比较多，这里不详细展开，后面有空单独捞出 II. 路由转发 请求path匹配只是第一步，匹配完了之后，如何将请求转发给其他的web服务呢？ 0. 反向代理通常可见的一种使用姿势就是使用nginx，代理请求，转发到内部的tomact服务上 主要是通过 proxy_pass 这个来实现 123location ^~ /webs &#123; proxy_pass http://127.0.0.1:8080/webs;&#125; 将所有以 webs开头的请求，转发给8080端口的tomcat服务上 上面是直接写死转发到一个ip上，如果是多个机器提供服务呢？可以这么玩 12345678910## 下面放在http的括号内，作为第一层upstream test.online &#123; server 120.11.11.11:8080 weight=1; server 120.11.11.12:8080 weight=1;&#125;location ^~ /webs &#123; proxy_pass http://test.online; proxy_redirect default;&#125; 1. Rewrite命令rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。 rewrite只能放在server{},location{},if{}中， 并且只能对域名后边的除去传递的参数外的字符串起作用, 如 http://zbang.online/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。 语法rewrite regex replacement [flag]; 一个case，通过rewrite实现对url的重写，将下面的 12345678location ^~ /hexo &#123; root &apos;/Users/yihui/GitHub/&apos;;&#125;location ~ /hello &#123; rewrite ^(/hello).*$ /hexo/public/index.html last; return 603;&#125; 将hello开头的，全部转发到/hexo/public/index.html III. 小结1. demo将所有以blog开头的请求，全部转发到某个地方 123location ^~ /blog &#123; root &apos;/var/www/html/blog&apos;;&#125; 2. 路径匹配规则 = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 匹配顺序如下： =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 3. 路由转发 通过 proxy_pass 可以实现反向代理 通过 rewrite 可以实现路由转发 IV. 参考 location匹配顺序 nginx 常见正则匹配符号表示 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如有问题，请不吝指正，感激 扫描关注，不定时分享各种java学习笔记","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zbang.online/hexblog/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"https://zbang.online/hexblog/tags/配置/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}]},{"title":"Centos 安装gitbook","slug":"Centos-安装gitbook","date":"2017-12-25T03:26:00.000Z","updated":"2017-12-29T04:16:00.000Z","comments":true,"path":"2017/12/25/Centos-安装gitbook/","link":"","permalink":"https://zbang.online/hexblog/2017/12/25/Centos-安装gitbook/","excerpt":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务","text":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务 1. nodejs安装1sudo yum install nodejs 2. gitbook安装12npm install gitbook -gnpm install gitbook-cli -g 上面执行完毕，可能出现一个问题 1npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl 解决方法 1yum update openssl 3. calibre安装直接到官网上下载 ； ·https://calibre-ebook.com/download· 1sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\\n&apos;); exec(sys.stdin.read()); main()&quot; 4. 测试1gitbook build . 执行完毕之后，会出现一个 _book 目录， 里面就是生成的静态网页，直接加上去即可 5. 输出pdf如果报错 1ImportError: libGL.so.1: cannot open shared object file: No such file or directory 则安装 1yum install mesa-libGL.x86_64 如果报错 1ImportError: libXrender.so.1: cannot open shared object file: No such file or directory 1yum install libXrender.so.1 -y 参考文档 基于centos6构建私有gitbook平台","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Gitbook","slug":"Gitbook","permalink":"https://zbang.online/hexblog/tags/Gitbook/"},{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","slug":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","date":"2017-12-17T11:53:51.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","excerpt":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来","text":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来 1. 内容说明看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下 介绍下两种拷贝方式的区别 深拷贝的辅助工具类 如何自定义实现对象拷贝 II. 深拷贝和浅拷贝0. 定义说明深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 看到上面两个简单的说明，那么问题来了 浅拷贝中，是所有的内容公用呢？还是某些内容公用？ 从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？ 1. 浅拷贝一般来说，浅拷贝方式需要实现Cloneable接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Datapublic class ShallowClone implements Cloneable &#123; private String name; private int age; private List&lt;String&gt; books; public ShallowClone clone() &#123; ShallowClone clone = null; try &#123; clone = (ShallowClone) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125; public static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(28); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.clone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(20); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); &#125;&#125; 输出结果: 12345falsesource: ShallowClone(name=newName, age=20, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript])source: ShallowClone(name=newName, age=20, books=[hello])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript]) 结果分析： 拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址 基本元素类型，两者是隔离的（虽然上面只给出了int，String） 基本元素类型包括: int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String 非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份 其实，浅拷贝有个非常简单的理解方式： 浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 = 进行赋值 这个怎么理解呢？ 上面的流程拆解就是： 1234- Object clone = new Object();- clone.a = source.a- clone.b = source.b- ... 那么=赋值有什么特点呢？ 基本数据类型是值赋值；非基本的就是引用赋值 2. 深拷贝深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已 那么上面的实例改成深拷贝应该是怎样的呢？ 可以加上这么一个方法 1234567891011121314151617181920212223242526272829303132333435363738public ShallowClone deepClone() &#123; ShallowClone clone = new ShallowClone(); clone.name = this.name; clone.age = this.age; if (this.books != null) &#123; clone.books = new ArrayList&lt;&gt;(this.books); &#125; return clone;&#125;// 简单改一下测试casepublic static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(new Integer(1280)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.deepClone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(2000); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString());&#125; 输出结果为： 12345falsesource: ShallowClone(name=newName, age=2000, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++])source: ShallowClone(name=newName, age=2000, books=[hello])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++]) 结果分析： 深拷贝独立的对象 拷贝后对象的内容，与原对象的内容完全没关系，都是独立的 简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值 3. 应用场景区分深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了 那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？ 假设又这么一个通知对象长下面这样 12345private String notifyUser;// xxxprivate List&lt;String&gt; notifyRules; 我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样 在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了 III. 对象拷贝工具上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？ 对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝 Apache的两个版本：（反射机制） 1234org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils#cloneBean Spring版本：（反射机制） 1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高） 1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路 1. 借助反射实现对象拷贝通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值 上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125;&#125;private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; return null;&#125; 上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值 123Field field = obj.getClass().getDeclaredField(name);field.setAccessible(true);return field.get(obj); 如果找不到，则找getXXX, isXXX来获取 2. 代理的方式实现对象拷贝Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显 代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A 那么这种技术是如何使用在对象拷贝的呢？ 我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy 在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上 说明 从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了 IV. 小结1. 深拷贝和浅拷贝深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 完全独立 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性 需要实现Cloneable接口 2. 对象拷贝的两种方法通过反射方式实现对象拷贝 主要原理就是通过反射获取所有的属性，然后反射更改属性的内容 通过代理实现对象拷贝 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"clone","slug":"clone","permalink":"https://zbang.online/hexblog/tags/clone/"},{"name":"beancopy","slug":"beancopy","permalink":"https://zbang.online/hexblog/tags/beancopy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"图片合成支持的前世今生","slug":"图片合成支持的前世今生","date":"2017-12-17T09:50:31.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2017/12/17/图片合成支持的前世今生/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/图片合成支持的前世今生/","excerpt":"图片合成的前世今生 作为一个后端，为什么要做图片合成？为什么要实现类xml标记语言的渲染？ 本片博文准备详细的记录一下，一个java后端如何去支持图片合成，在这个过程中采用了哪些猥琐的方案，又遇到了哪些鬼畜的问题","text":"图片合成的前世今生 作为一个后端，为什么要做图片合成？为什么要实现类xml标记语言的渲染？ 本片博文准备详细的记录一下，一个java后端如何去支持图片合成，在这个过程中采用了哪些猥琐的方案，又遇到了哪些鬼畜的问题 I. 背景0. 无聊的技术研究最开始萌发支持图片合成的想法，那时候还是在做二维码的时候，用了一些awt的画图工具，感觉还挺有意思的，这是一个和当前的电商主流完全不搭边的技术分支，开始用的时候感慨，这东西牛逼了，什么都可以干（虽然操作非常不友好），再加上用到有道云，它的会员功能支持加功能将笔记以图片方式生成，所以就有个想法，java后端能不能支持markdown输出图片呢？ 1. 蛋疼的小程序不是一个专业的小程序开发者，虽然写过一个小程序，但是很多特性依然不知道； 突然很多前端突然提了这么一个需求，要求后端支持图片合成，用于分享到朋友圈 至于原因: 有的说小程序没有提供截屏接口 小程序不支持绘图（这个我不太确定真实性） 小程序绘图的api不可控（如果他们有bug，我们就没法玩了；对此我的看法是，你整个东西都是在小程序的体系里了，要是有个严重bug，那我们的小程序干脆就不玩好了…） 前端这么多，每个人都去绘制一遍低效，有个后端通用的，各个平台都释放了，都可以直接用… (对此我也没啥好说的，如果我是前端我也挺这一点；然而我不是，所以我拒绝😢) 声明 上面括号的内容纯粹是个人吐槽，没有任何偏向性， 2. 开动有需求了，就必须去支持了，而且从技术角度出发，这是一个非常有意思的点，新的挑战，可以一试 II. 技术尝试为了支持这个需求，尝试了不少的手段，接下来一一说明，当然由于个人见识有限，最终选择的也不一定是啥好东西，目前也只是处于可用的状态，离友好支持，还比较遥远 0. java的html渲染库 最先想到的就是这个，有没有直接可以渲染的库，大Java号称是在github上拥有最多开源工具的语言 查了一些开源库，也主动去尝试过一些，下面给出使用姿势 a. html2image直接在Github上搜，找一个最多star的就可以了，测试的框架 java-html2image 接入及测试方式 pmo 依赖引入 12345678910111213&lt;dependency&gt; &lt;groupId&gt;gui.ava&lt;/groupId&gt; &lt;artifactId&gt;html2image&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yoava&lt;/id&gt; &lt;name&gt;AOL yoava&lt;/name&gt; &lt;url&gt;http://yoava.artifactoryonline.com/yoava/repo&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 测试代码也比较简单 123456789@Testpublic void testRenderHtml() &#123; String url = \"http://www.baidu.com\"; HtmlImageGenerator generator = new HtmlImageGenerator(); generator.loadUrl(url); BufferedImage img = generator.getBufferedImage(); System.out.println(\"---\");&#125; 接下来就是看输出的图片了，看下是否和我们预期相同 这个颜色，样式有点鬼畜，折腾了一番，实际验证这个框架挺不错的，就是有以下几个问题 很久很久很久很久很久以前的产物了 没人维护 css样式支持不友好 换个复杂点的url，比如淘宝or蘑菇街商品详情页，返回就更鬼畜了，有兴趣的童鞋可自己尝试一下 b. xhtml渲染包这个也可以实现html渲染，又是一个老古董级别的东西，已经忘记从哪里捞出来的，最初实现markdown渲染成图片，就是采用的这个包，对简单的css的支持还算友好 pom依赖 12345678910111213&lt;!--html to image render--&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;core-renderer&lt;/artifactId&gt; &lt;version&gt;R8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--html to image render--&gt; 测试case 12345678910@Testpublic void testRender() &#123; try &#123; String url = \"http://www.baidu.com\"; BufferedImage buf = ImageRenderer.renderToImage(url, \"/Users/yihui/html2image.pdf\", 800); System.out.println(\"---\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用起来还是比较简单的，但是，上面这种直接执行，会抛异常，说访问的html有些语法有问题; 然后做了一些修改和调整，修正后的测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static DOMParser domParser;static &#123; domParser = new DOMParser(new HTMLConfiguration()); try &#123; domParser.setProperty(\"http://cyberneko.org/html/properties/names/elems\", \"lower\"); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Can't create HtmlParserImpl\", e); &#125;&#125;private Document parseDocument(String content) throws Exception &#123; domParser.parse(new InputSource(new StringReader(content))); return domParser.getDocument();&#125;private String readHtmlContent(String url) throws Exception &#123; InputStream in = HttpUtil.downFile(url); StringBuilder out = new StringBuilder(); byte[] b = new byte[4096]; for (int n; (n = in.read(b)) != -1; ) &#123; out.append(new String(b, 0, n)); &#125; return out.toString();&#125;@Testpublic void testRender() &#123; try &#123; String url = \"http://www.baidu.com\"; Document doc = parseDocument(readHtmlContent(url)); int width = 800; int height = 1024; Graphics2DRenderer renderer = new Graphics2DRenderer(); renderer.setDocument(doc, doc.getDocumentURI()); BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D graphics2D = GraphicUtil.getG2d(bufferedImage); // do layout with temp buffer renderer.layout(graphics2D, new Dimension(width, height)); graphics2D.dispose(); Rectangle size = renderer.getMinimumSize(); final int autoWidth = width; final int autoHeight = (int) size.getHeight(); bufferedImage = new BufferedImage(autoWidth, autoHeight, BufferedImage.TYPE_INT_RGB); Dimension dimension = new Dimension(autoWidth, autoHeight); graphics2D = GraphicUtil.getG2d(bufferedImage); renderer.layout(graphics2D, dimension); renderer.render(graphics2D); graphics2D.dispose(); System.out.println(\"---------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果输出图片为空白的页面，为啥？ 仔细去看百度的网页，发现没有dom结构，一堆的js和css代码，换个本地的html来试一下，输出效果还不错，我之前做了一个小工具，实现markdown转image，就是用的这个框架做中转，将markdown生成的html渲染为图片，当然复杂一点的css就不行了 相信看到这里，这个库的缺陷也好很明显了，不适合生产环境，自己玩玩还行 过于古老，基本没人维护 对html的格式有要求 复杂的css没法玩 指定宽度也比较恶心 c. 借助转pdf的包java中，提供html转pdf的包还不少，借助这些工具，也是可以间接实现这个功能的，具体的就不贴了，可以用的不少，收钱的，免费的都有 推荐几个搞标记的 flyingsaucer openhtmltopdf itext d. 小结基本上，没有找到合乎心意的转换包，其实有些包也不错，如果深入进去改一波，应该也能使用，然实际就是深入进去，基本上挖不动 1. imagemagic的合成大名鼎鼎的图片处理工具，c++的，可以提供图片的各种姿势的操作，当然也包括了图片合成，要玩这个，首先得搭建这个环境（这个成本比上面会大一点） a. 环境准备简单搭建方式： 12345678yum install libjpeg-develyum install libpng-devel# 本地环境搭建sudo brew install jpegsudo brew install libpngsudo brew install GraphicsMagick 搭建完毕后，测试先是否可用 1234## 搭建完毕，开始测试gm convert input.jpg -thumbnail &apos;100x100&apos; output_1.jpggm convert -crop 640x960+0+0 test.jpg output.jpg 如果上面的搞不定，也可以用下面的下载包的方式安装 12345678910111213141516安装jpeg 包 `wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz`安装webp 包 `wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz`安装png 包 `wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz`安装 graphicsmagick `wget http://nchc.dl.sourceforge.net/project/graphicsmagick/graphicsmagick/1.3.22/GraphicsMagick-1.3.22.tar.gz`## ----------make distclean ## 清楚上次make的东西imagemagick ：`wget http://www.imagemagick.org/download/ImageMagick.tar.gz`安装命令 `sudo ./configure; sudo make; sudo make install`裁图命令 `convert test.jpg -crop 640x960+0+0 output.jpg` linux 安装imagemagick 发现一直找不到 png的依赖， linux 安装之后，可能有两个问题 imagemagick 依然无法读取png图片 查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz 执行 convert 提示linux shared libraries 不包含某个库 临时解决方案： export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 一劳永逸的方案：https://my.oschina.net/guanyue/blog/220264 vi /etc/ld.so.conf 在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置 然后再执行/sbin/ldconf b. java调用当然，我们是java的后端，现在就需要用java来调用imagemagic的执行了 依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.im4java&lt;/groupId&gt; &lt;artifactId&gt;im4java&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 下面给一个图片裁剪的测试 123456789101112131415161718192021222324252627282930313233/** * 裁剪图片 * * @param imagePath 源图片路径 * @param outPath 处理后图片路径 * @param x 起始X坐标 * @param y 起始Y坐标 * @param width 裁剪宽度 * @param height 裁剪高度 * @return 返回true说明裁剪成功, 否则失败 */public static boolean cut(String imagePath, String outPath, int x, int y, int width, int height) &#123; boolean flag; try &#123; IMOperation op = new IMOperation(); op.addImage(imagePath); /** width：裁剪的宽度 * height：裁剪的高度 * x：裁剪的横坐标 * y：裁剪纵坐标 */ op.crop(width, height, x, y); op.addImage(outPath); // 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 ConvertCmd convert = new ConvertCmd(); convert.run(op); flag = true; &#125; catch (IOException e) &#123; flag = false; &#125; catch (InterruptedException e) &#123; flag = false; &#125; catch (IM4JavaException e) &#123; flag = false; &#125; return flag;&#125; 具体使用姿势就不说了，这个框架本身是支持简单的图片合成的，几张图和一下，加上文字水印啥的，主要说一下有什么问题 图片合成参数不是一般的复杂，想实现一个模板的合成，这个命令可以说很难完美的写出来 性能一般般 总得来说，这个用来做图片的基本操作还很好，真心不太合适复杂点的图片合成，分分钟虐哭 c. 其他一些不得不说的故事说到imagemagic，就不得不说graphicmagic，两者基本差不多，有说法是 graphicmagic的性能要高与imagemagic，那么我们为什么选择 imagemagic graphicmagic 处理jpg图片，会有精度丢失的问题（不知道是不是我的使用姿势不对，同样的case，imagemagic不会） 公司的基线是支持imagemagic的 很久以前写了一篇博文，就是如何利用 imagegraphic 搭建一个图片处理服务器的 im4java + imagemagic 搭建一个图片处理服务 2. awt的绘制利用java的awt包，也是可以实现绘图的，而且功能也比较强大，完全可以实现各种姿势的绘图场景, 一个case如 : 上面这个图的合成，就是基于awt做到的，这一张图，我们需要做些什么？ 图片的绘制 圆角图片 文字输出 文字对其方式 直线 矩形 纯色背景 一般来将，上面几种场景的支持，可以满足绝大多数的合图要求，接下来看一下是如何支持上面的几种case的 o. 接口定义定义一个基本的绘图单元接口 12public interface IDrawBO &#123;&#125; a. 图片 ： ImgBO图片的定义比较简单，一般只需要知道坐标，和宽高就ok了，所以我们的定义如下 123456789101112131415@Data@NoArgsConstructor@AllArgsConstructorpublic class ImgBO implements IDrawBO &#123; private BufferedImage image; private int x; private int y; private int w; private int h;&#125; b. 文字：FontBO文字相比较图片就有些额外的区别，有字体，样式、颜色，坐标，删除线 1234567891011121314151617@Data@NoArgsConstructor@AllArgsConstructorpublic class FontBO implements IDrawBO &#123; private String msgs; private Font font; private Color color; private int x; private int y; private boolean deleted = false;&#125; c. 直线: LineBO直线，除了我们常规的起点坐标，末尾坐标之外，颜色的设置，虚线样式也是常见的属性 123456789101112131415161718192021222324@Datapublic class LineBO implements IDrawBO &#123; public static final Stroke DEFAULT_STROKE = new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 3.5f, new float[]&#123;12, 6, 6, 6&#125;, 0f); private Color color; private int x1; private int y1; private int x2; private int y2; /** * 是否是虚线 */ private boolean dashed;&#125; d. 矩形： RoundRectBO和直线的属性差不多, 但是会多一些有意思的东西，如是否为圆角矩形 1234567891011121314151617181920212223242526272829public class RoundRectBO implements IDrawBO &#123; public static final Stroke DEFAULT_DASH = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 3.5f, new float[]&#123;4, 2,&#125;, 0f); private int x; private int y; private int w; private int h; private Color color; /** * 是否为虚线 */ private boolean dashed; /** * 圆角弧度 */ private int radius;&#125; e. 纯色： ColorBgBO纯色背景，相比较其他的会多一个透明度的属性，主要是因为很多场景下，会做一层纯色的浮层 1234567891011121314151617@Datapublic class ColorBgBO implements IDrawBO &#123; private Color color; private int w; private int h; private int x; private int y; private int radius; private boolean transparence;&#125; 上面定义了这些BO对象，仅仅是定义又什么用？接下来就需要实现对BO对象的绘制，也是核心的逻辑层了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Created by yihui on 2017/9/21. */public interface IShareModule &#123; void draw(Graphics2D g2d); default void drawFont(Graphics2D g2d, FontBO fontBo) &#123; if (fontBo != null) &#123; g2d.setFont(fontBo.getFont()); g2d.setColor(fontBo.getColor()); g2d.drawString(fontBo.getMsgs(), fontBo.getX(), fontBo.getY()); if (fontBo.isDeleted()) &#123; // 删除时，需要在文字上绘制一条删除线 FontMetrics fontMetrics = FontUtil.getFontMetric(fontBo.getFont()); int y = fontBo.getY() - (fontBo.getFont().getSize() &gt;&gt; 1) + fontMetrics.getDescent(); int w = fontMetrics.stringWidth(fontBo.getMsgs()); g2d.drawLine(fontBo.getX(), y, fontBo.getX() + w, y); &#125; &#125; &#125; default void drawImage(Graphics2D g2d, ImgBO imgBo) &#123; if (imgBo != null) &#123; g2d.drawImage(imgBo.getImage(), imgBo.getX(), imgBo.getY(), imgBo.getW(), imgBo.getH(), null); &#125; &#125; default void drawLine(Graphics2D g2d, LineBO lineBO) &#123; if(lineBo == null) return; g2d.setColor(lineBO.getColor()); if (lineBO.isDashed()) &#123; Stroke stroke = g2d.getStroke(); g2d.setStroke(LineBO.DEFAULT_STROKE); g2d.drawLine(lineBO.getX(), lineBO.getY(), lineBO.getX() + lineBO.getW(), lineBO.getY()); g2d.setStroke(stroke); &#125; else &#123; g2d.drawLine(lineBO.getX(), lineBO.getY(), lineBO.getX() + lineBO.getW(), lineBO.getY()); &#125; &#125; default void drawRoundRect(Graphics2D g2d, RoundRectBO roundRectBO) &#123; if(roundRectBO == null) return; g2d.setColor(roundRectBO.getColor()); if (!roundRectBO.isDashed()) &#123; g2d.drawRoundRect(roundRectBO.getX(), roundRectBO.getY(), roundRectBO.getW(), roundRectBO.getH(), roundRectBO.getRadius(), roundRectBO.getRadius()); &#125; else &#123; Stroke stroke = g2d.getStroke(); g2d.setStroke(RoundRectBO.DEFAULT_DASH); g2d.drawRoundRect(roundRectBO.getX(), roundRectBO.getY(), roundRectBO.getW(), roundRectBO.getH(), roundRectBO.getRadius(), roundRectBO.getRadius()); g2d.setStroke(stroke); &#125; if (roundRectBO.getSpaceW() &gt; 0) &#123; // 上边距空白的宽度 int x = roundRectBO.getX() + (roundRectBO.getW() - roundRectBO.getSpaceW() &gt;&gt; 1); int y = roundRectBO.getY() - 2; int w = roundRectBO.getSpaceW(); int h = 4; g2d.setColor(roundRectBO.getSpaceColor()); g2d.fillRect(x, y, w, h); &#125; &#125; default void drawColorBG(Graphics2D g2d, ColorBgBO color) &#123; if(color == null) return; g2d.setColor(color.getColor()); Composite composite = null; if (color.isTransparence()) &#123; composite = g2d.getComposite(); g2d.setComposite(AlphaComposite.Src); &#125; if (color.getRadius() == 0) &#123; g2d.fillRect(color.getX(), color.getY(), color.getW(), color.getH()); &#125; else &#123; g2d.fill(new RoundRectangle2D.Float(color.getX(), color.getY(), color.getW(), color.getH(), color.getRadius(), color.getRadius())); &#125; if (color.isTransparence()) &#123; g2d.setComposite(composite); &#125; &#125;&#125; 上面配合起来使用，就可以实现基本的模板图片的合成需求了，当然我们提供的服务比上面列出的要丰富一些，我们还支持 图片的处理：圆角，裁剪贴图 文字对齐：三种对齐方式，自动换行 小结&amp;问题上面虽然说可以支持合图的需求，但有个最大的问题，就是对后端的工作太多，每个模板，都需要后端来配合，进行参数指定，联调，极其繁琐和费时费力，分分钟搞死人 对这种方式，想的一个方法是，采用搭积木的方式支持，事先定义一系列的基本绘图组建，然后前端自己填入参数来组装 当然没有做，原因也很简单，接口太复杂，对前端不友好，没人愿意这么用，换成我也是不想这么干的 3. html 转 图片接着又来的是一个猥琐的方案，html转图，到github上一搜，发现还是js靠谱，比较多，一种常见的思路是： 采用无界面浏览器加载html页面，然后截图 在无界面浏览器中，非常有名的是 phantomjs，以及后起之秀chrome，这里主要说一下phantomjs的接入方式，简单提起chrmoe的无界面使用方式 a. 环境准备phantomjs 安装 12345678910111213141516171819202122232425262728293031# 1. 下载## mac 系统wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-macosx.zip## linux 系统wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2## windows 系统## 就不要玩了，没啥意思# 2. 解压sudo su tar -jxvf phantomjs-2.1.1-linux-x86_64.tar.bz2# 如果解压报错，则安装下面的# yum -y install bzip2# 3. 安装## 简单点，移动到bin目录下cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin# 4. 验证是否okphantomjs --version# 输出版本号，则表示ok pom依赖 1234567891011121314151617181920&lt;!--phantomjs --&gt;&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.53.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.detro&lt;/groupId&gt; &lt;artifactId&gt;ghostdriver&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; b. 实测思路比较清晰，在服务器上搭建一个phantomjs服务，然后java来调用，主要借助的是selenium和ghostdriver两个开源包，额外提一句，selenium在自动化测试和爬虫使用中非常有名，有兴趣的可以自己搜索相关资料，非常有意思的一个东西 图片渲染的主要业务逻辑： 12345678910111213141516171819202122232425262728public class Html2ImageByJsWrapper &#123; private static PhantomJSDriver webDriver = getPhantomJs(); private static PhantomJSDriver getPhantomJs() &#123; //设置必要参数 DesiredCapabilities dcaps = new DesiredCapabilities(); //ssl证书支持 dcaps.setCapability(&quot;acceptSslCerts&quot;, true); //截屏支持 dcaps.setCapability(&quot;takesScreenshot&quot;, true); //css搜索支持 dcaps.setCapability(&quot;cssSelectorsEnabled&quot;, true); //js支持 dcaps.setJavascriptEnabled(true); //驱动支持（第二参数表明的是你的phantomjs引擎所在的路径，which/whereis phantomjs可以查看） // fixme 这里写了执行， 可以考虑判断系统是否有安装，并获取对应的路径 or 开放出来指定路径 dcaps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY, &quot;/usr/local/bin/phantomjs&quot;); //创建无界面浏览器对象 return new PhantomJSDriver(dcaps); &#125; public static BufferedImage renderHtml2Image(String url) throws IOException &#123; webDriver.get(url); File file = webDriver.getScreenshotAs(OutputType.FILE); return ImageIO.read(file); &#125;&#125; 那么测试case就很好写了 12345@Testpublic void testRender() throws IOException &#123; String url = &quot;https://www.baidu.com&quot;; BufferedImage img = Html2ImageByJsWrapper.renderHtml2Image(url);&#125; 输出图片 看到这个结果之后，是否会觉得已经完美了？ 然而并不是，测试一些需要异步请求的接口，比较渣，性能差，返回的样式会错乱 c. 分析小结这个方案从实现来讲，是没有什么问题的，从支持情况来说，问题其实也不太大，那为什么不用这个方案呢？ 这个方案的支持，原本我的希望是前端传给我们需要渲染的html 是直出好的页面 所有的dom结构已经很清晰了， 尽量不要有什么js， 不要有异步请求， 不要又复杂的css依赖， 没有大量的图片 然而事与愿违，至于为什么不实现这样的html，我也不太懂前端的技术难点在哪，不好多评，那么也就只好转方案了 还有一点，对这个方案我不太满意的就是性能太渣，而且我也不知道可以怎么去优化，简单来讲，就是这个js渲染，完全不在我的把控之内，有什么问题、如何去优化、如何防止ssrf攻击，我都没有好的解决办法，所以我本人也是不喜欢这个方案的 d. chrome 方式chrome浏览器，大家都知道，chrome还有一种无界面启动方式，可能知道的比较少了 只要你本机安装了chrome浏览器，打开控制台就可以愉快的玩耍了，html输出图片的指令为 12345## 输出pdf/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --headless --print-to-pdf http://www.baidu.com## 输出图片/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --headless --screenshot http://www.baidu.com 输出截图 说明 chrome headless有很多指令，可设置窗口的大小解决上面的边框问题，有兴趣的可以百度 4. svg 转 图片然后万能的前端同学又提出了svg渲染图片，在提这个之前，完全没接触过svg，也不知道svg是个什么鬼，更不知道svg能不能渲染出图片（最重要的是java有没有现成可用的库） 查了一番，不错，发现apace有个batik，就是干这个事情的 插播一句，感觉无论多偏的东西，apache或者是google都至少有那么一个可以支持的开源项目，虽然有不少都已经不怎么维护了 a. 依赖整理依赖包有那么点多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!--batik svg to image--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-svggen&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-bridge&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-dom&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-parser&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-svg-dom&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-transcoder&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-util&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-xml&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.xmlgraphics/xmlgraphics-commons --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;xmlgraphics-commons&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.xmlgraphics/batik-codec --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-codec&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt; &lt;!-- 此处不能使用2.9.1版本，使用2.9.1生成png会失败 --&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;xerces&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;xercesImpl&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;2.5.0&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt;&lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xmlParserAPIs&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.axsl.org.w3c.dom.svg&lt;/groupId&gt; &lt;artifactId&gt;svg-dom-java&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xml-apis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.w3c.css&lt;/groupId&gt; &lt;artifactId&gt;sac&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt; b. 实测一个简单的接口支持 12345678910111213141516171819202122232425262728293031323334public static void convertToPngByFile(String path, OutputStream outputStream, Map&lt;String, String&gt; parmMap) throws TranscoderException, IOException &#123; try &#123; // 1. 加载document File file = new File(path); String parser = XMLResourceDescriptor.getXMLParserClassName(); SAXSVGDocumentFactory f = new SAXSVGDocumentFactory(parser); Document doc = f.createDocument(file.toURI().toString()); // 2. 遍历参数，填充渲染的svg节点 Set&lt;String&gt; keySet = parmMap.keySet(); for (Map.Entry&lt;String, String&gt; entry : parmMap.entrySet()) &#123; doc.getElementById(entry.getKey()).setTextContent(entry.getValue()); &#125; // 3. 输出图片 PNGTranscoder t = new PNGTranscoder(); TranscoderInput input = new TranscoderInput(doc); TranscoderOutput output = new TranscoderOutput(outputStream); t.transcode(input, output); outputStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面主要是为了演示下使用姿势，实际的项目中肯定不会这么简陋，官方使用链接: https://xmlgraphics.apache.org/batik/using/transcoder.html 分析下主要流程 解析svg文件，加载Document对象 根据传入的参数，填充Document中的节点 渲染输出图片 测试演示就不来了，最终方案就是这个，成品也没啥好说的 c. 问题 文本的边框支持问题: 即 outline属性 测试了好久，发现不支持这个属性 图片内容替换与文本内容替换是不一样的，需要区分对待 多个标签填充同样的内容时 从接口上来看，支持一个根据Name来获取节点功能，但是实际测试，发现标签name属性，并没有什么鸟用；不知道是使用姿势问题还是别的 然后翻看源码，发现当多个标签的id相同时，在Document的底层存储单元中，elementById 这个Map结构中，value会是一个数组 然后自然而然的想法就是，直接遍历这个数组，依次填充内容就好；结果发现压根就没有暴露这个接口，而这个属性是protectd，也无法直接访问 然后采用反射获取这个属性值，来绕过限制 模板加载缓存 实际场景中，模板往往是固定的，每次都进行渲染是非常消耗性能的，因此想的是能不能缓存住这个Document，再使用的时候，直接深拷贝一个对象出来，这样就避免了重复加载的开销 直接使用 AbstractDocumen#deepClone(true) 方法 然后，出现了一个鬼畜的并发问题，这个单独领出来细说，此处不展开 III. 最后收尾鉴于篇幅太长，有一些有意思的东西没有深入展开，特别是svg方案的支持中，遇到了一些比较有趣的问题，也涉及到三个好玩的知识点： 深拷贝+反射+并发，后面准备等这一块完结之后，好好的沉淀下，分析下这个case 1. 吐槽后端支持已经很勉强了，请大家都友好点，比如下面几个我实在支持不了 自定义设置字体（jdk字体，没新加一个都需要pe安装到jre的字体库） 图片的左上角圆角（暂时没想到好的解决方法） 渐变色（这个有点难） 这个需求，做得比较恶心，支持得也比较蛋疼，实现得比较猥琐，调bug修问题也比较闹心，总得来说，是一个开始前很有趣，做时让人吐血又很不爽，做完之后又特么的很有收获的需求 发现特别能有收获的事情，往往不是哪种做的特别爽的需求（爽，是因为这些东西你都完全能hold住，没什么难度了），相反是那些让你很闹心，完全不想继续下去的需求（因为你不了解，但是又不得不支持，还会遇到一堆鬼畜的bug，做完简直是吐血三升） 2. 小结图片合成的方式，我想应该不仅限于上面几种，由于限制于见识，终究是没有一个让人特别满意的方案，简单小结下上面的几种case java的开源包 html2image, xhtmlrender, pdfTech 一般来说，不怎么好用，大多不维护状态，对CSS的支持友好度待检验 imagemagic 适用于图片的基本处理，合图太复杂 awt绘图 属于基本的接口了，啥都可以干，只要你可以弄出来 但是工作量太大 js实现html渲染 phantmjs，效果不错，性能略渣，异步请求不友好，且完全不可控 chrome 性能由于上面的 svg渲染 batik 并不能非常完美的支持svg的渲染，有较多的限制要求，各种属性的必填，某些style的无法支持等 基本场景的支持，ok，优化后，性能高于html渲染，且可控 III. 其他体验网址基于react写了个前端，可以来体验渲染 phantomJs渲染 svg渲染 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"吐槽","slug":"杂记/吐槽","permalink":"https://zbang.online/hexblog/categories/杂记/吐槽/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/tags/杂记/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"吐槽","slug":"杂记/吐槽","permalink":"https://zbang.online/hexblog/categories/杂记/吐槽/"}]},{"title":"ForkJoin 学习使用笔记","slug":"ForkJoin-学习使用笔记","date":"2017-09-08T14:24:34.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2017/09/08/ForkJoin-学习使用笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/09/08/ForkJoin-学习使用笔记/","excerpt":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架","text":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架 I. 背景在日常的业务需求中，经常出现的批量查询，批量写入等接口的提供，一般来说，最简单最low的方式就是写一个for循环来一次执行，但是当业务方对接口的性能要求较高时，就比较尴尬了 通常可以想到的方式是采用并发操作，首先想到可以实现的方式就是利用线程池来做 通常实现方式如下 12345678910111213141516171819202122// 1. 创建线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"biz-exec\"), new ThreadPoolExecutor.CallerRunsPolicy());// 2. 创建执行任务List&lt;Future&lt;Object&gt;&gt; futureList = new ArrayList&lt;&gt;();for(Object arg : list) &#123; futureList.add(executorService.submit(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; // xxx &#125; &#125;));&#125;// 3. 结果获取for(Future f: futureList) &#123; Object obj = f.get();&#125; 用上面的这种方式并没有什么问题，我们接下来考虑的是如何使用ForkJoin框架来实现类似的功能 II. ForkJoin 基本知识 Fork: 将大任务拆分成若干个可以并发执行的小任务 Join: 合并所有小任务的执行结果 1. 任务分割ForkJoinTask : 基本任务，使用forkjoin框架必须创建的对象，提供fork,join操作，常用的两个子类 RecursiveAction : 无结果返回的任务 RecursiveTask : 有返回结果的任务 说明： fork : 让task异步执行 join : 让task同步执行，可以获取返回值 ForkJoinTask 在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行 2. 结果合并ForkJoinPool 执行 ForkJoinTask， 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。 当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务 三中提交方式： execute 异步，无返回结果 submit 异步，有返回结果 （返回Future&lt;T&gt;） invoke 同步，有返回结果 （会阻塞） III. 使用说明 结合两个场景，给出使用姿势 1. 累加 实现从 start - end 的累加求和 首先是定义一个CountTask 来实现求和 首先是确定任务分割的阀值，当 end-start 的差值大于阀值时，将任务一分为二 1234567891011121314151617181920212223242526272829303132333435public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private int start; private int end; private static final int THRED_HOLD = 30; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; boolean canCompute = (end - start) &lt;= THRED_HOLD; if (canCompute) &#123; // 不需要拆分 for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; System.out.println(\"thread: \" + Thread.currentThread() + \" start: \" + start + \" end: \" + end); &#125; else &#123; int mid = (end + start) / 2; CountTask left = new CountTask(start, mid); CountTask right = new CountTask(mid + 1, end); left.fork(); right.fork(); sum = left.join() + right.join(); &#125; return sum; &#125;&#125; 调用case 1234567891011@Testpublic void testFork() throws ExecutionException, InterruptedException &#123; int start = 0; int end = 200; CountTask task = new CountTask(start, end); ForkJoinPool pool = ForkJoinPool.commonPool(); Future&lt;Integer&gt; ans = pool.submit(task); int sum = ans.get(); System.out.println(sum);&#125; 输出结果： 123456789thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 51 end: 75thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 101 end: 125thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 0 end: 25thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 126 end: 150thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 76 end: 100thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 151 end: 175thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 26 end: 50thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 176 end: 20020100 2. 排序 int 数组进行排序 同样先定义一个SortTask, 主要是为了演示ForkJoin的使用姿势，具体的排序和合并的逻辑比较简陋的实现了一下（这块不是重点） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SortTask extends RecursiveTask&lt;List&lt;Integer&gt;&gt; &#123; private List&lt;Integer&gt; list; private final static int THRESHOLD = 5; public SortTask(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override protected List&lt;Integer&gt; compute() &#123; if (list.size() &lt; THRESHOLD) &#123; Collections.sort(list); System.out.println(\"thread: \" + Thread.currentThread() + \" sort: \" + list); return list; &#125; int mid = list.size() &gt;&gt; 1; SortTask l = new SortTask(list.subList(0, mid)); SortTask r = new SortTask(list.subList(mid, list.size())); l.fork(); r.fork(); List&lt;Integer&gt; left = l.join(); List&lt;Integer&gt; right = r.join(); return merge(left, right); &#125; private List&lt;Integer&gt; merge(List&lt;Integer&gt; left, List&lt;Integer&gt; right) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(left.size() + right.size()); int rightIndex = 0; for (int i = 0; i &lt; left.size(); i++) &#123; if (rightIndex &gt;= right.size() || left.get(i) &lt;= right.get(rightIndex)) &#123; result.add(left.get(i)); &#125; else &#123; result.add(right.get(rightIndex++)); i -= 1; &#125; &#125; if (rightIndex &lt; right.size()) &#123; result.addAll(right.subList(rightIndex, right.size())); &#125; return result; &#125;&#125; 测试case和上面基本一样，我们改用 invoke 替换上面的 submit 12345678@Testpublic void testMerge() throws ExecutionException, InterruptedException &#123; List&lt;Integer&gt; list = Arrays.asList(100, 200, 150, 123, 4512, 3414, 3123, 34, 5412, 34, 1234, 893, 213, 455, 6, 123, 23); SortTask sortTask = new SortTask(list); ForkJoinPool pool = ForkJoinPool.commonPool(); List&lt;Integer&gt; ans = pool.invoke(sortTask); System.out.println(ans);&#125; 输出结果 123456thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [34, 3123, 3414, 4512]thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] sort: [100, 123, 150, 200]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [34, 893, 1234, 5412]thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [213, 455]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [6, 23, 123][6, 23, 34, 34, 100, 123, 123, 150, 200, 213, 455, 893, 1234, 3123, 3414, 4512, 5412] IV. 其他参考 聊聊并发（八）——Fork/Join框架介绍 线程池与ForkJoin比较 关于看完ForkJoinPool和ForkJoinTask文章后一些总结 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://zbang.online/hexblog/tags/ForkJoin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"ffmpeg安装","slug":"ffmpeg安装","date":"2017-08-11T09:47:51.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2017/08/11/ffmpeg安装/","link":"","permalink":"https://zbang.online/hexblog/2017/08/11/ffmpeg安装/","excerpt":"I. 音频转码服务支持 机器扩容时，需要手动安装ffmpeg，以支持音频转码","text":"I. 音频转码服务支持 机器扩容时，需要手动安装ffmpeg，以支持音频转码 安装过程如下出于解压方便，将 .tar.xz 格式的压缩包转为 .tar.gz， 传到ftp待用 1234567891011121314151617181920212223242526272829## download ffmpge cmdwget https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-64bit-static.tar.xz## exact packagexz -d ffmpeg-release-64bit-static.tar.xztar -xvf ffmpeg-release-64bit-static.tarmv ffmpeg-release-64bit-static ffmpegtar -zcvf ffmpeg.tar.gz ffmpeg## 将安装包上传到ftpftp ftp.mogujie.orgput ffmpeg.tar.gz## 登录到新的机器， 安装ftpsudo yum install ftp## 下载安装包ftp ftp.mogujie.orgget ffmpeg.tar.gz## 进入mapp目录cp ffmpeg.tar.gz /home/yihui## 解压tar -zxvf ffmpeg.tar.gz II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zbang.online/hexblog/tags/ffmpeg/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"imagemagic安装","slug":"imagemagic安装","date":"2017-08-09T09:45:08.000Z","updated":"2018-04-17T08:13:16.802Z","comments":true,"path":"2017/08/09/imagemagic安装/","link":"","permalink":"https://zbang.online/hexblog/2017/08/09/imagemagic安装/","excerpt":"ImageMagic 安装ImageMagic/GraphicMagic 使用for java（im4java）","text":"ImageMagic 安装ImageMagic/GraphicMagic 使用for java（im4java） 1. 环境配置一键安装方式 123456789101112yum install libjpeg-develyum install libpng-devel本地环境搭建sudo brew install jpegsudo brew install libpngsudo brew install GraphicsMagickgm convert input.jpg -thumbnail '100x100' output_1.jpggm convert -crop 640x960+0+0 test.jpg output.jpg 源码安装方式 安装jpeg 包 wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz 安装webp 包 wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz 安装png 包 wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz 安装 graphicsmagick wget http://nchc.dl.sourceforge.net/project/graphicsmagick/graphicsmagick/1.3.22/GraphicsMagick-1.3.22.tar.gz 安装imagemagick wget http://www.imagemagick.org/download/ImageMagick.tar.gz 安装命令 sudo ./configure; sudo make; sudo make install 几个命令 make distclean 清除上次make的东西 裁图命令 convert test.jpg -crop 640x960+0+0 output.jpg 问题修复 linux 安装imagemagick 发现一直找不到 png的依赖，查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz imagemagick 依然无法读取png图片 执行 convert 提示linux shared libraries 不包含某个库 –》临时解决方案： export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 一劳永逸的方案：https://my.oschina.net/guanyue/blog/220264 vi /etc/ld.so.conf 在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置 然后再执行/sbin/ldconf 2. 常用命令汇总图片操作方式 裁图 + 旋转 + 缩放 + 缩略图 + 翻转（flip） + 镜像（flop） + 水印(composite) + 边框(border) 裁图 convert test.jpg -crop 640x960+0+0 output.jpg 旋转 convert test.jpg -rotate 90 output.jpg 缩放 convert test.jpg -resize 200x200 output.jpg 强制宽高缩放 convert test.jpg -resize 200x200! output.jpg 缩略图 convert -thumbnail 200x300 test.jpg thumb.jpg 翻转 上下翻转： convert -flip foo.png bar.png 左右翻转： convert -flop foo.png bar.png 图片合成方式 水印 ：composite -gravity northwest -dissolve 100 -geometry +0+0 water.png temp.jpg out.jpg 其中 gravity 表示起始位置dissolve 表示水印图片的透明度， 100 表示100%透明water.png为水印图， temp.jpg 为背景图, out.jpg 为输出图片 方法二：convert -gravity southeast -geometry +5+10 -composite test.jpg water.png out.jpg water.png作为水印图片，合在test.jpg的东南 （5，10）坐标处，输出文件为 out.jpg 添加边框 : convert -border 6x6 -bordercolor &quot;#ffffff&quot; test.jpg bord.jpg 去除边框 : convert -thumbnail 200x300 test.jpg thumb.jpg II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"imagemagic","slug":"imagemagic","permalink":"https://zbang.online/hexblog/tags/imagemagic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"4. SPI框架实现之旅四：使用测试","slug":"SPI框架实现之旅四：使用测试","date":"2017-05-30T12:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/30/SPI框架实现之旅四：使用测试/","link":"","permalink":"https://zbang.online/hexblog/2017/05/30/SPI框架实现之旅四：使用测试/","excerpt":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等","text":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等 1. 简单的静态使用定义一个SPI接口 IPrint, 两个实现 FilePrint, ConsolePrint 123456789101112131415161718@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125; 添加配置文件 com.hust.hui.quicksilver.spi.test.print.IPrint, 内容如下 com.hust.hui.quicksilver.spi.test.print.ConsolePrint com.hust.hui.quicksilver.spi.test.print.FilePrint 测试代码如下 1234567891011121314151617181920212223242526272829@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;); print.print(&quot;console----&gt;&quot;); print = spiLoader.getService(&quot;FilePrint&quot;); print.print(&quot;file----&gt;&quot;); try &#123; print = spiLoader.getService(&quot;undefine&quot;); print.print(&quot;undefine----&quot;); Assert.assertTrue(false); &#125; catch (Exception e) &#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125; try &#123; print = spiLoader.getService(123); print.print(&quot;type error----&quot;); Assert.assertTrue(false); &#125; catch (Exception e)&#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125;&#125; 输出如下 1234console print: console----&gt;file print: file----&gt;type error--&gt;com.hust.hui.quicksilver.spi.exception.NoSpiMatchException: no spiImpl match the name you choose! your choose is: undefinetype error--&gt;java.lang.IllegalArgumentException: conf spiInterfaceType should be sub class of [class java.lang.String] but yours:class java.lang.Integer 演示如下 2. 动态适配与静态的使用有点区别，主要的区别点在于接口的定义（需要注意第一个参数是作为选择器选择SPI实现的参数），同样是上面这个spi接口 123456789101112131415161718192021222324252627282930313233@Spipublic interface IPrint &#123; void print(String str); void adaptivePrint(String conf, String str);&#125; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"file adaptivePrint: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"console adaptivePrint: \" + str); &#125;&#125; 主要是新增了一个接口 adaptivePrint, 其他的没有啥区别，测试代码如下 12345678@Testpublic void testAdaptivePrint() throws SpiProxyCompileException &#123; IPrint print = SpiLoader.load(IPrint.class).getAdaptive(); print.adaptivePrint(\"FilePrint\", \"[file print]\"); print.adaptivePrint(\"ConsolePrint\", \"[console print]\");&#125; 输出结果 1234567891011121314151617181920212223242526file adaptivePrint: [file print]console adaptivePrint: [console print]``` 演示图 ![http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif](http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif)## 3. 自定义选择器&gt; 上面两个很简单的演示了下使用方式，最基本的方法， 没有加上 @SpiConf 注解， 没有显示指定选择器类型，下面则演示下，如何自定义选择器**SPI接口**有一个欢迎方法，我们需求根据用户的来源显示不同的欢迎至此， 下面定义了一个 `UserSelector`选择器，这个就是我们自定义的选择器```java@Spipublic interface IUser &#123; @SpiAdaptive(selector = UserSelector.class) void welcome(UserDO userDO);&#125; spi实现类 123456789101112131415public class QQUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"qq 欢迎你! \" + userDO); &#125;&#125;public class WeixinUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"weixin 欢迎你! \" + userDO); &#125;&#125; META-INF/services/ 目录下的配置如下 com.hust.hui.quicksilver.spi.def.spi.IUser com.hust.hui.quicksilver.spi.def.spi.QQUser com.hust.hui.quicksilver.spi.def.spi.WeixinUser 选择器实现如下 12345678910111213141516171819public class UserSelector implements ISelector&lt;UserDO&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, UserDO conf) throws NoSpiMatchException &#123; if (conf == null || conf.getMarket() == null) &#123; throw new IllegalArgumentException(\"userDo or userDO#market should not be null!\"); &#125; String name = conf.getMarket().getName(); if (map.containsKey(name)) &#123; return map.get(name).getSpiImpl(); &#125; throw new NoSpiMatchException(\"no spiImp matched marked: \" + conf.getMarket()); &#125;&#125; 从上面的选择器逻辑可以看出，我们是根据 UserDO的market参数来进行选择的， UserDO的定义如下 12345678910111213141516171819202122232425262728@Getter@Setter@ToStringpublic class UserDO &#123; private String uname; private String avatar; private MarketEnum market;&#125;public enum MarketEnum &#123; WEIXIN(\"WeixinUser\"), QQ(\"QQUser\"); private String name; MarketEnum(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 测试代码如下 123456789101112131415161718192021@Testpublic void testUserSPI() throws SpiProxyCompileException &#123; SpiLoader&lt;IUser&gt; loader = SpiLoader.load(IUser.class); IUser user = loader.getAdaptive(); UserDO weixinUser = new UserDO(); weixinUser.setAvatar(\"weixin.avatar.jpg\"); weixinUser.setUname(\"微信用户\"); weixinUser.setMarket(MarketEnum.WEIXIN); user.welcome(weixinUser); UserDO qqUser = new UserDO(); qqUser.setAvatar(\"qq.avatar.jpg\"); qqUser.setUname(\"qq用户\"); qqUser.setMarket(MarketEnum.QQ); user.welcome(qqUser); System.out.println(\"-----over------\");&#125; 输出结果: weixin 欢迎你! UserDO(uname=微信用户, avatar=weixin.avatar.jpg, market=WEIXIN) qq 欢迎你! UserDO(uname=qq用户, avatar=qq.avatar.jpg, market=QQ) 演示如下: 3. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"3. SPI框架实现之旅三：实现说明","slug":"SPI框架实现之旅三：实现说明","date":"2017-05-29T02:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/29/SPI框架实现之旅三：实现说明/","link":"","permalink":"https://zbang.online/hexblog/2017/05/29/SPI框架实现之旅三：实现说明/","excerpt":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下：","text":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下： SpiLoader 全解析 spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等 1. 获取spiLoader对象 SpiLoader 是一个泛型对象，每个SPI接口，对应一个SpiLoader&lt;T&gt; 对象，我们提供了一个静态方法来获取这个对象 实现优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回 123456789101112131415161718192021222324252627282930/*** spiLoader缓存, 其中key为 spi接口, value为对应的Loader对象*/private static final ConcurrentMap&lt;Class&lt;?&gt;, SpiLoader&lt;?&gt;&gt; loaderCache = new ConcurrentHashMap&lt;&gt;();@SuppressWarnings(\"unchecked\")public static &lt;T&gt; SpiLoader&lt;T&gt; load(Class&lt;T&gt; type) &#123; if (null == type) &#123; throw new IllegalArgumentException(\"common cannot be null...\"); &#125; if (!type.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must be interface!\"); &#125; if (!withSpiAnnotation(type)) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must have the annotation of @Spi\"); &#125; SpiLoader&lt;T&gt; spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); if (spiLoader == null) &#123; loaderCache.putIfAbsent(type, new SpiLoader&lt;&gt;(type)); spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); &#125; return spiLoader;&#125; 说明 上面有几个校验，前一篇已经说明，不再赘述 上面新建对象，不是线程安全的 2. 新建 SpiLoader对象 创建对象，主要会初始化选择器 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private SpiLoader(Class&lt;T&gt; type) &#123; // 初始化默认的选择器, 为保留项目, 必然会提供的服务 selectorInstanceCacheMap.putIfAbsent(DefaultSelector.class, DEFAULT_SELECTOR); this.spiInterfaceType = type; initSelector();&#125;private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 持有一个选择器缓存列表，selectorInstanceCacheMap 保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在 不做成全局唯一的原因是尽量隔离, 比如 ParamsSelector 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类 类选择器 + 方法选择器 currentSelector ： 类选择器, 解析 @Spi 注解获取，适用于静态选择 + 动态选择两种使用方式 currentMethodSelector : 方法选择器，解析 @SpiAdaptive 注解获取， 仅适用于动态选择SPI实现的方式 优先级： 方法上定义的选择器 由于 类上定义的选择器； 方法上未定义时，默认使用类定义的选择器 3. 静态使用 静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回 实现1234567891011121314151617181920212223242526272829303132333435/*** 根据传入条件, 选择具体的spi实现类* &lt;p/&gt;* 这里要求conf的类型和选择器的参数类型匹配, 否则会尝试使用默认的选择器补救, 若补救失败, 则抛异常** @param conf* @return* @throws NoSpiMatchException* @throws IllegalArgumentException*/@SuppressWarnings(\"unchecked\")public T getService(Object conf) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; if (!currentSelector.getConditionType().isAssignableFrom(conf.getClass())) &#123; /** * 参数类型不匹配时, 判断是否可以根据默认的选择器来获取 */ if (conf instanceof String) &#123; return (T) DEFAULT_SELECTOR.getSelector().selector(spiImplClassCacheMap, conf); &#125; /** * 参数类型完全不匹配, 则抛参数异常 */ throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; return (T) currentSelector.getSelector().selector(spiImplClassCacheMap, conf);&#125; 说明 spiImplClassCacheMap spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑 校验 校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行 当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的） 静态使用方式，使用类定义选择器 : currentSelector 静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的 静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释 IPrint 是一个Spi接口， 有两个实现 FilePrint, ConsolePrint 假设 `currentSelector=DefaultSelector`， 方法 methodA 上定义的是 ParamsSelector 时 静态使用方式，获取一个spi实现，希望在所有的spi接口使用处，都输出到文件，用户根据 `FilePrint` 选择 FilePrint 这个类来执行具体的输出逻辑， 如果在调用 methodA 方法执行时， 假设根据 ParamsSelector 判断， ConsolePrint 才满足这儿条件，这是相当于在具体实现时，换成了另一个 ConsolePrint, 这下子就与我们的初衷背离了（如果目标是想实现这个场景，显然动态适配的方式才是正确的使用姿势） loadService 的逻辑后面详细说明 4. 动态使用 动态使用区别于静态的直接确定实现类， 通过getService 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行 设计的出发点可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？ 考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的 最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回 实现如下和静态实现的逻辑差不多，一般流程如下: 判断spi实现类的映射关系表是否初始化，若没有则初始化 获取选择器 优先从方法选择器中查找， 若存在，则直接选中； 不存在，则使用类选择器 校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件） 返回实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@SuppressWarnings(\"unchecked\")public T getService(Object conf, String methodName) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; // 首先获取对应的selector SelectorWrapper selector = currentMethodSelector.get(methodName); if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector); &#125; if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; selector = DEFAULT_SELECTOR; &#125; if (spiImplMethodCacheMap.size() == 0) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; try &#123; // 采用默认的选择器,根据指定name 进行查询时, 需要兼容一下, 因为method对应的缓存key为 SpiImpName_methodName if (DEFAULT_SELECTOR.equals(selector)) &#123; if (spiImplMethodCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; if (spiImplClassCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf + \"_\" + methodName); &#125; else &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; &#125; catch (Exception e) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125;&#125; 说明 这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑） 区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器 默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 spiImplMethodCacheMap 中key的生成，有一个小转换 若实现类上没有 @SpiConf注解，或者 @SpiConf的注解没有定义 name 属性，则类的唯一标识name为：简单类名； 否则为指定的name属性 若方法上显示使用 @SpiConf 指定了name属性，则key的生成规则为： 方法注解上指定的name； 如果没有 @SpiConf注解，或其中没有指定name属性，则key生成规则: 类name属性 + 下划线 + 方法名 这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来 动态生成代理类的逻辑，放在最后进行说明 5. spi实现类映射关系表初始化 为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干 缓存结构使用了两个Map： 一个是类级别的映射关系 spiImplClassCacheMap 静态使用时，只会用搞这个 动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断 key： @SpiConf 注解中定义的name； 或者spi实现类的简单类名 一个是方法的映射关系 spiImplMethodCacheMap 动态适配时， 选择器优先从这里进行判断 key: @SpiConf 注解中定义的name； 或者是 实现类的 name + “_” + 方法名 12345678910/*** name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplClassCacheMap;/*** 自适应时, 根据方法选择实现; name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplMethodCacheMap; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private void loadSpiService() &#123; List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;(); List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceMethodList = new ArrayList&lt;&gt;(); ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType); SpiConf spiConf; String implName; int implOrder; for (T t : serviceLoader) &#123; spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); String methodImplName; int methodImplOrder; Map&lt;String, String&gt; methodParams; for (Method method : methods) &#123; spiConf = method.getAnnotation(SpiConf.class); if (spiConf == null) &#123; continue; &#125; // 方法上有自定义注解, 且定义的name与类实现名不同, 则直接采用 // 否则采用 ServiceName_MethodName 方式定义 if (StringUtils.isBlank(spiConf.name()) || implName.equals(spiConf.name())) &#123; methodImplName = implName + \"_\" + method.getName(); &#125; else &#123; methodImplName = spiConf.name(); &#125; // 优先级, 以最小的为准 （即一个类上的优先级很低, 也可以定义优先级高的方法） // 方法注解未定义顺序时, 继承类上的顺序 methodImplOrder = Math.min(implOrder, spiConf.order() &lt; 0 ? implOrder : spiConf.order()); // 自适应方法的参数限制, 要求继承类上的参数 methodParams = parseParms(spiConf.params()); if (map.size() &gt; 0) &#123; // 方法的参数限定会继承类上的参数限定 if (methodParams.size() == 0) &#123; methodParams = map; &#125; else &#123; methodParams.putAll(map); &#125; &#125; spiServiceMethodList.add(new SpiImplWrapper&lt;&gt;(t, methodImplOrder, methodImplName, methodParams)); &#125; &#125; if (spiServiceList.size() == 0) &#123; throw new IllegalStateException(\"no spiImpl implements spi: \" + spiInterfaceType); &#125; this.spiImplClassCacheMap = initSpiImplMap(spiServiceList); this.spiImplMethodCacheMap = initSpiImplMap(spiServiceMethodList);&#125;private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; initSpiImplMap(List&lt;SpiImplWrapper&lt;T&gt;&gt; list) &#123; // 映射为map, 限定不能重名 Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; tempMap = new ConcurrentHashMap&lt;&gt;(); for (SpiImplWrapper&lt;T&gt; wrapper : list) &#123; if (tempMap.containsKey(wrapper.getName())) &#123; throw new IllegalArgumentException(\"duplicate spiImpl name \" + wrapper.getName()); &#125; tempMap.put(wrapper.getName(), wrapper); &#125; return tempMap;&#125; 上面的逻辑可以分为两块，一块是上半边的初始化，获取spiImplClassCacheMap;下一块则是扫描实现类的所有方法，将方法上标有@SpiConf注解的捞出来，用于初始化 spiImplMethodCacheMap 说明 缓存结构中value为 SpiImplWrapper 缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了 1234567891011121314151617181920private T spiImpl;private int order;/*** spiImpl 的标识name, 要求唯一* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.DefaultSelector 选择具体的SpiImpl 时使用&#125;*/private String name;/*** 参数校验规则* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.ParamsSelector&#125; 选择具体的SpiImpl 时使用* 要求每个实现类都有注解 &#123;@link SpiConf&#125;*/private Map&lt;String, String&gt; paramCondition; name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明 采用 ParamsSelector 时， 要求 @SpiConf 注解必须存在 注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题 // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); 动态代码生成 上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法 1. 代理类格式采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码 获取具体的实现类 （调用上面的 SpiLoader.getService(conf, methodName） 执行实现类的接口 123456789101112131415161718192021222324package com.hust.hui.quicksilver.spi.test.print;import com.hust.hui.quicksilver.spi.SpiLoader;public class IPrint$Proxy implements com.hust.hui.quicksilver.spi.test.print.IPrint &#123; public void print(java.lang.String arg0) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"print\"); spiImpl.print(arg0); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125; public void adaptivePrint(java.lang.String arg0, java.lang.String arg1) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"adaptivePrint\"); spiImpl.adaptivePrint(arg0, arg1); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125;&#125; 上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行） 代理类生成对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 构建SPI接口的实现代理类, 在执行动态适配的方法时, 调用SpiLoader的 spiImpl选择器, 选择具体的实现类执行 * * @return */public static String buildTempImpl(Class type) &#123; StringBuilder codeBuilder = new StringBuilder(); codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); codeBuilder.append(\"\\nimport \").append(SpiLoader.class.getName()).append(\";\"); codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Proxy implements \").append(type.getCanonicalName()).append(\" &#123;\\n\"); Method[] methods = type.getMethods(); for (Method method : methods) &#123; Class&lt;?&gt; returnType = method.getReturnType(); //函数返回值 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//函数参数列表 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();//函数异常列表 // build method code StringBuilder code = new StringBuilder(512); if (parameterTypes.length &lt; 0) &#123; //检查该函数参数列表中，第一个参数作为选择器参数 code.append(\"throw new IllegalArgumentException(\\\"there should be one argument for selector to choose spiImpl\\\")\"); &#125; else &#123; // 没有 SpiAdaptive注解的, 采用默认的注解方式 code.append(\"try&#123;\\n\"); code.append(type.getName()).append(\" spiImpl=\") .append(\"SpiLoader.load(\") .append(type.getName()).append(\".class\") .append(\").getService(arg0,\\\"\") .append(method.getName()) .append(\"\\\");\"); if (!\"void\".equals(returnType.getName())) &#123; code.append(\"return \"); &#125; code.append(\"spiImpl.\").append(method.getName()).append(\"(arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; code.append(\",\").append(\"arg\").append(i); &#125; code.append(\");\"); code.append(\"\\n&#125; catch(com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e)&#123;\\nthrow new java.lang.RuntimeException(e);\\n&#125;\"); &#125; // build method signature codeBuilder.append(\"\\npublic \").append(returnType.getName()).append(\" \").append(method.getName()) .append(\"(\").append(parameterTypes[0].getName()).append(\" arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; codeBuilder.append(\", \").append(parameterTypes[i].getName()).append(\" arg\").append(i); &#125; codeBuilder.append(\") \"); if (exceptionTypes.length &gt; 0) &#123; codeBuilder.append(\"throw \").append(exceptionTypes[0].getName()); for (int i = 1; i &lt; exceptionTypes.length; i++) &#123; codeBuilder.append(\", \").append(exceptionTypes[i].getName()); &#125; &#125; codeBuilder.append(\"&#123;\\n\"); codeBuilder.append(code.toString()).append(\"\\n&#125;\"); &#125; codeBuilder.append(\"\\n&#125;\"); return codeBuilder.toString();&#125; 动态编译运行动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译 12345678910111213141516@SuppressWarnings(\"unchecked\")public static &lt;T&gt; T compile(String code, Class&lt;T&gt; interfaceType, ClassLoader classLoader) throws SpiProxyCompileException &#123; GroovyClassLoader loader = new GroovyClassLoader(classLoader); Class clz = loader.parseClass(code); if (!interfaceType.isAssignableFrom(clz)) &#123; throw new IllegalStateException(\"illegal proxy type!\"); &#125; try &#123; return (T) clz.newInstance(); &#125; catch (Exception e) &#123; throw new SpiProxyCompileException(\"init spiProxy error! msg: \" + e.getMessage()); &#125;&#125; 小结至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了 博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"2. SPI框架实现之旅二：整体设计","slug":"SPI框架实现之旅二：整体设计","date":"2017-05-28T02:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/28/SPI框架实现之旅二：整体设计/","link":"","permalink":"https://zbang.online/hexblog/2017/05/28/SPI框架实现之旅二：整体设计/","excerpt":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式","text":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式 设计思路下图围绕 SpiLoader 为中心，描述了三个主要的流程： load所有的spi实现 初始化选择器 selector 获取spi实现类 （or一个实现类代理） 基础类说明 主要介绍一下框架中涉及到的接口和注解，并指出需要注意的点 1. Selector 选择器 为了最大程度的支持业务方对spi实现类的选择，我们定义了一个选择器的概念，用于获取spi实现类 接口定义如下:123public interface ISelector&lt;T&gt; &#123; &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, T conf) throws NoSpiMatchException;&#125; 结合上面的接口定义，我们可以考虑下，选择器应该如何工作？ 根据传入的条件，从所有的实现类中，找到一个最匹配的实现类返回 如果查不到，则抛一个异常NoSpiMatchException出去 所以传入的参数会是两个， 一个是所有的实现类列表map（至于上面为什么用map，后续分析），一个是用于判断的输入条件conf 框架中会提供两种基本的选择器实现， DefaultSelector ， 对每个实现类赋予唯一的name，默认选择器则表示根据name来查找实现类 ParamsSelector， 在实现类上加上 @SpiConf 注解，定义其中的 params，当传入的参数(conf)， 能完全匹配定义的params，表示这个实现类就是你所需要的 自定义实现自定义实现比较简单，实现上面的接口即可 2. Spi 注解 要求所有的spi接口，都必须有这个注解； 定义如下主要是有一个参数，用于指定是选择器类型，定义spi接口的默认选择器， 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Spi &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明在上一篇《SPI框架实现之旅一》中，使用jdk的spi方式中，并没有使用注解依然可以正常工作，我们这里定义这个注解且要求必需有，出于下面几个考虑 醒目，告诉开发者，这个接口是声明的spi接口， 使用的时候注意下 加入选择器参数，方便用户扩展自己的选择方式 3. SpiAdaptive 注解 对需要自适应的场景，为了满足一个spi接口，应用多重不同的选择器场景，可以加上这个注解；如果不加这个注解，则表示采用默认的选择器来自适应 接口说明1234567891011/** * SPI 自适应注解, 表示该方法会用到spi实现 * &lt;p/&gt; * Created by yihui on 2017/5/24. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface SpiAdaptive &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明这个注解内容和 @Spi 基本上一模一样，唯一的区别是一个放在类上，一个放在方法上，那么为什么这么考虑？ @Spi 注解放在类上，更多的表名这个接口是我们定义的一个SPI接口，但是使用方式可以有两种（静态 + 动态确认） @SpiAdaptive 只能在自适应的场景下使用，用于额外指定spi接口中某个方法的选择器 （如果一个spi接口全部只需要一个选择器即可，那么可以不使用这个注解） 如下面的这个例子，print方法和 echo方法其实是等价的，都是采用 DefaultSelector 来确认具体的实现类；而 write 和 pp 方法则是采用 ParamsSelector 选择器; 1234567891011121314151617181920/** * Created by yihui on 2017/5/25. */@Spipublic interface ICode &#123; void print(String name, String contet); @SpiAdaptive void echo(String name, String content); @SpiAdaptive(selector = ParamsSelector.class) void write(Context context, String content); @SpiAdaptive(selector = ParamsSelector.class) void pp(Context context, String content);&#125; 4. SpiConf 注解 这个主键主要是用在实现类上（或实现类的方法上），里面存储一些选择条件，通常是和Selector搭配使用 定义如下定义了三个字段: name 唯一标识，用于 DefaultSelector； params 参数条件， 用于 ParamsSelector； order : 优先级， 主要是为了解决多个实现类都满足选择条件时， 应该选择哪一个 （谈到这里就有个想法， 通过一个参数，来选择是否让满足条件的全部返回） 123456789101112131415161718192021222324252627282930@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface SpiConf &#123; /** * 唯一标识 * * @return */ String name() default \"\"; /** * 参数过滤, 单独一个元素,表示参数必须包含; 用英文分号,左边为参数名,右边为参数值,表示参数的值必须是右边的 * &lt;p/&gt; * 形如 &#123;\"a\", \"a:12\", \"b:TAG\"&#125; * * @return */ String[] params() default &#123;&#125;; /** * 排序, 越小优先级越高 * * @return */ int order() default -1;&#125; 说明SpiConf 注解可以修饰类，也可以修饰方法，因此当一个实现类中，类和方法都有这个注解时， 怎么处理 ？ 以下面的这个测试类进行说明 1234567891011121314151617181920212223242526272829303132333435/** * Created by yihui on 2017/5/25. */@SpiConf(params = \"code\", order = 1)public class ConsoleCode implements ICode &#123; @Override public void print(String name, String contet) &#123; System.out.println(\"console print:---&gt;\" + contet); &#125; /** * 显示指定了name, 因此可以直接通过 consoleEcho 来确定调用本实现方法 * @param name * @param content */ @Override @SpiConf(name = \"consoleEcho\") public void echo(String name, String content) &#123; System.out.println(\"console echo:----&gt;\" + content); &#125; /** * 实际的优先级取 方法 和类上的最高优先级, 实际为1； * `ParamsSelector`选择器时， 执行该方法的条件等同于 `&#123;\"code\", \"type:console\"&#125;` * @param context * @param content */ @Override @SpiConf(params = &#123;\"type:console\"&#125;, order = 3) public void write(Context context, String content) &#123; System.out.println(\"console write:----&gt;\" + content); &#125;&#125; 在设计中，遵循下面几个原则： 类上的SpiConf注解， 默认适用与类中的所有方法 方法上有SpiConf注解，采取下面的规则 方法注解声明name时，两个会同时生效，即想调用上面的echo方法， 通过传入 ConsoleCode（类注解不显示赋值时，采用类名代替） 和 consoleEcho 等价 方法注解未声明name时，只能通过类注解上定义的name（or默认的类名）来选择 order，取最高优先级，如上面的 write 方法的优先级是 1; 当未显示定义order时，以定义的为准 params: 取并集，即要求类上 + 方法上的条件都满足 SPI加载器 spi加载器的主要业务逻辑集中在 SpiLoader 类中，包含通过spi接口，获取所有的实现类； 获取spi接口对应的选择器 （包括类对应的选择器， 方法对应的选择器）； 返回Spi接口实现类（静态确认的实现类，自适应的代理类） 从上面的简述，基本上可以看出这个类划分为三个功能点， 下面将逐一说明，本篇博文主要集中在逻辑的设计层，至于优化（如懒加载，缓存优化等） 放置下一篇博文单独叙述 1. 加载spi实现类 这一块比较简单，我们直接利用了jdk的 ServiceLoader 来根据接口，获取所有的实现类；因此我们的spi实现，需要满足jdk定义的这一套规范 具体的代码业务逻辑非常简单，大致流程如下 1234567891011121314151617 if (null == spiInterfaceType) &#123; throw new IllegalArgumentException(\"common cannot be null...\");&#125;if (!spiInterfaceType.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must be interface!\");&#125;if (!withSpiAnnotation(spiInterfaceType)) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must have the annotation of @Spi\");&#125; ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType);for(T spiImpl: serviceLoader) &#123; // xxx&#125; 注意 因为使用了jdk的标准，因此每定义一个spi接口，必须在 META_INF.services 下新建一个文件， 文件名为包含包路径的spi接口名， 内部为包含包路径的实现类名 每个spi接口，要求必须有 @Spi 注解 Spi接口必须是 interface 类型， 不支持抽象类和类的方式 拓展虽然这里直接使用了spi的规范，我们其实完全可以自己定义标准的，只要能将这个接口的所有实现类找到， 怎么实现都可以由你定义 如使用spring框架后，可以考虑通过 applicationContext.getBeansOfAnnotaion(xxx ) 来获取所有的特定注解的bean，这样就可以不需要自己新建一个文件，来存储spi接口和其实现类的映射关系了 构建spi实现的关系表上面获取了spi实现类，显然我们的目标并不局限于简单的获取实现类，在获取实现类之后，还需要解析其中的 @SpiConf 注解信息，用于表示要选择这个实现，必须满足什么样的条件 SpiImplWrapper : spi实现类，以及定义的各种条件的封装类 注解的解析过程流程如下: name: 注解定义时，采用定义的值； 否则采用简单类名 （因此一个系统中不允许两个实现类同名的情况） order： 优先级， 注解定义时，采用定义的值；未定义时采用默认； params: 参数约束条件， 会取类上和方法上的并集（原则上要求类上的约束和方法上的约束不能冲突） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;();// 解析注解spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; // 没有添加注解时， 采用默认的方案 implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // ------------ // 解析参数的方法 private Map&lt;String, String&gt; parseParms(String[] params) &#123; if (params.length == 0) &#123; return Collections.emptyMap(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(params.length); String[] strs; for (String param : params) &#123; strs = StringUtils.split(param, \":\"); if (strs.length &gt;= 2) &#123; map.put(strs[0].trim(), strs[1].trim()); &#125; else if (strs.length == 1) &#123; map.put(strs[0].trim(), null); &#125; &#125; return map; &#125; 2. 初始化选择器 我们的选择器会区分为两类，一个是类上定义的选择器， 一个是方法上定义的选择器； 在自适应的使用方式中，方法上定义的优先级 &gt; 类上定义 简单来讲，初始化选择器，就是扫一遍SPI接口中的注解，实例化选择器后，缓存住对应的结果, 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*** 选择器, 根据条件, 选择具体的 SpiImpl;*/private SelectorWrapper currentSelector;/*** 自适应时, 方法对应的选择器*/private Map&lt;String, SelectorWrapper&gt; currentMethodSelector;/*** 每一个 SpiLoader 中, 每种类型的选择器, 只保存一个实例* 因此可以在选择器中, 如&#123;@link ParamsSelector&#125; 对spiImplMap进行处理并缓存结果*/private ConcurrentHashMap&lt;Class, SelectorWrapper&gt; selectorInstanceCacheMap = new ConcurrentHashMap&lt;&gt;(); private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 SeectorWrapper 选择器封装类 这里我们在获取选择器时，特意定义了一个封装类，其中包含具体的选择器对象，以及所匹配的参数类型，因此可以在下一步通过选择器获取实现类时，保证传入的参数类型合法 private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) 具体的实例化选择器的方法 从实现来看，优先从选择器缓存中获取选择器对象，这样的目的是保证一个spi接口，每种类型的选择器只有一个实例；因此在自定义选择器中，你完全可以做一些选择判断的缓存逻辑，如 ParamsSelector 中的spi实现类的有序缓存列表 currentSelector , currentMethodSelector, selectorInstanceCacheMap currentSelector: 对应的是类选择器，每个SPI接口必然会有一个，作为打底的选择器 currentMethodSelector: 方法选择器映射关系表，key为方法名，value为该方法对应的选择器； 所以spi接口中，不支持重载 selectorInstanceCacheMap: spi接口所有定义的选择器映射关系表，key为选择器类型，value是实例；用于保障每个spi接口中选择器只会有一个实例 3. 获取实现类 对使用者而言，最关注的就是这个接口，这里会返回我们需要的实现类（or代理）；内部的逻辑也比较清楚，首先确定选择器，然后通过选择器便利所有的实现类，把满足条件的返回即可 从上面的描述可以看到，主要分为两步 获取选择器 根据选择器，遍历所有的实现类，找出匹配的返回 获取选择器初始化选择器之后，我们会有 currentSelector , currentMethodSelector 两个缓存 静态确定spi实现时，直接用 currentSelector 即可 （spi接口中所有方法都公用类定义选择器） 动态适配时， 根据方法名在 currentMethodSelector 中获取选择器，如果没有，则表示该方法没有@SpiAdaptive注解，直接使用类的选择器 currentMethodSelector 即可 123456789101112131415// 动态适配时，获取方法对应对应的selector实现逻辑SelectorWrapper selector = currentMethodSelector.get(methodName);if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector);&#125;if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; // 参数不匹配时，且传入的参数为String类型， 则尝试使用默认选择器进行兼容（不建议在实现时，出现这种场景） selector = DEFAULT_SELECTOR;&#125; 选择实现类这个的主要逻辑就是遍历所有的实现类，判断是否满足选择器的条件，将第一个找到的返回即可，所有的业务逻辑都在 ISelector 中实现，如下面给出的默认选择器，根据name来获取实现类 1234567891011121314151617181920212223242526/** * 默认的根据name 获取具体的实现类 * &lt;p/&gt; * Created by yihui on 2017/5/24. */public class DefaultSelector implements ISelector&lt;String&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, String name) throws NoSpiMatchException &#123; if (StringUtils.isBlank(name)) &#123; throw new IllegalArgumentException(\"spiName should not be empty!\"); &#125; if (map == null || map.size() == 0) &#123; throw new IllegalArgumentException(\"no impl spi!\"); &#125; if (!map.containsKey(name)) &#123; throw new NoSpiMatchException(\"no spiImpl match the name you choose! your choose is: \" + name); &#125; return map.get(name).getSpiImpl(); &#125;&#125; 流程说明 上面主要就各个点单独的进行了说明，看起来可能比较分散，看完之后可能没有一个清晰的流程，这里就整个实现的流程顺一遍，主要从使用者的角度出发，当定义了一个SPI接口后，到获取spi实现的过程中，上面的这些步骤是怎样串在一起的 流程图先拿简单的静态获取SPI实现流程说明（动态的其实差不多，具体的差异下一篇说明），先看下这种用法的使用姿势 1234567891011121314151617181920212223242526@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125;@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(\"ConsolePrint\"); print.print(\"console----&gt;\");&#125; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class);这行代码触发的action 主要是初始化所有的选择器, 如下图 首先从缓存中查 是否已经初始化过了有则直接返回； 缓存中没有，则进入new一个新的对象出来 解析类上注解 @Spi，初始化 currentSelector 解析所有方法的注解 @SpiAdaptive ， 初始化 currentMethodSelector 塞入缓存，并返回 IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;);根据name获取实现类，具体流程如下 判断是否加载过所有实现类 spiImplClassCacheMap 没有加载，则重新加载所有的实现类 通过jdk的 ServiceLoader.load() 方法获取所有的实现类 遍历实现类，根据 @SpiConf 注解初始化参数，封装 SpiImplWrapper对象 保存封装的 SpiImplWrapper对象到缓存 执行 currentSelector.select() 方法，获取匹配的实现类 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"1. SPI框架实现之旅一：背景介绍","slug":"SPI框架实现之旅一：背景介绍","date":"2017-05-26T02:46:42.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/05/26/SPI框架实现之旅一：背景介绍/","link":"","permalink":"https://zbang.online/hexblog/2017/05/26/SPI框架实现之旅一：背景介绍/","excerpt":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制","text":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制 1. 背景上面摘抄了一下spi的概念，接着以个人的理解，简单的谈一下为什么会用到SPI， 什么场景下可以用到这个， 以及使用了SPI机制后有什么优越性 什么是SPI虽然最开始就引用了spi的解释，这里浅谈一下个人理解。Service Provider Interface 以接口方式提供服务， 和API不同，spi的机制是定义一套标准规范的接口，实现交给其他人来做。 所以一个接口，可以有很多的实现，你完全可以根据自己的需要去选择具体的实现方式，因为是面向接口的开发，所以你的业务代码基本上就不用修改，就可以切到另一个实现了 什么场景可以用 分别从框架层面和业务层面，给出一个我认为比较合适的场景 1. 日志输出 SLF4jSLF4j：大名鼎鼎的日志输出接口，这个jar包里面提供的都只是接口方式，具体的实现需要自己去实现，当然比较常用的 logback 就是一个具体的实现包了， 在项目中使用 slf4j 的api进行日志的输出， 通过简单的配置，引入logback， 就可以使用logback来实现具体的日志输出； 也可以换一个日志实现 commons-logging，业务上不需要任何的改动，就可以用不同的实现来输出日志 2. 业务场景假设你现在有个用户注册成功后的欢迎用户的业务，不同渠道（微信，qq，微博等）注册的，显示的欢迎不同，对此有两种不同的实现方式 如果每个不同的渠道进来的，都有一个独立的应用来响应 （因为绝大多数的业务都一样，可能就欢迎词不同，如果做到代码最大程度的复用） 只有一个应用，来处理所有的这些场景 可以怎么用 结合上面的业务场景，来描述下可以怎么用 1. 代码复用为了实现代码最大程度的复用，那么可以将不同的地方，抽象成一个SPI接口，在业务层通过接口来代替具体的实现类实现业务逻辑； 每个渠道，都有个独立的应用，那么在微信渠道，创建一个 WeixinSpiImpl来实现接口 在qq渠道，实现 QQSpiImpl；那么在具体的接口调用处，实际上就是执行的spi实现类方法 2. 业务场景的选择区分这个与上面不同，同一个服务接口，根据不同的业务场景，选择不同的实现来执行；当然你是完全可以使用 if， else来实现这种场景，唯一的问题就是扩展比较麻烦； 这种场景下，我们希望的就是这个接口，能自动的根据业务场景，来选择最合适的实现类来执行 简单来讲，就是\u0010spi接口执行之前，其实需要有一个自动选择匹配的实现类的前置过程； 通常这种业务场景下，具体的spi实现会有多个，但是需要有一个选择的策略 2. 小目标 在具体的实现之前，先定义一个小目标，我们想要实现一个什么样子的东西出来 通过上面的背景描述，我们的小目标也就很明确了，我们的实现至少需要满足两个场景 静态选择SPI实现， 即在选择完成之后，所有对这个spi接口的引用都是确定由这个实现来承包 动态选择SPI实现， 不到运行之时，你都不知道会是哪个spi实现来干这件事 3. 技术储备 java本身就提供了一套spi的支持方式: ServiceLoader，我们后续的开发，也会在这个基础之上进行 利用java的 ServiceLoader 找到服务接口的实现类，有一些约定，下面给出要求说明和一个测试case 一般实现流程 定义spi接口 ： IXxx 具体的实现类: AXxx, BXxx 在jar包的META-INF/services/目录下新建一个文件，命名为 spi接口的完整类名，内容为spi接口实现的完整类名，一个实现类占一行 测试case如下 spi接口 com.hust.hui.quicksilver.commons.spi.HelloInterface 12345678910package com.hust.hui.quicksilver.commons.spi;/** * Created by yihui on 2017/3/17. */public interface HelloInterface &#123; void sayHello();&#125; spi接口的两个实现类 com.hust.hui.quicksilver.commons.spi.impl.ImageHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class ImageHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"image hello!\"); &#125;&#125; com.hust.hui.quicksilver.commons.spi.impl.TextHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class TextHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"text hello\"); &#125;&#125; 配置文件 com.hust.hui.quicksilver.commons.spi.HelloInterface 12com.hust.hui.quicksilver.commons.spi.impl.ImageHellocom.hust.hui.quicksilver.commons.spi.impl.TextHello 测试类 1234567891011public class HelloSpiTest &#123; @Test public void testSPI() &#123; ServiceLoader&lt;HelloInterface&gt; serviceLoader = ServiceLoader.load(HelloInterface.class); for (HelloInterface hello: serviceLoader) &#123; hello.sayHello(); &#125; &#125;&#125; 输出如下: 12image hello!text hello 测试类演示如下图: 4. 设计思路画了一下结构图，方便理解, 下面的核心是 SpiLoader 类， 负责加载spi接口的所有实现类， 初始化所有定义的选择器， 返回一个spi接口的实现类初始化用户自定义的spi对象，然后用户持有此对象调用spi接口中提供的方法即可 5. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]}]
[{"title":"test","slug":"test","date":"2018-03-16T14:48:57.000Z","updated":"2018-03-16T14:48:57.917Z","comments":true,"path":"2018/03/16/test/","link":"","permalink":"https://zbang.online/hexblog/2018/03/16/test/","excerpt":"","text":"II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[],"tags":[],"keywords":[]},{"title":"JVM学习之垃圾回收机制","slug":"JVM学习之垃圾回收机制","date":"2018-03-15T12:18:44.000Z","updated":"2018-03-16T12:31:07.744Z","comments":true,"path":"2018/03/15/JVM学习之垃圾回收机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/JVM学习之垃圾回收机制/","excerpt":"","text":"JVM学习之垃圾回收机制jvm的垃圾回收算法，除了我们熟悉的引用计数判断对象是否活着之外，其他还有那些有意思的东西呢？ 总是听到的年轻代年老代又是啥？ 传说中的YoungGC(MinorGC) 和 FullGC的时机是什么，又干了些啥？ I. 对象存活判断垃圾回收，回收的都是那些不在使用的对象（也就是没有存活的对象），因此怎么判断对象是否存活，就显得比较重要了 对这个映像最深刻的就是引用计数方式，一个对象被使用了，计数就+1；不用了，技术就-1；当计数为0的时候，就表示对象没人用了，简单粗暴，然而实际的情况中，大都不用这个方式，因为无法解决对象相互循环引用的问题 目前更多的是采用gc root可达性分析，简单来讲就是从一个根节点往下走，走的轨迹上所有的对象，都表示是存活的；也就是说，所有游离在这个之外的对象，都是需要回收的 那么什么是GC ROOT呢 ？ 虚拟机栈内引用的对象 方法区静态属性引用的对象 方法区常量引用的对象 本地方法栈中JNI引用的对象 II. 垃圾回收算法回收，主要指的是将堆和运行时方法区内没有存活的对象干掉；而通常我们所说的垃圾回收，则主要针对的就是堆内的回收 1. 标记-清除算法简单理解：根据可达性扫一遍，有用的对象打个标记；剩下来一次大清理，将没有标记的都ko掉 说明 看书和博文时，常感觉标记，是将需要回收的对象标记出来，但仔细想了下，从实现成本来讲，根据可达性分析对象是否存活，顺带的直接将存活的打个标记，比将所有没存活的上面打上标记要来的简单，而且这也能算是标记出需要回收的对象 缺点 缺点很明显，会出现大量的碎片空间 2. 复制算法将存储空间一分为二，每次回收就是将这一边的存活对象搬移到另一边 缺点 空间少了一半 对于存活时间比较久的对象，需要频繁的来回搬迁 3. 标记-压缩算法（或标记-整理算法）为了节省空间，这个的策略是将所有存活的对象，往某一边界进行复制，等复制完毕之后，将辩解之外的对象都ko掉 4. 分代收集算法分代收集，实际来说就是综合其他算法的优良特性，结合实际应用场景来处理 将存活时间久，占用空间大的对象，放在老年代 其他的对象可以放在年轻代 也就是说： 老年代中，基本上是老而弥坚的对象，更加适合标记-整理算法，移到一边之后，由于经常活着，也就避免了频繁的复制了 新生代中，常是一些朝生夕死的对象，可能用了一次就可以ko，因此可以采用复制算法，标记-清除也是ok的 分代的主要思想就是根据不同的情况，给予不同的策略 III. 简单说下垃圾收集器收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现 1. Serial收集串行收集器，也就是程序跑一会，停下，让我们的回收线程（只有一个）来实现垃圾回收 新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩 2. ParNew收集上面的多线程版本 新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 3. Parallel收集类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例； 新生代复制算法、老年代标记-压缩 4. Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供 5. CMS收集器这个是比较常用的，有必要好好了解下 Concurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标记-清除算法 a 步骤 初始标记：标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记：进行 GC Roots Tracing的过程 重新标记：为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除：并发干掉被回收的问题 初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 b. 优缺点优点：并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6. G1收集器传说中是最先进的收集器。。。。 用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合 a. 步骤 标记阶段：初始标记，会停顿，触发minorgc Root Region Scanning: 程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在minorGC之前完成 并发标记：若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)；并发执行，可能被minorgc打断 再标记：再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)，停顿 复制-整理：并发干掉死亡对象，G1将回收区域的存活对象拷贝到新区域 IV. GC分析这个日志主要针对的是CMS收集器的分析，因为我接触的应用，服务器上就是选择的这个… 看一张神奇的图 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区之间发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无需等Age达到阈值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC V. 小结1. 怎么判断对象是否存活两种方式，引用计数和可达性分析 引用计数: 循环依赖问题，没啥用 可达性：从gc roots出发，可达的都是存活的 2. 几种回收算法对比 算法 简述 缺点 标记-清除 标记对象，统一清楚可回收对象 大量碎片 复制算法 内存一分为二，将存活的移动到另一边 存活久的对象，频繁复制；空间变小 标记-整理 存活对象往一边界拷贝，边界外的都干掉 对于生命周期特别短的不太合适 分代 年轻代 + 年老代，不同代选用不同算法 - 3. CMS和G1阶段对比cms主要区分四个步骤： 标记：停顿 并发标记 重新标记：停顿，重新处理并发过程中新标记的对象 并发清除：并发回收 g1，从结构上而言，划分为一个个独立区域(region)，采用标记-整理算法，避免碎皮空间 4. 简述内存分配和回收基于CMS进行说明 优先分配edge区（不够则触发gc） 大对象，分配在old区 存活时间久的塞入old区 动态时间判断（某个age对象总和大于Survivor一半，则塞入old区） 分配担保（进入old区，但是old区空间不够的策略，决定是否触发gc） VI. 其他参考 jvm系列(三):java GC算法 垃圾收集器 JVM调优工具介绍 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://zbang.online/hexblog/tags/垃圾回收/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"熔断Hystrix使用尝鲜","slug":"熔断Hystrix使用尝鲜","date":"2018-03-15T04:13:15.000Z","updated":"2018-03-15T12:31:04.958Z","comments":true,"path":"2018/03/15/熔断Hystrix使用尝鲜/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/熔断Hystrix使用尝鲜/","excerpt":"","text":"熔断Hystrix使用尝鲜当服务有较多外部依赖时，如果其中某个服务的不可用，导致整个集群会受到影响（比如超时，导致大量的请求被阻塞，从而导致外部请求无法进来），这种情况下采用hystrix就很有用了 出于这个目的，了解了下hystrix框架，下面记录下，框架尝新的历程 I. 原理探究通过官网和相关博文，可以简单的说一下这个工作机制，大致流程如下 首先是请求过来 -&gt; 判断熔断器是否开 -&gt; 服务调用 -&gt; 异常则走fallback，失败计数+1 -&gt; 结束 下面是主流程图 12345678910graph LR A(请求)--&gt;B&#123;熔断器是否已开&#125; B --&gt; | 熔断 | D[fallback逻辑] B --&gt; | 未熔断 | E[线程池/Semphore] E --&gt; F&#123;线程池满/无可用信号量&#125; F --&gt; | yes | D F --&gt; | no | G&#123;创建线程执行/本线程运行&#125; G --&gt; | yes | I(结束) G --&gt; | no | D D --&gt; I(结束) 熔断机制主要提供了两种，一个是基于线程池的隔离方式来做；还有一个则是根据信号量的抢占来做 线程池方式 ： 支持异步，支持超时设置，支持限流 信号量方式 ： 本线程执行，无异步，无超时，支持限流，消耗更小 基本上有上面这个简单的概念之后，开始进入我们的使用测试流程 II. 使用尝鲜1. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt; &lt;version&gt;1.5.12&lt;/version&gt;&lt;/dependency&gt; 2. 简单使用从官方文档来看，支持两种Command方式，一个是基于观察者模式的ObserverCommand, 一个是基本的Command，先用简单的看以下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class HystrixConfigTest extends HystrixCommand&lt;String&gt; &#123; private final String name; public HystrixConfigTest(String name, boolean ans) &#123;// 注意的是同一个任务， super(Setter.withGroupKey(// CommandGroup是每个命令最少配置的必选参数，在不指定ThreadPoolKey的情况下，字面值用于对不同依赖的线程池/信号区分 HystrixCommandGroupKey.Factory.asKey(\"CircuitBreakerTestGroup\"))// 每个CommandKey代表一个依赖抽象,相同的依赖要使用相同的CommandKey名称。依赖隔离的根本就是对相同CommandKey的依赖做隔离. .andCommandKey(HystrixCommandKey.Factory.asKey(\"CircuitBreakerTestKey_\" + ans))// 当对同一业务依赖做隔离时使用CommandGroup做区分,但是对同一依赖的不同远程调用如(一个是redis 一个是http),可以使用HystrixThreadPoolKey做隔离区分 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(\"CircuitBreakerTest_\" + ans)) .andThreadPoolPropertiesDefaults( // 配置线程池 HystrixThreadPoolProperties.Setter() .withCoreSize(12) // 配置线程池里的线程数，设置足够多线程，以防未熔断却打满threadpool ) .andCommandPropertiesDefaults( // 配置熔断器 HystrixCommandProperties.Setter() .withCircuitBreakerEnabled(true) .withCircuitBreakerRequestVolumeThreshold(3) .withCircuitBreakerErrorThresholdPercentage(80)// .withCircuitBreakerForceOpen(true) // 置为true时，所有请求都将被拒绝，直接到fallback// .withCircuitBreakerForceClosed(true) // 置为true时，将忽略错误// .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE) // 信号量隔离 .withExecutionIsolationSemaphoreMaxConcurrentRequests(20) .withExecutionTimeoutEnabled(true) .withExecutionTimeoutInMilliseconds(200) .withCircuitBreakerSleepWindowInMilliseconds(1000) //熔断器打开到关闭的时间窗长度// .withExecutionTimeoutInMilliseconds(5000) ) ); this.name = name; &#125; @Override protected String run() throws Exception &#123; System.out.println(\"running run():\" + name + \" thread: \" + Thread.currentThread().getName()); int num = Integer.valueOf(name); if (num % 2 == 0 &amp;&amp; num &lt; 10) &#123; // 直接返回 return name; &#125; else if (num &lt; 40) &#123; Thread.sleep(300); return \"sleep+\"+ name; &#125; else &#123; // 无限循环模拟超时 return name; &#125; &#125;//// @Override// protected String getFallback() &#123;// Throwable t = this.getExecutionException();// if(t instanceof HystrixRuntimeException) &#123;// System.out.println(Thread.currentThread() + \" --&gt; \" + ((HystrixRuntimeException) t).getFailureType());// &#125; else if (t instanceof HystrixTimeoutException) &#123;// System.out.println(t.getCause());// &#125; else &#123;// t.printStackTrace();// &#125;// System.out.println(Thread.currentThread() + \" --&gt; ----------over------------\");// return \"CircuitBreaker fallback: \" + name;// &#125; public static class UnitTest &#123; @Test public void testSynchronous() throws IOException, InterruptedException &#123; for (int i = 0; i &lt; 50; i++) &#123; if (i == 41) &#123; Thread.sleep(2000); &#125; try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute()); &#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\"); &#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause()); &#125; &#125; System.out.println(\"------开始打印现有线程---------\"); Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces(); for (Thread thread : map.keySet()) &#123; System.out.println(\"---&gt;name--&gt;\" + thread.getName()); &#125; System.out.println(\"thread num: \" + map.size()); System.in.read(); &#125; &#125;&#125; 使用起来还是比较简单的，一般步骤如下： 继承 HsytrixCommand 类 重载构造方法，内部需要指定各种配置 实现run方法，这个里面主要执行熔断监控的方法 写上面的代码比较简单，但是有几个地方不太好处理 配置项的具体含义，又是怎么生效的？ 某些异常不进入熔断逻辑怎么办？ 监控数据如何获取？ 如何模拟各种不同的case（超时？服务异常？熔断已开启？线程池满？无可用信号量？半熔断的重试？） 3. 实测理解根据上面那一段代码的删删改改，貌似理解了以下几个点，不知道对误 a. 配置相关 groupKey 用于区分线程池和信号量，即一个group对应一个 commandKey 很重要，这个是用于区分业务 简单来讲，group类似提供服务的app，command则对应app提供的service，一个app可以有多个service，这里就是将一个app的所有请求都放在一个线程池（or共享一个信号量） 开启熔断机制，指定触发熔断的最小请求数（10s内），指定打开熔断的条件（失败率） 设置熔断策略（线程池or信号量） 设置重试时间（默认熔断开启后5s，放几个请求进去，看服务是否恢复） 设置线程池大小，设置信号量大小，设置队列大小 设置超时时间，设置允许超时设置 b. 使用相关run方法是核心执行服务调用，如果需要某些服务不统计到熔断的失败率（比如因为调用姿势不对导致服务内部的异常抛上来了，但是服务本身是正常的），这个时候，就需要包装下调用逻辑，将不需要的异常包装到 HystrixBadRequestException 类里 如 12345678910111213@Overrideprotected String run() &#123; try &#123; return func.apply(route, parameterDescs); &#125; catch (Exception e) &#123; if (exceptionExcept(e)) &#123; // 如果是不关注的异常case， 不进入熔断逻辑 throw new HystrixBadRequestException(\"unexpected exception!\", e); &#125; else &#123; throw e; &#125; &#125;&#125; c. 如何获取失败的原因当发生失败时，hystrix会把原生的异常包装到 HystrixRuntimeException 这个类里，所以我们可以在调用的地方如下处理 1234567try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute());&#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\");&#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause());&#125; 当定义了fallback逻辑时，异常则不会抛到具体的调用方，所以在 fallback 方法内，则有必要获取对应的异常信息 12// 获取异常信息Throwable t = this.getExecutionException(); 然后下一步就是需要获取对应的异常原因了，通过FailureType来表明失败的根源 1((HystrixRuntimeException) t).getFailureType() d.如何获取统计信息hystrix自己提供了一套监控插件，基本上公司内都会有自己的监控统计信息，因此需要对这个数据进行和自定义，目前还没看到可以如何优雅的处理这些统计信息 4. 小结主要是看了下这个东西可以怎么玩，整个用下来的感觉就是，设计的比较有意思，但是配置参数太多，很多都没有完全摸透 其次就是一些特殊的case（如监控，报警，特殊情况过滤）需要处理时，用起来并不是很顺手，主要问题还是没有理解清楚这个框架的内部工作机制的问题 III. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"hystrix","slug":"hystrix","permalink":"https://zbang.online/hexblog/tags/hystrix/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"JVM学习之内存结构","slug":"JVM学习之内存结构","date":"2018-03-13T08:00:31.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/03/13/JVM学习之内存结构/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之内存结构/","excerpt":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了","text":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了 I. 内存布局 简单来讲，内存可以划分为三块： 堆 最大的一块区域，创建的对象都在这个上面 方法区 加载类时对应的类信息，常量，静态变量 栈 虚拟机栈和本地方法栈，存储线程相关的信息 II. 分区详解1. 堆区所有线程共享，虚拟机启动时创建，存放对象实例 垃圾回收，主要就是针对堆区而言，一般划分为年轻代，年老代 Young区：Edge + From Survivor + To Sruvivor (8：1：1) Old区 对象开始在Young区，一般内存回收时，会有标记整理，就涉及到两个Survivor区的转移，对象存的时间够久之后，就会将对象塞入Old区 2. 方法区所有线程共享，存储JVM加载的类信息，常量，静态变量，即使编译代码 3. 程序计数器当前线程所执行的字节码的行号指示器，线程私有 字节码解释器，就是来改变这个计数器来选择下一条要执行的命令 4. Java虚拟机栈线程私有，描述java方法执行的内存模型，它的生命周期与线程相同 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表（所占用空间，编译期间分配完成） 编译期可知的各种基本数据类型 对象引用 returnAddress类型（指向了一条字节码指令的地址） 操作栈 动态链接 方法出口 当栈深大于允许的高度时，会抛出StackOverflowError，常见于递归调用异常的情况 当无法申请到足够的空间时，会抛出OutOfMemoryError 5. 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务 III. 其他参考: JVM内存结构 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"内存结构","slug":"内存结构","permalink":"https://zbang.online/hexblog/tags/内存结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JVM学习之Java类的加载机制","slug":"JVM学习之Java类的加载机制","date":"2018-03-13T06:26:40.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/03/13/JVM学习之Java类的加载机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之Java类的加载机制/","excerpt":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制","text":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制 I. 什么是类的加载简单来讲，类加载就是将class文件中的二进制，读取到内存中，解析其中定义的数据结构，然后在运行时方法区创建对应的数据结构，在堆内创建对应的class对象，而这个class对象，就是封装了对应的数据结构，和相关数据的访问操作方法； 上面的这一段简述中，却包含以下几个点： 1. 加载哪里的class文件？第一步就是要明确的获取到对应的class文件了，jvm支持以下几个case中获取 本地系统 从网络上获取 从数据库(or缓存等第三方存储)中获取 从jar，zip包获取（比如我们依赖的第三方jar，大部分都是这种方式了） 源码编译获取（如我们常用的Groovy脚本，源码方式存在，由GroovyEngine加载时就是源码编译成class文件之后由jvm加载的） 2. 数据结构将class文件加载到内存后，一是在堆内创建class对象，一是在运行时方法区内创建对应的数据结构，具体的数据结构主要应该是类型信息 类的方法代码，变量名，方法名，访问权限，返回值等 类(静态)变量也存储在方法区 这一块有必要在jvm的内存分配中详细的研究下，每个存储区间到底干嘛用的，内部存写啥，先留一个坑位 3. class对象class对象是在堆内创建，反射机制就是主要利用它来实现，通过class对象基本可以完全的操作这个类（包括创建对象，访问成员，调用方法） II. 类加载过程类加载过程主要包括： 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载 用一张图来表示整个过程，且会带上每个过程主要干嘛用的 1. 加载加载作为类加载的第一个过程，主要就是将class文件代表的二进制，加载到内存中 获取class对应的二进制流（可以从任何能获取到的地方读取对应的二进制流） 将二进制流的静态存储结构转换为方法区的运行时数据结构 在堆内创建class对象 上面的三个过程中，最灵活的就是获取二进制的过程，可以按照你的实际场景，从各种地方捞出数据 2. 验证主要是验证class文件是否合法，有没有被篡改等，属于连接的一个过程 文件格式验证：魔数校验，jdk版本校验 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 3. 准备简单来说就是准备好静态变量的存储空间，并设置默认值，属于连接的一个过程 正式为类分配内存 为类变量设置默认的初始化值（不执行实际的赋值语句，这里专指基本类型的零值，对象的null） 对static final 变量赋与代码中实际的值 4. 解析简单来讲就是将常量池内的符号引用替换成实际引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，同样属于连接的一个过程 符号引用：是一组符号来描述目标，可以是任何字面量 直接引用：是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 5. 初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化 准备阶段为类变量赋上了默认值，这里则主要是初始化代码中的赋值，一般而言根据实际定义的顺序进行初始化 a. 初始化步骤 若类没有被加载连接，则优先加载 若父类没有被初始化，则优先初始化父类 执行类的初始化语句（直接赋值，静态代码块） b. 初始化的时机 new创建一个对象时 访问或修改类的静态变量，执行静态方法 反射调用 子类被使用 jvm启动时指定 6. 卸载简单来说就是用完了，收拾线程的过程 程序执行完成 异常 系统层面错误 System.exit() III. 类加载器可以理解为类加载器就是用来加载类的工具，同一个类被不同的类加载器加载之后，也认为他们是不同的 四种类加载器：自定义类加载器，应用类加载器，扩展类加载器，启动类加载器 1. 启动类加载器(BootStrap ClassLoader)源头，根，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的 2. 扩展类加载器（Extension ClassLoader）该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器 3. 应用类加载器（Application ClassLoader）该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 4. 自定义类加载器（User ClassLoader）自己实现的继承ClassLoader的加载器，可以按照自己的意愿，从某些地方加载类 5.类加载机制 全盘负责 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托 先尝试让父类加载器来加载，当父类做不到时，再自己来做 缓存机制 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 6.类的加载类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 加载class到内存，并执行static块 3、通过ClassLoader.loadClass()方法动态加载 只加载class文件到jvm，在class.newInstance()时，执行static块 IV. 双亲委托双亲委托，就是来了一个类加载，先扔给上面去处理，层层上传，只有上面处理不了时，才自己来决定 有啥好处？ 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 说明：双亲委托机制是可以被破坏的 V. 其他参考: java类的加载机制 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://zbang.online/hexblog/tags/ClassLoader/"},{"name":"双亲委托","slug":"双亲委托","permalink":"https://zbang.online/hexblog/tags/双亲委托/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"Chrome插件之DomToImage实现","slug":"Chrome插件之DomToImage实现","date":"2018-03-12T11:08:09.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/03/12/Chrome插件之DomToImage实现/","link":"","permalink":"https://zbang.online/hexblog/2018/03/12/Chrome插件之DomToImage实现/","excerpt":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片","text":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片 1. 实现 主要借助开源包: dom-to-image来实现 基本实现原理： 在网页中插入一段html代码，然后绑定上点击事件，核心逻辑如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(\"body\").append('&lt;div id=\"rendFloatDom\" class=\"NYwishes\"&gt;' + '&lt;div id=\"expandInputBtn\" class=\"send\"&gt;&lt;div class=\"send-btn\" style=\"float:right\"&gt;&lt;a onclick=\"document.getElementById(\\'expandInputBtn\\').style.display=\\'none\\';document.getElementById(\\'showRenderImgDiv\\').style.display=\\'block\\';\"&gt;展开&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;' + '&lt;div class=\"send\" id=\"showRenderImgDiv\" style=\"display:none\"&gt;' + '&lt;div class=\"input\"&gt;&lt;input id=\"choose-id\" name=\"content\" type=\"text\" placeholder=\"cid: | id: + 标签\" &gt;&lt;/div&gt;' + '&lt;div class=\"send-btn\" &gt;&lt;a id=\"RenderImgBtn\"&gt;渲染&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;' + '');function doRender() &#123; var chooseVal = document.getElementById('choose-id').value; var node; if(chooseVal.startsWith('cid:')) &#123; chooseVal = chooseVal.substring(4); node = document.getElementsByClassName(chooseVal)[0]; &#125; else &#123; if(chooseVal.startsWith(\"id:\")) &#123; chooseVal = chooseVal.substring(3); &#125; if (\"\" == chooseVal) &#123; return; &#125; node = document.getElementById(chooseVal); &#125; if(node == null || typeof(node) == undefined) &#123; alert(\"没有选中的dom结构\"); return; &#125; domtoimage.toPng(node) .then(function (dataUrl) &#123; var url = dataUrl; window.open().document.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;渲染图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\\'text-align:center\\'&gt;&lt;a download=\"out.png\" href=\"' + url + '\"&gt;&lt;img src=\"' + url + '\" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;) .catch(function (error) &#123;&#125;);&#125;$(\"#choose-id\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; doRender(); &#125;&#125;);$('#RenderImgBtn').click(function() &#123; doRender();&#125;); 2. 使用演示 II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zbang.online/hexblog/tags/Chrome/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}]},{"title":"JQuery 实战笔记一","slug":"JQuery-实战笔记一","date":"2018-03-08T14:58:26.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/03/08/JQuery-实战笔记一/","link":"","permalink":"https://zbang.online/hexblog/2018/03/08/JQuery-实战笔记一/","excerpt":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应","text":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应 1. jquery控制div标签的显示隐藏123&lt;div id=\"queryExtend\"&gt; &lt;label&gt; hah &lt;/label&gt;&lt;/div jquery的用法, 判断是否隐藏，是则显示；否则隐藏 1234567function showQueryCondition() &#123; if($('#queryExtend').is(\":hidden\")) &#123; $('#queryExtend').show(); &#125; else &#123; $('#queryExtend').hide(); &#125;&#125; 2. 时间戳转日期1234// 获取当前时间戳var ns = Date.parse(new Date())/1000;var timestamp4 = new Date(parseInt(nS) * 1000);return timestamp4.toLocaleDateString().replace(/\\//g, \"/\") + \" \" + timestamp4.toTimeString().substr(0, 8); 3. 获取radio群的值123456789101112&lt;div class=\"col-md-10 input-group input-group-lg\"&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"1\" checked/&gt; &amp;nbsp;&amp;nbsp; 默认 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"2\"/&gt; &amp;nbsp;&amp;nbsp; 查主库 &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"3\"/&gt; &amp;nbsp;&amp;nbsp; 查从库 &lt;/div&gt;&lt;/div&gt; 对应的jquery获取选中值 1var queryDB = $(\"input[name='queryType']:checked\").val(); 4. 动态修改placeholder值1$('#itemId').attr('placeholder', '请输入商品ID '); 5. 判断字符串是否为数字类型123456var str = \"37\";var n = Number(str);if (!isNaN(n))&#123; alert(\"是数字\");&#125; 6. tab标签页的实现12345678910111213141516171819202122232425262728293031323334&lt;ul id=\"myTab\" class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#home\" data-toggle=\"tab\"&gt; 菜鸟教程 &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#ios\" data-toggle=\"tab\"&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" id=\"myTabDrop1\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Java &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"myTabDrop1\"&gt; &lt;li&gt;&lt;a href=\"#jmeter\" tabindex=\"-1\" data-toggle=\"tab\"&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#ejb\" tabindex=\"-1\" data-toggle=\"tab\"&gt;ejb&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"home\"&gt; &lt;p&gt;菜鸟教程是一个提供最新的web技术站点，本站免费提供了建站相关的技术文档，帮助广大web技术爱好者快速入门并建立自己的网站。菜鸟先飞早入行——学的不仅是技术，更是梦想。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ios\"&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"jmeter\"&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ejb\"&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 借助bootstrap，主要点 myTab 标签表示的导航内容 href 指向的本标签对应的内容 myTagContent 对应的标签页内容 id 与 导航的锚点对应 class=&quot;tab-pane fade in active&quot; 表示生效的标签内容 class=&quot;tab-pane fade&quot; 未激活的标签属性 7. 标签点击事件1$('#btn').click(function()&#123;&#125;); 8. jquery跳转链接12345678910// 本页面直接打开urlwindow.location.href=url;// 新标签页打开urlwindow.open(url, \"_blank\")// 在demo窗口打开urlwindow.open(url, \"demo\"); 9. jquery 修改图片url1$('#img').attr(\"src\", newImgUrl); 10. 图片加边框1&lt;image id=\"data\" style=\"border:1px solid #b5b3b3;\"/&gt; 11. 实现一个可检索的table在一个bootstrap项目中，必要的 jquery, bootstrap.min.js需要依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"wrapper\"&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"ibox float-e-margins\"&gt; &lt;div class=\"ibox-content\"&gt; &lt;input type=\"text\" class=\"form-control input-sm m-b-xs\" id=\"filter\" placeholder=\"Search in table\"&gt; &lt;table class=\"footable table table-stripped\" data-page-size=\"8\" data-filter=#filter&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Rendering engine&lt;/th&gt; &lt;th&gt;Browser&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Platform(s)&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Engine version&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;CSS grade&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=\"gradeX\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 4.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;4&lt;/td&gt; &lt;td class=\"center\"&gt;X&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"gradeC\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 5.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;5&lt;/td&gt; &lt;td class=\"center\"&gt;C&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt; &lt;ul class=\"pagination pull-right\"&gt;&lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"http://s11.mogucdn.com/mlcdn/c45406/1512464758975_footable.all.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function() &#123; $('.footable').footable(); $('.footable2').footable(); &#125;);&lt;/script&gt; 12. 表格内容固定1&lt;td style=\"word-break:break-all;width:20%\"&gt;dc:650|tp:1|ci:700004593373|st:1481299200|mk:9|ws:1480694400|et:1481558399|nm:活动价|&lt;/td&gt; 13. input回车响应12345678910111213141516171819202122232425262728293031323334353637383940414243444546$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 2.方法2$('#applyCertNum').on('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 3.方法3$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == \"13\") &#123; alert('你输入的内容为2：' + $('#applyCertNum').val()); &#125; &#125;);4.方法4$(\"#applyCertNum\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; alert(\"12345....\"); &#125; &#125;); html中直接加入 1onkeydown=\"if(event.keyCode==13) &#123;queryAppAuthList();&#125;\" II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"},{"name":"Jquery","slug":"Jquery","permalink":"https://zbang.online/hexblog/tags/Jquery/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}]},{"title":"Java并发学习之线程池ThreadPoolExecutor的小结","slug":"Java并发学习之线程池ThreadPoolExecutor的小结","date":"2018-03-06T09:33:54.000Z","updated":"2018-03-16T14:41:25.262Z","comments":true,"path":"2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","link":"","permalink":"https://zbang.online/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","excerpt":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制","text":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制 I. 什么是线程池1. 通俗讲解我们先举一个小例子来说一下什么是线程池，以及线程池的工作方式 首先在看一下线程池中提交一个任务的流程图 下面就是实际的case：基本上大家都去过银行，我们就以到银行的柜台上办理业务的流程来说明线程池，我们先假设这里有一个xx银行（这里是广告位，待租😉），总共有8个柜台，平时只开放4个柜台，大厅内总共有20个座位。 那么来一个办理业务的，如果开放的四个柜台上，有空的，直接上去办理业务即可 如果四个柜台都在处理业务了，那么办理业务则需要取一个号，到大厅的座位上等着叫号 如果大厅坐满了，银行经理决定开放所有的柜台，那么新来办理的人直接到新的柜台上处理 如果所有柜台都在处理，且大厅也满了，这个时候就告诉新来办理业务的现在已经满载了，你们到xxx地的银行去办理吧（或者回家等下午再来好了） 从流程上的对比来看，就很相似了，虽然实际上银行可不会因为人的太多来新增开放柜台的数量，下面简单的将上面的case映射到线程池的成员上 4个开放柜台 ： 对应线程池的corePoolSize(核心工作线程数) 8个总柜台：对应线程池的maximumPoolSize(最大工作线程数) 20个座位：对应线程池的workQueue(任务队列) 所以线程池中提交一个任务时，优先看核心工作线程数是否已满，未满时，直接创建线程执行；已满，则丢入队列；如果队列也满了，则判断工作线程数是否超过最大数，没有则直接创建线程执行；否则直接“丢弃”这个任务了 （注意这个丢弃不是真的丢弃，其处理策略可以由你自己定义） 上面是基本流程，并没有涉及到工作线程的回收，线程池的状态（比如银行是否打烊了），任务的执行策略等 2. 线程池说明线程池是一种多线程的处理机制，主要是为了减少线程的频繁创建和销毁，从而提升系统效率 使用线程池优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 线程池组成类定义： java.util.concurrent.ThreadPoolExecutor 构造 1234567891011121314151617181920212223// 线程池构造方法public ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 存活时间 TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, // 排队队列 ThreadFactory threadFactory, // 创建线程的工作类 RejectedExecutionHandler handler) // 线程数满，队列满时具体任务策略&#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; II. 线程池使用1. 构造参数详解构造参数较多，创建一个线程池，当然首先得搞清楚这些参数是干嘛用的 参数 含义 说明 corePoolSize 核心工作线程数 没有任务时，线程池中允许存在的最小空闲线程数 工作线程数 &lt; corePoolSize时，提交任务创建工作线程来执行任务 maximumPoolSize 最大工作线程数 线程池中允许出现的最大工作线程数量 当队列满 &amp;&amp; 工作线程数 &lt; maximumPoolSize时，新的队列将创建线程来执行； 如果队列没有边界，那么这个参数没有意义 workQueue 任务队列 保存待执行任务的阻塞队列； 当 (工作线程数 &gt;= corePoolSize) &amp;&amp; (任务数 &lt; 任务队列长度)时，任务会offer()入队等待 keepAliveTime 工作线程最大空闲时间 当线程数 &gt; corePoolSize时，这个参数表示空闲线程存活时间； 超时的空闲线程，会被回收掉，直到线程数==corePoolSzie; 当allowCoreThreadTimeOut=true时，则超时的核心工作线程也会被回收 unit 时间单位 keepAliveTime的时间单位 threadFactory 线程创建工厂 创建线程的工厂类，可以在这里指定创建线程的name，设置守护线程，异常case处理等 handler 饱和策略执行器 线程池和队列都已满时，新提交任务的处理策略 默认是Abort(直抛Reject异常)，包括Discard(LIFO规则丢弃)、DiscardOldest(LRU规则丢弃) 以及 CallerRuns(调用者线程执行)，允许自定义执行器 2. 线程池的创建直接调用构造方法创建最直观的方式，直接构造方法new一个 1234567891011121314151617181920212223242526272829303132333435// 报警线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"test-thread\"), new ThreadPoolExecutor.CallerRunsPolicy()); // 线程创建工厂，主要设置为非守护线程，指定线程名，设置优先级// 关于这个工厂类，推荐看netty的实现public class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; public DefaultThreadFactory(String poolName) &#123; if (null == poolName) &#123; poolName = \"pool\"; &#125; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = poolName + poolNumber.getAndIncrement() + \"-thread-\"; &#125; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 利用 Executors创建jdk1.5+ 中提供了 java.util.concurrent.Executors 来创建常见的集中线程池方式 关于各种线程池的说明可以参考: Java并发学习之玩转线程池 固定大小线程池 123456// 创建一个固定大小的线程池public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 工作窃取线程池 123456public static ExecutorService newWorkStealingPool(int parallelism) &#123; return new ForkJoinPool (parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 创建单线程池 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 缓存线程池 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 定时任务线程池 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 不可配置线程池 12345public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123; if (executor == null) throw new NullPointerException(); return new DelegatedExecutorService(executor);&#125; 3. 提交任务execute: 提交无须返回值的任务 submit(Runnable): 适用于提交需要返回值的任务 相比较于上面的，区别是这个会返回一个 Future 对象，通过调用future.get()可以获取线程的返回值， 其中这个方程是线程阻塞的，直到返回了结果之后，才会继续执行下去 4. 关闭线程池shutdown(): 有序地关闭线程池，已提交的任务会被执行(包含正在执行和任务队列中的)，但会拒绝新任务 shutdownNow(): 立即(尝试)停止执行所有任务(包含正在执行和任务队列中的)，并返回待执行任务列表 III. 线程池实现原理1. 线程池状态线程池状态流程如下： RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED 每个状态含义 1234567891011121314//高3位111，低29位为0 该状态下线程池会接收新提交任务和执行队列任务private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//高3位000，低29位为0 该状态下线程池不再接收新任务，但还会继续执行队列任务private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//高3位001，低29位为0 该状态下线程池不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务private static final int STOP = 1 &lt;&lt; COUNT_BITS;//高3位010，低29位为0 该状态下线程池的所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated()private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//高3位011，低29位为0 该状态下表明线程池terminated()方法已经调用完成private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 2. 任务提交逻辑最开始的流图就说明了任务提交后的流程，针对流程块也就不继续细说，只提一个注意点 若实际工作线程数workers&lt;核心工作线程数corePoolSize，则创建新工作线程来执行新任务execute(Runable) 若实际工作线程数workers&gt;=核心工作线程数corePoolSize(核心工作线程们都在执行任务)且任务队列workQueue未满，则将任务加入到任务队列workQueue中 若任务队列workQueue已满，则创建新工作线程来执行任务execute() 若实际工作线程数workers&gt;=最大工作线程数maximumPoolSize(所有线程都在执行任务)，此时任务数已饱和，需要根据饱和拒绝策略rejectedExecutionHandler执行相对应的饱和拒绝操作 线程池的总体设计是基于性能考虑，尽可能避免获取全局锁： 由于创建新线程时都需要获取全局锁，因此步骤1和步骤3必须加锁 为了避免多次获取全局锁(性能伸缩瓶颈)，当实际工作线程数&gt;=核心工作线程数时，之后会执行步骤2(入队时无须获取全局锁) 线程池内线程回收策略 若实际工作线程数workers&gt;核心工作线程数corePoolSize，回收空闲时间超过keepAliveTime的空闲的非核心线程(减少工作线程数直到&lt;=核心工作线程数即可) 若设置allowCoreThreadTimeOut为true时，则超过keepAliveTime的空闲的核心工作线程也会被回收 3. 任务执行说明，下面两段代码解析来自转载： 并发番@ThreadPoolExecutor execute() - 提交任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 1.若实际工作线程数 &lt; 核心工作线程数，会尝试创建一个工作线程去执行该 * 任务，即该command会作为该线程的第一个任务，即第一个firstTask * * 2.若任务入队成功，仍需要执行双重校验，原因有两点： * - 第一个是去确认是否需要新建一个工作线程，因为可能存在 * 在上次检查后已经死亡died的工作线程 * - 第二个是可能在进入该方法后线程池被关闭了， * 比如执行shutdown() * 因此需要再次检查state状态，并分别处理以上两种情况： * - 若线程池中已无可用工作线程了，则需要新建一个工作线程 * - 若线程池已被关闭，则需要回滚入队列(若有必要) * * 3.若任务入队失败(比如队列已满)，则需要新建一个工作线程； * - 若新建线程失败，说明线程池已停止或者已饱和，必须执行拒绝策略 */public void execute(Runnable command) &#123; //新任务不允许为空，空则抛出NPE if (command == null) throw new NullPointerException(); // ctl 为线程池状态控制器，用于保证线程池状态和工作线程数 // 低29位为工作线程数量，高3位为线程池状态 int c = ctl.get(); /** * case1：当实际工作线程数 &lt; 核心工作线程数时 * 执行方案：会创建一个新的工作线程去执行该任务 * 注意：此时即使有其他空闲的工作线程也还是会新增工作线程， * 直到达到核心工作线程数为止 */ if (workerCountOf(c) &lt; corePoolSize) &#123; /** * 新增工作线程，true表示要对比的是核心工作线程数 * 一旦新增成功就开始执行当前任务 * 期间也会通过自旋获取队列任务进行执行 */ if (addWorker(command, true)) return; /** * 需要重新获取控制器状态，说明新增线程失败 * 线程失败的原因可能有两种： * - 1.线程池已被关闭，非RUNNING状态的线程池是不允许接收新任务的 * - 2.并发时，假如都通过了workerCountOf(c) &lt; corePoolSize校验，但其他线程 * 可能会在addWorker前先创建出线程，导致workerCountOf(c) &gt;= corePoolSize， * 即实际工作线程数 &gt;= 核心工作线程数，此时需要进入case2 */ c = ctl.get(); &#125; /** * case2：当实际工作线程数&gt;=核心线程数时，新提交任务需要入队 * 执行方案：一旦入队成功，仍需要处理线程池状态突变和工作线程死亡的情况 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //双重校验 int recheck = ctl.get(); /** * recheck的目的是为了防止线程池状态的突变 - 即被关闭 * 一旦线程池非RUNNING状态时，除了从队列中移除该任务(回滚)外 * 还需要执行任务拒绝策略处理新提交的任务 */ if (!isRunning(recheck) &amp;&amp; remove(command)) //执行任务拒绝策略 reject(command); /** * 若线程池还是RUNNING状态 或 * 队列移除失败(可能正好被一个工作线程拿到处理了) * 此时需要确保至少有一个工作线程还可以干活 * 补充一句：之所有无须与核心工作线程数或最大线程数相比，而只是比较0的原因是 * 只要保证有一个工作线程可以干活就行，它会自动去获取任务 */ else if (workerCountOf(recheck) == 0) /** * 若工作线程都已死亡，需要新增一个工作线程去干活 * 死亡原因可能是线程超时或者异常等等复杂情况 * * 第一个参数为null指的是传入一个空任务， * 目的是创建一个新工作线程去处理队列中的剩余任务 * 第二个参数为false目的是提示可以扩容到最大工作线程数 */ addWorker(null, false); &#125; /** * case3：一旦线程池被关闭 或者 新任务入队失败(队列已满) * 执行方案：会尝试创建一个新的工作线程，并允许扩容到最大工作线程数 * 注意：一旦创建失败，比如超过最大工作线程数，需要执行任务拒绝策略 */ else if (!addWorker(command, false)) //执行任务拒绝策略 reject(command);&#125; 上面的代码虽然非常少，但是逻辑还是比较多的，创建线程是根据 addWorker方法来实现的，其主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/** * 新增工作线程需要遵守线程池控制状态规定和边界限制 * * @param core core为true时允许扩容到核心工作线程数，否则为最大工作线程数 * @return 新增成功返回true，失败返回false */private boolean addWorker(Runnable firstTask, boolean core) &#123; //重试标签 retry: /*** * 外部自旋 -&gt; 目的是确认是否能够新增工作线程 * 允许新增线程的条件有两个： * 1.满足线程池状态条件 -&gt; 条件一 * 2.实际工作线程满足数量边界条件 -&gt; 条件二 * 不满足条件时会直接返回false，表示新增工作线程失败 */ for (;;) &#123; //读取原子控制量 - 包含workerCount(实际工作线程数)和runState(线程池状态) int c = ctl.get(); //读取线程池状态 int rs = runStateOf(c); /** * 条件一.判断是否满足线程池状态条件 * 1.只有两种情况允许新增线程： * 1.1 线程池状态==RUNNING * 1.2 线程池状态==SHUTDOWN且firstTask为null同时队列非空 * * 2.线程池状态&gt;=SHUTDOWN时不允许接收新任务，具体如下： * 2.1 线程池状态&gt;SHUTDOWN，即为STOP、TIDYING、TERMINATED * 2.2 线程池状态==SHUTDOWN，但firstTask非空 * 2.3 线程池状态==SHUTDOWN且firstTask为空，但队列为空 * 补充：针对1.2、2.2、2.3的情况具体请参加后面的\"小问答\"环节 */ if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; /*** * 内部自旋 -&gt; 条件二.判断实际工作线程数是否满足数量边界条件 * -数量边界条件满足会对尝试workerCount实现CAS自增，否则新增失败 * -当CAS失败时会再次重新判断是否满足新增条件： * 1.若此期间线程池状态突变(被关闭)，重新判断线程池状态条件和数量边界条件 * 2.若此期间线程池状态一致，则只需重新判断数量边界条件 */ for (;;) &#123; //读取实际工作线程数 int wc = workerCountOf(c); /** * 新增工作线程会因两种实际工作线程数超标情况而失败： * 1.实际工作线程数 &gt;= 最大容量 * 2.实际工作线程数 &gt; 工作线程比较边界数(当前最大扩容数) * -若core = true，比较边界数 = 核心工作线程数 * -若core = false，比较边界数 = 最大工作线程数 */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; /** * 实际工作线程计数CAS自增: * 1.一旦成功直接退出整个retry循环，表明新增条件都满足 * 2.因并发竞争导致CAS更新失败的原因有三种: * 2.1 线程池刚好已新增一个工作线程 * -&gt; 计数增加，只需重新判断数量边界条件 * 2.2 刚好其他工作线程运行期发生错误或因超时被回收 * -&gt; 计数减少，只需重新判断数量边界条件 * 2.3 刚好线程池被关闭 * -&gt; 计数减少，工作线程被回收， * 需重新判断线程池状态条件和数量边界条件 */ if (compareAndIncrementWorkerCount(c)) break retry; //重新读取原子控制量 -&gt; 原因是在此期间可能线程池被关闭了 c = ctl.get(); /** * 快速检测是否发生线程池状态突变 * 1.若状态突变，重新判断线程池状态条件和数量边界条件 * 2.若状态一致，则只需重新判断数量边界条件 */ if (runStateOf(c) != rs) continue retry; &#125; &#125; /** * 这里是addWorker方法的一个分割线 * 前面的代码的作用是决定了线程池接受还是拒绝新增工作线程 * 后面的代码的作用是真正开始新增工作线程并封装成Worker接着执行后续操作 * PS:虽然笔者觉得这个方法其实可以拆分成两个方法的(在break retry的位置) */ //记录新增的工作线程是否开始工作 boolean workerStarted = false; //记录新增的worker是否成功添加到workers集合中 boolean workerAdded = false; Worker w = null; try &#123; //将新提交的任务和当前线程封装成一个Worker w = new Worker(firstTask); //获取新创建的实际工作线程 final Thread t = w.thread; /** * 检测是否有可执行任务的线程，即是否成功创建了新的工作线程 * 1.若存在，则选择执行任务 * 2.若不存在，则需要执行addWorkerFailed()方法 */ if (t != null) &#123; /** * 新增工作线程需要加全局锁 * 目的是为了确保安全更新workers集合和largestPoolSize */ final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; /** * 获得全局锁后，需再次检测当前线程池状态 * 原因在于预防两种非法情况： * 1.线程工厂创建线程失败 * 2.在锁被获取之前，线程池就被关闭了 */ int rs = runStateOf(ctl.get()); /** * 只有两种情况是允许添加work进入works集合的 * 也只有进入workers集合后才是真正的工作线程，并开始执行任务 * 1.线程池状态为RUNNING(即rs&lt;SHUTDOWN) * 2.线程池状态为SHUTDOWN且传入一个空任务 * (理由参见：小问答之快速检测线程池状态?) */ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; /** * 若线程处于活动状态时，说明线程已启动，需要立即抛出\"线程状态非法异常\" * 原因是线程是在后面才被start的，已被start的不允许再被添加到workers集合中 * 换句话说该方法新增线程时，而线程是新的，本身应该是初始状态(new) * 可能出现的场景：自定义线程工厂newThread有可能会提前启动线程 */ if (t.isAlive()) throw new IllegalThreadStateException(); //由于加锁，所以可以放心的加入集合 workers.add(w); int s = workers.size(); //更新最大工作线程数，由于持有锁，所以无需CAS if (s &gt; largestPoolSize) largestPoolSize = s; //确认新建的worker已被添加到workers集合中 workerAdded = true; &#125; &#125; finally &#123; //千万不要忘记主动解锁 mainLock.unlock(); &#125; /** * 一旦新建工作线程被加入工作线程集合中，就意味着其可以开始干活了 * 有心的您肯定发现在线程start之前已经释放锁了 * 原因在于一旦workerAdded为true时，说明锁的目的已经达到 * 根据最小化锁作用域的原则，线程执行任务无须加锁，这是种优化 * 也希望您在使用锁时尽量保证锁的作用域最小化 */ if (workerAdded) &#123; /** * 启动线程，开始干活啦 * 若您看过笔者的\"并发番@Thread一文通\"肯定知道start()后， * 一旦线程初始化完成便会立即调用run()方法 */ t.start(); //确认该工作线程开始干活了 workerStarted = true; &#125; &#125; &#125; finally &#123; //若新建工作线程失败或新建工作线程后没有成功执行，需要做新增失败处理 if (!workerStarted) addWorkerFailed(w); &#125; //返回结果表明新建的工作线程是否已启动执行 return workerStarted;&#125; 小问：快速检测线程状态时，情况1.2、2.1、2.3的意义是什么？ 小答：在阐明这个问题之前，我们先明确两个知识点： 新增Worker的目的是处理任务，任务来源分初始任务和队列任务(即剩余的待处理任务) 线程池在非RUNNING状态下是不允许接收新任务的，换句话说您都要下班了，难道还想接新需求？ 针对2.1 - &gt; 线程池状态==SHUTDOWN，但firstTask！= null，不允许新增Worker当线程池状态为SHUTDOWN时，由于不允许接收新任务，因此一旦firstTask！= null需要直接拒绝 针对2.2 - &gt; 线程池状态==SHUTDOWN，且firstTask == null， 但队列为空， 不允许新增Worker当firstTask为null时，说明调用addWorker()目的不是为了处理新增任务那么其目的应该是为了处理剩余任务，即队列中的任务，而一旦队列为空，那也没必要新增Worker了 针对1.2 - &gt; 若线程池状态==SHUTDOWN，必须满足firstTask为null且队列非空，才允许新增Worker当线程池状态为SHUTDOWN时(调用shutdown())，此时不允许接收新任务，因此firstTask必须为null但需要处理剩余任务，因此队列必须非空，否则新增的工作线程就无任务可做，那就没意义了结论：传入一个空任务的目的是为了新增工作线程去处理任务队列中的剩余任务 3. Worker类详解worker包装了任务的调度，用于封装工作线程和任务并管理工作线程的中断状态等功能 由于工作线程和worker实例是一对一的关系，因为可以简单的理解工作线程等价于worker，尤其是谈及数量时，比如创建工作线程实际上就是创建一个worker 线程在线程池执行任务的工作流程： 工作线程开始执行前，需先对worker加锁，任务完成解锁 任务执行前后分别执行beforeExecute()和afterExecute()方法 执行中遇到异常会向外抛出，线程是否死亡取决于您对于异常的处理 每个任务执行完后，当前工作线程任务完成数自增，同时会循环调用getTask()从任务队列中反复获取任务并执行，无任务可执行时线程会阻塞在该方法上 当工作线程因各种理由退出时，会执行processWorkerExit()回收线程(核心是将该worker从workers集合中移除，注意之前worker已经退出任务循环，因此已经不再做工了，从集合移除后就方便gc了) 问：worker中断如何控制的 当工作线程真正开始执行之前，不允许被中断 当工作线程正在执行任务时，不允许被中断 当工作线程正等待从任务队列中获取任务getTask()时才能被中断 调用interruptIdleWorkers()中断空闲线程时必须先获得worker锁 问：为什么Worker不被设计成可重入锁？ 由于在动态控制方法中可能会中断线程，比如调用interruptIdleWorkers()，由此该方法在执行interrupt()之前会调用worker.tryLock()，若此时允许重入，就会导致线程被意外中断，这跟当工作线程正在执行任务时，不允许被中断准则是相违背的 IV. 问题解答1. 如何创建线程池直接根据构造方法创建 12345java.util.concurrent.ThreadPoolExecutor#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt;, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler) 利用 Executors 创建线程池 12345678910111213java.util.concurrent.Executors#newFixedThreadPool(int)java.util.concurrent.Executors#newWorkStealingPool(int)java.util.concurrent.Executors#newSingleThreadExecutor()java.util.concurrent.Executors#newCachedThreadPool()java.util.concurrent.Executors#newSingleThreadScheduledExecutor()java.util.concurrent.Executors#newScheduledThreadPool(int)java.util.concurrent.Executors#unconfigurableExecutorService 2. 线程池的适用场景优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 如何使用线程池创建线程池，提交任务 execute 适用于提交没有返回结果的任务 submit 适用于提交有返回结果的任务， 返回一个Futrure的包装类 4. 线程池实现原理 &amp; 任务提交后的流程在实现原理中会穿插上任务提交后的流程，所以就放在一起了 首先从提交一个任务开始： 首先判断工作线程数是否小于核心工作线程数，是则直接创建工作线程执行 否，则将任务丢入任务队列中 若任务队列已满，且工作线程数 &lt; 最大工作线程数，则直接创建工作线程执行任务 若队列满，且工作线程数达到最大值，则采用拒绝任务策略 其中上面的任务进队or创建线程执行，都需要关注线程池的状态，每个状态对应的原则 状态 说明 限制 RUNNING 运行状态 线程池会接收新提交任务和执行队列任务 SHUTDOWN 关闭状态 线程池不再接收新任务，但还会继续执行队列任务 STOP 停止状态 不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务 TIDYING 整理状态 所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated() TERMINATED 终止状态 线程池terminated()方法已经调用完成 接着上面，工作线程执行完毕之后，会尝试从任务队列中获取任务来执行，如果队列为空，则阻塞；此时工作线程空闲 根据工作线程的回收机制 允许回收核心工作线程时，将所有空闲时间大于keepAliveTime的线程回收掉 不允许回收核心工作线程，回收空闲时间大于keepAliveTime的线程，知道工作线程数量为核心工作线程数 5. 异常状况处理submit()异常处理 异常会保存在Future对象的ExecutionException中，可以在调用get()使用try-catch方式捕获，有N个任务有异常就会抛出来N个异常，但不会终止当前工作线程 单独设置UncaughtExceptionHandler没卵用，但结合(3)使用就有效 允许在submit()方法内部用try-catch捕获该异常，同样不会终止当前线程 若想在内部处理异常，还可以重写afterExecute()方法， execute()异常处理 默认会在execute()方法内部直接抛出异常，注意这不会中断线程池运行，但会终止当前工作线程，并重新创建新的工作线程执行该任务 允许在execute()方法内部用try-catch捕获该异常，好处是不会终止当前线程并重新创建一个新的线程了 重写afterExecute()方法 还可以设置UncaughtExceptionHandler 一个实例如下: 1234567891011ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 2, 3, TimeUnit.SECONDS, new LinkedBlockingQueue(), //我们自定义一个线程工厂和重写线程的setUncaughtExceptionHandler方法 new ThreadFactory() &#123; final AtomicInteger threadNumber = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; Thread thread = new Thread(Thread.currentThread().getThreadGroup(), r, \"thread-\" + (threadNumber.getAndIncrement())); thread.setUncaughtExceptionHandler((t,e) -&gt; System.out.println(e)); return thread; &#125;&#125;); 6. 线程池关闭关闭线程池主要有两种方式，两者的区别是： shutdown() : 队列剩余任务全部执行完毕再终止 shutdownNow() : 放弃执行队列剩余任务，但会将它们返回 两者的共性在于： 正在执行中的任务会继续执行，不会被终止或放弃 新提交的任务会被直接拒绝 V. 其他参考 Java-线程池专题（什么是线程池，如何使用，为什么要用） 并发番@ThreadPoolExecutor 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"https://zbang.online/hexblog/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"7. 报警系统QuickAlarm之默认报警规则扩展","slug":"报警系统QuickAlarm之默认报警规则扩展","date":"2018-03-05T04:25:00.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","link":"","permalink":"https://zbang.online/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","excerpt":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度","text":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度 I. 配置文件的扩展先看一下原有的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;&#125; 我们希望是能够支持多重报警方式同时选中，那么上面的配置中， threshold中只定义了一个阀值参数显然是不合适的，主要问题在于 单一阀值，不允许不同报警方式存在交叉 两个报警方式的threshold值相等时，选中的具体是哪个不可预期 所以我们的目标是将上面的参数中，新增一个指定上限的值max 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"ZZZ\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"max\": 27, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 9, \"max\": 14, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; 向上面这般改动之后，相当于每个报警方式都可以定义自己的区间，因此允许多重报警方式存在区间的交叉，计数在交叉区间即表示选中这多重方式 II. 扩展的实现支持从配置文件的变动来看，改动很小，只是新增一个参数而已，且这个参数不是必填的，那么对应的do应该为 123456789101112131415161718192021222324public class BasicAlarmThreshold &#123; private String level; /** * 启用定义的报警方式的阀值下限， * * 当报警计数 count &gt;= min * - max 非null, count &lt; max 则选择本报警方式; * count &gt;= max 则不选择本报警方式 * - max 为null（即表示为定义时）， * 则max赋值为:恰好大于 min 的 &#123;@link BasicAlarmThreshold#threshold&#125;值 * */ private int threshold; /** * 报警上限值，注意这是包装类型，允许为null */ private Integer max; private List&lt;String&gt; users;&#125; 然后顺带着，优化一把我们的映射规则，将配置规则的DO对象，映射为业务对象 主要的映射规则如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 将配置项转换为业务DO对象, 会做一些兼容, 保证 level. min, max, users, thresholds 都不会为null * * @param basicAlarmConfig * @return */private static AlarmConfig parse2BizConfig(BasicAlarmConfig basicAlarmConfig) &#123; if (basicAlarmConfig.getUsers() == null || basicAlarmConfig.getUsers().isEmpty()) &#123; // 如果没有填写用户, 则直接抛弃 return null; &#125; AlarmConfig alarmConfig = new AlarmConfig(); // 如果配置的报警类型是异常的, 则下面会兼容一把，设置为 NONE, 避免因为配置的原因导致系统异常 alarmConfig.setExecutor(SimpleExecuteFactory.getExecute(basicAlarmConfig.getLevel())); alarmConfig.setAutoIncEmergency(basicAlarmConfig.isAutoIncEmergency()); // 报警用户, 要求用户必须存在 alarmConfig.setUsers(basicAlarmConfig.getUsers()); // 报警上限, 如果用户没有填写，采用默认的（因为短信报警按条数要钱, 没必要一直无上限的报） alarmConfig.setMaxLimit(basicAlarmConfig.getMax() == null ? AlarmConfig.DEFAULT_MAX_NUM : basicAlarmConfig.getMax()); // 报警下限, 如果用户没有填写, 采用默认的最小值0 alarmConfig.setMinLimit(basicAlarmConfig.getMin() == null ? AlarmConfig.DEFAULT_MIN_NUM : basicAlarmConfig.getMin()); // 获取配置中的阀值列表，并排序 List&lt;BasicAlarmThreshold&gt; basicAlarmThresholdList = basicAlarmConfig.getThreshold(); if(basicAlarmThresholdList == null) &#123; basicAlarmThresholdList = Collections.emptyList(); &#125; basicAlarmThresholdList.sort(Comparator.comparingInt(BasicAlarmThreshold::getThreshold)); List&lt;AlarmThreshold&gt; alarmThresholdList = new ArrayList&lt;&gt;(basicAlarmThresholdList.size() + 2); AlarmThreshold tmpAlarmThreshold; BasicAlarmThreshold tmpBasicAlarmThreshold; boolean containDefaultExecute = false; for (int i = 0; i &lt; basicAlarmThresholdList.size(); i++) &#123; tmpBasicAlarmThreshold = basicAlarmThresholdList.get(i); tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(SimpleExecuteFactory.getExecute(tmpBasicAlarmThreshold.getLevel())); tmpAlarmThreshold.setUsers(tmpBasicAlarmThreshold.getUsers()); tmpAlarmThreshold.setMin(tmpBasicAlarmThreshold.getThreshold()); if (tmpBasicAlarmThreshold.getMax() == null || tmpBasicAlarmThreshold.getMax() &lt;= tmpBasicAlarmThreshold.getThreshold()) &#123; if (i == basicAlarmThresholdList.size() - 1) &#123; // 最后一个，则使用默认的上限阀值 tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); &#125; else &#123; tmpAlarmThreshold.setMax(basicAlarmThresholdList.get(i + 1).getThreshold()); &#125; &#125; else &#123; tmpAlarmThreshold.setMax(tmpBasicAlarmThreshold.getMax()); &#125; if (!containDefaultExecute) &#123; containDefaultExecute = tmpBasicAlarmThreshold.getLevel().equals(basicAlarmConfig.getLevel()); &#125; alarmThresholdList.add(tmpAlarmThreshold); &#125; int thresholdSize = alarmThresholdList.size(); if (thresholdSize == 0) &#123; // 没有配置阀值列表，直接使用默认 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; else if (!containDefaultExecute) &#123; // 不包含时默认时，补全 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmThresholdList.get(0).getMin()); alarmThresholdList.add(0, tmpAlarmThreshold); if (alarmThresholdList.get(thresholdSize).getMax() &lt; alarmConfig.getMaxLimit()) &#123; tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmThresholdList.get(thresholdSize).getMax()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; &#125; alarmConfig.setAlarmThreshold(alarmThresholdList); return alarmConfig;&#125; 在映射为业务对象的逻辑中，直接保障了AlarmThreshold列表中的顺序为最终的需求顺序，映射规则为 123456789101112131415161718192021222324252627/** * 如果配置的basicAlarmThresholdList列表中包含默认的报警方式 * - 则报警方式完全按照basicAlarmThresholdList的定义来 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Log, min=6 &#125;, &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=6, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - count : [6, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * * 如果不包含默认报警方式 * - 则需要补全最外层定义的Min-Max区间中的空余位 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=5, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125;, &#123; Log, min=26, max=30 &#125; * - count : [5, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * - count : [26, 30) Log * * * 上面改造后，很容易得知，支持多重报警方式同时工作，即当技术为14，15 时，同时发起WeiXin和SMS报警 */ 相应的就可以干掉原来不太好懂的Executor选择逻辑，对应的代码为 123456789101112131415161718192021222324252627282930// com.hust.hui.alarm.core.execut.AlarmExecuteSelector#getExecutepublic static List&lt;ExecuteHelper&gt; getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return Collections.singletonList(new ExecuteHelper(alarmConfig.getExecutor(), alarmConfig.getUsers())); &#125; if (count &lt; alarmConfig.getAlarmThreshold().get(0).getMin()) &#123; // 未达到报警的下限 return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; List&lt;ExecuteHelper&gt; list = new ArrayList&lt;&gt;(); for(AlarmThreshold alarmThreshold: alarmConfig.getAlarmThreshold()) &#123; if (alarmThreshold.getMin() &lt;= count &amp;&amp; count &lt; alarmThreshold.getMax()) &#123; list.add(new ExecuteHelper(alarmThreshold.getExecutor(), alarmThreshold.getUsers())); &#125; if(alarmThreshold.getMin() &gt; count) &#123; break; &#125; &#125; return list;&#125; III. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"借助GitHub搭建属于自己的maven仓库教程","slug":"借助GitHub搭建属于自己的maven仓库教程","date":"2018-02-12T06:01:13.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","link":"","permalink":"https://zbang.online/hexblog/2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","excerpt":"","text":"I. 背景在Github上也写了不少的项目了，然后经常遇到的一个问题就是，很多自己写的项目，希望在另外一个项目中使用时，只能把这个项目下载下来，相当之不方便 因为大多数的java后端项目都是基于maven管理依赖的，所以就希望能有一个公共的maven仓库，可以把自己的项目扔进去，然后再应用就方便很多了 基于此，就有了本文这个教程了 II. 实现步骤1. github仓库建立新建一个repository的前提是有github帐号，默认看到本文的是有帐号的 首先是在github上新建一个仓库，命令随意，如我新建项目为 https://github.com/liuyueyi/maven-repository 2. 配置本地仓库本地指定一个目录，新建文件夹 maven-repository, 如我的本地配置如下 1234567891011121314## 进入目录cd /Users/yihui/GitHub## 新建目录mkdir maven-repository; cd maven-repository## 新建repository目录# 这个目录下面就是存放我们deploy的项目相关信息# 也就是说我们项目deploy指定的目录，就是这里mkdir repository## 新增一个readme文档# 保持良好的习惯，每个项目都有一个说明文档touch README.md 这个目录结构为什么是这样的？ 我们直接看maven配置中默认的目录结构，同样拷贝一份出来而已 3. 仓库关联将本地的仓库和远程的github仓库关联起来，执行的命令也比较简单了 1234git add .git commit -m 'first comit'git remote add origin https://github.com/liuyueyi/maven-repository.gitgit push -u origin master 接着就是进行分支管理了 约定将项目中的snapshot版，deploy到仓库的 snapshot分支上 约定将项目中的release版，deploy到仓库的 release分支上 master分支管理所有的版本 所以需要新创建两个分支 12345678## 创建snapshot分支git checkout -b snapshot git push origin snapshot# 也可以使用 git branch snapshot , 我通常用上面哪个，创建并切换分支## 创建release分支git checkout -b releasegit push origin release 4. 项目deploy项目的deploy，就需要主动的指定一下deploy的地址了，所以我们的deploy命令如下 12## deploy项目到本地仓库mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository 上面的命令就比较常见了，主要需要注意的是file后面的参数，根据自己前面设置的本地仓库目录来进行替换 5. deploy脚本每次进行上面一大串的命令，不太好记，特别是不同的版本deploy到不同的分支上，主动去切换分支并上传，也挺麻烦，所以就有必要写一个deploy的脚本了 由于shell实在是不太会写，所以下面的脚本只能以凑合能用来说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashif [ $# != 1 ];then echo 'deploy argument [snapshot(s for short) | release(r for short) ] needed!' exit 0fi## deploy参数，snapshot 表示快照包，简写为s， release表示正式包，简写为rarg=$1DEPLOY_PATH=/Users/yihui/GitHub/maven-repository/CURRENT_PATH=`pwd`deployFunc()&#123; br=$1 ## 快照包发布 cd $DEPLOY_PATH ## 切换对应分支 git checkout $br cd $CURRENT_PATH # 开始deploy mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository # deploy 完成,提交 cd $DEPLOY_PATH git add -am 'deploy' git push origin $br # 合并master分支 git checkout master git merge $br git commit -am 'merge' git push origin master cd $CURRENT_PATH&#125;if [ $arg = 'snapshot' ] || [ $arg = 's' ];then ## 快照包发布 deployFunc snapshotelif [ $arg = 'release' ] || [ $arg = 'r' ];then ## 正式包发布 deployFunc releaseelse echo 'argument should be snapshot(s for short) or release(r for short). like: `sh deploy.sh snapshot` or `sh deploy.sh s`'fi 将上面的脚本，考本到项目的根目录下，然后执行 12345678chmod +x deploy.sh## 发布快照包./deploy.sh s# sh deploy.sh snapshot 也可以## 发布正式包./deploy.sh r 基于此，整个步骤完成 III. 使用上面仓库的基本搭建算是ok了，然后就是使用了，maven的pom文件应该怎么配置呢？ 首先是添加仓库地址 添加仓库 如果要区分snapshot和release的话，如下配置 12345678910&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-snap&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/snapshot/repository&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-release&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/release/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 如果不care的话，直接添加下面的即可 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/master/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 仓库配置完毕之后，直接引入依赖即可，如依赖我的Quick-Alarm包，就可以添加下面的依赖配置 12345&lt;dependency&gt; &lt;groupId&gt;com.hust.hui.alarm&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Github","slug":"Github","permalink":"https://zbang.online/hexblog/tags/Github/"},{"name":"Maven","slug":"Maven","permalink":"https://zbang.online/hexblog/tags/Maven/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}]},{"title":"6. 报警系统QuickAlarm使用手册","slug":"报警系统QuickAlarm使用手册","date":"2018-02-11T10:53:33.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm使用手册/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm使用手册/","excerpt":"","text":"本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项 1. 基本使用姿势首先我们不做任何的自定义操作，全部依靠系统默认的实现，我们的使用步骤如下 1. 添加注册文件首先在项目的资源目录下，添加注册文件 alarm.properties，文件内容如下 12345678910111213## 应用名，必填appName=test## 报警规则文件所在的路径，如果采用系统默认加载方式，必填## / 开头，表示存的是绝对路径## 非/开头，表示存的是系统相对路径，一般是放在资源目录下alarmConfPath=/tmp/alarmConfig## 最大的报警类型，非必填maxAlarmType=1000## 默认报警用户，必填defaultAlarmUsers=yihui 具体存放的位置，可以参考下图，放在resources目录下（源码中，是放在测试资源目录下的） 2. 添加报警规则根据注册文件中指定的路径，设置报警规则文件，如我们的报警规则文件 内容为json串格式，支持格式化的json串解析，为了节省篇幅，下面压缩成一行，点击获取json格式化小工具 /tmp/alarmConig: 1&#123;\"default\":&#123;\"level\":\"LOG\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"LOG\",\"threshold\":5,\"users\":[\"yihui\",\"erhui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"NPE\":&#123;\"level\":\"WEIXIN\",\"autoIncEmergency\":false,\"max\":30,\"min\":0,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"3h ui\",\"4hui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"XXX,YYY\":&#123;\"level\":\"EMAIL\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"EMAIL\",\"threshold\":5,\"users\":[\"yihui@xxx.com\",\"erhui@xxx.com\"]&#125;],\"users\":[\"yihui@xxx.com\"]&#125;&#125; 3. 测试类一个简单的使用测试 123456789101112@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; II. 报警执行机器扩展前面的报警规则配置中，有WEIXIN, SMS, EMAIL的报警，但是系统只提供了两个NONE和LOG，所以我们可以看下如何自定义实现上面的三个 1. 实现IExecute接口邮件报警 123456public class EmailExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 短信报警 12345678910/** * Created by yihui on 2018/2/7. */public class SmsExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 微信报警 123456789/** * Created by yihui on 2018/2/7. */public class WeiXinExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 说明，因为没有具体的实现，所以我们直接用日志输出来模拟，所以就都继承了LogExecute, 实际使用中，可以在上面补上相应的实现代码 2. 添加SPI定义在 resources 目录下，新增 目录：META-INF/services/ 文件：com.hust.hui.alarm.core.execut.api.IExecute 文件内容为上面几个实现类的全路径 123com.hust.hui.alarm.core.test.execute.EmailExecutecom.hust.hui.alarm.core.test.execute.SmsExecutecom.hust.hui.alarm.core.test.execute.WeiXinExecute 目录结构如： 3. 测试1234567891011121314151617181920public static void main(String[] args) throws InterruptedException &#123; // 测试异常升级的case // 计数 [1 - 2] 默认报警（即无日志） （其中 &lt; 3 的是因为未达到下限, 采用的默认报警） // 计数 [3 - 4] 默认邮件报警（其中 &lt; 5 采用的默认报警, 与下面的区别是报警用户） // 计数 [5 - 9] 邮件报警 （大于5小于10根据上升规则,还是选择邮件报警） // 计数 [10 - 19] 微信报警 // 计数 [20 - 30] 短信报警 // 计数 [31 -] 默认报警 （超过上限, 不报警） for (int i = 0; i &lt; 40; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; AlarmWrapper.getInstance().sendMsg(\"YYY\", \"异常报警升级测试\"); &#125; &#125;).start(); &#125; Thread.sleep(1000 * 600);&#125; 实测输出结果如下: 1234567891011121314151617181920212223242526272818:36:28.997 [Thread-12] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 26 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-24] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 16 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-33] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 6 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-22] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 18 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-26] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-23] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 17 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-35] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 4 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-3] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 5 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-18] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 27 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-11] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 28 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-21] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 19 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-2] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 9 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-14] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 24 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-10] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 29 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-15] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 22 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-16] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 23 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 15 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-9] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 30 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-13] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 25 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-19] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 21 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-34] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 3 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-4] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 7 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:36:29.011 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-5] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 8 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-1] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 20 &gt;&gt;&gt; 异常报警升级测试 III. 报警规则加载自定义1. 实现IConfLoader接口自定义加载器，给了一个最基本的 12345678910111213141516171819202122232425262728293031323334public class SelfAlarmConfLoader implements IConfLoader &#123; @Override public RegisterInfo getRegisterInfo() &#123; RegisterInfo registerInfo = new RegisterInfo(); registerInfo.setMaxAlarmType(100); registerInfo.setDefaultAlarmUsers(\"yihui\"); registerInfo.setAppName(\"test\"); return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public int order() &#123; return 0; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; //db 查询，获取对应的配置信息 // 下面是模拟，返回一个固定的配置 AlarmConfig alarmConfig = new AlarmConfig(); alarmConfig.setAlarmLevel(\"WEIXIN\"); alarmConfig.setAutoIncEmergency(false); alarmConfig.setMinLimit(10); alarmConfig.setMaxLimit(14); alarmConfig.setUsers(Arrays.asList(\"yihui\")); alarmConfig.setAlarmThreshold(Collections.emptyList()); return alarmConfig; &#125;&#125; 2. 添加SPI配置在resources目录下新增 目录： META-INF/services 文件： com.hust.hui.alarm.core.loader.api.IConfLoader 文件内容 1com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader 3. 测试同样是上面的代码，输出结果 1234518:43:04.275 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:43:04.276 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试 4. 说明系统默认的order是10，所以如果在测试上面的第二步时，不妨把com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader#order返回值，改成大于10，这样就会走到默认的配置加载类 采用 SelfAlarmConfLoader 时，前面说的两个基础配置文件，是可以没有的，完全不会有任何影响，因为对应的注册类和报警规则，都是右这个类内部提供了 IV. 小结所有测试相关数据，均可以在测试工程中获取，请主要关注: 测试case 注册文件：alarmConfig 报警规则配置文件：alarm.properties V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"5. 报警系统QuickAlarm之频率统计及接口封装","slug":"报警系统QuickAlarm之频率统计及接口封装","date":"2018-02-11T08:59:47.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","excerpt":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦","text":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦 I. 报警频率统计1. 设计前面在解析报警规则时，就有一个count参数，用来确定具体选择什么报警执行器的核心参数，我们维护的方法也比较简单： 针对报警类型，进行计数统计，没调用一次，则计数+1 每分钟清零一次 2. 实现因为每种报警类型，都维护一个独立的计数器 定义一个map来存储对应关系 1private ConcurrentHashMap&lt;String, AtomicInteger&gt; alarmCountMap; 每分钟执行一次清零 1234567// 每分钟清零一把报警计数ScheduledExecutorService scheduleExecutorService = Executors.newScheduledThreadPool(1);scheduleExecutorService.scheduleAtFixedRate(() -&gt; &#123; for (Map.Entry&lt;String, AtomicInteger&gt; entry : alarmCountMap.entrySet()) &#123; entry.getValue().set(0); &#125;&#125;, 0, 1, TimeUnit.MINUTES); 注意上面的实现，就有什么问题？ 有没有可能因为map中的数据过大（或者gc什么原因），导致每次清零花不少的时间，而导致计数不准呢？ （先不给出回答） 计数加1操作 1234567891011121314151617/** * 线程安全的获取报警总数 并自动加1 * * @param key * @return */private int getAlarmCount(String key) &#123; if (!alarmCountMap.containsKey(key)) &#123; synchronized (this) &#123; if (!alarmCountMap.containsKey(key)) &#123; alarmCountMap.put(key, new AtomicInteger(0)); &#125; &#125; &#125; return alarmCountMap.get(key).addAndGet(1);&#125; II. 报警线程池目前也只是提供了一个非常简单的线程池实现，后面的考虑是抽象一个基于forkjoin的并发框架来处理（主要是最近接触到一个大神基于forkjoin写的并发器组件挺厉害的，所以等我研究透了，山寨一个） 123456// 报警线程池private ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"sms-sender\"), new ThreadPoolExecutor.CallerRunsPolicy()); 任务提交执行 12345678private void doSend(final ExecuteHelper executeHelper, final AlarmContent alarmContent) &#123; alarmExecutorService.execute(() -&gt; executeHelper.getIExecute().sendMsg( executeHelper.getUsers(), alarmContent.getTitle(), alarmContent.getContent()));&#125; III. 接口封装这个就没什么好说的了 123456789101112131415161718192021222324252627282930313233343536373839404142public void sendMsg(String key, String content) &#123; sendMsg(new AlarmContent(key, null, content));&#125;public void sendMsg(String key, String title, String content) &#123; sendMsg(new AlarmContent(key, title, content));&#125;/** * 1. 获取报警的配置项 * 2. 获取当前报警的次数 * 3. 选择适当的报警类型 * 4. 执行报警 * 5. 报警次数+1 * * @param alarmContent */private void sendMsg(AlarmContent alarmContent) &#123; try &#123; // get alarm config AlarmConfig alarmConfig = confLoader.getAlarmConfig(alarmContent.key); // get alarm count int count = getAlarmCount(alarmContent.key); alarmContent.setCount(count); ExecuteHelper executeHelper; if (confLoader.alarmEnable()) &#123; // get alarm execute executeHelper = AlarmExecuteSelector.getExecute(alarmConfig, count); &#125; else &#123; // 报警关闭, 则走空报警流程, 将报警信息写入日志文件 executeHelper = AlarmExecuteSelector.getDefaultExecute(); &#125; // do send msg doSend(executeHelper, alarmContent); &#125; catch (Exception e) &#123; logger.error(\"AlarmWrapper.sendMsg error! content:&#123;&#125;, e:&#123;&#125;\", alarmContent, e); &#125;&#125; 接口封装完毕之后如何使用呢？ 我们使用单例模式封装了唯一对外使用的类AlarmWrapper，使用起来也比较简单，下面就是一个测试case 12345678910111213@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; 使用起来比较简单，就那么一行即可，从这个使用也可以知道，整个初始化，就是在这个对象首次被访问时进行 构造函数内容如下: 12345678910private AlarmWrapper() &#123; // 记录每种异常的报警数 alarmCountMap = new ConcurrentHashMap&lt;&gt;(); // 加载报警配置信息 confLoader = ConfLoaderFactory.loader(); // 初始化线程池 initExecutorService();&#125; 所有如果你希望在自己的应用使用之前就加载好所有的配置，不妨提前执行一下 AlarmWrapper.getInstance() IV. 小结基于此，整个系统设计基本上完成，当然代码层面也ok了，剩下的就是使用手册了 再看一下我们的整个逻辑，基本上就是下面这个流程了 提交报警 封装报警内容（报警类型，报警主题，报警内容） 维护报警计数（每分钟计数清零，每个报警类型对应一个报警计数） 选择报警 根据报警类型选择报警规则 根据报警规则，和当前报警频率选择报警执行器 若不开启区间映射，则返回默认执行器 否则遍历所有执行器的报警频率区间，选择匹配的报警规则 执行报警 封装报警任务，提交线程池 报警执行器内部实现具体报警逻辑 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"4. 报警系统QuickAlarm之报警规则解析","slug":"报警系统QuickAlarm之报警规则解析","date":"2018-02-11T08:08:04.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之报警规则解析/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之报警规则解析/","excerpt":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器","text":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器 I. 背景知识点0. 声明在正式进入之前，有必要额外声明一下，因为目前的v1版本，没有开放报警规则的自定义，也就是说，目前只支持默认的报警规则，所以接下来的主要内容将集中在 系统默认的报警规则的解析 即基于报警频率阀值，自动选择报警执行器的规则解析 1. 报警规则如果对于报警规则，依然不是很清晰的，可以阅读一下《报警系统QuickAlarm之报警规则的设定与加载》 这里简单的进行说明，系统中默认的报警规则结构为： key为报警类型（即用户执行报警时，传进来的报警类型参数） value为具体报警规则 每个报警执行器拥有一个报警频率区间，通过报警频率映射到报警执行器的区间来选择对应的AlarmExecutor，这就是系统定义的报警规则 II. 报警规则解析通过前面的报警规则的简单说明，基本上也可以捞出报警规则的解析原则了 每种报警类型，对应一个报警规则 每个报警规则中，可以有多个报警执行器 每个报警执行器都有一个对应的报警频率的阀值 根据阀值对所有的报警执行器排序 计算报警频率，映射到哪个区间，则选择哪个报警执行器 上面是一个简单的解析规则，当然实际上和这个差不多，但有一些问题需要额外注意 只想选择一种报警方式，是否可以支持？ 多重报警方式同时调用怎么处理？（如我希望用短信提示说有问题，同时用邮件包含详细的异常堆栈） 频率限制 报警类型没有设置报警规则如何处理？ 报警规则中使用了一个未注册的报警执行器会怎样？ 1. 实现方案说明再次将报警规则类拿出来看一下 12345678910111213141516171819202122232425262728293031323334/** * 报警用户 */private List&lt;String&gt; users;/** * 报警的阀值 */private List&lt;AlarmThreshold&gt; alarmThreshold;/** * 最小的报警数 */private int minLimit;/** * 最大的报警数 */private int maxLimit;/** * 报警类型 &#123;@link IExecute#getName()&#125; */private String alarmLevel;/** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */private boolean autoIncEmergency; 针对上面的问题，逐一说明 首先是 autoIncEmergency 这个参数，如果为true，则表示可以走上面的哪个区间映射的规则；否则就全部走AlarmConfig中默认的报警类型了 minLimit : 表示发生报警的频率下限值，小于这个值就不会执行具体的报警逻辑 maxLimit : 最大的报警频率，超过了也不报警（简单的频率控制） alarmLevel: 对应的就是具体的报警类型 alarmThreshold: 这个只有在autoIncEmergency=true时，才有小，也就是我们前面说的不同的报警执行器，根据阀值区间进行排序，开启之后，遍历，判断频率是否在这个区间内，若在，则表示可以选择它了 如果不存在报警规则，则采用默认的兜底规则 若报警执行器也不存在，就直接采用系统定义的日志报警执行器 2. 实现基本上前面已经将整个逻辑都说了，所以实际的编码反而比较清晰了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 获取具体的报警执行器 * &lt;p&gt; * 1. 未开启严重等级上升时, 直接返回 * 2. 开启之后, 判断当前的计数 范围 * * @param alarmConfig 报警配置项, 内部所有的参数都不可能为null */public static ExecuteHelper getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers()); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return new ExecuteHelper(SimpleExecuteFactory. getExecute(alarmConfig.getAlarmLevel()), alarmConfig.getUsers()); &#125; // 报警等级开启上升之趋势 // 1. 获取设置的默认等级 // 2. 判断当前的报警次数, 选择对应的报警类型 // 3. 选择具体的报警类型 String defaultLevel = alarmConfig.getAlarmLevel(); String selectLevel = null; List&lt;String&gt; selectUser = alarmConfig.getUsers(); List&lt;AlarmThreshold&gt; list = alarmConfig.getAlarmThreshold(); boolean useNew = false; boolean containDefaultLevel = false; for (AlarmThreshold alarmThreshold : list) &#123; if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; containDefaultLevel = true; &#125; &#125; for (AlarmThreshold alarmThreshold : list) &#123; // 表示当前的报警等级已经赶上默认的报警等级了, 所以要选择新的报警类型 if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; useNew = true; &#125; if (count &lt; alarmThreshold.getThreshold()) &#123; break; &#125; selectLevel = alarmThreshold.getAlarmLevel(); // 选择新的报警类型时, 需要更新报警用户 selectUser = alarmThreshold.getUsers(); &#125; // 阀值列表中不包含默认报警类型，则根据新的来 if (!containDefaultLevel &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; // 如果阀值列表中包含了默认报警类型, 且已经超过默认阀值 if (useNew &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; else &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(defaultLevel), alarmConfig.getUsers()); &#125;&#125; 具体的实现基本和我们前面分析的一样，但有一个地方需要额外注意 默认报警阀值，可以直接决定是否需要报警 因此定义的其他报警方式的阀值，应该在默认的阀值区间内 当然AlarmThreshold中不包含默认报警方式时，优先选择阀值区间的报警方式 当然AlarmThreshold中包含默认报警方式时，根据新的规则做处理 （吐槽：上面这个实现有点绕，后面想办法规避下，搞得不太好理解了） 另外一个问题就是，上面的实现没有支持可以同时选择多个报警执行器的情况 因为考虑到后面肯定会对报警规则的定义和解析放开，所以先实现了一个简单的场景，具体的放在后面处理 III. 小结到这里报警规则和报警执行器之间的解析关系已确定，剩下的东西就简单了，一个维持报警频率计数，一个报警线程池，再加上一个对外接口的封装而言 基本上，到这里主要的核心逻辑已经完成，小结一下本系统中的核心设计理念 – 一切可自定义（当然目前差得有点远） 1. 报警执行器 通过SPI机制支持用户自定义扩展 要求 Executor 拥有唯一标识 因为报警执行器支持扩展，所以Executor的内部实现，完全可以由用户决定 2. 报警规则 目前报警规则只提供默认的基于频率区间的选择方案 报警规则通过报警执行器的name与之唯一对应，若对应不上，则选择默认执行器 报警规则的加载同样基于SPI，支持自定义，因此报警规则可以存在任何地方 报警规则加载器，提供一个报警规则变动的钩子(load()),若采用自定义的加载类，则确保规则变动时，主动回调这个方法 默认的报警规则加载类，是基于系统的配置文件实现，内部托管了文件的变动更新事件（使用commons-io实现） IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"3. 报警系统QuickAlarm之报警规则的设定与加载","slug":"报警系统QuickAlarm之报警规则的设定与加载","date":"2018-02-09T11:39:43.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","excerpt":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择","text":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择 I. 报警规则定义 目前针对报警规则没有给出自定义配置的入口，即完全采用了默认的方案，后续可以考虑支持适用方来自定义报警规则以及解析器，这样扩展性就更强了 首先说明下我们的设计规则，我们针对不同的AlarmExecute定义了一个优先级，我们的目标是 针对报警频率设置不同区间，每个区间对应一种报警类型 当实际调用的报警频率达到这个区间，就选择这种报警类型 同时也允许关闭根据频率选择报警器的功能，全程用一个默认 每种报警类型的用户都可以自定义 针对上面的目标，我们设计的类就比较明确了 阀值类： 1234567891011121314151617181920212223242526272829303132@Getter@Setter@ToStringpublic class AlarmThreshold implements Comparable&lt;AlarmThreshold&gt; &#123; /** * 报警类型，对应 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * 晋升此报警的阀值 */ private int threshold; /** * 对应的报警用户 */ private List&lt;String&gt; users; @Override public int compareTo(AlarmThreshold o) &#123; if (o == null) &#123; return -1; &#125; return threshold - o.getThreshold(); &#125;&#125; 配置类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Getter@Setter@ToStringpublic class AlarmConfig &#123; public static final int DEFAULT_MIN_NUM = 0; public static final int DEFAULT_MAX_NUM = 30; /** * 报警用户 */ private List&lt;String&gt; users; /** * 报警的阀值 */ private List&lt;AlarmThreshold&gt; alarmThreshold; /** * 最小的报警数 */ private int minLimit; /** * 最大的报警数 */ private int maxLimit; /** * 报警类型 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */ private boolean autoIncEmergency;&#125; 一个报警类型对应一个AlarmConfig，这样当执行报警时，就可以很容易的获取对应的规则 同样根据定义，也可以看出报警规则比较简单，直接根据阀值区间来选择 II. 报警规则加载关于如何加载报警规则，想了很久，选择把这块放开，因为我们无法确定，使用方的配置是存在什么地方的，而且使用的配置是否能和我们的设计的DO兼容也是个问题，因此干脆放手，同样是通过SPI的方式来做的 我们定义规则加载接口： IConfLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface IConfLoader &#123; /** * 加载配置到内存的操作，启动时，被调用 * * @return true 表示加载成功; false 表示加载失败 */ default boolean load() &#123; return true; &#125; /** * 排序，越小优先级越高 * &lt;p&gt; * 说明： 当系统中多个Loader存在时，会根据优先级来选择order最小的一个作为默认的Loader * * @return */ default int order() &#123; return 10; &#125; /** * 获取注册信息 * * @return */ RegisterInfo getRegisterInfo(); /** * 是否开启报警 * * @return */ boolean alarmEnable(); /** * 根据报警类型，获取对应的报警规则 * * @param alarmKey * @return */ AlarmConfig getAlarmConfig(String alarmKey);&#125; 上面的方法，可以划分为两类: 加载时使用 load 为具体的执行加载配置到内存的方法，返回true表示加载成功 order 排序 getRegisterInfo 获取基础的配置信息（包括应用名等相关配置） 业务运行时使用 alarmEnable ： 是否开启报警 （当大量报警时，可以先关闭报警，然后再查问题） getAlarmConfig：核心方法，根据报警类型，返回对应的报警规则 系统默认提供一个从配置文件中加载报警规则的方案，主要会依赖两个配置文件 alarm.properties : 初始化注册信息，内部保存 RegisterInfo 所需要的属性 alarmConfig : 保存具体的报警规则，json格式 1. 配置加载配置加载的实现逻辑，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class PropertiesConfLoader implements IConfLoader &#123; private RegisterInfo registerInfo; private Map&lt;String, AlarmConfig&gt; cacheMap; public boolean load() &#123; // 获取注册信息 registerInfo = RegisterInfoLoaderHelper.load(); if (registerInfo == null) &#123; return false; &#125; // 获取报警的配置类 File file; String path = registerInfo.getAlarmConfPath(); if (path.startsWith(\"/\")) &#123; file = new File(path); &#125; else &#123; URL url = this.getClass().getClassLoader().getResource(path); file = new File(url.getFile()); &#125; // 加载成功，才替换 cacheMap的内容； 主要是为了防止修改配置出现问题 Map&lt;String, AlarmConfig&gt; tmp = init(file); boolean ans = tmp != null; // 注册配置文件的变动 ans = ans &amp;&amp; PropertiesConfListenerHelper.registerConfChangeListener(file, this::init); if (ans) &#123; cacheMap = tmp; &#125; return ans; &#125; private Map&lt;String, AlarmConfig&gt; init(File file) &#123; try &#123; // 正常来讲，是一个完整的json串 List&lt;String&gt; list = IOUtils.readLines(new FileInputStream(file), \"utf-8\"); String config = Joiner.on(\"\").join(list); return AlarmConfParse.parseConfig(config, Splitter.on(\",\").splitToList(registerInfo.getDefaultAlarmUsers())); &#125; catch (IOException e) &#123; log.error(\"load config into cacheMap error! e: &#123;&#125;\", e); return null; &#125; &#125; @Override public RegisterInfo getRegisterInfo() &#123; return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; AlarmConfig config = cacheMap.get(alarmKey); if (config == null) &#123; return cacheMap.get(AlarmConfParse.DEFAULT_ALARM_KEY); &#125; else &#123; return config; &#125; &#125;&#125; 主要查看默认的load方法即可, alarmEnable 和 getAlarmConfig还是比较简单的，看一下就知道怎么玩的 2. RegisterInfo 加载上面的实现中，第一步就是从 alarm.properteis 文件中读取对应的配置，然后初始化 RegisterInfo对象 1234567891011@Datapublic class RegisterInfo implements Serializable &#123; // 报警规则文件的路径，系统默认加载时，必填；否则选填 private String alarmConfPath; // 最大报警类型数，非必填，默认1000 private Integer maxAlarmType; // 默认报警用户， 必须 private String defaultAlarmUsers; // 应用名， 必须 private String appName;&#125; 一个配置文件实例 1234appName=testalarmConfPath=/tmp/alarmConfigmaxAlarmType=1000defaultAlarmUsers=yihui 从配置文件中读取信息，然后初始化对象的过程就比较简单了，我这里做了一个小简化，使用反射的方式实现对象拷贝 123456789101112131415161718public static void copy(Properties source, Object dest) throws IllegalAccessException &#123; Field[] fields = dest.getClass().getDeclaredFields(); for (Field f : fields) &#123; // 不修改静态变量 if (Modifier.isStatic(f.getModifiers())) &#123; continue; &#125; f.setAccessible(true); // 值拷贝，因为不同数据类型的问题，所以需要对properties中获取的String类型转换一把 f.set(dest, parseObj(source.getProperty(f.getName()), f.getType())); &#125;&#125;// 强制类型转换private static &lt;T&gt; T parseObj(String obj, Class&lt;T&gt; clz) &#123; return ParseFuncEnum.getFunc(clz).apply(obj);&#125; 上面的实现目前比较简单，没有考虑父类的情况，没有考虑复杂的数据类型转换，目前只支持了基本类型的转换，后续可考虑抽象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public enum ParseFuncEnum &#123; INT_PARSE(Arrays.asList(int.class, Integer.class)) &#123; @Override public Function&lt;String, Integer&gt; getFunc() &#123; return Integer::valueOf; &#125; &#125;, LONG_PARSE(Arrays.asList(long.class, Long.class)) &#123; @Override public Function&lt;String, Long&gt; getFunc() &#123; return Long::valueOf; &#125; &#125;, BOOLEAN_PARSE(Arrays.asList(boolean.class, Boolean.class)) &#123; @Override public Function&lt;String, Boolean&gt; getFunc() &#123; return Boolean::valueOf; &#125; &#125;, FLOAT_PARSE(Arrays.asList(float.class, Float.class)) &#123; @Override public Function&lt;String, Float&gt; getFunc() &#123; return Float::valueOf; &#125; &#125;, DOUBLE_PARSSE(Arrays.asList(double.class, Double.class)) &#123; @Override public Function&lt;String, Double&gt; getFunc() &#123; return Double::valueOf; &#125; &#125;, SHORT_PARSE(Arrays.asList(short.class, Short.class)) &#123; @Override public Function&lt;String, Short&gt; getFunc() &#123; return Short::valueOf; &#125; &#125;, BYTE_PARSE(Arrays.asList(byte.class, Byte.class)) &#123; @Override public Function&lt;String, Byte&gt; getFunc() &#123; return Byte::valueOf; &#125; &#125;, CHAR_PARSE(Arrays.asList(char.class, Character.class)) &#123; @Override public Function&lt;String, Character&gt; getFunc() &#123; return s -&gt; s.charAt(0); &#125; &#125;, STRING_PARSE(Arrays.asList(String.class)) &#123; @Override public Function&lt;String, String&gt; getFunc() &#123; return s -&gt; s; &#125; &#125;,; private List&lt;Class&gt; clzList; public abstract &lt;T&gt; Function&lt;String, T&gt; getFunc(); private static Map&lt;Class, ParseFuncEnum&gt; map = new ConcurrentHashMap&lt;&gt;(20); static &#123; for (ParseFuncEnum enu : ParseFuncEnum.values()) &#123; for (Class clz : enu.clzList) &#123; map.put(clz, enu); &#125; &#125; &#125; ParseFuncEnum(List&lt;Class&gt; clz) &#123; this.clzList = clz; &#125; public static &lt;T&gt; Function&lt;String, T&gt; getFunc(Class&lt;T&gt; clz) &#123; return map.get(clz).getFunc(); &#125;&#125; 3. 报警规则加载注册信息加载完毕之后，就可以获取报警规则的文件地址了，因此首先是读取配置规则的内容（我们要求是JSON格式），然后反序列化即可 将json串格式配置，反序列化为 BaseAlarmConf 对象 12345678910111213141516171819202122232425262728293031323334353637private static final TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt; typeReference = new TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt;() &#123;&#125;;/** * 将json串格式的报警规则配置，映射为对应实体类 * &lt;p&gt; * 如果传如的是null, 则采用默认的兜底配置 * 如果传入的是非法的配置，直接返回null， 这样做的目的如下 * &lt;p&gt; * - 启动时，直接获知配置有问题，需要修改 * - 启动中，修改配置，此时新配置有问题，依然使用旧的配置 * * @param configs * @return */private static Map&lt;String, BasicAlarmConfig&gt; parseStrConfig2Map(String configs) &#123; Map&lt;String, BasicAlarmConfig&gt; map = null; if (configs != null) &#123; try &#123; map = JSON.parseObject(configs, typeReference); &#125; catch (Exception e) &#123; logger.error(\"ConfigWrapper.parseStrConfig2Map() init config error! configs: &#123;&#125;, e:&#123;&#125;\", configs, e); return null; &#125; &#125; if (map == null) &#123; map = new HashMap&lt;&gt;(1); &#125; if (!map.containsKey(DEFAULT_ALARM_KEY)) &#123; map.put(DEFAULT_ALARM_KEY, DEFAULT_ALARM_CONFIG); &#125; return map;&#125; 需要额外说明一下，json串并没有直接的映射我们前面定义的 AlarmConfig 对象，因为在原型版本的设计的过程中，考虑到配置与内部的使用对象，可能不是特别匹配，最初的设计中，是希望直接将AlarmConfig中的alarmLevel直接替换成 AlarmExecute 实例对象的，然而在实际实现中没有这么干…，所以看源码时，这里就有点奇怪，后面完全可以干掉这个无用的逻辑 此外，就是需要给一个默认的配置项，当报警类型匹配不到对应的报警规则时，就选择默认的了 下面是一个报警配置的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; \"default\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE\": &#123; \"level\": \"WEIXIN\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"3h ui\", \"4hui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"XXX,YYY\": &#123; \"level\": \"EMAIL\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 5, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; III. ConfLoader选择并初始化前面说明，为了确保报警规则的多样性存储与加载，我们支持用户自定义加载类，所以就会有这么个ConfLoaderFactory, 来创建系统中使用的ConfLoader 12345678910111213141516171819202122232425262728293031323334353637383940public class ConfLoaderFactory &#123; private static IConfLoader currentAlarmConfLoader; public static IConfLoader loader() &#123; if (currentAlarmConfLoader == null) &#123; synchronized (ConfLoaderFactory.class) &#123; if (currentAlarmConfLoader == null) &#123; initConfLoader(); &#125; &#125; &#125; return currentAlarmConfLoader; &#125; private static void initConfLoader() &#123; Iterator&lt;IConfLoader&gt; iterator = ServiceLoader.load(IConfLoader.class).iterator(); List&lt;IConfLoader&gt; list = new ArrayList&lt;&gt;(); // 根据优先级进行排序，选择第一个加载成功的Loader while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; list.sort(Comparator.comparingInt(IConfLoader::order)); for (IConfLoader iConfLoader : list) &#123; if (iConfLoader.load()) &#123; currentAlarmConfLoader = iConfLoader; break; &#125; &#125; if (currentAlarmConfLoader == null) &#123; throw new NoAlarmLoaderSpecifyException(\"no special alarmConfLoader selected!\"); &#125; &#125;&#125; 实现逻辑依旧采取了SPI机制，不够我们定义了一个优先级，默认从最高优先级的开始加载，加载成功之后，就选择这个东西了；否则继续加载下一个，当所有的ConfLoader加载完毕，都没有一个成功的，就抛出一个异常 IV. 小结鉴于篇幅问题，关于报警规则与报警执行器之间的关系，对应的解释器放在下一篇进行说明，简要小结一下本文内容 报警规则： 采用阀值区间方式，将报警频率与报警执行器关联起来 规则加载： 支持SPI方式注入用户加载器，默认提供基于配置文件的加载器，且优先级最低 基本上本文说的就是下面这张图的内容了 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"2. 报警系统QuickAlarm之报警执行器的设计与实现","slug":"报警系统QuickAlarm之报警执行器的设计与实现","date":"2018-02-09T11:38:59.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","excerpt":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现","text":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现 I. AlarmExecute接口定义在定义接口之前，先来根据几个问题来加深下这个概念的理解： 1. 基础知识 说一下这个报警执行器到底是干嘛的？ 执行具体的报警逻辑（感觉说了依据废话） 因此不同的报警方式，可以选择不同的实现，这个强业务关联的逻辑可以交由适用方自己来把控 多个alarmExecute之间如何区分？ 给一个类似身份证的标识，将标识与alarmExecute绑定，则可以报警规则中，用这个标识来表示对应的报警执行器 标识要求全局唯一，否则就没法找到对应的执行器 2. 接口定义根据上面的基础知识，那么很容易给出接口的定义了 123456789101112131415161718192021public interface IExecute &#123; /** * 报警的具体实现 * * @param users 报警用户，支持批量 * @param title 报警信息的title * @param msg 报警的主题信息 */ void sendMsg(List&lt;String&gt; users, String title, String msg); /** * 获取报警单元唯一标识 * * @return name 要求全局唯一 */ default String getName() &#123; return ExecuteNameGenerator.genExecuteName(this.getClass()); &#125;&#125; 第一个方法sendMsg也就是需要使用者来实现的具体执行报警代码的核心模块了，比较清晰，其中用户是列表，因此，支持同时报警给多个用户（但是报警内容都是相同的） 第二个方法getName表示获取标识，默认给了一个实现，规则如下 获取类的 SimpleName 干掉类名后面的 Execute （如果不是以这个结尾的就不需要了） 剩下的全部转大写 实例： SmsExecute -&gt; SMS; LogExecute -&gt; LOG; 3. 额外说明上面接口定义中的sendMsg中，支持给多个用户发送报警信息，如果要求每个报警信息都不同，比如最常见的是: 发送一段文本，其中通知人地方根据报警人来替换，其他的不变 当然这样的场景完全可以自己在实现中来做 传入的content作为一个话术模板 然后利用 String#format() 来实现参数代替 当然更激进一点就是，穿进来的title或者content作为一个key，然后我可以通过这个key，到其他的地方（如db，缓存等）获取报警内容，甚至我连传进来的报警人都不care，直接从其他地方来获取 简单来说，这个实现委托给用户自己实现，你完全可以随意的控制，做任何你想做的事情 II. AlarmExecute的加载1. 问题分析加载AlarmExecut，貌似没有什么特别复杂的东西，一般的思路是创建一个简单工厂类，然后实例化对应的Executor返回，（再多一点确保只有一个实例对象，加以缓存） 这样有什么问题？ 很简单的实现，但是我们需要加载用户自定义的执行器，要怎么支持呢？ 几种可行的解决手段 1. 开放一个注册接口这个可算是最容易想到的了，直接让用户把自己的Executor实例，主动的扔进来 2. 抽象工厂将前面说的简单工厂，改成抽象工厂类，让后具体的加载委托给用户自己来做 3. 借助Spring容器来加载如果所有的AlarmExecute都委托给Spring容器来管理，那么就很简单了，直接通过ApplicationContext#getBean来获取所有的执行器即可 4. SPI加载方式通过JDK的spi机制来实现（详细后面来说） 针对上面的几个手段，首先排除掉前面两个，因为不满足我们的设计目标一： 简单 （只有报警这个接口进行交互，不需要额外的接口调用） 然后也排除掉spring容器，因为我们希望这个东西，可以较独立的被引用到java工程中，后面可以看情况实现一个spring版 从使用来讲，由spring容器来托管的方式，对使用者而言，是最简单，成本最低的，因为不需要额外添加SPI配置 2. 实现我们采用SPI方式来实现加载，对于SPI是什么东西，这里不详细展看，有兴趣的童鞋可以看我之前的一个系类博文：自定义SPI框架设计 实现方式，可说是非常简单了 1234567891011121314151617181920212223242526272829303132333435363738394041public class SimpleExecuteFactory &#123; private static Map&lt;String, IExecute&gt; cacheMap; private static void loadAlarmExecute() &#123; Map&lt;String, IExecute&gt; map = new HashMap&lt;&gt;(); Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); IExecute tmp; while (iExecutes.hasNext()) &#123; tmp = iExecutes.next(); if (!map.containsKey(tmp.getName())) &#123; map.put(tmp.getName(), tmp); &#125; else &#123; throw new DuplicatedAlarmExecuteDefinedException( \"duplicated alarm execute defined!\" + \"\\n\" + \"&gt;&gt;name:\" + tmp.getName() + \"&gt;&gt;&gt;clz:\" + tmp.getClass() + \"&gt;&gt;&gt;clz:\" + map.get(tmp.getName()) ); &#125; &#125; cacheMap = map; &#125; public static IExecute getExecute(String execute) &#123; if (cacheMap == null) &#123; synchronized (SimpleExecuteFactory.class) &#123; if (cacheMap == null) &#123; loadAlarmExecute(); &#125; &#125; &#125; // 如果不存在，则降级为 LogExecute IExecute e = cacheMap.get(execute); return e == null ? cacheMap.get(LogExecute.NAME) : e; &#125;&#125; 上面对外就暴露一个方法，内部比较简单，如果传入标识对应的报警器没有，则返回一个默认的，确保不会因此挂掉 通过SPI加载所有的执行器的逻辑就一行 1Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); 然后需要关注的是循环内部，做了name的唯一性判断，不满足就直接抛出异常了 III. AlarmExecute内部实现内部提供了两个基本的报警实现，比较简单 日志报警执行器 123456789101112131415/** * 有些报警,不需要立即上报,但是希望计数, 当大量出现时, 用于升级 * &lt;p/&gt; * Created by yihui on 2017/4/28. */public class LogExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(LogExecute.class); private static final Logger logger = LoggerFactory.getLogger(\"alarm\"); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; logger.info(\"Do send msg by &#123;&#125; to user:&#123;&#125;, title: &#123;&#125;, msg: &#123;&#125;\", getName(), users, title, msg); &#125;&#125; 空报警执行器 12345678910111213/** * 空报警执行器, 什么都不干 * &lt;p&gt; * Created by yihui on 2017/5/12. */public class NoneExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(NoneExecute.class); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; &#125;&#125; IV. 小结AlarmExecute 的定义，加载以及实现规则目前都已经完成 定义：两个方法，一个执行报警方法，一个返回唯一标识方法 加载：通过SPI方式加载所有定义的alarmExecute 实现：由用户自定义实现IExecute接口，内部逻辑无任务特殊要求，只是需要确保每个executor的name唯一 整个系统的第一步已经迈出，但是有个问题就是什么时候，才会来调用 com.hust.hui.alarm.core.execut.SimpleExecuteFactory#getExecute 从而触发执行器的加载呢？ V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"1. 报警系统QuickAlarm设计总纲","slug":"报警系统QuickAlarm总纲","date":"2018-02-09T11:37:29.000Z","updated":"2018-03-15T12:31:04.957Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm总纲/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm总纲/","excerpt":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了","text":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了 目标因此我们准备设计一个通用的报警框架 可以自由选择报警方式， 支持用户自定义报警方式拓展 支持动态的报警配置， 支持用户自定义报警规则拓展 支持报警方式自动切换规则设定 支持报警方式自定义自动切换规则拓展 设计整体来说，报警主要可以划分为三个步骤，如下： 提交报警：对外部使用者提供的接口 选择报警：根据报警相关信息，选择具体的报警执行单元 执行报警：实现具体的报警逻辑 从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展， 选择报警： 报警规则的制定 报警规则加载器 ConfLoader 报警规则变更的触发器 ConfChangeTrigger 报警规则解析器 ConfParse ： 解析文本格式报警规则为业务对象 AlarmSelector ：根据报警规则和报警类型，选择具体报警执行器 AlarmExecute 执行报警： 线程池执行（以防止影响主业务流程） AlarmExecute的动态拓展（支持用户自定义的报警器实现） 实际的报警逻辑 根据上面的拆解，在应用启动的时候，就有一些事情必须去做了 ConfLoader的选择 报警规则加载 AlarmExecute的加载（包括默认的+自定义实现的） 下图显示在应用启动时，报警规则解析的相关步骤 至于报警执行器的加载就比较简单了，如下图 因此，整个的工作流程如下图 任务拆解通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来 最直接的就是设计报警执行器AlarmExecute 定义基本接口 制定自定义扩展规则 接下来就是设计报警规则 如何加载报警规则？ 报警规则具体的定义细则 报警规则的解析：即根据报警类型来获取报警执行器 报警规则动态更新支持 报警线程池 维护报警队列 报警的计数与频率控制 封装对外使用接口 所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明 小结做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？ 用途： 支持灵活可配的报警规则，以及具体报警业务的自定义拓展 目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了 学习： 抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了 我们可以如何支持功能的动态可拓展 线程池的使用 IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"Java可以如何实现文件变动的监听","slug":"Java可以如何实现文件变动的监听","date":"2018-02-08T04:01:58.000Z","updated":"2018-03-15T12:31:04.954Z","comments":true,"path":"2018/02/08/Java可以如何实现文件变动的监听/","link":"","permalink":"https://zbang.online/hexblog/2018/02/08/Java可以如何实现文件变动的监听/","excerpt":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？","text":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？ I. 问题描述及分析针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 Z+中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下 现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存 一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下： 如何轮询？ 如何判断文件是否修改？ 配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要…） II. 设计与实现问题抽象出来之后，对应的解决方案就比较清晰了 如何轮询 ？ –》 定时器 Timer, ScheduledExecutorService 都可以实现 如何判断文件修改？ –》根据 java.io.File#lastModified 获取文件的上次修改时间，比对即可 那么一个很简单的实现就比较容易了: 12345678910111213141516171819202122232425262728293031public class FileUpTest &#123; private long lastTime; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); // 首先文件的最近一次修改时间戳 lastTime = file.lastModified(); // 定时任务，每秒来判断一下文件是否发生变动，即判断lastModified是否改变 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); &#125; &#125; &#125;,0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？ 定时任务的执行中，如果出现了异常会怎样？ 对上面的代码稍作修改 12345678910111213141516171819202122232425262728293031323334public class FileUpTest &#123; private long lastTime; private void ttt() &#123; throw new NullPointerException(); &#125; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); lastTime = file.lastModified(); ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); ttt(); &#125; &#125; &#125;, 0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 ScheduledExecutorService 的原因了 直接查看ScheduledExecutorService的源码注释说明 If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。 所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了 对应的解决方法也比较简单，整个catch一下就好 III. 进阶版前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列 首先maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 主要是借助这个工具中的 FileAlterationObserver, FileAlterationListener, FileAlterationMonitor 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PropertiesConfListenerHelper &#123; public static boolean registerConfChangeListener(File file, Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; try &#123; // 轮询间隔 5 秒 long interval = TimeUnit.SECONDS.toMillis(5); // 因为监听是以目录为单位进行的，所以这里直接获取文件的根目录 File dir = file.getParentFile(); // 创建一个文件观察器用于过滤 FileAlterationObserver observer = new FileAlterationObserver(dir, FileFilterUtils.and(FileFilterUtils.fileFileFilter(), FileFilterUtils.nameFileFilter(file.getName()))); //设置文件变化监听器 observer.addListener(new MyFileListener(func)); FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer); monitor.start(); return true; &#125; catch (Exception e) &#123; log.error(\"register properties change listener error! e:&#123;&#125;\", e); return false; &#125; &#125; static final class MyFileListener extends FileAlterationListenerAdaptor &#123; private Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func; public MyFileListener(Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; this.func = func; &#125; @Override public void onFileChange(File file) &#123; Map&lt;String, AlarmConfig&gt; ans = func.apply(file); // 如果加载失败，打印一条日志 log.warn(\"PropertiesConfig changed! reload ans: &#123;&#125;\", ans); &#125; &#125;&#125; 针对上面的实现，简单说明几点： 这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听 如上面registerConfChangeListener方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤 第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象 一个问题，如果 func方法执行时，也抛出了异常，会怎样？ 实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常 那么简单来看一下上面的实现逻辑，直接扣出核心模块 1234567891011121314151617181920212223public void run() &#123; while(true) &#123; if(this.running) &#123; Iterator var1 = this.observers.iterator(); while(var1.hasNext()) &#123; FileAlterationObserver observer = (FileAlterationObserver)var1.next(); observer.checkAndNotify(); &#125; if(this.running) &#123; try &#123; Thread.sleep(this.interval); &#125; catch (InterruptedException var3) &#123; ; &#125; continue; &#125; &#125; return; &#125;&#125; 从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了 JDK版本jdk1.7，提供了一个WatchService，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testFileUpWather() throws IOException &#123; // 说明，这里的监听也必须是目录 Path path = Paths.get(\"/tmp\"); WatchService watcher = FileSystems.getDefault().newWatchService(); path.register(watcher, ENTRY_MODIFY); new Thread(() -&gt; &#123; try &#123; while (true) &#123; WatchKey key = watcher.take(); for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; if (event.kind() == OVERFLOW) &#123; //事件可能lost or discarded continue; &#125; Path fileName = (Path) event.context(); System.out.println(\"文件更新: \" + fileName); &#125; if (!key.reset()) &#123; // 重设WatchKey break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; IV. 小结使用Java来实现配置文件变动的监听，主要涉及到的就是两个点 如何轮询： 定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep 文件修改： File#lastModified 整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是： 千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！ 为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 @Subscribe注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明） V. 其他参考项目 项目： quick-alarm 测试类： FileUpTest.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"File","slug":"File","permalink":"https://zbang.online/hexblog/tags/File/"},{"name":"ScheduledExecutorService","slug":"ScheduledExecutorService","permalink":"https://zbang.online/hexblog/tags/ScheduledExecutorService/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Java中变量的初始化顺序","slug":"Java中变量的初始化顺序","date":"2018-02-07T04:28:12.000Z","updated":"2018-03-15T12:31:04.954Z","comments":true,"path":"2018/02/07/Java中变量的初始化顺序/","link":"","permalink":"https://zbang.online/hexblog/2018/02/07/Java中变量的初始化顺序/","excerpt":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因","text":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因 I. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） II. 静态变量初始化顺序类初始化时，会优先初始化静态成员，那么一个类中有多个静态成员时，如何处理的？ 下面是一个使用静态成员，静态代码块，静态方法的测试类，那么下面的输出应该是怎样的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 输出如下 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 从实际的输出结果来看： 初始化的顺序比较清晰了，压根就是根据初始化代码的先后顺序来的， 且在调用静态方法时，静态方法内部的静态成员已经被初始化 那么问题来了，如果在某个静态成员初始化的时候抛出了异常，会怎样？ 那么稍稍改一下上面的代码，加一个主动抛异常的case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; private static A aError = genError(); private static A genError() &#123; System.out.println(\"gen error!\"); throw new RuntimeException();// return new A(10); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 此时输出： 12345678a init! 1b init! 2gen A: 2a init! 2b init! 1gen error!Exception in thread \"main\" java.lang.ExceptionInInitializerErrorCaused by: java.lang.RuntimeException 也就是说，初始化异常之后的代码将不会在继续执行 那么第二个问题来了，前面说到哪个问题是什么情况 最开始说到，在调用类的静态方法时，发现本该被初始化的静态成员，依然是null，从上面的分析来说，唯一的可能就是在成员变量初始化的过程中，出现了异常 那么，就有另一个问题了，初始化就报错了，这个类的静态方法还能被调用执行么（加入这个静态方法不依赖内部的静态成员）？ 将前面的 genA()方法的private去掉，改成默认的访问范围，然后下面给出一个演示： 通过这个演示，也挺有意思的，第一次访问，会抛出一个初始化异常；但是再调用一次，结果发现居然正常执行了；但是调用public方法时，每次都是抛异常 导致这个问题的原因，还有待考究，但是前面这个问题的答案，估摸着和下面差不多了（但是不敢确定，有待大神指点） 理论上类初始化失败，应该就不允许被调用了 但是某些情况下，可以绕过这个限制 III. 成员变量的初始化测试case也比较简单，把前面的代码中的static去掉即可， 输出 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 依然是根据初始化代码的先后顺序进行的 当然如果出现异常的情况，和前面的结果类似，不再赘述 IV. 小结1. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） 相同等级的初始化的先后顺序，是直接依赖代码中初始化的先后顺序 2. 初始化异常时理论上，类初始化中抛出了异常，那么这个类将无法被classLoader正确的加载，因此也无法有效的使用这个类 但是不排除某些情况下，依然强行的使用了这个类（如上面gif图中的演示），这个原理还不太清晰，也有可能是idea的debug功能有什么黑科技？ 注意 因此，请格外注意，在初始化代码中，请确保不会有抛出异常，如果无法把控，不妨新建一个init()方法来实现初始化各种状态，然后在代码中主动调用好了 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://zbang.online/hexblog/tags/JDK/"},{"name":"Initialize","slug":"Initialize","permalink":"https://zbang.online/hexblog/tags/Initialize/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"SpringMVC统一异常处理","slug":"SpringMVC统一异常处理","date":"2018-02-04T11:21:15.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/02/04/SpringMVC统一异常处理/","link":"","permalink":"https://zbang.online/hexblog/2018/02/04/SpringMVC统一异常处理/","excerpt":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题","text":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题 I. 借助@ControllerAdvice拦截异常给一个简单的demo，便可以很容易的了解这种手段如何处理了 1234567891011121314151617181920@ControllerAdvice@Slf4j@ResponseBodypublic class ActionExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public String defaultHandler(HttpServletRequest request, Exception e) &#123; log.error(\"unexpected exception! request: &#123;&#125;, params: &#123;&#125; refer: &#123;&#125;, e: &#123;&#125;\", request.getRequestURI(), request.getParameterMap(), request.getHeader(\"referer\"), e); if (StringUtils.isBlank(e.getMessage())) &#123; return ResponseWrapper.errorReturn(new Status(500, \"内部异常\")); &#125; else &#123; return ResponseWrapper.errorReturn(new Status(500, e.getMessage())); &#125; &#125;&#125; 这里主要借助两个注解来实现，ControllerAdvice 和 ExceptionHandler II. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Exception","slug":"Exception","permalink":"https://zbang.online/hexblog/tags/Exception/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":" JavaWeb三大组件之Filter学习详解","slug":"JavaWeb三大组件之Filter学习详解","date":"2018-01-26T10:02:01.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/01/26/JavaWeb三大组件之Filter学习详解/","link":"","permalink":"https://zbang.online/hexblog/2018/01/26/JavaWeb三大组件之Filter学习详解/","excerpt":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项","text":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项 I. 基本知识Filter称之为过滤器，是用来做一些拦截的任务， 在Servlet接受请求之前，做一些事情，如果不满足限定，可以拒绝进入Servlet 从上面的图，可以看出一个Filter的工作流程: 一个http请求过来之后 首先进入filter，执行相关业务逻辑 若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方 判定失败，直接返回，不需要将请求发给Servlet 通过上面的流程，可以推算使用场景： 在filter层，来获取用户的身份 可以考虑在filter层做一些常规的校验（如参数校验，referer校验等） 可以在filter层做稳定性相关的工作（如全链路打点，可以在filter层分配一个traceId；也可以在这一层做限流等） 1. 基本使用姿势要使用一个Filter，一半需要两步，实现Filter接口的自定义类，web.xml中对filter的定义 1234567891011public interface Filter &#123; public void init(FilterConfig filterConfig) throws ServletException; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public void destroy();&#125; 主要就三个方法，从命名来看， 也比较清晰，在创建Filter对象的时候，调用 init 方法 销毁Filter对象的时候，调用 destroy 方法 当请求过来之后，调用 doFilter，也就是主要的业务逻辑所在了 详细case后面再说 接下来就是xml的配置了，和Servlet类似，每自定义一个，都需要在xml中加上一个配置（挺繁琐的操作的） 123456789101112131415161718&lt;!-- 解决乱码的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置也比较简单了，一个 一个 前者定义具体的Filter，后者表示这个Filter拦截的URL （看起来和Servlet的配置规则没什么两样） II. 实例我们的实例，就拿大名鼎鼎的CharacterEncodingFilter来说明，顺带膜拜下Spring的大神的优秀源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; public CharacterEncodingFilter() &#123; &#125; public CharacterEncodingFilter(String encoding) &#123; this(encoding, false); &#125; public CharacterEncodingFilter(String encoding, boolean forceEncoding) &#123; Assert.hasLength(encoding, \"Encoding must not be empty\"); this.encoding = encoding; this.forceEncoding = forceEncoding; &#125; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; public void setForceEncoding(boolean forceEncoding) &#123; this.forceEncoding = forceEncoding; &#125; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); System.out.printl(\"servelt 执行完成，又返回filter\"); &#125;&#125; 上面的实现比较简单，主要将视线集中在 doFilterInternal 方法内部，如果要设置编码参数，则直接修改 HttpServletRequest, HttpServletResponse 两个参数，操作完成之后，执行下面这一行 1filterChain.doFilter(request, response); 注意 上面这一行执行，表示Filter层已经通过了，请求可以转发给下一个Filter或者直接传给Servlet 而下一个Filter, Servlet执行完成之后，还会继续往下走，就是上面的那一行输出，也会被调用（那一行是我加的，源码中没有） 所以，如果你不希望继续往下走，那么就简单了，不执行上面的那一行即可 疑问问题一：看了上面的源码，一个很明显的问题就是，参数怎么设置的？ 仔细看上面的源码，发现自定义Filter是继承 org.springframework.web.filter.OncePerRequestFilter 而不是直接实现的 Filter 接口，而且方法内也没有显示的实现 init()方法，所有很容易猜到是父类中实现了参数的初始化过程 具体的实现逻辑是在 org.springframework.web.filter.GenericFilterBean#init 中，同样是Spring实现的，主要代码捞出来 12345678910111213141516171819202122232425262728293031public final void init(FilterConfig filterConfig) throws ServletException &#123; Assert.notNull(filterConfig, \"FilterConfig must not be null\"); if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing filter '\" + filterConfig.getFilterName() + \"'\"); &#125; this.filterConfig = filterConfig; // Set bean properties from init parameters. try &#123; PropertyValues pvs = new FilterConfigPropertyValues(filterConfig, this.requiredProperties); BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(filterConfig.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment)); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; String msg = \"Failed to set bean properties on filter '\" + filterConfig.getFilterName() + \"': \" + ex.getMessage(); logger.error(msg, ex); throw new NestedServletException(msg, ex); &#125; // Let subclasses do whatever initialization they like. initFilterBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Filter '\" + filterConfig.getFilterName() + \"' configured successfully\"); &#125;&#125; 看上面一大串的代码，到底干了嘛？ 简单来讲，就是获取xml中配置的参数，然后填充到Filter对象中（对Srping而言，CharacterEncodingFilter就是一个bean），这个具体的逻辑和本篇关系不大，就直接跳过了 问题二：在Filter层中可以获取参数么 从doFilter的方法签名中看，既然有Request参数，那么应该是可以获取到请求参数的，那么实际验证一下 先实现一个最最最简单的Filter 123456789101112131415161718public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in filter\"); System.out.println(\"args: \" + JSON.toJSONString(request.getParameterMap())); chain.doFilter(request, response); System.out.println(\"out filter\"); &#125; @Override public void destroy() &#123; &#125;&#125; 开始测试 1curl -d 'name=Hello&amp;password=world' http://127.0.0.1:8088/123 输出如下 123in filterargs: &#123;\"name\":[\"Hello\"],\"password\":[\"world\"]&#125;out filter 注意 在Filter中获取参数时，最好不要直接使用获取请求流的方式，如果获取请求流，那么Servlet就获取不到请求参数了 问题三：多个filter的顺序怎么定 前面学习Servlet的时候，也有这个问题，一个URL被多个Servlet命中了，那么先后顺序是怎样的呢？ 精确匹配 &gt; 最长匹配 &gt; 其他模糊匹配 &gt; 没有匹配的则是404 那么Filter呢，他们的区别还是比较明显的，很多Filter都是拦截所有的请求，即很多Filter的命中规则都是一样的，那么怎么办？ 先执行带有url-pattern标签的filter，再执行带有servlet-name标签的filter 如果同为url-pattern或servlet-name，则会按照在web.xml中的声明顺序执行 测试case如下，我们定义三个Filter： TestFilter: 匹配所有路径 ATestFilter: 匹配所有路径 ServletFilter: 匹配 mvc-servlet 123456789101112131415161718192021// ATestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ATestFilter\"); chain.doFilter(request, response);&#125;// TestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in TestFilter\"); chain.doFilter(request, response);&#125;// ServletFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ServletFilter\"); chain.doFilter(request, response);&#125; 对应的xml配置如下 123456789101112131415161718192021222324252627282930&lt;filter&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ServletFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.TestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ATestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 输出结果 123in TestFilterin ATestFilterin ServletFilter III. 小结Filter 通常用于JavaWeb的过滤使用，通过doFilter方法中执行 chain.doFilter(request, response);，进入下一个Filter或者Servlet执行逻辑，当执行完成之后，依然会回到Filter这一层，继续走下去 针对上面的逻辑，Filter的常见应用场景有： 用户信息获取，身份校验 安全校验（referer校验失败，直接拒绝） 稳定性相关（限流，监控埋点，全链路日志埋点） Filter的执行顺序： url-mapping 的优先执行，其次是 servlet-mapping 同一个匹配方式（如都是url-mapping）中，根据在xml中定义的先后顺序来确定 Filter的注意事项： 正常业务，请记得一定执行 chain.doFilter(request, response)， 最后把它放在finnal块中，防止你在Filter中的代码抛异常导致进入不到后续的逻辑 在Filter中不要直接获取请求数据流（请求流被读取完之后，Servlet就get不到了!） IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Filter","slug":"Filter","permalink":"https://zbang.online/hexblog/tags/Filter/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"JavaWeb三大组件之Servlet学习","slug":"JavaWeb三大组件之Servlet学习","date":"2018-01-24T01:55:49.000Z","updated":"2018-03-15T12:31:04.954Z","comments":true,"path":"2018/01/24/JavaWeb三大组件之Servlet学习/","link":"","permalink":"https://zbang.online/hexblog/2018/01/24/JavaWeb三大组件之Servlet学习/","excerpt":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置","text":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置 I. 基本知识点1. 什么是ServletServlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 接受请求 处理请求 完成响应 2. 怎么玩Servlet一般来讲，创建一个自定义的Servlet有两个步骤，在web.xml中配置serverlt的声明；实现Servlet接口，实现自定义的Servlet逻辑 一个简单的case如下 web.xml中，添加配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实现自定义Servlet 1234567891011public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125;&#125; 上面这个Servlet，实现了拦截 /study 下的所有请求， 然后返回一段文本，上面作为演示，具体的展开下面说明 3. Servlet接口说明上面是直接继承了HttpServlet，可能没法完全的暴露一个Servlet的具体接口有哪些，以及它的生命周期是怎样的，接下来则直接针对源头进行说明 1234567891011121314151617public interface Servlet &#123; // 初始化 public void init(ServletConfig config) throws ServletException; // 获取配置信息 public ServletConfig getServletConfig(); // 处理请求 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; // Returns information about the servlet, such as author, version, and copyright public String getServletInfo(); // 销毁 public void destroy();&#125; 五个方法，从命名也可以看出对应的生命周期 首先是创建： init() 方法被创建 创建完毕之后，请求来了，分给 service方法，执行对应的业务逻辑 最后不想玩了，就销毁掉，此时触发 destroy方法 说明 在Servlet被创建后，服务器会马上调用Servlet的void init(ServletConfig)方法。请记住， Servlet出生后马上就会调用init()方法，我们可以把一些对Servlet的初始化工作放到init方法中，今后所有分配到这个Servlet的请求，都是公用这个Servlet的 4. ServletConfig init()方法的参数 ServletConfig对象对应web.xml文件中的元素。例如你想获取当前Servlet在web.xml文件中的配置名，那么可以使用servletConfig.getServletName()方法获取 1234String getServletName()：获取Servlet在web.xml文件中的配置名称，即指定的名称； ServletContext getServletContext()：用来获取ServletContext对象，ServletContext会在后面讲解； String getInitParameter(String name)：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames()：用来获取在web.xml中配置的所有初始化参数名称； 5. ServletRequest 请求对象，可以从其中获取请求数据，请求头等 内部提供的方法挺多，通常我们最关心的有: 获取参数: javax.servlet.ServletRequest#getParameter 获取头 : javax.servlet.http.HttpServletRequest#getHeader 获取cookie: javax.servlet.http.HttpServletRequest#getCookies 获取请求 : javax.servlet.http.HttpServletRequest#getRequestURI … 还有一个比较重要的就是指定字符编码，如我们通常要求提交的参数满足utf8编码，这时就可以如下设置 12// javax.servlet.ServletRequest#setCharacterEncodingrequest.setCharacterEncoding(&quot;utf-8&quot;); 如我们最常用的一个spring的fitler，关键代码如下 123456789101112131415// org.springframework.web.filter.CharacterEncodingFilter#doFilterInternal// @Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response);&#125; 6. ServletResponse 返回对象，返回响应给调用方的结构，设置返回头 返回数据给调用方，主要就是利用这个东西了，内部提供的方法也不少，我们主要关心的其实也并不太多 设置返回头：javax.servlet.http.HttpServletResponse#setHeader 添加cookie: javax.servlet.http.HttpServletResponse#addCookie 重定向 : javax.servlet.http.HttpServletResponse#sendRedirect 异常 : javax.servlet.http.HttpServletResponse#sendError 设置ContentType: javax.servlet.ServletResponse#setContentType 设置返回流: javax.servlet.ServletResponse#getOutputStream, javax.servlet.ServletResponse#getWriter 设置编码: javax.servlet.ServletResponse#setCharacterEncoding II. 进阶1. web.xml中配置 这个配置，主要针对 Servlet 的顺序指定，URL匹配这两个问题，所以有必要研究下这个配置中的说明 通常web.xml的配置，下面两个是必须的 1234567891011121314&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.xxx.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中 servlet-mapping 指定映射的路径，满足条件的会匹配对应的Servlet，匹配规则有以下几个定义 必须 / 开头 /servlet 表示精确匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlets 不匹配 http://localhost:8088/servlet/123 不匹配 /servlet/* 表示目录匹配，所有servlet路径开头的都可以匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlet/123 匹配 http://localhost:8088/servlet/123/123 匹配 http://localhost:8088/servlets 不匹配 /*.do 表示扩展名匹配，所有以 .do 结尾的匹配 既然这个url匹配支持模糊匹配，那么问题来了，如果两个servlet都匹配了这个path路径，那么到底是哪个处理呢？ 注意到前面有个配置参数：load-on-startup 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet； 当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载 正数的值越小，启动该servlet的优先级越高 注意 这个参数是加载顺序，而不是最终的匹配顺序 那么匹配顺序的优先级是： 精确路径匹配 比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了 最长路径匹配 servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源，即匹配defaultServlet 2. 参数获取 参数获取，则主要区分get请求参数，post提交表单，上传的文件了 a. 通过 getQueryString这种获取参数的方式，只能获取url上面的参数，无法获取到post的表单内容 1String str = req.getQueryString(); b. 通过 getParameter12// 返回所有的请求参数javax.servlet.ServletRequest#getParameterMap 这种使用姿势，和我们在SpringMVC中常见的基本一致 c. 通过 getInputStream获取请求流，一般的使用姿势如下 1234InputStream stream = req.getInputStream();byte[] bytes = new byte[stream.available()];stream.read(bytes);String str = new String(bytes); 然后就需要自己对上面的请求参数进行处理了；两厢对比，常规的获取方法，直接使用 getParameter方式更加优雅 注意 通过getInputStream方式获取了请求数据之后，再通过 getParameter获取不到参数的，也好理解，请求的流，被你读取之后，其他的地方就无法获取流中的数据了 d. 获取上传的文件从请求参数中获取上传的文件，网上随意搜索了一下，发现大部分都使用apache的fileupload包， 其实处理的依然是inputstream这个请求流，只是逻辑比较复杂，粗略的翻看了一下源码，发现这一块还挺有意思的，准备单独的深入看一下 3. 数据返回返回数据，前面介绍HttpServletResponse的时候，就给出了两个方法 a. getWriter1public PrintWriter getWriter() throws IOException; b. getOutputStream1public ServletOutputStream getOutputStream() throws IOException; 下面简单说一下上面的区别 PrintWriter ServletOutputStream 字符流返回 字节流返回 需要字符编码 字节流直接返回（返回文件就很占优势了） 说明 上面两种方式互斥，只能使用其中一种case Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象 4. 返回头设置常见的请求头和返回头设置，对于servlet而言也是比较常见的，一般常见的几个设置 是否缓存，缓存时间 设置cookie 设置 corss-origin 相关，以支持跨域 设置 content-type… 而实际的使用也比较简单了，如下即可 12# javax.servlet.http.HttpServletResponse#addHeaderresponse.addHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); III. 实例测试创建一个自定义的嗯Servlet，然后拦截所有 /study 下面的请求 1234567891011121314151617public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; Map map = req.getParameterMap(); System.out.println(\"arg: \" + map); res.getWriter().append(\"success\").flush(); &#125;&#125; 对应的xml配置如下 123456789 &lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实测演示： IV. 其他参考 servlet详解(第一篇) 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zbang.online/hexblog/tags/Servlet/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"Android学习之旅1D:首屏页的开发","slug":"Android学习之旅1D-首屏页的开发","date":"2018-01-22T12:16:18.000Z","updated":"2018-03-15T12:31:04.952Z","comments":true,"path":"2018/01/22/Android学习之旅1D-首屏页的开发/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/Android学习之旅1D-首屏页的开发/","excerpt":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程","text":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程 I. 前置主要copy两个开源项目 JianshuApp SUESNews 上面两个工程，第二个用到的依赖比较少，实现的基本功能也都很ok，而第一个里面则用了很多有意思的第三方框架，但是目前我看不太懂，所以第一版以SUESNews作为主要的学习目标 所以，第一版的目标是： 实现基本功能 完成主体业务逻辑 II. Splash页面开发一般来将，进入app之前，会进入一个类似首屏页的页面（比如12306的显示广告啥的），那么第一件事情就是做这个了 1. 做什么这个页面，主要显示的东西比较简单了 上边是一个图片，右上角一个倒计时 下边显示的应用信息，版本等 业务逻辑： 显示广告（😄），点击进入相应的详情页 判断是否登录，若未登录，则进入登录页 若已经登录，则进入主APP 2. 开动a. 全屏进入的首页，所以状态栏，标题啥的都不要，主要的逻辑如下 styles.xml 文件中新增 1234&lt;style name=\"AppTheme.FullScreen\"&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 其次，就是在定义的Activity中，使用对应的style AndroidManifest.xml 1234567&lt;activity android:name=\".ui.SplashActivity\" android:theme=\"@style/AppTheme.FullScreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; b. xml实现activity_splash.xml 对应的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" tools:context=\"com.yihui.yifeng.ui.SplashActivity\"&gt; &lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignBottom=\"@+id/title_text\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt; &lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:textStyle=\"bold\" tools:text=\"Copyright @2017-2018 一封 | 小灰灰技术支持\" /&gt;&lt;/RelativeLayout&gt; 运行截图如下： 上面这个布局，是直接使用可视化的拖拽的，所以操作起来挺蛋疼的，而且最终的结果也不太好，下面单独的开一节来研究下这个布局的东西了 c. Activity的实现上面是xml的配置，当然还得有对应的实体类了，大部分逻辑是直接从参考的工程中copy过来的，所以相关的动画配置，图片也是直接扣过来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SplashActivity extends Activity &#123; private ImageView mBackgroundImage; private ImageView infoBgImg; private TextView mTitleText; private TextView mVersionText; private int[] ary = new int[] &#123;R.drawable.pic_background_1, R.drawable.pic_background_2, R.drawable.pic_background_3, R.drawable.pic_background_4&#125;; private int getBgDrawable() &#123; return ary[new Random().nextInt(ary.length)]; &#125; private void initInfoBg() &#123; infoBgImg = findViewById(R.id.image_info_bg); infoBgImg.setImageDrawable(getResources().getDrawable(ary[0])); &#125; private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome); mBackgroundImage.startAnimation(animImage); animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); // 下半的提示文案信息 initInfoBg(); // 上半的广告动画 initAdBg(); &#125;&#125; todo登录状态判断，如果未登录，则应该跳转到登录页面；否则才是跳转到主页 III. 知识点小结上面只是实现了一个简单的应用开启页面，但也涉及了几个有趣的知识点，下面来深入一下 1. RelativeLayout 布局控件的位置是按照相对位置来计算的，后一个控件在什么位置依赖于前一个控件的基本位置，是布局最常用，也是最灵活的一种布局 常见的属性值 123456789101112131415161718192021222324第一类:属性值为true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中android:layout_alignParentBottom 贴紧父元素的下边缘android:layout_alignParentLeft 贴紧父元素的左边缘android:layout_alignParentRight 贴紧父元素的右边缘android:layout_alignParentTop 贴紧父元素的上边缘 第二类：属性值必须为id的引用名“@id/id-name”android:layout_below 在某元素的下方android:layout_above 在某元素的的上方android:layout_toLeftOf 在某元素的左边android:layout_toRightOf 在某元素的右边android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐第三类：属性值为具体的像素值，如30dip，40pxandroid:layout_marginBottom 离某元素底边缘的距离android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离 所以可以简单的修改一下上面的布局，相对布局的样式就两个，上面一个图，下面一个图 1234567891011121314151617181920&lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行 --&gt; android:layout_alignBottom=\"@+id/image_info_bg\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt;&lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行，确保背景图可以包含文本信息 --&gt; android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; 那么剩下的两个文本显示就可以直接指定下边距来确定位置了 123456789101112131415161718192021222324&lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt;&lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:text=\"@string/splash_copyright\" /&gt; 2. 获取组件在Activity中，先要绑定视图，然后再获取view进行相关的操作（如修改值，绑定事件等） 12345678910// Activity 的 oncreate方法中，进行初始化// 绑定视图super.onCreate(savedInstanceState);setContentView(R.layout.activity_splash);// 获取组件findViewById(R.id.image_info_bg);// 获取资源，如图片Drawable drawable = getResources().getDrawable(R.drawable.pic_background_1) 有一个非常有名的工具叫做 butterknife, 可以通过注解的方式来解决 findViewById这种频繁的调用姿势，这个放在后续的进阶版中使用 3. 设置动画开屏使用了一个图片放大的动画，持续3s，动画播放完毕之后跳转主页；所以这里有个有趣的知识点就是如何使用xml来配置动画效果，从实现来看也挺简单的 123456789101112131415161718192021222324// 解析xml配置为 Animation 对象Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome);// 设置组件的动画属性mBackgroundImage.startAnimation(animImage);// 配置监听事件animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; // 动画结束后的回调 @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;); 对应的xml配置如下 image_welcome.xml 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:fromXScale=\"1.0\" android:toXScale=\"1.3\" android:fromYScale=\"1.0\" android:toYScale=\"1.3\" android:duration=\"3000\" android:pivotY=\"50%\" android:pivotX=\"50%\" /&gt;&lt;/set&gt; 那么，我们需要实现开头说的，这个图片如果是个广告，点击时展开详情页；右上角显示一个倒计时的小控件，可以怎么处理？（看最后） 4. 页面跳转从一个Activity跳转到另一个，常见的使用姿势如下 1startActivity(new Intent(SplashActivity.this, MainActivity.class)); IV. 倒计时改进如何使用倒计时来替换前面的动画呢？最容易想到的就是用Timer或者ScheduleService来实现一个计时器，当然这是一个后端java的想法，对于Android呢，特意查了一下，发现有个 CountDownTimer 的类，专门干这个的，所以简单的改造一下 12345678910111213141516171819202122232425262728private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); mBackgroundImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 点击 Toast.makeText(SplashActivity.this, \"点击了\", Toast.LENGTH_SHORT).show(); &#125; &#125;); final TextView countDown = findViewById(R.id.splash_timedown); CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long l) &#123; countDown.setText(\"倒计时:\" + (l / 1000) + \"s\"); &#125; @Override public void onFinish() &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; &#125;; timer.start();&#125; 改造后的输出图, 注意右上角的时间，已经下面分割处，不会有前面的空白了 V. 其他额外话感觉最近不太能专心下来学习一门技术，有点浮躁了，所以决定学习下andorid，锻炼下自己，初步规划，先入门，然后接收一些有趣的第三方框架，最后再试一下kotalin Android学习第一天，总感觉这将是个漫长的过程，也不晓得最终会完成得怎么样，努力坚持吧 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/tags/Android/"},{"name":"一封","slug":"一封","permalink":"https://zbang.online/hexblog/tags/一封/"},{"name":"RelativeLayout","slug":"RelativeLayout","permalink":"https://zbang.online/hexblog/tags/RelativeLayout/"},{"name":"CountDownTimer","slug":"CountDownTimer","permalink":"https://zbang.online/hexblog/tags/CountDownTimer/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}]},{"title":"兼容ImageIO读取jpeg图片变红","slug":"兼容ImageIO读取jpeg图片变红","date":"2018-01-22T06:38:39.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/22/兼容ImageIO读取jpeg图片变红/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/兼容ImageIO读取jpeg图片变红/","excerpt":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case","text":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case 问题重现有问题的图片： 测试验证代码 123456789101112/** * 图片读取之后，颜色变红的测试 */@Testpublic void testLoadRedImg() throws IOException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); BufferedImage bf = ImageIO.read(u); ImageIO.write System.out.println(\"--over--\");&#125; debug截图如下： 问题兼容不实用ImageIO来加载图片，改用Toolkit来实现图片读取，然后再将读取到的图片绘制到BufferedImage对象上 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void testLoadRedImg2() throws MalformedURLException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); Image img = Toolkit.getDefaultToolkit().getImage(u); BufferedImage bf = toBufferedImage(img); System.out.println(\"eeee\");&#125;static BufferedImage toBufferedImage(Image image) &#123; if (image instanceof BufferedImage) &#123; return (BufferedImage) image; &#125; // This code ensures that all the pixels in the image are loaded image = new ImageIcon(image).getImage(); BufferedImage bimage = null; GraphicsEnvironment ge = GraphicsEnvironment .getLocalGraphicsEnvironment(); try &#123; int transparency = Transparency.OPAQUE; GraphicsDevice gs = ge.getDefaultScreenDevice(); GraphicsConfiguration gc = gs.getDefaultConfiguration(); bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency); &#125; catch (HeadlessException e) &#123; // The system does not have a screen &#125; if (bimage == null) &#123; // Create a buffered image using the default color model int type = BufferedImage.TYPE_INT_RGB; bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); &#125; // Copy image to buffered image Graphics g = bimage.createGraphics(); // Paint the image onto the buffered image g.drawImage(image, 0, 0, null); g.dispose(); return bimage;&#125; 实测验证 为什么会出现这个问题： ImageIO.read()方法读取图片时可能存在不正确处理图片ICC信息的问题，ICC为JPEG图片格式中的一种头部信息，导致渲染图片前景色时蒙上一层红色。 其他参考 Java处理某些图片红色问题 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/tags/BugFix/"},{"name":"BufferedImage","slug":"BufferedImage","permalink":"https://zbang.online/hexblog/tags/BufferedImage/"},{"name":"Jpeg","slug":"Jpeg","permalink":"https://zbang.online/hexblog/tags/Jpeg/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"Batik渲染png图片异常的bug修复","slug":"Batik渲染png图片异常的bug修复","date":"2018-01-20T12:36:56.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2018/01/20/Batik渲染png图片异常的bug修复/","link":"","permalink":"https://zbang.online/hexblog/2018/01/20/Batik渲染png图片异常的bug修复/","excerpt":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程","text":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程 I. 问题重现svg文件: 123456&lt;svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;image y=\"0\" width=\"100%\" height=\"100%\" x=\"0\" xlink:href=\"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"/&gt; &lt;!--xlink:href=\"https://s17.mogucdn.com/mlcdn/c45406/180119_46ld8kkb54d3el06hela5d61e18f5_1024x966.png\"/&gt;--&gt; &lt;!--xlink:href=\"http://avatar.csdn.net/A/8/B/3_u010889145.jpg\"/&gt;--&gt;&lt;/svg&gt; 依次测试了三个图片，两个png，一个jpg，很不幸第一个png会抛异常 输出的堆栈信息如 12345678910111213141516The URI \"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"on element &lt;image&gt; can't be opened because:PNG URL is corrupt or unsupported variant at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) at org.apache.batik.bridge.SVGImageElementBridge.buildImageGraphicsNode(SVGImageElementBridge.java:180) at org.apache.batik.bridge.SVGImageElementBridge.createGraphicsNode(SVGImageElementBridge.java:122) at org.apache.batik.bridge.GVTBuilder.buildGraphicsNode(GVTBuilder.java:213) at org.apache.batik.bridge.GVTBuilder.buildComposite(GVTBuilder.java:171) at org.apache.batik.bridge.GVTBuilder.build(GVTBuilder.java:82) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:208) at org.apache.batik.transcoder.image.ImageTranscoder.transcode(ImageTranscoder.java:92) at org.apache.batik.transcoder.XMLAbstractTranscoder.transcode(XMLAbstractTranscoder.java:142) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:156) ... II. 问题定位及分析既然出现了这个问题，那么就要去修复解决了，当然遇到这么鬼畜的问题，最常见的几个步骤： 其他人遇到过么 （问百度） – 结果度娘没有给出任何有效的建议，也没有搜到任何有用的信息 然后问谷歌，靠谱了一点，至少有些相关的主题了，但建设性的意见也没收到 外援实在找不到，只能debug查问题了 1. DEBUG的一路通过上面的堆栈信息，可以想见，debug的几个地方也和明确了，首先定位到下面这一行 1at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) 为什么这么干？因为首先得确认下这个异常是怎么抛出来的，逆向推，直接看源码，发现直接抛出异常 再往上走 1at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) 所以说因为这个if条件判断成立，导致进入了这个异常逻辑，判断的逻辑也没啥好说的，现在的关键是这个参数对象img是怎么来的 1at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) 然后就稍微清晰一点了，直接将火力放在下面的方法中 12345org.apache.batik.ext.awt.image.spi.ImageTagRegistry#readURL(java.io.InputStream, org.apache.batik.util.ParsedURL, org.apache.xmlgraphics.java2d.color.ICCColorSpaceWithIntent, boolean, boolean) 在这个方法内部，也没什么好说的，单步多调几次，就能发现异常的case是怎么来的了，省略掉中间各种单步debug的过程，下面直接进入关键链路 2. 火力全开，问题定位1org.apache.batik.ext.awt.image.codec.imageio.AbstractImageIORegistryEntry 通过上面的一路之后，发现最终的关键就是上面这个抽象类，顺带也可以看下这个抽象类的几个子类，有JPEGxxx, PNGxxx, TIFFxxx，然后问题来了，都已经有相关实现了，所以png讲道理应该是会支持的才对吧，但和实际的表现太不一样了吧，所以有必要撸一把源码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Filter handleStream(InputStream inIS, ParsedURL origURL, boolean needRawData) &#123; final DeferRable dr = new DeferRable(); final InputStream is = inIS; final String errCode; final Object [] errParam; if (origURL != null) &#123; errCode = ERR_URL_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName(), origURL&#125;; &#125; else &#123; errCode = ERR_STREAM_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName()&#125;; &#125; Thread t = new Thread() &#123; @Override public void run() &#123; Filter filt; try&#123; Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReadersByMIMEType( getMimeTypes().get(0).toString()); if (!iter.hasNext()) &#123; throw new UnsupportedOperationException( \"No image reader for \" + getFormatName() + \" available!\"); &#125; ImageReader reader = iter.next(); ImageInputStream imageIn = ImageIO.createImageInputStream(is); reader.setInput(imageIn, true); int imageIndex = 0; dr.setBounds(new Rectangle2D.Double (0, 0, reader.getWidth(imageIndex), reader.getHeight(imageIndex))); CachableRed cr; //Naive approach possibly wasting lots of memory //and ignoring the gamma correction done by PNGRed :-( //Matches the code used by the former JPEGRegistryEntry, though. BufferedImage bi = reader.read(imageIndex); cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image); filt = new RedRable(cr); &#125; catch (IOException ioe) &#123; // Something bad happened here... filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; catch (ThreadDeath td) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); dr.setSource(filt); throw td; &#125; catch (Throwable t) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; dr.setSource(filt); &#125; &#125;; t.start(); return dr;&#125; 看上面的实现是一个非常有意思的事情， 开了一个线程做事情，而且直接就返回了，相当于给了别人一个储物箱的钥匙，虽然现在储物箱是空的，但是回头我会填满的 言归正传，主要的业务逻辑就在这个线程里了，核心的几行代码就是 123456789101112// 加载图片，转为BufferedImage对象BufferedImage bi = reader.read(imageIndex);cr = GraphicsUtil.wrap(bi);// 下面实现对图片的ARGB进行修改cr = new Any2sRGBRed(cr);cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre);WritableRaster wr = (WritableRaster)cr.getData();ColorModel cm = cr.getColorModel();BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null);cr = GraphicsUtil.wrap(image);filt = new RedRable(cr); debug上面的几行代码，发现问题比较明显了，就是这个图片的转换跪了，至于为啥？ java的图片各种蛋疼至极，这里面的逻辑，真心搞不进去，so深挖到此为止 III. 兼容逻辑问题定位到了，当然就是想办法来修复了，简单来说，需要兼容的就是图片的类型转换上了，直接用原来的可能会抛异常，所以做了一个简单的兼容逻辑 12345678910111213141516if(bi.getType() == BufferedImage.TYPE_BYTE_INDEXED) &#123; BufferedImage image = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = image.createGraphics(); g2d.drawImage(bi, 0, 0, null); g2d.dispose(); cr = GraphicsUtil.wrap(image);&#125; else &#123; cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image);&#125; 再次验证，ok 注意： 一个问题来了，上面的兼容是需要修改源码的，我们可以怎么办？有几种解决方法 猥琐方法一：down下源码，修改版本，然后传到自己的私服，使用自己的vip包 猥琐方法二：把 batik-codec 工程原样拷贝到自己的项目中，就可以随意的使用改了 猥琐方法三：写一个完全相同的类（包路径完全相同），然后构造一个自定义类加载器，加载这个自己的这个兼容版本的，替换原来的（未测试，不确定是否能行） 至于我的选择，就是使用了猥琐方法二 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"https://zbang.online/hexblog/tags/Bugfix/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"batik","slug":"batik","permalink":"https://zbang.online/hexblog/tags/batik/"},{"name":"Png","slug":"Png","permalink":"https://zbang.online/hexblog/tags/Png/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"SpringMVC支持跨域的几种姿势","slug":"SpringMVC支持跨域的几种姿势","date":"2018-01-19T07:43:38.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/19/SpringMVC支持跨域的几种姿势/","link":"","permalink":"https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/","excerpt":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数","text":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数 I. Jsonp的支持jsonp的请求表现方式就是url里面会多一个参数 callback，一般如下 1callback=jQuery21105810685605043302_1516257942328 jsonp的返回与一般调用方式的返回也会有点区别，会在外面包装一层，如 1jQuery21105810685605043302_1516257942328(...); springmvc中，jsonp的支持却是比较简单了，不需要对现有的接口进行任何处理，只需要像下面这么玩即可 123456@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super(\"callback\"); &#125;&#125; 分析说明首先是利用了注解 @ControllerAdvice ， 这个注解在后面说到的统一异常处理时，也会用到，从命名也可以看出，就是为Controller添加一个切面，简单来讲，就是在直接返回数据前，对返回的结果包装一把；从实现也可以看出，主要的逻辑就在 AbstractJsonpResponseBodyAdvice 里面，所以有必要看一下这个东西是怎么支持的了 核心的代码逻辑就是 123456789101112131415161718192021222324@Overrideprotected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) &#123; HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest(); for (String name : this.jsonpQueryParamNames) &#123; String value = servletRequest.getParameter(name); if (value != null) &#123; if (!isValidJsonpQueryParam(value)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Ignoring invalid jsonp parameter value: \" + value); &#125; continue; &#125; // 下面三行是主要的逻辑 MediaType contentTypeToUse = getContentType(contentType, request, response); response.getHeaders().setContentType(contentTypeToUse); bodyContainer.setJsonpFunction(value); break; &#125; &#125;&#125; 直接看可能看不太明白究竟做了什么，写了个测试，debug下相关的参数如下 即，修改返回的 content-type 为： application/javascript 返回的Container里面设置了jsonpFunction，为请求参数的value，至于是在什么时候封装的返回结果呢？这个有待后续补全 II. 支持cors跨域 Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求 1. 背景CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否 所以问题就来了，安全如何保证？ 一般而言，为了避免夸站点攻击(csrf)，常见的手段无非： 身份校验（比如要求用户登录） token验证 ip白名单 来源referer校验 频率限制 2. 实现方式要支持csrf，也比较简单了，无非就是设置下responseHeader了, 一般需要设置以下几项 Access-Control-Allow-Origin: *; // 允许的来源 Access-Control-Allow-Methods: GET, POST, PUT, DELETE Access-Control-Allow-Credentials: true Access-Control-Allow-Headers: Content-Type Access-Control-Max-Age: 1800 //30 min 所以实现起来的方式就比较多了，一个是新增一个filter，主动设置下返回头，当然spring mvc提供了更友好的方式了 常见的几种手段如下: a. xml配置方式12345&lt;mvc:cors&gt; &lt;mvc:mapping path=\"/ajax/*\" allowed-origins=\"*\" max-age=\"3600\" /&gt;&lt;/mvc:cors&gt; b. 注解方式在controller方法上，添加下面这个注解即可 12345@CrossOrigin(origins = \"*\")@RequestMapping(value = &#123;\"xx\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)public ResponseWrapper&lt;WxBaseResponse&gt; create(HttpServletRequest httpServletRequest) &#123;&#125; c. 直接修改返回的responseHeader123response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"origin\"));response.setHeader(\"Access-Control-Allow-Methods\", \"*\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); III. 小结上面介绍了两种方式，支持起来都比较简单 jsonp: 通过ControllerAdvice拦截Controller，然后继承AbstractJsonpResponseBodyAdvice即可 cors: 通过xml配置或者直接使用 @CrossOrigin注解 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Jsonp","slug":"Jsonp","permalink":"https://zbang.online/hexblog/tags/Jsonp/"},{"name":"CORS","slug":"CORS","permalink":"https://zbang.online/hexblog/tags/CORS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"SpringMVC返回图片的几种方式","slug":"SpringMVC返回图片的几种方式","date":"2018-01-18T03:13:22.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/18/SpringMVC返回图片的几种方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/18/SpringMVC返回图片的几种方式/","excerpt":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？","text":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？ I. 返回二进制图片主要借助的是 HttpServletResponse这个对象，实现case如下 1234567891011121314@RequestMapping(value = &#123;\"/img/render\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@CrossOrigin(origins = \"*\")@ResponseBodypublic String execute(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; // img为图片的二进制流 byte[] img = xxx; httpServletResponse.setContentType(\"image/png\"); OutputStream os = httpServletResponse.getOutputStream(); os.write(img); os.flush(); os.close(); return \"success\";&#125; 注意事项 注意ContentType定义了图片类型 将二进制写入 httpServletResponse#getOutputStream 写完之后，flush(), close()请务必执行一次 II. 返回图片的几种方式封装一般来说，一个后端提供的服务接口，往往是返回json数据的居多，前面提到了直接返回图片的场景，那么常见的返回图片有哪些方式呢？ 返回图片的http地址 返回base64格式的图片 直接返回二进制的图片 其他…（我就见过上面三种，别的还真不知道） 那么我们提供的一个Controller，应该如何同时支持上面这三种使用姿势呢？ 1. bean定义因为有几种不同的返回方式，至于该选择哪一个，当然是由前端来指定了，所以，可以定义一个请求参数的bean对象 123456789101112131415161718192021222324252627282930@Datapublic class BaseRequest &#123; private static final long serialVersionUID = 1146303518394712013L; /** * 输出图片方式: * * url : http地址 （默认方式） * base64 : base64编码 * stream : 直接返回图片 * */ private String outType; /** * 返回图片的类型 * jpg | png | webp | gif */ private String mediaType; public ReturnTypeEnum returnType() &#123; return ReturnTypeEnum.getEnum(outType); &#125; public MediaTypeEnum mediaType() &#123; return MediaTypeEnum.getEnum(mediaType); &#125;&#125; 为了简化判断，定义了两个注解，一个ReturnTypeEnum, 一个 MediaTypeEnum， 当然必要性不是特别大，下面是两者的定义 12345678910111213141516171819202122232425262728293031public enum ReturnTypeEnum &#123; URL(\"url\"), STREAM(\"stream\"), BASE64(\"base\"); private String type; ReturnTypeEnum(String type) &#123; this.type = type; &#125; private static Map&lt;String, ReturnTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(3); for(ReturnTypeEnum e: ReturnTypeEnum.values()) &#123; map.put(e.type, e); &#125; &#125; public static ReturnTypeEnum getEnum(String type) &#123; if (type == null) &#123; return URL; &#125; ReturnTypeEnum e = map.get(type.toLowerCase()); return e == null ? URL : e; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@Datapublic enum MediaTypeEnum &#123; ImageJpg(\"jpg\", \"image/jpeg\", \"FFD8FF\"), ImageGif(\"gif\", \"image/gif\", \"47494638\"), ImagePng(\"png\", \"image/png\", \"89504E47\"), ImageWebp(\"webp\", \"image/webp\", \"52494646\"), private final String ext; private final String mime; private final String magic; MediaTypeEnum(String ext, String mime, String magic) &#123; this.ext = ext; this.mime = mime; this.magic = magic; &#125; private static Map&lt;String, MediaTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(4); for (MediaTypeEnum e: values()) &#123; map.put(e.getExt(), e); &#125; &#125; public static MediaTypeEnum getEnum(String type) &#123; if (type == null) &#123; return ImageJpg; &#125; MediaTypeEnum e = map.get(type.toLowerCase()); return e == null ? ImageJpg : e; &#125;&#125; 上面是请求参数封装的bean，返回当然也有一个对应的bean 1234567891011121314151617181920@Datapublic class BaseResponse &#123; /** * 返回图片的相对路径 */ private String path; /** * 返回图片的https格式 */ private String url; /** * base64格式的图片 */ private String base;&#125; 说明： 实际的项目环境中，请求参数和返回肯定不会像上面这么简单，所以可以通过继承上面的bean或者自己定义对应的格式来实现 2. 返回的封装方式既然目标明确，封装可算是这个里面最清晰的一个步骤了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void buildResponse(BaseRequest request, BaseResponse response, byte[] bytes) throws SelfError &#123; switch (request.returnType()) &#123; case URL: upload(bytes, response); break; case BASE64: base64(bytes, response); break; case STREAM: stream(bytes, request); &#125;&#125;private void upload(byte[] bytes, BaseResponse response) throws SelfError &#123; try &#123; // 上传到图片服务器，根据各自的实际情况进行替换 String path = UploadUtil.upload(bytes); if (StringUtils.isBlank(path)) &#123; // 上传失败 throw new InternalError(null); &#125; response.setPath(path); response.setUrl(CdnUtil.img(path)); &#125; catch (IOException e) &#123; // cdn异常 log.error(\"upload to cdn error! e:&#123;&#125;\", e); throw new CDNUploadError(e.getMessage()); &#125;&#125;// 返回base64private void base64(byte[] bytes, BaseResponse response) &#123; String base = Base64.getEncoder().encodeToString(bytes); response.setBase(base);&#125;// 返回二进制图片private void stream(byte[] bytes, BaseRequest request) throws SelfError &#123; try &#123; MediaTypeEnum mediaType = request.mediaType(); HttpServletResponse servletResponse = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse(); servletResponse.setContentType(mediaType.getMime()); OutputStream os = servletResponse.getOutputStream(); os.write(bytes); os.flush(); os.close(); &#125; catch (Exception e) &#123; log.error(\"general return stream img error! req: &#123;&#125;, e:&#123;&#125;\", request, e); if (StringUtils.isNotBlank(e.getMessage())) &#123; throw new InternalError(e.getMessage()); &#125; else &#123; throw new InternalError(null); &#125; &#125;&#125; 说明： 请无视上面的几个自定义异常方式，需要使用时，完全可以干掉这些自定义异常即可；这里简单说一下，为什么会在实际项目中使用这种自定义异常的方式，主要是有以下几个优点 配合全局异常捕获(ControllerAdvie)，使用起来非常方便简单 所有的异常集中处理，方便信息统计和报警 1如，在统一的地方进行异常计数，然后超过某个阀值之后，报警给负责人，这样就不需要在每个出现异常case的地方来主动埋点了 避免错误状态码的层层传递 12- 这个主要针对web服务，一般是在返回的json串中，会包含对应的错误状态码，错误信息- 而异常case是可能出现在任何地方的，为了保持这个异常信息，要么将这些数据层层传递到controller；要么就是存在ThreadLocal中；显然这两种方式都没有抛异常的使用方便 有优点当然就有缺点了： 异常方式，额外的性能开销，所以在自定义异常中，我都覆盖了下面这个方法，不要完整的堆栈 1234@Overridepublic synchronized Throwable fillInStackTrace() &#123; return this;&#125; 编码习惯问题，有些人可能就非常不喜欢这种使用方式 III. 项目相关只说不练好像没什么意思，上面的这个设计，完全体现在了我一直维护的开源项目 Quick-Media中，当然实际和上面有一些不同，毕竟与业务相关较大，有兴趣的可以参考 QuickMedia: https://github.com/liuyueyi/quick-media : BaseAction: com.hust.hui.quickmedia.web.wxapi.WxBaseAction#buildReturn IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Response","slug":"Response","permalink":"https://zbang.online/hexblog/tags/Response/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"2017年全年回顾小结","slug":"2017年全年回顾小结","date":"2018-01-17T12:23:52.000Z","updated":"2018-03-15T12:31:04.952Z","comments":true,"path":"2018/01/17/2017年全年回顾小结/","link":"","permalink":"https://zbang.online/hexblog/2018/01/17/2017年全年回顾小结/","excerpt":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。","text":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。 15年开始工作，17年呢，不再是职场新人，但是说到老鸟，却也相差甚远，工作的第二个年度，总感觉有些不温不火的，仔细看看这一年，尝试了很多东西，也做了一些事情，但总的来说，依然是达不到预期。 一个比较好的坚持下去的习惯就是每周一次的锻炼，虽然是因为小团队内的要求，不达标就罚款的前提定在这，所以努力的坚持了下来，还是值得表扬的。唯一和预期不一致的就是锻炼的效果好像不太明显，比去去年，体重确实又增加了不少。从工作来，体重可算是算着工作时长线性增加，有点可怕，感觉再这么下去，就没法玩了。坚持锻炼，努力运动，健康生活，依然是18年需要去维持的事情；此外也有必要，增加下运动的类型，除了跑步、骑车，还有那么多可以去尝试的活动，有必要去探索一下。 17年，与之前那么多年，最不同的有两件事，一个是入了王者荣耀的坑、变成了一个手游爱好者；还有一个就是写博客，每周最少一篇博文。然后这一年的常态就变成了每天晚上抱着手机玩游戏，每个周末跑到公司吭哧吭哧的写博文（当然有不少时候是为了写而写，所以有些内容比较难入眼）。这两件事情，则有必要好好的谈一下了。 首先是玩游戏这个，之前不怎么玩，挺浪费时间的，而且也没有什么特别有意思的，不知道什么时候开始接触农药，期间卸载了又重装了n次，现在水平依然很烂，仔细想了想自己，对于玩游戏有个奇怪的地方，不愿意去研究，到现在玩耍了大半年，依然不知道装备怎么出，不知道铭文怎么组合，反正都是随意玩，不管什么场景，顺风逆风，都是那么一套玩法，玩来玩去也就是那一个英雄（芈月）；一起玩的小伙伴已经荣升星曜，而我依然在黄金白银徘徊，简直了。其实从这个玩游戏的状态中也可以看出，我属于那种一旦熟悉了某种事务之后，不太愿意去更改、去变动的性格（总是玩一个英雄），主动专研能力不够（不看教程，不看视频…），脾气还不错（被坑了也不骂人）,还有就是定力不足（多次卸载游戏又重装）; (再次不得不说一句，感谢温柔漂亮的美人姣，非常理性的对待我玩游戏这一点） 另一个就是写博文了，这一年的写作，感觉比我上大学之后写的东西都要多了，差不多有八九十篇的样子了，之前抽空整理了个gitbook，挂在了私人服务器上: 小灰灰博文Book。写博文的收获其实挺大的，很多时候对于一个知识点，如果不尝试着去像其他人分享，你都不知道你到底掌握到什么程度了。而且如何才能写出一个漂亮的博文，真的没那么简单，这一年看了不少，有见过写的特别漂亮的，也看过写的不知道什么鬼的东西，当然现在我自己水平也不怎么样，但对比下前后的质量，发现还是有长进的。很多东西写着写着，会忽然发现一些平时没有注意的点。在这一块，感觉最主要的就是勤于总结，善于思考了。18年，这个坚持还是得继续下去的。因为写博文，当然为了避免玩单机，开通了头条号和公众号, 下面是链接，欢迎关注 谈到公众号，就有必要说一下与之相关的小程序了，小程序大火的时候，也进来玩了一下，做了两个，一个是《古诗选》，每天会推送十条古诗，而且可以根据关键词搜索相关古诗的小程序，感觉还蛮有意思的，结果等做完之后，告诉类目不对个人开放，简直了…；然后开始做第二个了，这个纯粹是为了实例验证我之前推的一个开源项目Quick-Media，主要提供图片、二维码、音视频处理服务，目前处于非常简陋的状态，通过写着两个小程序，最大的一个感受是，对于布局和样式这一块，实在是太不敏感了。 既然说到了开源项目，那也有必要提一下了，17年的一个收获就是做了几个有意思的开源项目，虽然不怎么成功，没什么人关注，但对个人的学习和收获还是很不错的。比如 提供SPI服务的Quick-Spi:https://github.com/liuyueyi/quick-spi，通过这个项目的实现，算是理解了spi到底是个什么东西，又可以怎么去玩； Quick-Crawle爬虫框架:https://github.com/liuyueyi/quick-crawler，很久很久以前就对爬虫感兴趣了，然后就从0到1构建了一个非常简单的爬虫框架，前面说的《古诗选》的内容，就是通过这个爬虫框架从网上爬下来的，从玩票的性质来看，还不错； Quick-Media多媒体服务:https://github.com/liuyueyi/quick-media，目前算是个人最多star的项目了，里面深度的刨析了一下二维码的生成，完全可以替换二维码上各种元素，当然还有一些其他的东西，这个项目算是工作的附属品，因为实际的工作中，很多服务都是不需要的，但是偶尔我个人会对某一块比较感兴趣，所以干脆新搞了一个，把自己平时的各种想法都丢上去尝试一下； quick-doraemon，一个基于redis实现的配置中心框架:https://github.com/liuyueyi/quick-doraemon，了解阿里的Diaemond的同学大概可以猜到这个是干嘛的，做这个，纯粹是为了探究一下一个配置中心的实现，到底需要些什么东西，最关键的是，这个实现简不简单； 另外还有两个小工具包，一个是基于PopClip的 https://github.com/liuyueyi/PopClip， 一个基于Alfred的小工具集合（目前没有对外开放，主要扔在了公司内网，有较多的内部信息） 出去跑了个步，都接不下来上面写的东西了，干脆直接换个话题，谈谈生活。然而仔细想了想，好像没啥好说的，基本上就是上班，晚上加班，回家睡觉，第二天继续上班；这日子，过得有点单调啊。自勉，18年不能这么下去了，好歹也得有点业务生活，出去逛逛圈，到处走走也好过每天死宅 17年，家庭新增了两个成员，不到一岁的小朋友，老大已经会走路了，而老二则处于只晓得吃吃喝喝的状态；小外甥的成就已经远远超过他们老舅我的状态了，听我妈说两岁多我都还不会走路，也是尴尬; 多了小朋友之后，还挺不错的，最近没什么事情就喜欢在淘宝，京东上看一些小朋友的玩具，各种积木，玩具车之类的，发现还蛮有意思的，小时候没有玩过的东西，完全可以借着小朋友的名头买来自己耍，也是不错；一直都不太喜欢小孩子，总觉得难以沟通，还挺麻烦，但看着老爸老妈，每天教他们的大外甥一些东西的时候，还是蛮有趣的，陪伴与成长，如果可以的话，父母还是需要和小孩子一起 17年花了所有的积蓄，借了一些，方才勉强凑够首付，贷款了个小破房，生活艰辛，唉，啥时候房价才能平民，千年前的“安得广厦千万间，大庇天下寒士俱欢颜”放在现在，依然有效；脑子不够灵活，只能拿点死工资，得开拓下自己的思路了。 感谢@美人姣的这一路的相伴，虽然生活过得比较平淡，没有那么多的惊喜，没有那么多的浪漫，这些主要都是我的原因了，得改正，该有的小惊喜还是得有的，拓宽一下思路，改变一下习性，让生活变得有意思起来，这个需要在18年好好培养。 最后，再憧憬下18年，定个小目标，该结婚过小日子了!!! @美人姣","categories":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zbang.online/hexblog/tags/日记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}]},{"title":"胡思乱想123","slug":"胡思乱想123","date":"2018-01-15T06:10:27.000Z","updated":"2018-03-15T12:59:53.127Z","comments":true,"path":"2018/01/15/胡思乱想123/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/胡思乱想123/","excerpt":"一些异想天开的小想法","text":"一些异想天开的小想法 1. 俄罗斯方块俄罗斯方块堆积后，总会有空格留下，那么如何去填空就是个问题，从这里可以引入一个新的game思路 在一堆由方格拼成的墙面上，有很多的空个，现在需要你去填空，然后消去相同色，得分；或者拼成一排则得分或者是自由移动方块，来拼接最长的相连方块； 或者是移动，组成各种有趣的图案","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zbang.online/hexblog/tags/随笔/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}]},{"title":"基于OkHttp封装一个简单易用的http工具","slug":"基于OkHttp封装一个简单易用的http工具","date":"2018-01-15T05:15:03.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/15/基于OkHttp封装一个简单易用的http工具/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/基于OkHttp封装一个简单易用的http工具/","excerpt":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析","text":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析 I. 封装后测试效果一览基本上，最常见的http交互有两个，一个get请求，一个post请求，因此这里也就封装了这两种请求方式，并额外增加一个上传文件的功能，我们可以通过使用case，来看一下我们最终封装后的使用姿势 123456789101112131415161718192021222324252627282930313233343536// 简单的get请求@Testpublic void testGet() &#123; String url = \"https://zbang.online/wx/list\"; try &#123; okhttp3.Response res = HttpWrapper.of(url).get(); if (res.isSuccessful()) &#123; String ans = res.body().string(); System.out.println(\"ans : \" + ans); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @Testpublic void testUpload() &#123; String url = \"https://zbang.online/wx/qrcode/encode\"; String path = \"/Users/yihui/Desktop/img/test.jpg\"; File file = new File(path); try &#123; Response res = HttpWrapper.of(url) .file(\"image\", file.getName(), \"image/jpeg\", file) .addParam(\"content\", \"http://www.baidu.com\") .addParam(\"size\", \"400\") .upload(); if (res.isSuccessful()) &#123; String str = res.body().string(); System.out.println(\"ans: \" + str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面给出的是一个上传文件的case，实现主要是借助了builder模式，可以很简单的传递个中参数和配置，最后获取返回的结果，这样设计的好处很明显： 使用简单 阅读方便 II. 封装实现接下来进入正题，如何封装这个工具类呢，一般而言，发起http请求，需要设置请求参数，设置请求头，所以builder内部的元素可以很清晰的定义了 首先是引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt;&lt;/dependency&gt; 当然由于整个使用都比较简单，下面就直接贴出封装后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class HttpWrapper &#123; private static OkHttpClient client = new OkHttpClient(); private static final String DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\"; public static Builder of(String url) &#123; return new Builder(url); &#125; public static class Builder &#123; private String url; private Map&lt;String, String&gt; params; private List&lt;MultipartBody.Part&gt; uploadParts; Request.Builder reqBuilder; Builder(String url) &#123; this.url = url; params = new HashMap&lt;&gt;(); uploadParts = new ArrayList&lt;&gt;(); reqBuilder = new Request.Builder(); // 默认添加上user-agent addHeader(\"User-Agent\", DEFAULT_USER_AGENT); &#125; // 添加参数 public Builder addParam(String key, String value) &#123; params.put(key, value); return this; &#125; // 添加头 public Builder addHeader(String key, String value) &#123; reqBuilder.addHeader(key, value); return this; &#125; public Builder file(String key, String fileName, String fileMime, byte[] bytes) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), bytes)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, File file) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), file)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, InputStream stream) throws IOException &#123; int size = stream.available(); byte[] bytes = new byte[size]; stream.read(bytes); return file(key, fileName, fileMime, bytes); &#125; /** * 发送get请求 * * @return * @throws IOException */ public Response get() throws IOException &#123; StringBuilder urlBuilder = new StringBuilder(url); if (!params.isEmpty()) &#123; urlBuilder.append(\"?\").append(Joiner.on('&amp;').withKeyValueSeparator('=').join(params)); &#125; return client.newCall(reqBuilder.url(urlBuilder.toString()).build()).execute(); &#125; /** * post表单数据 * * @return */ public Response post() throws IOException &#123; // 创建表单 FormBody.Builder formBodyBuilder = new FormBody.Builder(); if (!params.isEmpty()) &#123; params.forEach(formBodyBuilder::add); &#125; return client.newCall(reqBuilder.url(url) .post(formBodyBuilder.build()) .build()) .execute(); &#125; /** * 文件上传 * * @return * @throws IOException */ public Response upload() throws IOException &#123; MultipartBody.Builder bodyBuilder = new MultipartBody.Builder() .setType(MultipartBody.FORM); uploadParts.forEach(bodyBuilder::addPart); // 添加参数 params.forEach(bodyBuilder::addFormDataPart); return client.newCall(reqBuilder.url(url) .post(bodyBuilder.build()) .build()) .execute(); &#125; &#125;&#125; 针对上面的实现，有几个需要注意的地方 get请求时，将参数拼装到url上（需要考虑是否要编码？） post请求时，主要借助 FormBody 来存储请求参数 文件上传时， 主要利用Part来封装上传的文件，借助 MultipartBody来包装Part和请求参数 上传文件，需要指定其 MIME（即 Content-Type, 如 image/jpeg, audio/mp3, file/txt等） 传文件的同时，也可以传递post参数，当然url参数也是可以的 III. 测试验证前面给出的是一个传文件的case，下面则给出一个提交post表单的测试用例 这个http接口主要功能是实现markdown输出图片 12345678910111213141516171819202122232425262728293031323334@Testpublic void testPost() &#123; String url = \"https://zbang.online/wx/md2img\"; String content = \"h1 header\\n\" + \"============\\n\" + \"\\n\" + \"Paragraphs are separated by a blank line.\\n\" + \"\\n\" + \"2nd paragraph. *Italic*, **bold**, and `monospace`. Itemized lists\\n\" + \"look like:\\n\" + \"\\n\" + \" * this one\\n\" + \" * that one\\n\" + \" * the other one\"; String token = \"0xdahdljk3u8eqhrjqwer90e\"; String noborder = \"true\"; try &#123; Response res = HttpWrapper.of(url) .addParam(\"content\", content) .addParam(\"token\", token) .addParam(\"noborder\", noborder) .addParam(\"type\", \"stream\") .post(); if (res.isSuccessful()) &#123; BufferedImage bf = ImageIO.read(res.body().byteStream()); System.out.println(\"over\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 测试演示 V. 其他源码相关源码可以参见： HttpWrapper.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Tool","slug":"技术/Java/Tool","permalink":"https://zbang.online/hexblog/categories/技术/Java/Tool/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://zbang.online/hexblog/tags/Okhttp/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Tool","slug":"技术/Java/Tool","permalink":"https://zbang.online/hexblog/categories/技术/Java/Tool/"}]},{"title":"Redis实现分布式锁相关注意事项","slug":"Redis实现分布式锁相关注意事项","date":"2018-01-14T08:12:29.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2018/01/14/Redis实现分布式锁相关注意事项/","link":"","permalink":"https://zbang.online/hexblog/2018/01/14/Redis实现分布式锁相关注意事项/","excerpt":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题","text":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题 I. 背景知识借助redis来实现分布式锁（我们先考虑单机redis的模式），首先有必要了解下以下几点： 单线程模式 setnx : 当不存在时，设置value，并返回1； 否则返回0 getset : 设置并获取原来的值 expire : 设置失效时间 get : 获取对应的值 del : 删除 ttl : 获取key对应的剩余时间，若key没有设置过超时时间，或者压根没有这个key则返回负数（可能是-1，-2） watch/unwatch : 事务相关 II. 方案设计1. 设计思路获取锁： 调用 setnx 尝试获取锁，如果设置成功，表示获取到了锁 设置失败，此时需要判断锁是否过期 未过期，则表示获取失败；循环等待，并再次尝试获取锁 已过期，getset再次设置锁，判断是否获取了锁（根据返回的值进行判断，后面给出具体的方案） 若失败，则重新进入获取锁的逻辑 释放锁： 一个原则就是确保每个业务方释放的是自己的锁 2. getset的实现方案网上一种常见的case，主要思路如下 setnx 尝试获取锁 失败，则 get 获取锁的value （一般是 uuid_timstamp） 判断是否过期，若没有过期，则表示真的获取失败 若过期，则采用 getset设置，尝试获取锁 实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public class DistributeLock &#123; private static final Long OUT_TIME = 30L; public String tryLock(Jedis jedis, String key) &#123; while (true) &#123; String value = UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; String getsetOldVal = jedis.getSet(key, value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 jedis.set(key, getsetOldVal); &#125; &#125; &#125; public void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); &#125; &#125;&#125; 观察获取锁的逻辑，特别是获取超时锁的逻辑，很容易想到有一个问题 getSet 方法会不会导致写数据混乱的问题，简单来说就是多个线程同时判断锁超时时，执行 getSet设置锁时，最终获取锁的线程，能否保证和redis中的锁的value相同 上面的实现方式，一个混乱的case如下: 三个线程a,b,c 都进入到了锁超时的阶段 线程a, 获取原始值 oldVal, 并设置 t1 线程b, 获取线程a设置的 t1, 并重设为 t2 线程c, 获取线程b设置的 t2, 并重设为 t3 线程a，判断，并正式获取到锁 线程b，判断失败，恢复原来锁的内容为t1 线程c, 判断失败，恢复原来锁的内容为t2 问题出现了，获取锁的线程a，期望所得内容为t1, 但是实际为t2; 导致无法释放锁 实际验证 在上面的代码中，配合测试case，加上一些日志输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static String tryLock(Jedis jedis, String key) throws InterruptedException &#123; String threadName = Thread.currentThread().getName(); while (true) &#123; String value = threadName + \"_\" + UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; // 强制使所有的线程都可以到这一步 Thread.sleep(50); System.out.println(threadName + \" in getSet!\"); // 人工接入，确保t1 获取到锁， t2 获取的是t1设置的内容， t3获取的是t2设置的内容 if (\"t2\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(20); &#125; else if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; String getsetOldVal = jedis.getSet(key, value); System.out.println(threadName + \" set redis value: \" + value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 System.out.println(threadName + \" get lock!\"); if (\"t1\".equalsIgnoreCase(threadName)) &#123; // t1获取到锁，强制sleep40ms， 确保线t2,t3也进入了 getSet逻辑 Thread.sleep(40); &#125; return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 // 人肉介入，确保t2优先执行，并设置回t1设置的值, t3后执行设置的是t2设置的值 if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; else if (\"t2\".equalsIgnoreCase(threadName))&#123; Thread.sleep(20); &#125; jedis.set(key, getsetOldVal); System.out.println(threadName + \" recover redis value: \" + getsetOldVal); &#125; &#125;&#125; 测试case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testLock() throws InterruptedException &#123; // 先无视获取jedis的方式 JedisPool jedisPool = cacheWrapper.getJedisPool(0); Jedis jedis = jedisPool.getResource(); String lockKey = \"lock_test\"; String old = DistributeLock.tryLock(jedis, lockKey); System.out.println(\"old lock: \" + old); // 确保锁超时 Thread.sleep(40); // 创建三个线程 Thread t1 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t1 &gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t2 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t2\"); Thread t3 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t3 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t3\"); t1.start(); t2.start(); t3.start(); Thread.sleep(10000);&#125;; 部分输出结果: 1234567891011121314main in getSet!main set redis value: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130main get lock!old lock: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130t1 in getSet!t2 in getSet!t1 set redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t1 get lock!t3 in getSet!t2 set redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t3 set redis value: t3_9aa5d755-43b2-43bd-9a0b-2bad13fa31f6_1515643763345t2 recover redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t3 recover redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341 重点关注 t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341，表示t1线程过去了锁，但是锁的内容不是其value，即便t2去恢复，也会被t3给覆盖 如何解决上面这个问题呢？ 上面是典型的并发导致的问题，当然可以考虑从解决并发问题的角度出发来考虑，一个常见的方式就是加锁了，思路如下：（不详细展开了） 在判断超时之后，加锁 再次获取对应的值，判断是否超时，是则执行上面的操作 否则退出逻辑，继续循环 这种实现方式，会有以下的问题： getset 这个方法执行，可能导致写入脏数据 基于服务器时钟进行超时判断，要求所有服务器始终一致，否则有坑 3. expire实现方式相比于前面一种直接将value设置为时间戳，然后来比对的方法，这里则直接借助redis本身的expire方式来实现超时设置，主要实现逻辑相差无几 123456789101112131415161718192021222324252627282930313233public class DistributeExpireLock &#123; private static final Integer OUT_TIME = 3; public static String tryLock(Jedis jedis, String key) &#123; String value = UUID.randomUUID().toString(); while(true) &#123; Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 jedis.expire(key, OUT_TIME); // 主动设置超时时间为3s return value; &#125; // 获取失败，先确认下是否有设置国超是时间 // 防止锁的超时时间设置失效，导致一直竞争不到 if(jedis.ttl(key) &lt; 0) &#123; jedis.expire(key, OUT_TIME); &#125; &#125; &#125; public static void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); System.out.println(Thread.currentThread() +\" del lock success!\"); &#125; else &#123; System.out.println(Thread.currentThread() +\" del lock fail!\"); &#125; &#125;&#125; 获取锁的逻辑相比之前的，就简单很多了，接下来则需要简单的分析下，上面这种实现方式，会不会有坑呢？我们主要看一下获取锁失败的场景 如果获取锁失败 表示有其他的业务方已经获取到了锁 此时，只能等持有锁的业务方主动释放锁 判断锁是否设置了超时时间，若没有则加一个（防止设置超时时间失败导致问题） 从上面这个逻辑来看问题不大，但是有个问题，case ： 如某个业务方setnx获取到了锁，但是因为网络问题，过了很久才获取到返回，此时锁已经失效并被其他业务方获取到了，就会出现多个业务方同时持有锁的场景 III. 小结说明想基于redis实现一个相对靠谱的分布式锁，需要考虑的东西还是比较多的，而且这种锁并不太适用于业务要求特别严格的地方，如 一个线程持有锁时，如果发生gc，导致锁超时失效，但是自己又不知道，此时就会出现多个业务方同时持有锁的场景 对于锁超时的场景，需要仔细考虑，是否会出现并发问题 确保只能释放自己的锁（以防止释放了别人的锁，出现问题） 参考链接 基于Redis的分布式锁到底安全吗? 利用redis实现的分布式锁 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/tags/Redis/"},{"name":"distributeLock","slug":"distributeLock","permalink":"https://zbang.online/hexblog/tags/distributeLock/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}]},{"title":"SpringMVC之请求参数的获取方式","slug":"SpringMVC之请求参数的获取方式","date":"2018-01-04T08:48:39.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/04/SpringMVC之请求参数的获取方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/04/SpringMVC之请求参数的获取方式/","excerpt":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE","text":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE I. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的 1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了，javax.servlet.ServletRequest#getParameter 来获取对应的参数，下面各处一个实例 1234567891011@RestController@RequestMapping(path = \"webs/demo\")public class DemoController &#123; @RequestMapping(path = \"req1\") public String req1(HttpServletRequest request) &#123; String user = request.getParameter(\"user\"); String password = request.getParameter(\"password\"); return \"req1 user: \" + user + \" pwd: \" + password; &#125;&#125; 根据上面暴露的接口，我们测试的case就很简单了 12345http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog&amp;password=123456## 输出 req1 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog## 输出 req1 user: 小灰灰Blog pwd: null 说明 这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数 除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息 在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象) 12HttpServletRequest httpServletRequest = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); 2. 直接方法参数获取直接给出case, 这个方法依然是放在上面的DemoController下面的 1234@RequestMapping(path = \"req2\")public String req2(String user, String password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 请求验证 12345678910http://127.0.0.1:8080/webs/demo/req2?user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password=123456## 输出： req2 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456## 输出： req2 user: null pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;User=blog## 输出： req2 user: null pwd: 123456 注意： 上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了 方法参数名必须和url参数名完全一致（区分大小写） 顺序无关 若参数没传，则默认为null 一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况 代码稍作修改 1234@RequestMapping(path = \"req2\")public String req2(String user, int password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 实际测试 12345678910111213# case1 http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;user=blog## 输出： req2 user: blog pwd: 123456# case 2http://127.0.0.1:8080/webs/demo/req2?password2=123456&amp;user=blog## 输出: 报错, Optional int parameter 'password' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type# case 3http://127.0.0.1:8080/webs/demo/req2?password=abc&amp;user=blog## 输出：报错, \"Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"abc\"\" 结果说明 如果请求参数与方法参数类型不一致，会抛出转换异常 如果方法参数为非封装基本类型，则url参数必须存在，否则报错 3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似，case如下 12345@RequestMapping(path = \"req3\", method = RequestMethod.GET)public String req3(@RequestParam(\"user\") String username, @RequestParam(\"password\") String pwd) &#123; return \"req3 user: \" + username + \" pwd: \" + pwd;&#125; 测试case 12345678# case1 http://127.0.0.1:8080/webs/demo/req3?password=123456&amp;user=blog## 输出: req3 user: blog pwd: 123456# case2http://127.0.0.1:8080/webs/demo/req3?password=123456## 输出：报错， Required String parameter 'user' is not presen 说明 不指定注解的name或value属性时，等同于第二种使用姿势 注解的name属性或value属性，用实际的参数名来指定 controller的参数名与url参数名没有强关联（区别第二种方式） 参数类型需要保证一致（通第二种方式） 如果url参数可选，请设置require属性为false，如下1@RequestParam(name = \"user\", required = false) String username 4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单 12345678910@Datapublic static class UserDO &#123; String user; String password;&#125;@RequestMapping(path = \"req4\", method = RequestMethod.GET)public String req4(UserDO userDO) &#123; return \"req4 userDO: \" + userDO;&#125; 测试case 12345678# case1http://127.0.0.1:8080/webs/demo/req4?password=123456&amp;user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog## 输出: req4 userDO: DemoController.UserDO(user=小灰灰Blog, password=123456)# case2http://127.0.0.1:8080/webs/demo/req4?password=123456## 输出: req4 userDO: DemoController.UserDO(user=null, password=123456) 说明 定义一个bean，内部属性和请求参数对应 允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常） bean的属性，可以根据实际情况指定类型 5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩 6. Path参数Path参数，专指的是请求路径的参数，如 1http://127.0.0.1:8080/webs/demo/req4?password=123456 上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接 1https://my.oschina.net/u/566591/blog/1601400 566591 : 这个参数主要用来区分用户 1601400 : 这个参数则主要是表示对应的博文 一般path参数的获取方式如下 1234@RequestMapping(path = \"req6/&#123;user&#125;/info\")public String req6(@PathVariable(name = \"user\") String user) &#123; return \"req6 user: \" + user;&#125; 测试case 1234567891011# case1 http://127.0.0.1:8080/webs/demo/req6/blog/info?user=haha## 输出：req6 user: blog# case2http://127.0.0.1:8080/webs/demo/req6/blog?user=haha## 输出: 404# case3http://127.0.0.1:8080/webs/demo/req6/info?user=haha## 输出: 404 注意: path参数的使用，需要确保参数存在且类型匹配 path参数和url参数不会相互影响 II. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok 1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求 123456789101112# case1 curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req1\"## 输出： req1 user: 小灰灰Blog pwd: 123456# case2curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?password=123456\"## 输出：req1 user: 小灰灰Blog pwd: 12345# case3curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?user=greyBlog\"## 输出：req1 user: greyBlog pwd: null curl也可以换成js请求测试方式 1234567891011var formData = new FormData();formData.append(\"user\", \"小灰灰Blog\");$.ajax(&#123; url: 'http://127.0.0.1:8080/webs/demo/req1?password=123456', type: 'post', cache: false, data: formData, processData: false, contentType: false&#125;); 说明 对于HttpServletReuqest方式获取参数时，get和post没什么区别 若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干） 2. 方法参数获取几个测试demo如下 12345678910111213# case 1curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出： req2 user: 小灰灰Blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出：req2 user: null pwd: 123456# case 3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2?user=blog\"## 输出： req2 user: blog pwd: 123456 基本上使用姿势和get没什么区别 3. RequestParam注解方式12345678910111213# case 1curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3\"## 输出： req3 user: blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req3?user=blog\"## 输出： req3 user: blog pwd: 123456# case 3curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3?password=900\"## 输出：req3 user: blog pwd: 900,123456 注意 和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串 4. Bean方式12345678910111213## case1 curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4?password=900\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=900,123456)## case2curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=123456)## case3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=null, password=123456) 这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数 5. PathVariable这个没法玩… III. 多媒体上传参数获取 上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好 1. 实例支持1234567891011121314@RequestMapping(path = &#123;\"wx/upload\", \"wx/wx/upload\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@ResponseBodypublic String upload(HttpServletRequest request) &#123; MultipartFile file = null; if (request instanceof MultipartHttpServletRequest) &#123; file = ((MultipartHttpServletRequest) request).getFile(\"image\"); &#125; if (file == null) &#123; throw new IllegalArgumentException(\"图片不能为空!\"); &#125; return \"success\";&#125; 简单来说，主要是利用HttpServletRequest来获取上传的文件 注意： 如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常） 如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断 ((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件 IV. 小结1. 五种获取参数的姿势 方式 注意事项 HttpServletRequest获取参数 最常见通用 方法参数与请求参数同名 注意参数名统一，注意类型一致，尽量不用非包装基本类型 @RequestParam注解 同上，可注解内指定http参数名 Bean方式 定义一个bean，会将同名的http参数赋值进去，推荐 @PathVariable 注解 请求url参数 2. 传文件使用姿势使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"RequestParam","slug":"RequestParam","permalink":"https://zbang.online/hexblog/tags/RequestParam/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"jvm调优的工具介绍","slug":"jvm调优的工具介绍","date":"2018-01-03T06:18:35.000Z","updated":"2018-03-15T12:31:04.956Z","comments":true,"path":"2018/01/03/jvm调优的工具介绍/","link":"","permalink":"https://zbang.online/hexblog/2018/01/03/jvm调优的工具介绍/","excerpt":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能","text":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能 jvm相关参数记录 12-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/java.hprof -XX:InitialCodeCacheSize=134217728 -XX:InitialHeapSize=4294967296 -XX:MaxDirectMemorySize=1073741824 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=268435456 -XX:MaxNewSize=2147483648 -XX:MetaspaceSize=268435456 -XX:NewSize=2147483648 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ReservedCodeCacheSize=268435456 -XX:SurvivorRatio=10 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 2. 监控工具使用tsar作为服务器性能监控工具，所以前提是先安装tsar 12345wget -O tsar.zip https://github.com/alibaba/tsar/archive/master.zip --no-check-certificateunzip tsar.zipcd tsarmakemake install 监控命令 1tsar --cpu --swap -i1 -l 说明 tsar相关可以参考： Linux系统性能监控工具介绍之-tsar II. 相关知识点简介截取几条gc日志 1234562018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs]2018-01-02T10:49:25.374+0800: 13.999: [GC (Allocation Failure) 2018-01-02T10:49:25.374+0800: 13.999: [ParNew: 1881830K-&gt;93708K(1922432K), 0.0910714 secs] 1949062K-&gt;197949K(4019584K), 0.0911833 secs] [Times: user=0.26 sys=0.01, real=0.09 secs]2018-01-02T10:55:53.013+0800: 401.639: [GC (GCLocker Initiated GC) 2018-01-02T10:55:53.013+0800: 401.639: [ParNew: 1841429K-&gt;142552K(1922432K), 0.0629031 secs] 1945670K-&gt;246793K(4019584K), 0.0630512 secs] [Times: user=0.14 sys=0.01, real=0.06 secs]2018-01-02T10:55:55.076+0800: 403.701: [GC (GCLocker Initiated GC) 2018-01-02T10:55:55.076+0800: 403.701: [ParNew: 1890281K-&gt;59983K(1922432K), 0.0661778 secs] 1994522K-&gt;201875K(4019584K), 0.0663176 secs] [Times: user=0.15 sys=0.01, real=0.07 secs]2018-01-02T11:47:25.271+0800: 3493.897: [GC (Allocation Failure) 2018-01-02T11:47:25.271+0800: 3493.897: [ParNew: 1807695K-&gt;20975K(1922432K), 0.0193077 secs] 1949587K-&gt;162867K(4019584K), 0.0195351 secs] [Times: user=0.04 sys=0.00, real=0.02 secs]2018-01-02T11:56:50.621+0800: 4059.247: [GC (GCLocker Initiated GC) 2018-01-02T11:56:50.622+0800: 4059.247: [ParNew: 1774543K-&gt;108899K(1922432K), 0.0401606 secs] 1916434K-&gt;250791K(4019584K), 0.0403586 secs] [Times: user=0.10 sys=0.00, real=0.04 secs] 1. CMS GC日志格式分析截取上面日志中的第一条，分别说明每一项是什么意思 2018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs] 2018-01-02T10:49:20.390+0800 ：发生gc的时间 9.015 - GC开始，相对JVM启动的相对时间，单位是秒 GC - 区别FullGC和MinorGC的标识，此处表示为MinorGC (Allocation Failure) - 发生gc的原因，此处表示空间不足，导致分配失败 ParNew – 收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器 1922431K-&gt;134118K – 收集前后年轻代的使用情况，未回收之前，大小为1922431K, 回收完毕之后，大小为134118K, 所以回收大小为: 1922431K - 134118K (1922432K) - 整个年轻代的容量 0.1486593 secs - 这个解释用原滋原味的解释：Duration for the collection w/o final cleanup. 1934749K-&gt;201350K - 收集前后整个堆的使用情况 (4019584K) - 整个堆的容量 0.1487460 secs – ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的花销）； [Times: user=0.78 sys=0.01, real=0.11 secs] – GC事件在不同维度的耗时，具体的用英文解释起来更加合理: user – Total CPU time that was consumed by Garbage Collector threads during this collection sys – Time spent in OS calls or waiting for system event real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount. 2. CMS简介 后端服务选用的就是CMS，那么就有必要看一下这个CMS到底是个什么东西 CMSConcurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标签-清除算法 步骤划分 初始标记 (CMS initial mark) : 标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记 (CMS concurrent mark) : 进行 GC Roots Tracing的过程 重新标记 (CMS remark) : 为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除 (CMS concurrent sweep) : 说明，初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 标记清除算法一句话描述： 标记所有需要回收的对象，在标记完成后，统一回收所有被标记的对象 常见的两个问题： 效率不高；回收后大量的碎片 3. 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区指尖发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无序等Age达到阀值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC 3. jstat 命令简介 既然问题是频繁的gc引起的，那么观察新生代，老年代对象占用空间的情况就不可避免了，所以jstat命令不得不出现了 截一个线程图 1234567$ jstat -gcutil 11573 1000 5 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 34.39 24.68 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 26.29 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 27.45 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 28.32 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 29.93 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 a. 参数说明 -gcutil ： 监视Java对状况，包括Eden区、两个survivor区，老年代，永久代等，已用空间，gc时间等 11573： java进程号 1000： 每1s刷新一次 5： 一共查询5次 b. 输出说明 S0, S1: 表示两个 survivor区 E(Eden) : 新生代Eden O(Old) : 老年代Old M(metaspace) : 元空间,本地内存， 在1.8移除了永久代改成这个 YGC : 程序运行以来，发生Minor GC(Young GC)次数 YGCT : Minor GC 总耗时（单位s) FGC : Full GC的总次数 FGCT : Full GC的总耗时 （单位s) GCT : 所有GC的总耗时 （单位s) III. 监控测试0. 准备a. 首先是获取对应的进程号12jps -ljinfo xxx 抓图 123$ jps -l30916 sun.tools.jps.Jps2909 org.apache.catalina.startup.Bootstrap b. 服务器性能监控命令12## 主要查看cpu和nginx访问的监控tsar --cpu --nginx -i1 -l 抓图: 12345678Time -----------------------cpu---------------------- ----------------------------------nginx---------------------------------Time user sys wait hirq sirq util accept handle reqs active read write wait qps rt03/01/18-11:29:37 16.54 1.50 0.00 0.00 0.00 18.05 2.00 2.00 6.00 15.00 0.00 1.00 14.00 6.00 89.5003/01/18-11:29:38 26.07 1.75 0.00 0.00 0.00 27.82 3.00 3.00 10.00 15.00 0.00 1.00 14.00 10.00 47.1003/01/18-11:29:39 19.60 1.01 0.00 0.00 0.00 20.60 4.00 4.00 11.00 15.00 0.00 1.00 14.00 11.00 37.8203/01/18-11:29:40 28.75 2.50 0.00 0.00 0.25 31.50 2.00 2.00 10.00 15.00 0.00 1.00 14.00 10.00 79.3003/01/18-11:29:41 14.07 1.51 0.00 0.00 0.00 15.58 1.00 1.00 10.00 15.00 0.00 3.00 12.00 10.00 51.3003/01/18-11:29:42 20.60 1.01 0.00 0.00 0.00 21.61 6.00 6.00 13.00 15.00 0.00 1.00 14.00 13.00 44.69 c. jvm内存的监控1jstat -gcutil 4354 1000 抓图: 123456$ jstat -gcutil 2909 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 29.03 0.00 66.34 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.37 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.50 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.54 16.34 98.57 96.32 200 6.393 0 0.000 6.393 d. 查看内存中对象的个数和大小1jmap -histo 4354 抓图 123456789101112num #instances #bytes class name---------------------------------------------- 1: 78179 181546608 [I 2: 1259 175880312 [S 3: 35915 65527520 [B 4: 242125 40558408 [C 5: 571604 13718496 java.util.concurrent.atomic.AtomicLong 6: 233282 5598768 java.lang.String 7: 55177 5296992 java.util.jar.JarFile$JarFileEntry 8: 119906 3836992 java.util.HashMap$Node 9: 33327 2932776 java.lang.reflect.Method 10: 1147 2303216 [Ljava.util.concurrent.atomic.AtomicLong; e. 压测模拟工具Jmetter 添加线程组 新增http请求 添加监听器中，结果的监控：图形结果，聚合报告，查看结果树，用表格查看结果 http请求中配置参数 协议 域名or IP + 端口号 编码: utf-8 请求方法 + 请求路径 请求参数，支持文件上传，注意编码方式 IV. 参考 Linux系统性能监控工具介绍之-tsar tsar使用说明 JVM调优——之CMS GC日志分析 jvm的GC日志分析 JVM 运行时内存使用情况监控 《深入理解JVM虚拟机》 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JDK学习之反射的使用姿势一览","slug":"JDK学习之反射的使用姿势一览","date":"2017-12-29T12:26:51.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2017/12/29/JDK学习之反射的使用姿势一览/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/JDK学习之反射的使用姿势一览/","excerpt":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景","text":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景 I. 反射定义 指程序可以访问、检测和修改它本身状态或行为的一种能力 直接说定义的话，可能并不能非常清晰的解释说明，结合作用进行描述 反射可以干什么？ 1234在运行时构造任意一个类的对象。在运行时判断任意一个对象所属的类。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法 有了上面四点，基本上你想干嘛就可以干嘛，比如我现在就有下面这个类 1234567891011121314151617181920212223242526272829public class RefectTest extends MyRefect implements IRefect &#123; private static String s1 = \"hello\"; private static int s2 = 100; private int s3 = 200; private boolean ans; protected RefectTest next; public RefectTest() &#123; &#125; public RefectTest(int s3, boolean ans, RefectTest next) &#123; this.s3 = s3; this.ans = ans; this.next = next; &#125; public RefectTest next() &#123; return next; &#125; private int count(int a, int b) &#123; return a + b; &#125;&#125; 现在我有了clz,其赋值语句为 Class clz = RefectTest.class， 那么我可以干啥？ 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 上面给出了可以干些什么，并给了对应的简单示例，引入了几个新的类Constructor, Field, Method， 下面将详细解释这三个类是什么，怎么用 II. 反射的使用努力结合实际的应用场景，给出每种利用反射的实现对应需求的使用姿势，有些场景可能并不是特别贴切，欢迎提出给合适的场景以此进行替换 1. 通过反射创建对象 这是个比较常见的场景，我在使用了自定义注解时，通常会这么晚 应用场景： 我定义了一个校验器的注解ValDot，注解中有个校验规则class对象，如下 1234567891011121314151617public interface ICheckRule &#123; boolean check(Object ... obj);&#125;public class DefaultCheckRule implements ICheckRule &#123; @Override public boolean check(Object... obj) &#123; return false; &#125;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CheckDot &#123; // 校验规则 Class&lt;? extends ICheckRule&gt; check() default DefaultCheckRule.class;&#125; 上面定义了注解和校验条件，接着进入整体，在切面中，需要获取 1234567891011121314@Aspect@Componentpublic class CheckAspect &#123; @Before(\"@annotation(checkDot)\") public void process(JoinPoint joinPoint, CheckDot checkDot) throws IllegalAccessException, InstantiationException &#123; // 注意，这里获取注解上的校验规则类，并获取实例 ICheckRule rule = checkDot.check().newInstance(); if(rule.check(joinPoint.getArgs())) &#123; throw new IllegalStateException(\"check argument error!\"); &#125; &#125;&#125; 上面是一个较好的利用反射获取实例的应用场景，想一想，如果不用反射，这个校验规则怎么传进来呢，这个时候就没那么方便了（当然也不是不可以，最简单的就是拿一个Holder持有类名到类对象的映射关系，然后在注解中传类名，也可以达到上面的效果） 还有一种场景可能就比较蛋疼了，如果一个类没有默认构造方法，通过反射就没法直接用class.newInstanace()了 Constructor构造器类 根据Class优先获取到 Constructor 对象，然后传入需要的构造参数, 测试如下 1234567891011121314151617181920212223public class ConTest &#123; private int a,b; public ConTest(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public String toString() &#123; return \"ConTest&#123;\" + \"a=\" + a + \", b=\" + b + '&#125;'; &#125; public static void main(String[] args) throws Exception &#123; Class clz = ConTest.class; // 获取对应的构造器（注意参数类型） Constructor constructor = clz.getConstructor(int.class, int.class); // 创建实例（注意参数要匹配） ConTest test = (ConTest) constructor.newInstance(10, 20); System.out.println(test.toString()); &#125;&#125; 输出 1ConTest&#123;a=10, b=20&#125; 一般常用下面四种方式获取 1234567891011// 根据参数类型获取匹配的构造器Constructor getConstructor(Class[] params)// 获取所有的Constructor[] getConstructors()// 相比较前面的，这里可以获取私有方法Constructor getDeclaredConstructor(Class[] params)// 可以获取私有方法Constructor[] getDeclaredConstructors() 2. 判断class的继承关系判断是否为基础数据类型基本类型较为特殊，所以JDK很人性化的给封装了一个方法，Class#isPrimitive 因此返回true的类型有: int long short byte char boolean 封装后的类型，返回的依然是false 附带一句，是没有null.class这种用法的 判断是否为另一个类的子类，另一个接口的实现类通常我们利用 instanceof 关键字来判断继承关系，但是这个是针对对象来的，现在给一个class，要怎么玩？ 看下面，主要就是 Class#isAssignableFrom() 的功劳了 1234567891011121314151617181920212223public class ExtendTest &#123; interface ITest &#123;&#125; abstract class ATest &#123; abstract public void print(); &#125; class TestClz extends ATest implements ITest &#123; @Override public void print() &#123; System.out.println(\"TestClz\"); &#125; &#125; public static void main(String[] args) &#123; Class clz = TestClz.class; System.out.println(ATest.class.isAssignableFrom(clz)); System.out.println(ITest.class.isAssignableFrom(clz)); &#125;&#125; 需要注意一点，父类作为调用方，子类作为参数 结合泛型时，获取泛型的实际类型泛型，又是一个有意思的功能，这里不多说，继承一个泛型基类，然后问题是如何通过反射获得泛型签名中的类型，一般会在继承或实现泛型接口时会用到它。 123456789class A&lt;T, ID&gt; &#123;&#125;class B extends A&lt;String, Integer&gt; &#123;&#125;public static void main(String[] args) &#123; System.out.println(B.class.getGenericSuperclass());&#125; 换成泛型接口呢 ? 12345678910111213interface A&lt;T, ID&gt; &#123; &#125; class B implements A&lt;String, Integer&gt; &#123; &#125;public static void main(String[] args) &#123; ParameterizedType parameterizedType = (ParameterizedType) B.class.getGenericInterfaces()[0]; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125;&#125; 3. 获取成员变量获取成员变量，主要是根据 B.class.getDeclaredFields() 来获取所有声明的变量，这个应用场景会和下面的获取方法并执行联合一起说明 1234567891011// 获取指定的公共成员变量Field getField(String name)// 获得所有公共字段Field[] getFields()// 获取指定声明的成员变量（包括prive）Field getDeclaredField(String name)// 获取所有声明的成员变量Field[] getDeclaredFields() 这个主要返回 Field对象，现在有了Field，可以做些啥？ 判断成员的修饰 Field#getModifiers() 12345678int modify = field.getModifiers();// 是否是静态变量boolean ans = Modifier.isStatic(modifier);// 是否是公共变量boolean ans = Modifier.isPublic(modifier);// 是否不可变boolean ans = Modifier.isFinal(modifier);// ... 获取成员的变量名 : field#getName() 获取成员对应的value: field#get(instance) 对于静态成员，instance可以为null 对于非静态成员，instance必须为一个实例对象 获取注解: field#getAnnotations() 这个就厉害了，hibernate的校验框架，在成员变量上加一个注解Max,就可以设置参数的最大值，其实就是通过反射获取到注解，然后进行相应的逻辑 4. 获取方法获取方法，同上面的差不多，也有四种方式 1234567891011// 根据方法名，参数类型获取公共方法Method getMethod(String name, Class[] params)// 获取所有的公共方法Method[] getMethods()// 根据方法名，参数类型，获取声明的方法（包括私有）Method getDeclaredMethod(String name, Class[] params)// 获取所有声明的方法Method[] getDeclaredMethods() 返回了一个Method类，那么这个东西又有一些什么功能？ 获取方法名 Method#getName() 获取方法所在的类 : Method#getDeclaringClass() 获取方法返回类型 : Method#getReturnType() 获取方法上的注解 : Method#getAnnotations() 执行方法 有了这个就可以做很多事情了，实例中给出说明 1234// 设置方法可访问（即私有方法也可以被调用）method.setAccessible(true);// instance为实例对象， args为传入参数method.invoke(instance, args) III. 实例DEMO通过反射的方式，实现一个 BeanUtils，实现Bean的拷贝 当一个Bean有较多的成员变量时，如果我们采用最原始的setXXX()来一次赋值的时候，一是实现比较繁琐，其次就是当Bean的字段发生变动之后，也需要同步的修改，那么我们借助反射的方式，实现一个优雅的 BeanUtils 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BeanUtils &#123; public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125; &#125; private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; // 没有匹配到，这里返回null实际上是不合适的 // 因为如果原属性为基本数据类型，赋值null为报错 throw new Exception(); &#125;&#125; IV. 小结反射的四种用途 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 使用注意事项 操作私有变量，私有方法时，先设置field.setAccessible(true);确保可访问 反射会带来额外的性能开销 可以用 Class#isAssignableFrom() 来判断类继承关系 可以用 Class#isPrimitive()判断是否为基本数据类型 可以用 Class#getGenericSuperclass() 获取泛型类型 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"https://zbang.online/hexblog/tags/Reflect/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Centos 安装hexo博客","slug":"Centos-安装hexo博客","date":"2017-12-29T10:10:43.000Z","updated":"2018-03-15T12:31:04.953Z","comments":true,"path":"2017/12/29/Centos-安装hexo博客/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/Centos-安装hexo博客/","excerpt":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选","text":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选 安装步骤12345678910## 1. nodejs安装sudo yum install nodejs## 2. 安装 hexosudo npm install -g hexo-clisudo npm install## 3. 创建hexohexo init xxxnpm install 测试验证 hexo server 使用说明1. 创建一个page执行下面的命令之后，就可以创建一个menu菜单 1hexo new page about 2. 新建一个博文1hexo new 'new blog' 新建一个草稿 12345hexo new draft '草稿博文'# 启动服务，预览草稿hexo server --drafts 3. 显示简介在md文件中，某一个地方地方添加 1&lt;!-- more --&gt; 则后面的内容都不会显示在首页了 4. 启动12345## 编译hexo g## 启动一个serverhexo s 5. deploy打开 _config.yml 文件，添加配置 1234deploy: type: git repository: https://github.com/liuyueyi/blogs.git branch: master 开始发布: 1hexo d -g 说明 如果github上，访问网页时，提示js或者css 404，则需要注意下面的配置 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liuyueyi.github.io/hexblogroot: /hexblog/permalink: :year/:month/:day/:title/permalink_defaults: lang: zh-cn 其中URL，和root是关键的设置属性，root最后的/不能漏掉 如果提示git没有，则需要安装 1npm install hexo-deployer-git --save","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zbang.online/hexblog/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Nginx 路由转发配置笔记","slug":"Nginx-路由转发配置笔记","date":"2017-12-27T09:57:18.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2017/12/27/Nginx-路由转发配置笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/12/27/Nginx-路由转发配置笔记/","excerpt":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html）","text":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html） I. location匹配规则1. 语法123location [=|~|~*|^~|@] /uri/ &#123; ...&#125; 2. 说明从上面的语法出发，可以了解到location可以区分为三个部分，接下来一个一个的研究一下 a. PartOne: [=|~|~*|^~|@] = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 上面定义了几个不同的符号，表示不同的匹配规则，那么先后顺序呢？ =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 直接看这个可能不太好理解，写几个case实际测试一下 测试case1: 123456789101112131415location = /world &#123; return 600;&#125;location = /hello &#123; return 600;&#125;location ~ /hellowo &#123; return 602;&#125;location ^~ /hello &#123; return 601;&#125; 12345678- 请求 localhost/world 返回600- 请求 localhost/world2 localhost/test/world 返回其他- 请求 localhost/hello 返回600- 请求 localhost/hello/123 返回601- 请求 localhost/hellow 返回601- 请求 localhost/hellowo 返回601- 请求 localhost/test/hellowo 返回602- 请求 localhost/test/hello 返回其他 因此可以知道 = 是精确完整匹配, 且优秀最高 正则匹配时，如果 ~ 和 ^~ 同时匹配规则，则 ^~ 优先 ^~ 这个不会匹配请求url中后面的路径, 如上面的 /test/hello 没有匹配上 ^~ 不支持正则，和=相比，范围更广， hellowo 是可以被^~匹配，但是 = 不会匹配 ~ 路径中只要包含就可以匹配，如上面的 /test/hellowo 返回了602 测试case2: 1234567location ~ /hello &#123; return 602;&#125;location ~ /helloworld &#123; return 601;&#125; 12- 请求 localhost/world/helloworld 返回 602- 请求 localhost/helloworld 返回 602 调整一下上面的顺序之后 1234567location ~ /helloworld &#123; return 601;&#125;location ~ /hello &#123; return 602;&#125; 123- 请求 localhost/helloworld 返回601- 请求 localhost/world/helloworld 返回601- 请求 localhost/helloWorld 返回602 所以同时正则匹配时 放在前面的优先匹配 注意如果不区分大小写时，使用~* 尽量将精确匹配的放在前面 测试case3: 1234567location ^~ /hello/ &#123; return 601;&#125;location /hello/world &#123; return 602;&#125; 这种场景中，存在一个没有符号的路由规则，那么实际的测试是怎样呢？ 1234- http://localhost/hello/wor 返回601- http://localhost/hello/world 返回602- http://localhost/hello/world23 返回602- http://localhost/hello/world/123 返回602 从上面case可以看出 没有符号时，全匹配是优先于^~的 b. PartTwo: [uri]这里主要填的就是需要匹配的path路径，根据前面的符号，这里可以填写精确的path路径，也可以填正则表达式，下面则主要针对正则进行说明 123456789101112. ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的介绍&#123;n&#125; ： 重复n次&#123;n,&#125; ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 c. PartThree: {}匹配完毕之后内部定义一些列的处理动作，这个涉及到的点比较多，这里不详细展开，后面有空单独捞出 II. 路由转发 请求path匹配只是第一步，匹配完了之后，如何将请求转发给其他的web服务呢？ 0. 反向代理通常可见的一种使用姿势就是使用nginx，代理请求，转发到内部的tomact服务上 主要是通过 proxy_pass 这个来实现 123location ^~ /webs &#123; proxy_pass http://127.0.0.1:8080/webs;&#125; 将所有以 webs开头的请求，转发给8080端口的tomcat服务上 上面是直接写死转发到一个ip上，如果是多个机器提供服务呢？可以这么玩 12345678910## 下面放在http的括号内，作为第一层upstream test.online &#123; server 120.11.11.11:8080 weight=1; server 120.11.11.12:8080 weight=1;&#125;location ^~ /webs &#123; proxy_pass http://test.online; proxy_redirect default;&#125; 1. Rewrite命令rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。 rewrite只能放在server{},location{},if{}中， 并且只能对域名后边的除去传递的参数外的字符串起作用, 如 http://zbang.online/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。 语法rewrite regex replacement [flag]; 一个case，通过rewrite实现对url的重写，将下面的 12345678location ^~ /hexo &#123; root &apos;/Users/yihui/GitHub/&apos;;&#125;location ~ /hello &#123; rewrite ^(/hello).*$ /hexo/public/index.html last; return 603;&#125; 将hello开头的，全部转发到/hexo/public/index.html III. 小结1. demo将所有以blog开头的请求，全部转发到某个地方 123location ^~ /blog &#123; root &apos;/var/www/html/blog&apos;;&#125; 2. 路径匹配规则 = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 匹配顺序如下： =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 3. 路由转发 通过 proxy_pass 可以实现反向代理 通过 rewrite 可以实现路由转发 IV. 参考 location匹配顺序 nginx 常见正则匹配符号表示 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如有问题，请不吝指正，感激 扫描关注，不定时分享各种java学习笔记","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zbang.online/hexblog/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"https://zbang.online/hexblog/tags/配置/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}]},{"title":"Centos 安装gitbook","slug":"Centos-安装gitbook","date":"2017-12-25T03:26:00.000Z","updated":"2017-12-29T04:16:00.000Z","comments":true,"path":"2017/12/25/Centos-安装gitbook/","link":"","permalink":"https://zbang.online/hexblog/2017/12/25/Centos-安装gitbook/","excerpt":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务","text":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务 1. nodejs安装1sudo yum install nodejs 2. gitbook安装12npm install gitbook -gnpm install gitbook-cli -g 上面执行完毕，可能出现一个问题 1npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl 解决方法 1yum update openssl 3. calibre安装直接到官网上下载 ； ·https://calibre-ebook.com/download· 1sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\\n&apos;); exec(sys.stdin.read()); main()&quot; 4. 测试1gitbook build . 执行完毕之后，会出现一个 _book 目录， 里面就是生成的静态网页，直接加上去即可 5. 输出pdf如果报错 1ImportError: libGL.so.1: cannot open shared object file: No such file or directory 则安装 1yum install mesa-libGL.x86_64 如果报错 1ImportError: libXrender.so.1: cannot open shared object file: No such file or directory 1yum install libXrender.so.1 -y 参考文档 基于centos6构建私有gitbook平台","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Gitbook","slug":"Gitbook","permalink":"https://zbang.online/hexblog/tags/Gitbook/"},{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","slug":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","date":"2017-12-17T11:53:51.000Z","updated":"2018-03-15T12:31:04.954Z","comments":true,"path":"2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","excerpt":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来","text":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来 1. 内容说明看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下 介绍下两种拷贝方式的区别 深拷贝的辅助工具类 如何自定义实现对象拷贝 II. 深拷贝和浅拷贝0. 定义说明深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 看到上面两个简单的说明，那么问题来了 浅拷贝中，是所有的内容公用呢？还是某些内容公用？ 从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？ 1. 浅拷贝一般来说，浅拷贝方式需要实现Cloneable接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Datapublic class ShallowClone implements Cloneable &#123; private String name; private int age; private List&lt;String&gt; books; public ShallowClone clone() &#123; ShallowClone clone = null; try &#123; clone = (ShallowClone) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125; public static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(28); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.clone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(20); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); &#125;&#125; 输出结果: 12345falsesource: ShallowClone(name=newName, age=20, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript])source: ShallowClone(name=newName, age=20, books=[hello])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript]) 结果分析： 拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址 基本元素类型，两者是隔离的（虽然上面只给出了int，String） 基本元素类型包括: int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String 非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份 其实，浅拷贝有个非常简单的理解方式： 浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 = 进行赋值 这个怎么理解呢？ 上面的流程拆解就是： 1234- Object clone = new Object();- clone.a = source.a- clone.b = source.b- ... 那么=赋值有什么特点呢？ 基本数据类型是值赋值；非基本的就是引用赋值 2. 深拷贝深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已 那么上面的实例改成深拷贝应该是怎样的呢？ 可以加上这么一个方法 1234567891011121314151617181920212223242526272829303132333435363738public ShallowClone deepClone() &#123; ShallowClone clone = new ShallowClone(); clone.name = this.name; clone.age = this.age; if (this.books != null) &#123; clone.books = new ArrayList&lt;&gt;(this.books); &#125; return clone;&#125;// 简单改一下测试casepublic static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(new Integer(1280)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.deepClone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(2000); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString());&#125; 输出结果为： 12345falsesource: ShallowClone(name=newName, age=2000, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++])source: ShallowClone(name=newName, age=2000, books=[hello])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++]) 结果分析： 深拷贝独立的对象 拷贝后对象的内容，与原对象的内容完全没关系，都是独立的 简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值 3. 应用场景区分深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了 那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？ 假设又这么一个通知对象长下面这样 12345private String notifyUser;// xxxprivate List&lt;String&gt; notifyRules; 我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样 在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了 III. 对象拷贝工具上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？ 对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝 Apache的两个版本：（反射机制） 1234org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils#cloneBean Spring版本：（反射机制） 1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高） 1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路 1. 借助反射实现对象拷贝通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值 上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125;&#125;private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; return null;&#125; 上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值 123Field field = obj.getClass().getDeclaredField(name);field.setAccessible(true);return field.get(obj); 如果找不到，则找getXXX, isXXX来获取 2. 代理的方式实现对象拷贝Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显 代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A 那么这种技术是如何使用在对象拷贝的呢？ 我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy 在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上 说明 从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了 IV. 小结1. 深拷贝和浅拷贝深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 完全独立 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性 需要实现Cloneable接口 2. 对象拷贝的两种方法通过反射方式实现对象拷贝 主要原理就是通过反射获取所有的属性，然后反射更改属性的内容 通过代理实现对象拷贝 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"clone","slug":"clone","permalink":"https://zbang.online/hexblog/tags/clone/"},{"name":"beancopy","slug":"beancopy","permalink":"https://zbang.online/hexblog/tags/beancopy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"ForkJoin 学习使用笔记","slug":"ForkJoin-学习使用笔记","date":"2017-09-08T14:24:34.000Z","updated":"2018-03-16T14:41:25.262Z","comments":true,"path":"2017/09/08/ForkJoin-学习使用笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/09/08/ForkJoin-学习使用笔记/","excerpt":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架","text":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架 I. 背景在日常的业务需求中，经常出现的批量查询，批量写入等接口的提供，一般来说，最简单最low的方式就是写一个for循环来一次执行，但是当业务方对接口的性能要求较高时，就比较尴尬了 通常可以想到的方式是采用并发操作，首先想到可以实现的方式就是利用线程池来做 通常实现方式如下 12345678910111213141516171819202122// 1. 创建线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"biz-exec\"), new ThreadPoolExecutor.CallerRunsPolicy());// 2. 创建执行任务List&lt;Future&lt;Object&gt;&gt; futureList = new ArrayList&lt;&gt;();for(Object arg : list) &#123; futureList.add(executorService.submit(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; // xxx &#125; &#125;));&#125;// 3. 结果获取for(Future f: futureList) &#123; Object obj = f.get();&#125; 用上面的这种方式并没有什么问题，我们接下来考虑的是如何使用ForkJoin框架来实现类似的功能 II. ForkJoin 基本知识 Fork: 将大任务拆分成若干个可以并发执行的小任务 Join: 合并所有小任务的执行结果 1. 任务分割ForkJoinTask : 基本任务，使用forkjoin框架必须创建的对象，提供fork,join操作，常用的两个子类 RecursiveAction : 无结果返回的任务 RecursiveTask : 有返回结果的任务 说明： fork : 让task异步执行 join : 让task同步执行，可以获取返回值 ForkJoinTask 在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行 2. 结果合并ForkJoinPool 执行 ForkJoinTask， 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。 当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务 三中提交方式： execute 异步，无返回结果 submit 异步，有返回结果 （返回Future&lt;T&gt;） invoke 同步，有返回结果 （会阻塞） III. 使用说明 结合两个场景，给出使用姿势 1. 累加 实现从 start - end 的累加求和 首先是定义一个CountTask 来实现求和 首先是确定任务分割的阀值，当 end-start 的差值大于阀值时，将任务一分为二 1234567891011121314151617181920212223242526272829303132333435public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private int start; private int end; private static final int THRED_HOLD = 30; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; boolean canCompute = (end - start) &lt;= THRED_HOLD; if (canCompute) &#123; // 不需要拆分 for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; System.out.println(\"thread: \" + Thread.currentThread() + \" start: \" + start + \" end: \" + end); &#125; else &#123; int mid = (end + start) / 2; CountTask left = new CountTask(start, mid); CountTask right = new CountTask(mid + 1, end); left.fork(); right.fork(); sum = left.join() + right.join(); &#125; return sum; &#125;&#125; 调用case 1234567891011@Testpublic void testFork() throws ExecutionException, InterruptedException &#123; int start = 0; int end = 200; CountTask task = new CountTask(start, end); ForkJoinPool pool = ForkJoinPool.commonPool(); Future&lt;Integer&gt; ans = pool.submit(task); int sum = ans.get(); System.out.println(sum);&#125; 输出结果： 123456789thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 51 end: 75thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 101 end: 125thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 0 end: 25thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 126 end: 150thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 76 end: 100thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 151 end: 175thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 26 end: 50thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 176 end: 20020100 2. 排序 int 数组进行排序 同样先定义一个SortTask, 主要是为了演示ForkJoin的使用姿势，具体的排序和合并的逻辑比较简陋的实现了一下（这块不是重点） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SortTask extends RecursiveTask&lt;List&lt;Integer&gt;&gt; &#123; private List&lt;Integer&gt; list; private final static int THRESHOLD = 5; public SortTask(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override protected List&lt;Integer&gt; compute() &#123; if (list.size() &lt; THRESHOLD) &#123; Collections.sort(list); System.out.println(\"thread: \" + Thread.currentThread() + \" sort: \" + list); return list; &#125; int mid = list.size() &gt;&gt; 1; SortTask l = new SortTask(list.subList(0, mid)); SortTask r = new SortTask(list.subList(mid, list.size())); l.fork(); r.fork(); List&lt;Integer&gt; left = l.join(); List&lt;Integer&gt; right = r.join(); return merge(left, right); &#125; private List&lt;Integer&gt; merge(List&lt;Integer&gt; left, List&lt;Integer&gt; right) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(left.size() + right.size()); int rightIndex = 0; for (int i = 0; i &lt; left.size(); i++) &#123; if (rightIndex &gt;= right.size() || left.get(i) &lt;= right.get(rightIndex)) &#123; result.add(left.get(i)); &#125; else &#123; result.add(right.get(rightIndex++)); i -= 1; &#125; &#125; if (rightIndex &lt; right.size()) &#123; result.addAll(right.subList(rightIndex, right.size())); &#125; return result; &#125;&#125; 测试case和上面基本一样，我们改用 invoke 替换上面的 submit 12345678@Testpublic void testMerge() throws ExecutionException, InterruptedException &#123; List&lt;Integer&gt; list = Arrays.asList(100, 200, 150, 123, 4512, 3414, 3123, 34, 5412, 34, 1234, 893, 213, 455, 6, 123, 23); SortTask sortTask = new SortTask(list); ForkJoinPool pool = ForkJoinPool.commonPool(); List&lt;Integer&gt; ans = pool.invoke(sortTask); System.out.println(ans);&#125; 输出结果 123456thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [34, 3123, 3414, 4512]thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] sort: [100, 123, 150, 200]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [34, 893, 1234, 5412]thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [213, 455]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [6, 23, 123][6, 23, 34, 34, 100, 123, 123, 150, 200, 213, 455, 893, 1234, 3123, 3414, 4512, 5412] IV. 其他参考 聊聊并发（八）——Fork/Join框架介绍 线程池与ForkJoin比较 关于看完ForkJoinPool和ForkJoinTask文章后一些总结 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://zbang.online/hexblog/tags/ForkJoin/"},{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"4. SPI框架实现之旅四：使用测试","slug":"SPI框架实现之旅四：使用测试","date":"2017-05-30T12:50:37.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2017/05/30/SPI框架实现之旅四：使用测试/","link":"","permalink":"https://zbang.online/hexblog/2017/05/30/SPI框架实现之旅四：使用测试/","excerpt":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等","text":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等 1. 简单的静态使用定义一个SPI接口 IPrint, 两个实现 FilePrint, ConsolePrint 123456789101112131415161718@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125; 添加配置文件 com.hust.hui.quicksilver.spi.test.print.IPrint, 内容如下 com.hust.hui.quicksilver.spi.test.print.ConsolePrint com.hust.hui.quicksilver.spi.test.print.FilePrint 测试代码如下 1234567891011121314151617181920212223242526272829@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;); print.print(&quot;console----&gt;&quot;); print = spiLoader.getService(&quot;FilePrint&quot;); print.print(&quot;file----&gt;&quot;); try &#123; print = spiLoader.getService(&quot;undefine&quot;); print.print(&quot;undefine----&quot;); Assert.assertTrue(false); &#125; catch (Exception e) &#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125; try &#123; print = spiLoader.getService(123); print.print(&quot;type error----&quot;); Assert.assertTrue(false); &#125; catch (Exception e)&#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125;&#125; 输出如下 1234console print: console----&gt;file print: file----&gt;type error--&gt;com.hust.hui.quicksilver.spi.exception.NoSpiMatchException: no spiImpl match the name you choose! your choose is: undefinetype error--&gt;java.lang.IllegalArgumentException: conf spiInterfaceType should be sub class of [class java.lang.String] but yours:class java.lang.Integer 演示如下 2. 动态适配与静态的使用有点区别，主要的区别点在于接口的定义（需要注意第一个参数是作为选择器选择SPI实现的参数），同样是上面这个spi接口 123456789101112131415161718192021222324252627282930313233@Spipublic interface IPrint &#123; void print(String str); void adaptivePrint(String conf, String str);&#125; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"file adaptivePrint: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"console adaptivePrint: \" + str); &#125;&#125; 主要是新增了一个接口 adaptivePrint, 其他的没有啥区别，测试代码如下 12345678@Testpublic void testAdaptivePrint() throws SpiProxyCompileException &#123; IPrint print = SpiLoader.load(IPrint.class).getAdaptive(); print.adaptivePrint(\"FilePrint\", \"[file print]\"); print.adaptivePrint(\"ConsolePrint\", \"[console print]\");&#125; 输出结果 1234567891011121314151617181920212223242526file adaptivePrint: [file print]console adaptivePrint: [console print]``` 演示图 ![http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif](http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif)## 3. 自定义选择器&gt; 上面两个很简单的演示了下使用方式，最基本的方法， 没有加上 @SpiConf 注解， 没有显示指定选择器类型，下面则演示下，如何自定义选择器**SPI接口**有一个欢迎方法，我们需求根据用户的来源显示不同的欢迎至此， 下面定义了一个 `UserSelector`选择器，这个就是我们自定义的选择器```java@Spipublic interface IUser &#123; @SpiAdaptive(selector = UserSelector.class) void welcome(UserDO userDO);&#125; spi实现类 123456789101112131415public class QQUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"qq 欢迎你! \" + userDO); &#125;&#125;public class WeixinUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"weixin 欢迎你! \" + userDO); &#125;&#125; META-INF/services/ 目录下的配置如下 com.hust.hui.quicksilver.spi.def.spi.IUser com.hust.hui.quicksilver.spi.def.spi.QQUser com.hust.hui.quicksilver.spi.def.spi.WeixinUser 选择器实现如下 12345678910111213141516171819public class UserSelector implements ISelector&lt;UserDO&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, UserDO conf) throws NoSpiMatchException &#123; if (conf == null || conf.getMarket() == null) &#123; throw new IllegalArgumentException(\"userDo or userDO#market should not be null!\"); &#125; String name = conf.getMarket().getName(); if (map.containsKey(name)) &#123; return map.get(name).getSpiImpl(); &#125; throw new NoSpiMatchException(\"no spiImp matched marked: \" + conf.getMarket()); &#125;&#125; 从上面的选择器逻辑可以看出，我们是根据 UserDO的market参数来进行选择的， UserDO的定义如下 12345678910111213141516171819202122232425262728@Getter@Setter@ToStringpublic class UserDO &#123; private String uname; private String avatar; private MarketEnum market;&#125;public enum MarketEnum &#123; WEIXIN(\"WeixinUser\"), QQ(\"QQUser\"); private String name; MarketEnum(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 测试代码如下 123456789101112131415161718192021@Testpublic void testUserSPI() throws SpiProxyCompileException &#123; SpiLoader&lt;IUser&gt; loader = SpiLoader.load(IUser.class); IUser user = loader.getAdaptive(); UserDO weixinUser = new UserDO(); weixinUser.setAvatar(\"weixin.avatar.jpg\"); weixinUser.setUname(\"微信用户\"); weixinUser.setMarket(MarketEnum.WEIXIN); user.welcome(weixinUser); UserDO qqUser = new UserDO(); qqUser.setAvatar(\"qq.avatar.jpg\"); qqUser.setUname(\"qq用户\"); qqUser.setMarket(MarketEnum.QQ); user.welcome(qqUser); System.out.println(\"-----over------\");&#125; 输出结果: weixin 欢迎你! UserDO(uname=微信用户, avatar=weixin.avatar.jpg, market=WEIXIN) qq 欢迎你! UserDO(uname=qq用户, avatar=qq.avatar.jpg, market=QQ) 演示如下: 3. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"3. SPI框架实现之旅三：实现说明","slug":"SPI框架实现之旅三：实现说明","date":"2017-05-29T02:50:37.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2017/05/29/SPI框架实现之旅三：实现说明/","link":"","permalink":"https://zbang.online/hexblog/2017/05/29/SPI框架实现之旅三：实现说明/","excerpt":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下：","text":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下： SpiLoader 全解析 spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等 1. 获取spiLoader对象 SpiLoader 是一个泛型对象，每个SPI接口，对应一个SpiLoader&lt;T&gt; 对象，我们提供了一个静态方法来获取这个对象 实现优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回 123456789101112131415161718192021222324252627282930/*** spiLoader缓存, 其中key为 spi接口, value为对应的Loader对象*/private static final ConcurrentMap&lt;Class&lt;?&gt;, SpiLoader&lt;?&gt;&gt; loaderCache = new ConcurrentHashMap&lt;&gt;();@SuppressWarnings(\"unchecked\")public static &lt;T&gt; SpiLoader&lt;T&gt; load(Class&lt;T&gt; type) &#123; if (null == type) &#123; throw new IllegalArgumentException(\"common cannot be null...\"); &#125; if (!type.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must be interface!\"); &#125; if (!withSpiAnnotation(type)) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must have the annotation of @Spi\"); &#125; SpiLoader&lt;T&gt; spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); if (spiLoader == null) &#123; loaderCache.putIfAbsent(type, new SpiLoader&lt;&gt;(type)); spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); &#125; return spiLoader;&#125; 说明 上面有几个校验，前一篇已经说明，不再赘述 上面新建对象，不是线程安全的 2. 新建 SpiLoader对象 创建对象，主要会初始化选择器 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private SpiLoader(Class&lt;T&gt; type) &#123; // 初始化默认的选择器, 为保留项目, 必然会提供的服务 selectorInstanceCacheMap.putIfAbsent(DefaultSelector.class, DEFAULT_SELECTOR); this.spiInterfaceType = type; initSelector();&#125;private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 持有一个选择器缓存列表，selectorInstanceCacheMap 保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在 不做成全局唯一的原因是尽量隔离, 比如 ParamsSelector 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类 类选择器 + 方法选择器 currentSelector ： 类选择器, 解析 @Spi 注解获取，适用于静态选择 + 动态选择两种使用方式 currentMethodSelector : 方法选择器，解析 @SpiAdaptive 注解获取， 仅适用于动态选择SPI实现的方式 优先级： 方法上定义的选择器 由于 类上定义的选择器； 方法上未定义时，默认使用类定义的选择器 3. 静态使用 静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回 实现1234567891011121314151617181920212223242526272829303132333435/*** 根据传入条件, 选择具体的spi实现类* &lt;p/&gt;* 这里要求conf的类型和选择器的参数类型匹配, 否则会尝试使用默认的选择器补救, 若补救失败, 则抛异常** @param conf* @return* @throws NoSpiMatchException* @throws IllegalArgumentException*/@SuppressWarnings(\"unchecked\")public T getService(Object conf) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; if (!currentSelector.getConditionType().isAssignableFrom(conf.getClass())) &#123; /** * 参数类型不匹配时, 判断是否可以根据默认的选择器来获取 */ if (conf instanceof String) &#123; return (T) DEFAULT_SELECTOR.getSelector().selector(spiImplClassCacheMap, conf); &#125; /** * 参数类型完全不匹配, 则抛参数异常 */ throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; return (T) currentSelector.getSelector().selector(spiImplClassCacheMap, conf);&#125; 说明 spiImplClassCacheMap spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑 校验 校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行 当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的） 静态使用方式，使用类定义选择器 : currentSelector 静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的 静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释 IPrint 是一个Spi接口， 有两个实现 FilePrint, ConsolePrint 假设 `currentSelector=DefaultSelector`， 方法 methodA 上定义的是 ParamsSelector 时 静态使用方式，获取一个spi实现，希望在所有的spi接口使用处，都输出到文件，用户根据 `FilePrint` 选择 FilePrint 这个类来执行具体的输出逻辑， 如果在调用 methodA 方法执行时， 假设根据 ParamsSelector 判断， ConsolePrint 才满足这儿条件，这是相当于在具体实现时，换成了另一个 ConsolePrint, 这下子就与我们的初衷背离了（如果目标是想实现这个场景，显然动态适配的方式才是正确的使用姿势） loadService 的逻辑后面详细说明 4. 动态使用 动态使用区别于静态的直接确定实现类， 通过getService 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行 设计的出发点可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？ 考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的 最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回 实现如下和静态实现的逻辑差不多，一般流程如下: 判断spi实现类的映射关系表是否初始化，若没有则初始化 获取选择器 优先从方法选择器中查找， 若存在，则直接选中； 不存在，则使用类选择器 校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件） 返回实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@SuppressWarnings(\"unchecked\")public T getService(Object conf, String methodName) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; // 首先获取对应的selector SelectorWrapper selector = currentMethodSelector.get(methodName); if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector); &#125; if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; selector = DEFAULT_SELECTOR; &#125; if (spiImplMethodCacheMap.size() == 0) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; try &#123; // 采用默认的选择器,根据指定name 进行查询时, 需要兼容一下, 因为method对应的缓存key为 SpiImpName_methodName if (DEFAULT_SELECTOR.equals(selector)) &#123; if (spiImplMethodCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; if (spiImplClassCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf + \"_\" + methodName); &#125; else &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; &#125; catch (Exception e) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125;&#125; 说明 这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑） 区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器 默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 spiImplMethodCacheMap 中key的生成，有一个小转换 若实现类上没有 @SpiConf注解，或者 @SpiConf的注解没有定义 name 属性，则类的唯一标识name为：简单类名； 否则为指定的name属性 若方法上显示使用 @SpiConf 指定了name属性，则key的生成规则为： 方法注解上指定的name； 如果没有 @SpiConf注解，或其中没有指定name属性，则key生成规则: 类name属性 + 下划线 + 方法名 这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来 动态生成代理类的逻辑，放在最后进行说明 5. spi实现类映射关系表初始化 为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干 缓存结构使用了两个Map： 一个是类级别的映射关系 spiImplClassCacheMap 静态使用时，只会用搞这个 动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断 key： @SpiConf 注解中定义的name； 或者spi实现类的简单类名 一个是方法的映射关系 spiImplMethodCacheMap 动态适配时， 选择器优先从这里进行判断 key: @SpiConf 注解中定义的name； 或者是 实现类的 name + “_” + 方法名 12345678910/*** name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplClassCacheMap;/*** 自适应时, 根据方法选择实现; name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplMethodCacheMap; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private void loadSpiService() &#123; List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;(); List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceMethodList = new ArrayList&lt;&gt;(); ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType); SpiConf spiConf; String implName; int implOrder; for (T t : serviceLoader) &#123; spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); String methodImplName; int methodImplOrder; Map&lt;String, String&gt; methodParams; for (Method method : methods) &#123; spiConf = method.getAnnotation(SpiConf.class); if (spiConf == null) &#123; continue; &#125; // 方法上有自定义注解, 且定义的name与类实现名不同, 则直接采用 // 否则采用 ServiceName_MethodName 方式定义 if (StringUtils.isBlank(spiConf.name()) || implName.equals(spiConf.name())) &#123; methodImplName = implName + \"_\" + method.getName(); &#125; else &#123; methodImplName = spiConf.name(); &#125; // 优先级, 以最小的为准 （即一个类上的优先级很低, 也可以定义优先级高的方法） // 方法注解未定义顺序时, 继承类上的顺序 methodImplOrder = Math.min(implOrder, spiConf.order() &lt; 0 ? implOrder : spiConf.order()); // 自适应方法的参数限制, 要求继承类上的参数 methodParams = parseParms(spiConf.params()); if (map.size() &gt; 0) &#123; // 方法的参数限定会继承类上的参数限定 if (methodParams.size() == 0) &#123; methodParams = map; &#125; else &#123; methodParams.putAll(map); &#125; &#125; spiServiceMethodList.add(new SpiImplWrapper&lt;&gt;(t, methodImplOrder, methodImplName, methodParams)); &#125; &#125; if (spiServiceList.size() == 0) &#123; throw new IllegalStateException(\"no spiImpl implements spi: \" + spiInterfaceType); &#125; this.spiImplClassCacheMap = initSpiImplMap(spiServiceList); this.spiImplMethodCacheMap = initSpiImplMap(spiServiceMethodList);&#125;private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; initSpiImplMap(List&lt;SpiImplWrapper&lt;T&gt;&gt; list) &#123; // 映射为map, 限定不能重名 Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; tempMap = new ConcurrentHashMap&lt;&gt;(); for (SpiImplWrapper&lt;T&gt; wrapper : list) &#123; if (tempMap.containsKey(wrapper.getName())) &#123; throw new IllegalArgumentException(\"duplicate spiImpl name \" + wrapper.getName()); &#125; tempMap.put(wrapper.getName(), wrapper); &#125; return tempMap;&#125; 上面的逻辑可以分为两块，一块是上半边的初始化，获取spiImplClassCacheMap;下一块则是扫描实现类的所有方法，将方法上标有@SpiConf注解的捞出来，用于初始化 spiImplMethodCacheMap 说明 缓存结构中value为 SpiImplWrapper 缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了 1234567891011121314151617181920private T spiImpl;private int order;/*** spiImpl 的标识name, 要求唯一* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.DefaultSelector 选择具体的SpiImpl 时使用&#125;*/private String name;/*** 参数校验规则* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.ParamsSelector&#125; 选择具体的SpiImpl 时使用* 要求每个实现类都有注解 &#123;@link SpiConf&#125;*/private Map&lt;String, String&gt; paramCondition; name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明 采用 ParamsSelector 时， 要求 @SpiConf 注解必须存在 注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题 // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); 动态代码生成 上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法 1. 代理类格式采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码 获取具体的实现类 （调用上面的 SpiLoader.getService(conf, methodName） 执行实现类的接口 123456789101112131415161718192021222324package com.hust.hui.quicksilver.spi.test.print;import com.hust.hui.quicksilver.spi.SpiLoader;public class IPrint$Proxy implements com.hust.hui.quicksilver.spi.test.print.IPrint &#123; public void print(java.lang.String arg0) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"print\"); spiImpl.print(arg0); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125; public void adaptivePrint(java.lang.String arg0, java.lang.String arg1) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"adaptivePrint\"); spiImpl.adaptivePrint(arg0, arg1); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125;&#125; 上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行） 代理类生成对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 构建SPI接口的实现代理类, 在执行动态适配的方法时, 调用SpiLoader的 spiImpl选择器, 选择具体的实现类执行 * * @return */public static String buildTempImpl(Class type) &#123; StringBuilder codeBuilder = new StringBuilder(); codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); codeBuilder.append(\"\\nimport \").append(SpiLoader.class.getName()).append(\";\"); codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Proxy implements \").append(type.getCanonicalName()).append(\" &#123;\\n\"); Method[] methods = type.getMethods(); for (Method method : methods) &#123; Class&lt;?&gt; returnType = method.getReturnType(); //函数返回值 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//函数参数列表 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();//函数异常列表 // build method code StringBuilder code = new StringBuilder(512); if (parameterTypes.length &lt; 0) &#123; //检查该函数参数列表中，第一个参数作为选择器参数 code.append(\"throw new IllegalArgumentException(\\\"there should be one argument for selector to choose spiImpl\\\")\"); &#125; else &#123; // 没有 SpiAdaptive注解的, 采用默认的注解方式 code.append(\"try&#123;\\n\"); code.append(type.getName()).append(\" spiImpl=\") .append(\"SpiLoader.load(\") .append(type.getName()).append(\".class\") .append(\").getService(arg0,\\\"\") .append(method.getName()) .append(\"\\\");\"); if (!\"void\".equals(returnType.getName())) &#123; code.append(\"return \"); &#125; code.append(\"spiImpl.\").append(method.getName()).append(\"(arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; code.append(\",\").append(\"arg\").append(i); &#125; code.append(\");\"); code.append(\"\\n&#125; catch(com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e)&#123;\\nthrow new java.lang.RuntimeException(e);\\n&#125;\"); &#125; // build method signature codeBuilder.append(\"\\npublic \").append(returnType.getName()).append(\" \").append(method.getName()) .append(\"(\").append(parameterTypes[0].getName()).append(\" arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; codeBuilder.append(\", \").append(parameterTypes[i].getName()).append(\" arg\").append(i); &#125; codeBuilder.append(\") \"); if (exceptionTypes.length &gt; 0) &#123; codeBuilder.append(\"throw \").append(exceptionTypes[0].getName()); for (int i = 1; i &lt; exceptionTypes.length; i++) &#123; codeBuilder.append(\", \").append(exceptionTypes[i].getName()); &#125; &#125; codeBuilder.append(\"&#123;\\n\"); codeBuilder.append(code.toString()).append(\"\\n&#125;\"); &#125; codeBuilder.append(\"\\n&#125;\"); return codeBuilder.toString();&#125; 动态编译运行动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译 12345678910111213141516@SuppressWarnings(\"unchecked\")public static &lt;T&gt; T compile(String code, Class&lt;T&gt; interfaceType, ClassLoader classLoader) throws SpiProxyCompileException &#123; GroovyClassLoader loader = new GroovyClassLoader(classLoader); Class clz = loader.parseClass(code); if (!interfaceType.isAssignableFrom(clz)) &#123; throw new IllegalStateException(\"illegal proxy type!\"); &#125; try &#123; return (T) clz.newInstance(); &#125; catch (Exception e) &#123; throw new SpiProxyCompileException(\"init spiProxy error! msg: \" + e.getMessage()); &#125;&#125; 小结至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了 博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"2. SPI框架实现之旅二：整体设计","slug":"SPI框架实现之旅二：整体设计","date":"2017-05-28T02:50:37.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2017/05/28/SPI框架实现之旅二：整体设计/","link":"","permalink":"https://zbang.online/hexblog/2017/05/28/SPI框架实现之旅二：整体设计/","excerpt":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式","text":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式 设计思路下图围绕 SpiLoader 为中心，描述了三个主要的流程： load所有的spi实现 初始化选择器 selector 获取spi实现类 （or一个实现类代理） 基础类说明 主要介绍一下框架中涉及到的接口和注解，并指出需要注意的点 1. Selector 选择器 为了最大程度的支持业务方对spi实现类的选择，我们定义了一个选择器的概念，用于获取spi实现类 接口定义如下:123public interface ISelector&lt;T&gt; &#123; &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, T conf) throws NoSpiMatchException;&#125; 结合上面的接口定义，我们可以考虑下，选择器应该如何工作？ 根据传入的条件，从所有的实现类中，找到一个最匹配的实现类返回 如果查不到，则抛一个异常NoSpiMatchException出去 所以传入的参数会是两个， 一个是所有的实现类列表map（至于上面为什么用map，后续分析），一个是用于判断的输入条件conf 框架中会提供两种基本的选择器实现， DefaultSelector ， 对每个实现类赋予唯一的name，默认选择器则表示根据name来查找实现类 ParamsSelector， 在实现类上加上 @SpiConf 注解，定义其中的 params，当传入的参数(conf)， 能完全匹配定义的params，表示这个实现类就是你所需要的 自定义实现自定义实现比较简单，实现上面的接口即可 2. Spi 注解 要求所有的spi接口，都必须有这个注解； 定义如下主要是有一个参数，用于指定是选择器类型，定义spi接口的默认选择器， 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Spi &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明在上一篇《SPI框架实现之旅一》中，使用jdk的spi方式中，并没有使用注解依然可以正常工作，我们这里定义这个注解且要求必需有，出于下面几个考虑 醒目，告诉开发者，这个接口是声明的spi接口， 使用的时候注意下 加入选择器参数，方便用户扩展自己的选择方式 3. SpiAdaptive 注解 对需要自适应的场景，为了满足一个spi接口，应用多重不同的选择器场景，可以加上这个注解；如果不加这个注解，则表示采用默认的选择器来自适应 接口说明1234567891011/** * SPI 自适应注解, 表示该方法会用到spi实现 * &lt;p/&gt; * Created by yihui on 2017/5/24. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface SpiAdaptive &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明这个注解内容和 @Spi 基本上一模一样，唯一的区别是一个放在类上，一个放在方法上，那么为什么这么考虑？ @Spi 注解放在类上，更多的表名这个接口是我们定义的一个SPI接口，但是使用方式可以有两种（静态 + 动态确认） @SpiAdaptive 只能在自适应的场景下使用，用于额外指定spi接口中某个方法的选择器 （如果一个spi接口全部只需要一个选择器即可，那么可以不使用这个注解） 如下面的这个例子，print方法和 echo方法其实是等价的，都是采用 DefaultSelector 来确认具体的实现类；而 write 和 pp 方法则是采用 ParamsSelector 选择器; 1234567891011121314151617181920/** * Created by yihui on 2017/5/25. */@Spipublic interface ICode &#123; void print(String name, String contet); @SpiAdaptive void echo(String name, String content); @SpiAdaptive(selector = ParamsSelector.class) void write(Context context, String content); @SpiAdaptive(selector = ParamsSelector.class) void pp(Context context, String content);&#125; 4. SpiConf 注解 这个主键主要是用在实现类上（或实现类的方法上），里面存储一些选择条件，通常是和Selector搭配使用 定义如下定义了三个字段: name 唯一标识，用于 DefaultSelector； params 参数条件， 用于 ParamsSelector； order : 优先级， 主要是为了解决多个实现类都满足选择条件时， 应该选择哪一个 （谈到这里就有个想法， 通过一个参数，来选择是否让满足条件的全部返回） 123456789101112131415161718192021222324252627282930@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface SpiConf &#123; /** * 唯一标识 * * @return */ String name() default \"\"; /** * 参数过滤, 单独一个元素,表示参数必须包含; 用英文分号,左边为参数名,右边为参数值,表示参数的值必须是右边的 * &lt;p/&gt; * 形如 &#123;\"a\", \"a:12\", \"b:TAG\"&#125; * * @return */ String[] params() default &#123;&#125;; /** * 排序, 越小优先级越高 * * @return */ int order() default -1;&#125; 说明SpiConf 注解可以修饰类，也可以修饰方法，因此当一个实现类中，类和方法都有这个注解时， 怎么处理 ？ 以下面的这个测试类进行说明 1234567891011121314151617181920212223242526272829303132333435/** * Created by yihui on 2017/5/25. */@SpiConf(params = \"code\", order = 1)public class ConsoleCode implements ICode &#123; @Override public void print(String name, String contet) &#123; System.out.println(\"console print:---&gt;\" + contet); &#125; /** * 显示指定了name, 因此可以直接通过 consoleEcho 来确定调用本实现方法 * @param name * @param content */ @Override @SpiConf(name = \"consoleEcho\") public void echo(String name, String content) &#123; System.out.println(\"console echo:----&gt;\" + content); &#125; /** * 实际的优先级取 方法 和类上的最高优先级, 实际为1； * `ParamsSelector`选择器时， 执行该方法的条件等同于 `&#123;\"code\", \"type:console\"&#125;` * @param context * @param content */ @Override @SpiConf(params = &#123;\"type:console\"&#125;, order = 3) public void write(Context context, String content) &#123; System.out.println(\"console write:----&gt;\" + content); &#125;&#125; 在设计中，遵循下面几个原则： 类上的SpiConf注解， 默认适用与类中的所有方法 方法上有SpiConf注解，采取下面的规则 方法注解声明name时，两个会同时生效，即想调用上面的echo方法， 通过传入 ConsoleCode（类注解不显示赋值时，采用类名代替） 和 consoleEcho 等价 方法注解未声明name时，只能通过类注解上定义的name（or默认的类名）来选择 order，取最高优先级，如上面的 write 方法的优先级是 1; 当未显示定义order时，以定义的为准 params: 取并集，即要求类上 + 方法上的条件都满足 SPI加载器 spi加载器的主要业务逻辑集中在 SpiLoader 类中，包含通过spi接口，获取所有的实现类； 获取spi接口对应的选择器 （包括类对应的选择器， 方法对应的选择器）； 返回Spi接口实现类（静态确认的实现类，自适应的代理类） 从上面的简述，基本上可以看出这个类划分为三个功能点， 下面将逐一说明，本篇博文主要集中在逻辑的设计层，至于优化（如懒加载，缓存优化等） 放置下一篇博文单独叙述 1. 加载spi实现类 这一块比较简单，我们直接利用了jdk的 ServiceLoader 来根据接口，获取所有的实现类；因此我们的spi实现，需要满足jdk定义的这一套规范 具体的代码业务逻辑非常简单，大致流程如下 1234567891011121314151617 if (null == spiInterfaceType) &#123; throw new IllegalArgumentException(\"common cannot be null...\");&#125;if (!spiInterfaceType.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must be interface!\");&#125;if (!withSpiAnnotation(spiInterfaceType)) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must have the annotation of @Spi\");&#125; ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType);for(T spiImpl: serviceLoader) &#123; // xxx&#125; 注意 因为使用了jdk的标准，因此每定义一个spi接口，必须在 META_INF.services 下新建一个文件， 文件名为包含包路径的spi接口名， 内部为包含包路径的实现类名 每个spi接口，要求必须有 @Spi 注解 Spi接口必须是 interface 类型， 不支持抽象类和类的方式 拓展虽然这里直接使用了spi的规范，我们其实完全可以自己定义标准的，只要能将这个接口的所有实现类找到， 怎么实现都可以由你定义 如使用spring框架后，可以考虑通过 applicationContext.getBeansOfAnnotaion(xxx ) 来获取所有的特定注解的bean，这样就可以不需要自己新建一个文件，来存储spi接口和其实现类的映射关系了 构建spi实现的关系表上面获取了spi实现类，显然我们的目标并不局限于简单的获取实现类，在获取实现类之后，还需要解析其中的 @SpiConf 注解信息，用于表示要选择这个实现，必须满足什么样的条件 SpiImplWrapper : spi实现类，以及定义的各种条件的封装类 注解的解析过程流程如下: name: 注解定义时，采用定义的值； 否则采用简单类名 （因此一个系统中不允许两个实现类同名的情况） order： 优先级， 注解定义时，采用定义的值；未定义时采用默认； params: 参数约束条件， 会取类上和方法上的并集（原则上要求类上的约束和方法上的约束不能冲突） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;();// 解析注解spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; // 没有添加注解时， 采用默认的方案 implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // ------------ // 解析参数的方法 private Map&lt;String, String&gt; parseParms(String[] params) &#123; if (params.length == 0) &#123; return Collections.emptyMap(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(params.length); String[] strs; for (String param : params) &#123; strs = StringUtils.split(param, \":\"); if (strs.length &gt;= 2) &#123; map.put(strs[0].trim(), strs[1].trim()); &#125; else if (strs.length == 1) &#123; map.put(strs[0].trim(), null); &#125; &#125; return map; &#125; 2. 初始化选择器 我们的选择器会区分为两类，一个是类上定义的选择器， 一个是方法上定义的选择器； 在自适应的使用方式中，方法上定义的优先级 &gt; 类上定义 简单来讲，初始化选择器，就是扫一遍SPI接口中的注解，实例化选择器后，缓存住对应的结果, 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*** 选择器, 根据条件, 选择具体的 SpiImpl;*/private SelectorWrapper currentSelector;/*** 自适应时, 方法对应的选择器*/private Map&lt;String, SelectorWrapper&gt; currentMethodSelector;/*** 每一个 SpiLoader 中, 每种类型的选择器, 只保存一个实例* 因此可以在选择器中, 如&#123;@link ParamsSelector&#125; 对spiImplMap进行处理并缓存结果*/private ConcurrentHashMap&lt;Class, SelectorWrapper&gt; selectorInstanceCacheMap = new ConcurrentHashMap&lt;&gt;(); private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 SeectorWrapper 选择器封装类 这里我们在获取选择器时，特意定义了一个封装类，其中包含具体的选择器对象，以及所匹配的参数类型，因此可以在下一步通过选择器获取实现类时，保证传入的参数类型合法 private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) 具体的实例化选择器的方法 从实现来看，优先从选择器缓存中获取选择器对象，这样的目的是保证一个spi接口，每种类型的选择器只有一个实例；因此在自定义选择器中，你完全可以做一些选择判断的缓存逻辑，如 ParamsSelector 中的spi实现类的有序缓存列表 currentSelector , currentMethodSelector, selectorInstanceCacheMap currentSelector: 对应的是类选择器，每个SPI接口必然会有一个，作为打底的选择器 currentMethodSelector: 方法选择器映射关系表，key为方法名，value为该方法对应的选择器； 所以spi接口中，不支持重载 selectorInstanceCacheMap: spi接口所有定义的选择器映射关系表，key为选择器类型，value是实例；用于保障每个spi接口中选择器只会有一个实例 3. 获取实现类 对使用者而言，最关注的就是这个接口，这里会返回我们需要的实现类（or代理）；内部的逻辑也比较清楚，首先确定选择器，然后通过选择器便利所有的实现类，把满足条件的返回即可 从上面的描述可以看到，主要分为两步 获取选择器 根据选择器，遍历所有的实现类，找出匹配的返回 获取选择器初始化选择器之后，我们会有 currentSelector , currentMethodSelector 两个缓存 静态确定spi实现时，直接用 currentSelector 即可 （spi接口中所有方法都公用类定义选择器） 动态适配时， 根据方法名在 currentMethodSelector 中获取选择器，如果没有，则表示该方法没有@SpiAdaptive注解，直接使用类的选择器 currentMethodSelector 即可 123456789101112131415// 动态适配时，获取方法对应对应的selector实现逻辑SelectorWrapper selector = currentMethodSelector.get(methodName);if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector);&#125;if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; // 参数不匹配时，且传入的参数为String类型， 则尝试使用默认选择器进行兼容（不建议在实现时，出现这种场景） selector = DEFAULT_SELECTOR;&#125; 选择实现类这个的主要逻辑就是遍历所有的实现类，判断是否满足选择器的条件，将第一个找到的返回即可，所有的业务逻辑都在 ISelector 中实现，如下面给出的默认选择器，根据name来获取实现类 1234567891011121314151617181920212223242526/** * 默认的根据name 获取具体的实现类 * &lt;p/&gt; * Created by yihui on 2017/5/24. */public class DefaultSelector implements ISelector&lt;String&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, String name) throws NoSpiMatchException &#123; if (StringUtils.isBlank(name)) &#123; throw new IllegalArgumentException(\"spiName should not be empty!\"); &#125; if (map == null || map.size() == 0) &#123; throw new IllegalArgumentException(\"no impl spi!\"); &#125; if (!map.containsKey(name)) &#123; throw new NoSpiMatchException(\"no spiImpl match the name you choose! your choose is: \" + name); &#125; return map.get(name).getSpiImpl(); &#125;&#125; 流程说明 上面主要就各个点单独的进行了说明，看起来可能比较分散，看完之后可能没有一个清晰的流程，这里就整个实现的流程顺一遍，主要从使用者的角度出发，当定义了一个SPI接口后，到获取spi实现的过程中，上面的这些步骤是怎样串在一起的 流程图先拿简单的静态获取SPI实现流程说明（动态的其实差不多，具体的差异下一篇说明），先看下这种用法的使用姿势 1234567891011121314151617181920212223242526@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125;@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(\"ConsolePrint\"); print.print(\"console----&gt;\");&#125; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class);这行代码触发的action 主要是初始化所有的选择器, 如下图 首先从缓存中查 是否已经初始化过了有则直接返回； 缓存中没有，则进入new一个新的对象出来 解析类上注解 @Spi，初始化 currentSelector 解析所有方法的注解 @SpiAdaptive ， 初始化 currentMethodSelector 塞入缓存，并返回 IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;);根据name获取实现类，具体流程如下 判断是否加载过所有实现类 spiImplClassCacheMap 没有加载，则重新加载所有的实现类 通过jdk的 ServiceLoader.load() 方法获取所有的实现类 遍历实现类，根据 @SpiConf 注解初始化参数，封装 SpiImplWrapper对象 保存封装的 SpiImplWrapper对象到缓存 执行 currentSelector.select() 方法，获取匹配的实现类 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"1. SPI框架实现之旅一：背景介绍","slug":"SPI框架实现之旅一：背景介绍","date":"2017-05-26T02:46:42.000Z","updated":"2018-03-15T12:31:04.955Z","comments":true,"path":"2017/05/26/SPI框架实现之旅一：背景介绍/","link":"","permalink":"https://zbang.online/hexblog/2017/05/26/SPI框架实现之旅一：背景介绍/","excerpt":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制","text":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制 1. 背景上面摘抄了一下spi的概念，接着以个人的理解，简单的谈一下为什么会用到SPI， 什么场景下可以用到这个， 以及使用了SPI机制后有什么优越性 什么是SPI虽然最开始就引用了spi的解释，这里浅谈一下个人理解。Service Provider Interface 以接口方式提供服务， 和API不同，spi的机制是定义一套标准规范的接口，实现交给其他人来做。 所以一个接口，可以有很多的实现，你完全可以根据自己的需要去选择具体的实现方式，因为是面向接口的开发，所以你的业务代码基本上就不用修改，就可以切到另一个实现了 什么场景可以用 分别从框架层面和业务层面，给出一个我认为比较合适的场景 1. 日志输出 SLF4jSLF4j：大名鼎鼎的日志输出接口，这个jar包里面提供的都只是接口方式，具体的实现需要自己去实现，当然比较常用的 logback 就是一个具体的实现包了， 在项目中使用 slf4j 的api进行日志的输出， 通过简单的配置，引入logback， 就可以使用logback来实现具体的日志输出； 也可以换一个日志实现 commons-logging，业务上不需要任何的改动，就可以用不同的实现来输出日志 2. 业务场景假设你现在有个用户注册成功后的欢迎用户的业务，不同渠道（微信，qq，微博等）注册的，显示的欢迎不同，对此有两种不同的实现方式 如果每个不同的渠道进来的，都有一个独立的应用来响应 （因为绝大多数的业务都一样，可能就欢迎词不同，如果做到代码最大程度的复用） 只有一个应用，来处理所有的这些场景 可以怎么用 结合上面的业务场景，来描述下可以怎么用 1. 代码复用为了实现代码最大程度的复用，那么可以将不同的地方，抽象成一个SPI接口，在业务层通过接口来代替具体的实现类实现业务逻辑； 每个渠道，都有个独立的应用，那么在微信渠道，创建一个 WeixinSpiImpl来实现接口 在qq渠道，实现 QQSpiImpl；那么在具体的接口调用处，实际上就是执行的spi实现类方法 2. 业务场景的选择区分这个与上面不同，同一个服务接口，根据不同的业务场景，选择不同的实现来执行；当然你是完全可以使用 if， else来实现这种场景，唯一的问题就是扩展比较麻烦； 这种场景下，我们希望的就是这个接口，能自动的根据业务场景，来选择最合适的实现类来执行 简单来讲，就是\u0010spi接口执行之前，其实需要有一个自动选择匹配的实现类的前置过程； 通常这种业务场景下，具体的spi实现会有多个，但是需要有一个选择的策略 2. 小目标 在具体的实现之前，先定义一个小目标，我们想要实现一个什么样子的东西出来 通过上面的背景描述，我们的小目标也就很明确了，我们的实现至少需要满足两个场景 静态选择SPI实现， 即在选择完成之后，所有对这个spi接口的引用都是确定由这个实现来承包 动态选择SPI实现， 不到运行之时，你都不知道会是哪个spi实现来干这件事 3. 技术储备 java本身就提供了一套spi的支持方式: ServiceLoader，我们后续的开发，也会在这个基础之上进行 利用java的 ServiceLoader 找到服务接口的实现类，有一些约定，下面给出要求说明和一个测试case 一般实现流程 定义spi接口 ： IXxx 具体的实现类: AXxx, BXxx 在jar包的META-INF/services/目录下新建一个文件，命名为 spi接口的完整类名，内容为spi接口实现的完整类名，一个实现类占一行 测试case如下 spi接口 com.hust.hui.quicksilver.commons.spi.HelloInterface 12345678910package com.hust.hui.quicksilver.commons.spi;/** * Created by yihui on 2017/3/17. */public interface HelloInterface &#123; void sayHello();&#125; spi接口的两个实现类 com.hust.hui.quicksilver.commons.spi.impl.ImageHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class ImageHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"image hello!\"); &#125;&#125; com.hust.hui.quicksilver.commons.spi.impl.TextHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class TextHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"text hello\"); &#125;&#125; 配置文件 com.hust.hui.quicksilver.commons.spi.HelloInterface 12com.hust.hui.quicksilver.commons.spi.impl.ImageHellocom.hust.hui.quicksilver.commons.spi.impl.TextHello 测试类 1234567891011public class HelloSpiTest &#123; @Test public void testSPI() &#123; ServiceLoader&lt;HelloInterface&gt; serviceLoader = ServiceLoader.load(HelloInterface.class); for (HelloInterface hello: serviceLoader) &#123; hello.sayHello(); &#125; &#125;&#125; 输出如下: 12image hello!text hello 测试类演示如下图: 4. 设计思路画了一下结构图，方便理解, 下面的核心是 SpiLoader 类， 负责加载spi接口的所有实现类， 初始化所有定义的选择器， 返回一个spi接口的实现类初始化用户自定义的spi对象，然后用户持有此对象调用spi接口中提供的方法即可 5. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]}]
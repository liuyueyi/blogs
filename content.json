[{"title":"redis安装","slug":"redis环境搭建","date":"2018-04-24T02:19:51.000Z","updated":"2018-04-24T02:36:00.922Z","comments":true,"path":"2018/04/24/redis环境搭建/","link":"","permalink":"https://zbang.online/hexblog/2018/04/24/redis环境搭建/","excerpt":"I. redis安装centos安装并后台启动redis记录过程","text":"I. redis安装centos安装并后台启动redis记录过程 安装redis命令，比较简单 1yum install redis 后台启动redis方式： 123456789101112# 设置redis.conf文件，开启后台启动vim /etc/redis.conf## 找到 daemonize no 这一行## 修改成yes，并保存daemonize yes## 启动redisredis-server /etc/redis.conf 查看redis启动是否正常 12# 查看进程号ps -ef | grep redis 客户端连接测试 12345redis-cli&gt; set test 123&gt; get test&gt; expire test II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"redis","slug":"redis","permalink":"https://zbang.online/hexblog/tags/redis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"18年4月18日离杭小记","slug":"18年4月18日离杭小记","date":"2018-04-18T06:41:40.000Z","updated":"2018-04-18T06:49:21.267Z","comments":true,"path":"2018/04/18/18年4月18日离杭小记/","link":"","permalink":"https://zbang.online/hexblog/2018/04/18/18年4月18日离杭小记/","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;从15年7月1日到18年4月18日，恍惚之间，来杭州已经度过1023天，将近三年的时光，有过满含激情充满朝气的时候，也有过浑浑噩噩每天无所事事的时候，这里是迈入社会的第一站，拉开了一段新的旅程序幕，于此驻足三年，却收益余生. &nbsp;&nbsp;&nbsp;&nbsp;这几天杭州的天气不错，阳光明媚，虽然能见度不怎么样，坐在蘑菇街大厦的11层，望向窗外，远处依然是雾蒙蒙的，没有蓝蓝的天，也看不到飘零的云，但就这么看着，也觉得有别样的风景。杭州，最忆是西湖。曾在古诗文中无数次憧憬着的人间天堂，依稀记得初次到西湖前的画面。粼粼的湖光、和煦的风，两条横插湖中的苏堤、白堤，却让我感受到完全不一样的风景。从没有想过，西湖会是这样的场景；和印象中《新白娘子传奇》里的小湖、断桥、微雨和油纸伞的水墨画完全不同；带上了浓厚的现代风之后的西湖，好像也只有那千古继承的湖波和岸边的依依杨柳，才是最出的风光，也才能给人更多的古韵遐想。","text":"&nbsp;&nbsp;&nbsp;&nbsp;从15年7月1日到18年4月18日，恍惚之间，来杭州已经度过1023天，将近三年的时光，有过满含激情充满朝气的时候，也有过浑浑噩噩每天无所事事的时候，这里是迈入社会的第一站，拉开了一段新的旅程序幕，于此驻足三年，却收益余生. &nbsp;&nbsp;&nbsp;&nbsp;这几天杭州的天气不错，阳光明媚，虽然能见度不怎么样，坐在蘑菇街大厦的11层，望向窗外，远处依然是雾蒙蒙的，没有蓝蓝的天，也看不到飘零的云，但就这么看着，也觉得有别样的风景。杭州，最忆是西湖。曾在古诗文中无数次憧憬着的人间天堂，依稀记得初次到西湖前的画面。粼粼的湖光、和煦的风，两条横插湖中的苏堤、白堤，却让我感受到完全不一样的风景。从没有想过，西湖会是这样的场景；和印象中《新白娘子传奇》里的小湖、断桥、微雨和油纸伞的水墨画完全不同；带上了浓厚的现代风之后的西湖，好像也只有那千古继承的湖波和岸边的依依杨柳，才是最出的风光，也才能给人更多的古韵遐想。 &nbsp;&nbsp;&nbsp;&nbsp;前两天，收拾了下行李，发现这几年来，增加的除了体重之外，还有那些零碎的东西。当初一个背包就来到这座陌生的城市，而现在再想一两个背包离开却没那么容易。各季的衣服，一些娱乐的玩具，当时信誓旦旦买来健身结果缺在角落吃灰的器材，还有哪些九成多新的各类书籍，七七八八的对扎在一起，却是颇为可观。又那么些东西，准备就这么舍去，却没有那么干脆，好歹这孤身的岁月中，它们终究是发挥了些许作用；话说直接扔掉，过于凉薄了些，当然最主要的原因还是荷包过于羞涩了。匆匆而来总是容易，想要匆匆而去，往往并没有那么干脆。 &nbsp;&nbsp;&nbsp;&nbsp;在杭州待了三年，仔细想想，对杭州这座城市的了解，好像并不太多。玩耍的地方，总是围绕着西湖展开。一年四季的西湖景色，有嫩牙初长成的初春时节风景；也有炎炎下一池荷叶碧波摇曳的酷暑夏日；还是喜欢秋日的荫凉，微风吹拂下的粼粼湖光，在水雾中朦朦胧胧的雷峰塔和飞来峰；当然也离不开被所有人津津乐道的断桥残雪。这些年，西湖边上演绎了多少故事，又迎来送往了多少代人呢。不知以后再次踏足，会是何年岁月。西湖边上的雷峰塔，飞来峰中的灵隐寺，龙井村里盘绕的茶园，西溪湿地的芦苇飞鸟，钱塘江上的滚滚潮水，想想这些景色风光，算不上绝色秀丽，却也别有一般风光。 &nbsp;&nbsp;&nbsp;&nbsp;很多年都没有写过东西了，笔也都不大会握，稍微写一会，手就酸的不行。除了思想会僵化，这手腕看来也不甘落后。想说些什么，然而却找不到什么主题。最终只化作简简单单的几个字，“匆匆而来，流连而去” by 一灰灰 | 2018.04.18","categories":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}],"tags":[{"name":"小记","slug":"小记","permalink":"https://zbang.online/hexblog/tags/小记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}]},{"title":"Java 借助ImageMagic实现图片编辑服务","slug":"Java-借助ImageMagic实现图片编辑服务","date":"2018-04-17T08:07:08.000Z","updated":"2018-04-17T08:13:16.802Z","comments":true,"path":"2018/04/17/Java-借助ImageMagic实现图片编辑服务/","link":"","permalink":"https://zbang.online/hexblog/2018/04/17/Java-借助ImageMagic实现图片编辑服务/","excerpt":"","text":"Java 借助ImageMagic实现图片编辑服务java原生对于图片的编辑处理并没有特别友好，而且问题也有不少，那么作为一个java后端，如果要提供图片的编辑服务可以怎么办？也得想办法去支持业务需求，本片博文基于此进行展开 I. 调研首先最容易想到的就是目前是不是已经有了相关的开源库，直接用不就很high了嘛，git上搜一下 1. thumbnailator差不多四年都没有更新了，基于awt进行图片的编辑处理，目前提供了基本的图片编辑接口，开始用了一段时间，有几个绕不够去的坑，所以最后放弃了 使用姿势： 12345&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; 一个使用case: 123456BufferedImage originalImage = ImageIO.read(new File(\"original.jpg\"));BufferedImage thumbnail = Thumbnails.of(originalImage) .size(200, 200) .rotate(90) .asBufferedImage(); 问题说明： jpg图片编辑后，输出图片变红的问题（详情参考：兼容ImageIO读取jpeg图片变红） 图片精度丢失（对于精度要求较高的场景下，直接使用Jdk的BufferedImage会丢失精度） 上面两个问题中，第二个精度丢失在某些对图片质量有要求的场景下比较严重，如果业务场景没那么将就的话，用这个库还是可以减少很多事情的，下面基于ImageMagic的接口设计，很大程度上参考了该工程的使用规范，因为使用起来（+阅读）确实特别顺畅 2. simpleimage阿里的开源库，文档极其欠缺，而且良久没有人维护，没有实际使用过，感觉属于玩票的性质（个人猜测是KPI为导向下的产物） 如果想造轮子的话，参考它的源码，某些图片的处理方案还是不错的 3. imagemagic + im4javaImageMagic/GraphicMagic 是c++的图象处理软件，很多服务基于此来搭建图片处理服务的 优点：稳定、性能高、支持接口多、开箱即用、靠谱 缺点：得提前配置环境，基本上改造不动，内部有问题也没辙 这个方法也是下面的主要讲述重点，放弃Thumbnailator选择imagemagic的原因如下： 支持更多的服务功能（比Thumbnailator多很多的接口） 没有精度丢失问题 没有图片失真问题（颜色变化，alpha值变化问题） II. 环境准备首先得安装ImageMagic环境，有不少的第三方依赖，下面提供linux和mac的安装过程 1. linux安装过程123456789101112131415161718# 依赖安装yum install libjpeg-develyum install libpng-develyum install libwebp-devel## 也可以使用源码方式安装安装jpeg 包 `wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz`安装webp 包 `wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz`安装png 包 `wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz`## 下载并安装ImageMagicwget http://www.imagemagick.org/download/ImageMagick.tar.gztar -zxvf ImageMagick.tar.gzcd ImageMagick-7.0.7-28./configure; sudo make; sudo make install 安装完毕之后，进行测试 1234567$ convert --versionVersion: ImageMagick 7.0.7-28 Q16 x86_64 2018-04-17 http://www.imagemagick.orgCopyright: © 1999-2018 ImageMagick Studio LLCLicense: http://www.imagemagick.org/script/license.phpFeatures: Cipher DPC HDRI OpenMPDelegates (built-in): fontconfig freetype jng jpeg lzma png webp x xml zlib 2. mac安装过程依赖安装 12345sudo brew install jpegsudo brew install libpngsudo brew install libwebpsudo brew install GraphicsMagicksudo brew install ImageMagick 源码安装方式与上面一致 3. 问题及修复如果安装完毕之后，可能会出现下面的问题 提示找不到png依赖: 安装：一直找不到 png的依赖，查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz 执行 convert 提示linux shared libraries 不包含某个库 临时方案：export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 永久方案： 123vi /etc/ld.so.conf在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置然后再执行/sbin/ldconf 4. 常见Convert命令imagemagic的场景使用命令如下 裁图 convert test.jpg -crop 640x960+0+0 output.jpg 旋转 convert test.jpg -rotate 90 output.jpg 缩放 convert test.jpg -resize 200x200 output.jpg 强制宽高缩放 convert test.jpg -resize 200x200! output.jpg 缩略图 convert -thumbnail 200x300 test.jpg thumb.jpg 上下翻转： convert -flip foo.png bar.png 左右翻转： convert -flop foo.png bar.png 水印： composite -gravity northwest -dissolve 100 -geometry +0+0 water.png temp.jpg out.jpg 添加边框 : convert -border 6x6 -bordercolor “#ffffff” test.jpg bord.jpg 去除边框 : convert -thumbnail 200x300 test.jpg thumb.jpg III. 接口设计与实现java调用ImageMagic的方式有两种，一个是基于命令行的，一种是基于JNI的，我们选则im4java来操作imagemagic的接口（基于命令行的操作） 目标： 对外的使用姿势尽可能如 Thumbnailtor，采用builder模式来设置参数，支持多种输入输出 1. im4java使用姿势几个简单的case，演示下如何使用im4java实现图片的操作 1234567891011121314151617181920212223242526272829303132333435363738394041IMOperation op = new IMOperation();// 裁剪op.crop(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY());// 旋转op.rotate(rotate);// 压缩op.resize(operate.getWidth(), operate.getHeight());op.quality(operate.getQuality().doubleValue()); // 精度// 翻转op.flip();// 镜像op.flop();// 水印op.geometry(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY()).composite();// 边框op.border(operate.getWidth(), operate.getHeight()).bordercolor(operate.getColor());// 原始命令方式添加op.addRawArgs(\"-resize\", \"!100x200\");// 添加原始图片地址op.addImage(sourceFilename);// 目标图片地址op.addImage(outputFilename);/** 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 */ConvertCmd convert = new ConvertCmd();convert.run(op); 2. 使用姿势在具体的设计接口之前，不妨先看一下最终的使用姿势，然后逆向的再看是如何设计的 123456789101112131415161718192021private static final String localFile = \"blogInfoV2.png\";/** * 复合操作 */@Testpublic void testOperate() &#123; BufferedImage img; try &#123; img = ImgWrapper.of(localFile) .board(10, 10, \"red\") .flip() .rotate(180) .crop(0, 0, 1200, 500) .asImg(); System.out.println(\"--- \" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 上面这个方法，演示了图片的多个操作，首先是加个红色边框，然后翻转，然后旋转180°，再裁剪输出图片 所以这个封装，肯定是使用了Builder模式了，接下来看下配置参数 3. 接口设计首先确定目前支持的几个方法：OperateType 其次就是相关的配置参数： Operate&lt;T&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136@Datapublic static class Operate&lt;T&gt; &#123; /** * 操作类型 */ private OperateType operateType; /** * 裁剪宽; 缩放宽 */ private Integer width; /** * 高 */ private Integer height; /** * 裁剪时,起始 x */ private Integer x; /** * 裁剪时,起始y */ private Integer y; /** * 旋转角度 */ private Double rotate; /** * 按照整体的缩放参数, 1 表示不变, 和裁剪一起使用 */ private Double radio; /** * 图片精度, 1 - 100 */ private Integer quality; /** * 颜色 (添加边框中的颜色; 去除图片中某颜色) */ private String color; /** * 水印图片, 可以为图片名, uri, 或者inputstream */ private T water; /** * 水印图片的类型 */ private String waterImgType; /** * 强制按照给定的参数进行压缩 */ private boolean forceScale; public boolean valid() &#123; switch (operateType) &#123; case CROP: return width != null &amp;&amp; height != null &amp;&amp; x != null &amp;&amp; y != null; case SCALE: return width != null || height != null || radio != null; case ROTATE: return rotate != null; case WATER: // 暂时不支持水印操作 return water != null; case BOARD: if (width == null) &#123; width = 3; &#125; if (height == null) &#123; height = 3; &#125; if (color == null) &#123; color = \"#ffffff\"; &#125; case FLIP: case FLOP: return true; default: return false; &#125; &#125; /** * 获取水印图片的路径 * * @return */ public String getWaterFilename() throws ImgOperateException &#123; try &#123; return FileWriteUtil.saveFile(water, waterImgType).getAbsFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;public enum OperateType &#123; /** * 裁剪 */ CROP, /** * 缩放 */ SCALE, /** * 旋转 */ ROTATE, /** * 水印 */ WATER, /** * 上下翻转 */ FLIP, /** * 水平翻转 */ FLOP, /** * 添加边框 */ BOARD;&#125; 4. Builder实现简化使用成本，因此针对图片裁剪、旋转等接口，封装了更友好的接口方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314public static class Builder&lt;T&gt; &#123; private T sourceFile; /** * 图片类型 JPEG, PNG, GIF ... * &lt;p&gt; * 默认为jpg图片 */ private String outputFormat = \"jpg\"; private List&lt;Operate&gt; operates = new ArrayList&lt;&gt;(); public Builder(T sourceFile) &#123; this.sourceFile = sourceFile; &#125; private static Builder&lt;String&gt; ofString(String str) &#123; return new Builder&lt;String&gt;(ImgWrapper.class.getClassLoader().getResource(str).getFile()); &#125; private static Builder&lt;URI&gt; ofUrl(URI url) &#123; return new Builder&lt;URI&gt;(url); &#125; private static Builder&lt;InputStream&gt; ofStream(InputStream stream) &#123; return new Builder&lt;InputStream&gt;(stream); &#125; /** * 设置输出的文件格式 * * @param format * @return */ public Builder&lt;T&gt; setOutputFormat(String format) &#123; this.outputFormat = format; return this; &#125; private void updateOutputFormat(String originType) &#123; if (this.outputFormat != null || originType == null) &#123; return; &#125; int index = originType.lastIndexOf(\".\"); if (index &lt;= 0) &#123; return; &#125; this.outputFormat = originType.substring(index + 1); &#125; /** * 缩放 * * @param width * @param height * @return */ public Builder&lt;T&gt; scale(Integer width, Integer height, Integer quality) &#123; return scale(width, height, quality, false); &#125; public Builder&lt;T&gt; scale(Integer width, Integer height, Integer quality, boolean forceScale) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.SCALE); operate.setWidth(width); operate.setHeight(height); operate.setQuality(quality); operate.setForceScale(forceScale); operates.add(operate); return this; &#125; /** * 按照比例进行缩放 * * @param radio 1.0 表示不缩放, 0.5 缩放为一半 * @return */ public Builder&lt;T&gt; scale(Double radio, Integer quality) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.SCALE); operate.setRadio(radio); operate.setQuality(quality); operates.add(operate); return this; &#125; /** * 裁剪 * * @param x * @param y * @param width * @param height * @return */ public Builder&lt;T&gt; crop(int x, int y, int width, int height) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.CROP); operate.setWidth(width); operate.setHeight(height); operate.setX(x); operate.setY(y); operates.add(operate); return this; &#125; /** * 旋转 * * @param rotate * @return */ public Builder&lt;T&gt; rotate(double rotate) &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.ROTATE); operate.setRotate(rotate); operates.add(operate); return this; &#125; /** * 上下翻转 * * @return */ public Builder&lt;T&gt; flip() &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.FLIP); operates.add(operate); return this; &#125; /** * 左右翻转,即镜像 * * @return */ public Builder&lt;T&gt; flop() &#123; Operate operate = new Operate(); operate.setOperateType(OperateType.FLOP); operates.add(operate); return this; &#125; /** * 添加边框 * * @param width 边框的宽 * @param height 边框的高 * @param color 边框的填充色 * @return */ public Builder&lt;T&gt; board(Integer width, Integer height, String color) &#123; Operate args = new Operate(); args.setOperateType(OperateType.BOARD); args.setWidth(width); args.setHeight(height); args.setColor(color); operates.add(args); return this; &#125; /** * 添加水印 * * @param water 水印的源图片 (默认为png格式) * @param x 添加到目标图片的x坐标 * @param y 添加到目标图片的y坐标 * @param &lt;U&gt; * @return */ public &lt;U&gt; Builder&lt;T&gt; water(U water, int x, int y) &#123; return water(water, \"png\", x, y); &#125; /** * 添加水印 * * @param water * @param imgType 水印图片的类型; 当传入的为inputStream时, 此参数才有意义 * @param x * @param y * @param &lt;U&gt; * @return */ public &lt;U&gt; Builder&lt;T&gt; water(U water, String imgType, int x, int y) &#123; Operate&lt;U&gt; operate = new Operate&lt;&gt;(); operate.setOperateType(OperateType.WATER); operate.setX(x); operate.setY(y); operate.setWater(water); operate.setWaterImgType(imgType); operates.add(operate); return this; &#125; /** * 执行图片处理, 并保存文件为: 源文件_out.jpg （类型由输出的图片类型决定） * * @return 保存的文件名 * @throws Exception */ public String toFile() throws Exception &#123; return toFile(null); &#125; /** * 执行图片处理,并将结果保存为指定文件名的file * * @param outputFilename 若为null, 则输出文件为 源文件_out.jpg 这种格式 * @return * @throws Exception */ public String toFile(String outputFilename) throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operates null!\"); &#125; /** * 获取原始的图片信息， 并构建输出文件名 * 1. 远程图片，则保存到临时目录下 * 2. stream， 保存到临时目录下 * 3. 本地文件 * * 输出文件都放在临时文件夹内，和原文件同名，加一个_out进行区分 **/ FileWriteUtil.FileInfo sourceFile = createFile(); if (outputFilename == null) &#123; outputFilename = FileWriteUtil.getTmpPath() + \"/\" + sourceFile.getFilename() + \"_\" + System.currentTimeMillis() + \"_out.\" + outputFormat; &#125; /** 执行图片的操作 */ if (ImgBaseOperate.operate(operates, sourceFile.getAbsFile(), outputFilename)) &#123; return outputFilename; &#125; else &#123; return null; &#125; &#125; /** * 执行图片操作,并输出字节流 * * @return * @throws Exception */ public InputStream asStream() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return new FileInputStream(new File(outputFilename)); &#125; public byte[] asBytes() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return BytesTool.file2bytes(outputFilename); &#125; public BufferedImage asImg() throws Exception &#123; if (CollectionUtils.isEmpty(operates)) &#123; throw new ImgOperateException(\"operate null!\"); &#125; String outputFilename = this.toFile(); if (StringUtils.isBlank(outputFilename)) &#123; return null; &#125; return ImageIO.read(new File(outputFilename)); &#125; private FileWriteUtil.FileInfo createFile() throws Exception &#123; if (this.sourceFile instanceof String) &#123; /** 生成的文件在源文件目录下 */ updateOutputFormat((String) this.sourceFile); &#125; else if (this.sourceFile instanceof URI) &#123; /** 源文件和生成的文件都保存在临时目录下 */ String urlPath = ((URI) this.sourceFile).getPath(); updateOutputFormat(urlPath); &#125; return FileWriteUtil.saveFile(this.sourceFile, outputFormat); &#125;&#125; 参数的设置相关的比较清晰，唯一需要注意的是输出asFile()，这个里面实现了一些有意思的东西 保存原图片（将网络/二进制的原图，保存到本地） 生成临时输出文件 命令执行 上面前两个，主要是借助辅助工具 FileWriteUtil实现，与主题的关联不大，但是内部东西还是很有意思的，推荐查看： https://github.com/liuyueyi/quick-media/blob/master/plugins/base-plugin/src/main/java/com/github/hui/quick/plugin/base/FileWriteUtil.java 命令执行的封装如下(就是解析Operate参数，翻译成对应的IMOperation) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * 执行图片的复合操作 * * @param operates * @param sourceFilename 原始图片名 * @param outputFilename 生成图片名 * @return * @throws ImgOperateException */public static boolean operate(List&lt;ImgWrapper.Builder.Operate&gt; operates, String sourceFilename, String outputFilename) throws ImgOperateException &#123; try &#123; IMOperation op = new IMOperation(); boolean operateTag = false; String waterFilename = null; for (ImgWrapper.Builder.Operate operate : operates) &#123; if (!operate.valid()) &#123; continue; &#125; if (operate.getOperateType() == ImgWrapper.Builder.OperateType.CROP) &#123; op.crop(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY());// if (operate.getRadio() != null &amp;&amp; Math.abs(operate.getRadio() - 1.0) &gt; 0.005) &#123;// // 需要对图片进行缩放// op.resize((int) Math.ceil(operate.getWidth() * operate.getRadio()));// &#125; operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.ROTATE) &#123; // fixme 180度旋转后裁图,会出现bug, 先这么兼容 double rotate = operate.getRotate(); if (Math.abs((rotate % 360) - 180) &lt;= 0.005) &#123; rotate += 0.01; &#125; op.rotate(rotate); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.SCALE) &#123; if (operate.getRadio() == null) &#123; if (operate.isForceScale()) &#123; // 强制根据给定的参数进行压缩时 StringBuilder builder = new StringBuilder(); builder.append(\"!\").append(operate.getWidth() == null ? \"\" : operate.getWidth()).append(\"x\"); builder.append(operate.getHeight() == null ? \"\" : operate.getHeight()); op.addRawArgs(\"-resize\", builder.toString()); &#125; else &#123; op.resize(operate.getWidth(), operate.getHeight()); &#125; &#125; else if(Math.abs(operate.getRadio() - 1) &gt; 0.005) &#123; // 对图片进行比例缩放 op.addRawArgs(\"-resize\", \"%\" + (operate.getRadio() * 100)); &#125; if (operate.getQuality() != null &amp;&amp; operate.getQuality() &gt; 0) &#123; op.quality(operate.getQuality().doubleValue()); &#125; operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.FLIP) &#123; op.flip(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.FLOP) &#123; op.flop(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.WATER &amp;&amp; waterFilename == null) &#123; // 当前只支持添加一次水印 op.geometry(operate.getWidth(), operate.getHeight(), operate.getX(), operate.getY()) .composite(); waterFilename = operate.getWaterFilename(); operateTag = true; &#125; else if (operate.getOperateType() == ImgWrapper.Builder.OperateType.BOARD) &#123; op.border(operate.getWidth(), operate.getHeight()).bordercolor(operate.getColor()); operateTag = true; &#125; &#125; if (!operateTag) &#123; throw new ImgOperateException(\"operate illegal! operates: \" + operates); &#125; op.addImage(sourceFilename); if (waterFilename != null) &#123; op.addImage(waterFilename); &#125; op.addImage(outputFilename); /** 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 */ ConvertCmd convert = new ConvertCmd(); convert.run(op); &#125; catch (IOException e) &#123; log.error(\"file read error!, e: &#123;&#125;\", e); return false; &#125; catch (InterruptedException e) &#123; log.error(\"interrupt exception! e: &#123;&#125;\", e); return false; &#125; catch (IM4JavaException e) &#123; log.error(\"im4java exception! e: &#123;&#125;\", e); return false; &#125; return true;&#125; 5. 接口封装包装一个对外使用的方式 1234567891011121314151617181920212223242526272829303132public class ImgWrapper &#123; /** * 根据本地图片进行处理 * * @param file * @return */ public static Builder&lt;String&gt; of(String file) &#123; checkForNull(file, \"Cannot specify null for input file.\"); if (file.startsWith(\"http\")) &#123; throw new IllegalArgumentException(\"file should not be URI resources! file: \" + file); &#125; return Builder.ofString(file); &#125; public static Builder&lt;URI&gt; of(URI uri) &#123; checkForNull(uri, \"Cannot specify null for input uri.\"); return Builder.ofUrl(uri); &#125; public static Builder&lt;InputStream&gt; of(InputStream inputStream) &#123; checkForNull(inputStream, \"Cannot specify null for InputStream.\"); return Builder.ofStream(inputStream); &#125; private static void checkForNull(Object o, String message) &#123; if (o == null) &#123; throw new NullPointerException(message); &#125; &#125;&#125; IV. 测试上面基本上完成了整个接口的设计与实现，接下来就是接口测试了 给出几个使用姿势演示，更多可以查看：ImgWrapperTest 123456789101112131415161718192021222324252627282930313233343536373839404142private static final String url = \"http://a.hiphotos.baidu.com/image/pic/item/14ce36d3d539b6006a6cc5d0e550352ac65cb733.jpg\";private static final String localFile = \"blogInfoV2.png\";@Testpublic void testCutImg() &#123; try &#123; // 保存到本地 ImgWrapper.of(URI.create(url)) .crop(10, 20, 500, 500) .toFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;@Testpublic void testRotateImg() &#123; try &#123; InputStream stream = FileReadUtil.getStreamByFileName(localFile); BufferedImage img = ImgWrapper.of(stream).rotate(90).asImg(); System.out.println(\"----\" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;@Testpublic void testWater() &#123; BufferedImage img; try &#123; img = ImgWrapper.of(URI.create(url)) .board(10, 10, \"red\") .water(localFile, 100, 100) .asImg(); System.out.println(\"--- \" + img); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; V. 其他项目：GitHub: 项目：Quick-Media 源码：imagic-plugin Gitee: 项目：Quick-Media 源码：imagic-plugin 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickMedia","slug":"技术/Quick系列项目/QuickMedia","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickMedia/"}],"tags":[{"name":"ImageMagic","slug":"ImageMagic","permalink":"https://zbang.online/hexblog/tags/ImageMagic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickMedia","slug":"技术/Quick系列项目/QuickMedia","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickMedia/"}]},{"title":"CSS图片点击拷贝","slug":"CSS图片点击拷贝","date":"2018-04-16T09:24:55.000Z","updated":"2018-04-16T09:28:48.391Z","comments":true,"path":"2018/04/16/CSS图片点击拷贝/","link":"","permalink":"https://zbang.online/hexblog/2018/04/16/CSS图片点击拷贝/","excerpt":"","text":"I. CSS图片点击拷贝点击实现文本or图片的复制， 主要利用 document.execCommand(&#39;Copy&#39;)来实现 1234567891011121314151617181920212223&lt;script type=\"text/javascript\"&gt;function copy2board()&#123; var Url2=document.getElementById(\"biao1\"); Url2.select(); // 选择对象 document.execCommand(\"Copy\"); // 执行浏览器复制命令 alert(\"已复制好，可贴粘。\");&#125;function copyimg(e) &#123; var range = document.createRange(); range.selectNode(e); //selectable为下面页面中DIV中的id window.getSelection().addRange(range); document.execCommand(\"Copy\"); alert(\"复制ok\");&#125;&lt;/script&gt;&lt;textarea cols=\"20\" rows=\"10\" id=\"biao1\"&gt;用户定义的代码区域&lt;/textarea&gt;&lt;input type=\"button\" onClick=\"copy2board()\" value=\"点击复制代码\" /&gt;&lt;img src=\"http://a.hiphotos.baidu.com/image/pic/item/8326cffc1e178a82112604dffa03738da977e8b3.jpg\" width=200 height=200 onclick=\"copyimg(this)\"&gt;&lt;/img&gt; II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"拷贝","slug":"拷贝","permalink":"https://zbang.online/hexblog/tags/拷贝/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"生产环境分库分表的实际操作全记录","slug":"生产环境分库分表的实际操作全记录","date":"2018-04-13T08:46:09.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2018/04/13/生产环境分库分表的实际操作全记录/","link":"","permalink":"https://zbang.online/hexblog/2018/04/13/生产环境分库分表的实际操作全记录/","excerpt":"一次分库分表全过程记录实际操刀过一次线上的分库分表，距离现在时间有点久了，现在想一想，发现还是有不少有意思的东西，所以来一个迟到的记录","text":"一次分库分表全过程记录实际操刀过一次线上的分库分表，距离现在时间有点久了，现在想一想，发现还是有不少有意思的东西，所以来一个迟到的记录 I. 背景分析当时主要负责商品评价这一块业务，评价信息单表存储，主要包括一些基本的评价信息，商品id，订单id，买家id和卖家id，当时DB量级已经在3-4亿了，经常出现一些慢SQL，考虑到量级的问题，所以着手分库分表 1. 分库分表首先知道分库分表一般有两种方式，水平划分和垂直划分 在具体划分，可如下 垂直分表：将大表拆分成小表，将表中一些不常用的信息拆分出去，避免跨页查询 垂直分库：根据不同的业务进行划分，每个业务有自己独立的数据库，如商品有商品库，用户有用户库，店铺有店铺库，db与db之间物理or逻辑分离 水平分表：根据表中某些数据行，定义某种映射规则，将不同的数据行分布到不同的表中（表的结构基本不变） 水平分库分表：将水平分表拆分出来的分表，放入不同的库中 2. 业务场景分析根据上面分库分表的理解，很容易得出一个期待的结果 独立的评价库，这个库里面只保存评价相关的信息 采用水平分表，将原表的数据，拆分到1024(这个分表数量可自定义)张分表中（如果拆分的较合理，则单表数据量在30-40w） 那么一个问题就是如何进行水平拆分了，而考虑这一点，则需要根据实际的场景出发，分析sql的case 商品详情的评价查询：根据商品ID进行查询 卖家管理端查询所有评价：根据卖家ID进行查询 买家评价管理：根据买家ID进行查询 订单列表的评价信息：根据订单ID进行查询 粗略可以设定两种分表方案： 方案一：上面四种场景，显然是根据商品ID查询的量最大（因为详情的流量最大），如果根据商品ID进行分表，那么一个商品的评价都在落在一个分表中，此时查询不会出现夸表，但是另外三中查询则会导致跨表；同样换成卖家ID则会导致其他三个查询会跨表 第二种方式，建立一张附表，只保存如下信息 12345rateId: 评价IDitemId: 商品IDsellerId: 卖家IDbuyerId: 买家IDorderId: 订单ID 然后根据rateId进行分库分表，这样每次查询时，先通过附表，查询到对应的评价ID，然后拿rateId到分表去获取评价信息 3. 基本信息在实际的操作之前，先给出当时的表信息（说明，数据库和表名和表结构为本文定义，与实际有差异） define desc 数据库 mysql 存储引擎 innorDB 库名 rate 表名 ItemRate 量级 3-4亿 binlog 开启binlog消息，有下游业务方通过mq方式消费db的变更 表结构类似下表，干掉了很多与主题无关的信息 12345678910111213CREATE TABLE `ItemRate` ( `id` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;评价id&apos;, `orderId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;订单id&apos;, `buyerId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;买家ID&apos;, `sellerId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;卖家ID&apos;, `itemId` bigint(20) unsigned NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;商品ID&apos;, `comment` varchar(1000) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;评价内容&apos;, `imgUrls` varchar(500) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;上传的图片&apos;, `created` int(11) unsigned NOT NULL DEFAULT &apos;0&apos;, `updated` int(11) unsigned NOT NULL DEFAULT &apos;0&apos;, `info` tinyint(4) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;其他信息，省略...&apos;, PRIMARY KEY `id` (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT=&apos;评价表&apos;; II. 设计&amp;实现在实际操作之前，首先是选择如何分库分表的方案了，其次就是整个操作的步骤规划，当这两个搞定之后，在开始编码实现才是比较合适的 首先确定分4库1024张表 （组内大神的建议，合理分表规则后单表量级在10w级别，业务没有大变化时，短期内将无序再次分表） 1. 方案设计前面业务场景的分析中，就给出了两种方式，一个是根据商品ID进行分表，一个是建立一个附表然后根据rateId进行分表，首先是分表规则，我们选择最简单的方式，根据id % 1024进行取模 接下来分析下两种的优劣 a. itemID分表方案优点： 相比与下一种而言，实现简单，无需附表，也不用考虑数据不一致问题 可以支持详情评价列表复杂的排序逻辑（当时排序方案不是离线计算的，走的DB的排序方式） 性能更优，少了一张附表的过渡 缺点： 非itemId查询会跨表 hash不均，导致单表量较多（比如可能出现某些爆款商品就有几十万的评价） b. rateId分表方案优点： 支持前面的几种查询场景，不过需要先查询出rateId 单表数据量分布均匀 缺点： 复杂的查询条件支持不友好，特别是排序，过滤等依赖到一些评价信息的场景 插入和更新时，都需要同步更新附表，这个保证复杂性更高（即要满足多表的事务，需要自己实现失败回滚） 每次查询都需要先通过附表查询rateIds，效率更低（公司内的数据库中间件不允许join查询） c. 方案选择通过实际分析，选择了根据itemId进行分表的方案，理由如下： 业务逻辑简单，后续维护也方便 线上的sql中，95%以上都是根据itemId进行查询 上层有一层根据solr的搜索，因此根据buyerId,sellerId,orderId 可以走搜索，不需进行db的多表联合查询，且性能ok 附表虽然结构简单，但是单表最终的数据量依然可能很大，在亿级已上性能怎样也不好保证 因此，最终选择的方式是： 1234567db ： Rate000 ~ Rate003, table ： ItemRate0000 ~ ItemRaet1023其中映射规则：tableIndex = itemId % 1024 ---&gt; 分表名 如 ItemRate0122dbIndex = itemId % 1024 / 256 ---&gt; 分库名 如 Rate001 2. 步骤计划整个迁移的步骤，有两种方式，一个是双写方案： 方案一：采用双写 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 线上开始双写（即新增一条评价时，即写入就得表，也写入新的表） 全量将旧表数据导入到新表数据 线上读流量切换到新表，验证是否有问题 所有关注旧表binlog的业务，全部迁移到关注新表的binlog（这里需要dba支持，因为新表有1024张，不可能关注1024个topic，这里需要dba提供binlog的整合，不在本文重点，此处略过） 关闭双写，所有写直接切到新表 删除旧代码 方案二：基于db的binlog实现的异步同步方式 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 开启增量，将某个时刻开始之后所有更新的数据，通过异步方式增量同步到新表 开始全量，将之前的数据全部导入到新表 线上读切新表，验证服务是否有问题 所有关注旧表binlog业务，全部迁移到关注新表binlog 线上切写到新表 增量完毕后，关闭增量 删除旧代码 两种方案本质上没有太大的区别，其中第一种双写，需要自己来保障双写成功；而后面增量的方式，一般DBA这边会有较好的方案来实现增量同步 额外说一点, 在实际的场景中，推动接听旧表binlog的业务方迁移是一件不可控的操作（因为啥原因大家都懂得），所以当时实际的情况是切到新表后，还会进行反向同步，即将新表的数据又重新的写入到旧表中，因此这种场景要求方案二中，切写到新表时，需要先停写一段时间，等待增量同步完毕之后，关闭增量，然后开启反向同步脚本，然后再切写 因为停写，对业务会有影响，所以当时采取第一种方案，因为反向同步不再本文重点，所以如果不考虑反向同步的情况，上面两种方式没有什么区别 3. 注意事项 全量迁移，如果dba没有提供相关工具的话，就只能自己写了，当时是找了一台机器，部署了个服务利用jdbcTemplate来扫表，实现全量数据插入 双写时，需要注意，如果双写失败应该怎么办 数据对账比较有必要 III. 小结1. 分库分表 一般而言，当量级达到qw时，就该考虑分库分表了，不同的业务有自己独立的库 根据表中某些列进行分表，将大表数据拆分到分表中 大表拆分为小表 2. 一般实现步骤 创建DB 服务的sql改造，主要是所有的sql，都要有一个新的分库分表的方式 线上开始双写 全量将旧表数据导入到新表数据 线上读流量切换到新表，验证是否有问题 关闭双写，所有写直接切到新表 删除旧代码 IV. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"分库分表","slug":"工作/分库分表","permalink":"https://zbang.online/hexblog/categories/工作/分库分表/"}],"tags":[{"name":"分库分表","slug":"分库分表","permalink":"https://zbang.online/hexblog/tags/分库分表/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"分库分表","slug":"工作/分库分表","permalink":"https://zbang.online/hexblog/categories/工作/分库分表/"}]},{"title":"Mybatis框架学习之使用篇二：标签语法","slug":"Mybatis框架学习之使用篇二：标签语法","date":"2018-04-11T03:43:14.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/11/Mybatis框架学习之使用篇二：标签语法/","link":"","permalink":"https://zbang.online/hexblog/2018/04/11/Mybatis框架学习之使用篇二：标签语法/","excerpt":"Mybatis框架学习之使用篇二：标签语法常用标签的使用姿势小结及参数绑定的三种方式 select update delete insert choose, when, otherwise if bind foreach trim set where","text":"Mybatis框架学习之使用篇二：标签语法常用标签的使用姿势小结及参数绑定的三种方式 select update delete insert choose, when, otherwise if bind foreach trim set where I. 结构标签xml中，一般常见的写法如下 123&lt;select id=\"selectByPrimaryKey\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.String\" &gt; selext * from xxx where ...&lt;/select&gt; 1. 结构说明分析上面的demo，三个参数比较重要 id：与dao层接口中定义的方法对应，不允许出现相同id的case resultMap: 出参 resultType: 出参类型 parameterType：传参类型 2. sql片段定义一般我们查询时，大多不建议直接使用 select * 的方式，而是具体的写上查询的列，然后一个问题就来了，每个查询都得写上一遍，不仅麻烦，对于后续表结构标定时，需要改的地方要多，所以就有了sql片段定义 ：通过该标签可定义能复用的sql语句片段，在执行sql语句标签中直接引用即可。这样既可以提高编码效率，还能有效简化代码，提高可读性 实际case 123456789101112131415&lt;sql id=\"poetryEntity\"&gt; id, title, author, content, `explain`, `type`, `tag`, `theme`, `is_deleted` as isDeleted, UNIX_TIMESTAMP(`created_at`) as created, UNIX_TIMESTAMP(`updated_at`) as updated&lt;/sql&gt;&lt;!-- 引用方式 --&gt;&lt;select id=\"queryPoetryById\" parameterType=\"long\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id=#&#123;id&#125;&lt;/select&gt; 3. 常见标签1234- &lt;select&gt; 表示这是一个查询sql- &lt;update&gt; 更新sql- &lt;delete&gt; 删除sql- &lt;insert&gt; 插入sql II. 内部标签1. where通常sql中，所有的where都可以被&lt;where&gt;替换，而这个标签的主要作用是为了防止sql可能出现的异常状况，如以下几种case a. case1 无查询条件1234select * from table where&lt;if test=\"id != null\"&gt; id = #&#123;id&#125;&lt;/if&gt; 当id不存在时，导致上面的sql被解析为 select * from table where, 显然这是一个非法sql b. case2 最前or最后的连接条件1234567select * from table where&lt;if test='id != null'&gt; id = #&#123;id&#125;&lt;/if&gt;&lt;if test='uname != null'&gt; and uname=#&#123;uname&#125;&lt;/if&gt; 当id不存在，uname存在时，上面的sql被解析为 select * from table where and uname=#{uname, 显然也是非法sql 所以，这种场景下，用&lt;where&gt;标签优势就很明显了，在解析时，会根据实际的sql，来决定是否有where，是否去掉前面和后面非法的and/or c. trim标签除了直接使用where标签之外，更常见的一个就是标签了， prefix：前缀 suffix：后缀 prefixOverrides：忽略第一个指定分隔符 suffixOverrides：会略最后一个分隔符 1234567891011121314&lt;select id=\"user\" parameterType=\"user\" resultType=\"User\"&gt; select * from user &lt;trim prefix=\"WHERE\" prefixoverride=\"and | or\"&gt; &lt;if test=\"id!=null and id!=''\"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"name!=null and name!=''\"&gt; and name=#&#123;name&#125; &lt;/if&gt; &lt;if test=\"gender!=null and gender!=''\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 2. foreach用于循环的场景，如常见的 xxx in (xxx, xxx) ，通常就是foreach来使用 collection：迭代的参数，一般是个列表or数组，值一般直接为参数名 index： 迭代过程中，元素的别称 open： 开始符号 如( close: 结束符号，如) separator：分割符号 一个实际case如下 接口为： 1List&lt;PoetryEntity&gt; queryPoetryByIds(@Param(\"ids\") List&lt;Long&gt; ids); 对应的sql为 123456789101112&lt;select id=\"queryPoetryByIds\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id IN &lt;foreach collection=\"ids\" index=\"index\" item=\"id\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;id&#125; &lt;/foreach&gt; limit 500&lt;/select&gt; 3. Choose选择标签，类似java中的switch，一旦其中一个条件匹配，整个choose块结束 一个xml如下 1234567891011121314151617181920&lt;select id=\"getUserList_choose\" resultMap=\"resultMap_user\" parameterType=\"com.yiibai.pojo.User\"&gt; SELECT * FROM User u &lt;where&gt; &lt;choose&gt; &lt;when test=\"username !=null \"&gt; u.username LIKE CONCAT(CONCAT('%', #&#123;username, jdbcType=VARCHAR&#125;),'%') &lt;/when &gt; &lt;when test=\"sex != null and sex != '' \"&gt; AND u.sex = #&#123;sex, jdbcType=INTEGER&#125; &lt;/when &gt; &lt;when test=\"birthday != null \"&gt; AND u.birthday = #&#123;birthday, jdbcType=DATE&#125; &lt;/when &gt; &lt;otherwise&gt; limit 10 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; mybatis的这个选择，基本上和我们的switch语句一样， 对应关系如下 1234567&lt;choose&gt; ---- switch&lt;when&gt;&lt;/when&gt; ---- case cond1&lt;when&gt;&lt;/when&gt; ---- case cond2&lt;otherwise&gt;&lt;/otherwise&gt; ---- default&lt;/choose&gt; 4. if条件判断，在拼装sql时，最常见的就是为了防止传入null的参数，导致拼出一个业务逻辑有问题的sql，用if标签就很有用了 使用姿势也比较简单了，主要是内部的test条件判断 123&lt;if test=\"sex != null and sex != ''\"&gt; and sex=#&#123;sex&#125;&lt;/if&gt; 5. set标签更新的时候使用，同样是为了解决拼装成的sql中，最前面or最后面的英文逗号 1234567891011121314&lt;update id=\"userUpdate\" parameterType=\"user\"&gt; update user &lt;set&gt; &lt;if test=\"id!=null and id!=''\"&gt; id=#&#123;id&#125;, &lt;/if&gt; &lt;if test=\"name!=null and name!=''\"&gt; name=#&#123;name&#125;, &lt;/if&gt; &lt;if test=\"gender!=null and gender!=''\"&gt; gender=#&#123;gender&#125;, &lt;/if&gt; &lt;/set&gt;&lt;/update&gt; 6. bindbind 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文 比如对于like查询，需要在参数的前面or后面加上 %， 就可以这么玩： 123456789&lt;select id=\"queryPoetryByContent\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; &lt;bind name=\"pattern\" value=\"'%' + content + '%'\" /&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where content LIKE #&#123;pattern&#125; limit 10&lt;/select&gt; 上面的也可以使用concat来做，如下 12345678&lt;select id=\"queryPoetryByContent\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where content LIKE CONCAT(CONCAT('%', #&#123;content&#125;), '%') limit 10&lt;/select&gt; III. 参数替换dao层的参数，是如何传入到xml中的sql语句的呢？ 1. map传递dao层接口参数为map，xml中可以直接通过map中的key，来绑定参数 1public User selectUser(Map paramMap); 假设传入的参数为两个，uname, password 对应的xml为 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;uname，jdbcType=VARCHAR&#125; and password=#&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; 2. 参数位置替换这种是直接根据参数的索引位置来绑定， {0} 表示第一个参数， {1} 表示第二个参数 1public User selectUser(String uname, String password); 对应的xml 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;0&#125; and password=#&#123;1&#125;&lt;/select&gt; 3. 注解指定方式通过 @Param注解，直接指定name，在sql中即可通过name方式引用 1public User selectUser(@Param(\"uname\") String uname, @Param(\"password\") String password); 对应的sql为 123&lt;select id=\" selectUser\" resultMap=\"BaseResultMap\"&gt; select * from users where uname = #&#123;uname，jdbcType=VARCHAR&#125; and password=#&#123;password,jdbcType=VARCHAR&#125;&lt;/select&gt; 4. $#区别使用#传入参数是，sql语句解析是会加上””, 比如 select * from table where name = #{name} ,传入的name为小李，那么最后打印出来的就是 select * from table where name = &quot;小李&quot;，就是会当成字符串来解析 因此在动态排序时，比如 order by column，这个时候务必要用${},因为如果你使用了#{} 区别 #将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号 $将传入的数据直接显示生成在sql中 #方式能够很大程度防止sql注入 $方式无法防止Sql注入 $方式一般用于传入数据库对象，例如传入表名，列名 简单来说，两者区别： $ 是sql替换，直接拼成一条可执行sql； # 是参数替换 IV. 其他项目工程 study-demo 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zbang.online/hexblog/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}]},{"title":"Mybatis框架学习之使用篇一：基本环境","slug":"Mybatis框架学习之使用篇一：基本环境","date":"2018-04-11T03:39:10.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/11/Mybatis框架学习之使用篇一：基本环境/","link":"","permalink":"https://zbang.online/hexblog/2018/04/11/Mybatis框架学习之使用篇一：基本环境/","excerpt":"Mybatis框架学习之使用篇主要介绍如何使用mybatis，来实现db的增删改查，通常mybatis一般是结合spring来使用，因此我们也不脱离这个大环境 主要内容将包括以下： 环境配置相关 Dao文件与xml的映射（接口绑定有两种，xml和注解方式，这里以xml方式进行说明） 增删改查的写法 常用命令 choose, if, set, …. #，$两种方式的区别","text":"Mybatis框架学习之使用篇主要介绍如何使用mybatis，来实现db的增删改查，通常mybatis一般是结合spring来使用，因此我们也不脱离这个大环境 主要内容将包括以下： 环境配置相关 Dao文件与xml的映射（接口绑定有两种，xml和注解方式，这里以xml方式进行说明） 增删改查的写法 常用命令 choose, if, set, …. #，$两种方式的区别 I. 前提准备在开始之前，先得准备好对应的环境，首先建立一个可有效运行的环境 依赖配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!-- mybatis 依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt;&lt;/dependency&gt;&lt;!-- druid数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 依赖相关--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 单测相关 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 这里采用druid来进行数据源的管理，目前仅作为一个使用工具，不深入探究 接下来就是xml的配置，如我们常见的jdbc链接相关的配置信息，一个demo如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;value&gt;classpath*:jdbc.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;property name=\"filters\" value=\"stat\"/&gt; &lt;property name=\"maxActive\" value=\"20\"/&gt; &lt;property name=\"initialSize\" value=\"1\"/&gt; &lt;property name=\"maxWait\" value=\"60000\"/&gt; &lt;property name=\"minIdle\" value=\"1\"/&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/&gt; &lt;property name=\"validationQuery\" value=\"SELECT 'x'\"/&gt; &lt;property name=\"testWhileIdle\" value=\"true\"/&gt; &lt;property name=\"testOnBorrow\" value=\"false\"/&gt; &lt;property name=\"testOnReturn\" value=\"false\"/&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\"/&gt; &lt;property name=\"maxPoolPreparedStatementPerConnectionSize\" value=\"50\"/&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!-- 指定mapper文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- 指定扫描dao --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.git.hui.demo.mybatis\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意上面的三个bean，一个dataSource, 主要配置一些db链接相关的参数，一个sqlSessionFactory, 属于bean工厂，用于创建一些Sql会话，里面一个非常重要的参数就是指定 mapperLocations 最终一个就是指定扫描dao的路径，这个不能忘，否则会发现无法注入dao II. 一个实例以一个实际的例子，演示dao与mapper文件的映射关系，以及调用姿势，首先定义DB实体类对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Datapublic class PoetryEntity implements Serializable &#123; private static final long serialVersionUID = 4888857290009801223L; private Long id; /** * 作者名 */ private String author; /** * 标题 */ private String title; /** * 内容 */ private String content; /** * 解释 */ private String explain; /** * 诗词的类型 0 成语，1 唐前诗词 */ private Integer type; /** * 标记，对应诗词的朝代 */ private Integer tag; /** * 诗词的题材，七言，五言等 */ private String theme; private Integer isDeleted; private Integer created; private Integer updated;&#125; dao文件 1234public interface PoetryDao &#123; PoetryEntity queryPoetryById(@Param(\"id\") Long id);&#125; 对应的xml文件 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.git.hui.demo.mybatis.mapper.PoetryDao\"&gt; &lt;sql id=\"poetryEntity\"&gt; id, title, author, content, `explain`, `type`, `tag`, `theme`, `is_deleted` as isDeleted, UNIX_TIMESTAMP(`created_at`) as created, UNIX_TIMESTAMP(`updated_at`) as updated &lt;/sql&gt; &lt;select id=\"queryPoetryById\" parameterType=\"long\" resultType=\"com.git.hui.demo.mybatis.entity.PoetryEntity\"&gt; select &lt;include refid=\"poetryEntity\"/&gt; from poetry where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试case 1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath*:spring/*.xml\")public class PoetryDaoTest &#123; @Autowired private PoetryDao poetryDao; @Test public void testGet() &#123; PoetryEntity entity = poetryDao.queryPoetryById(3L); System.out.println(\"query result: &#123;&#125;\" + entity); &#125;&#125; 看到上面自然就有一个疑问，定义的Dao接口，是如何和xml文件关联起来的呢？ 注意xml中的namespace，为dao的全限定名 注意xml中的sql标签中的id，与dao层定义的接口名完全一致 大胆的猜测一下，整个过程应该如下： mybatis通过前面配置文件指定的mapperLocations，扫描指定路径下的所有xml文件（即写sql逻辑的xml） MapperScannerConfigurer 这个bean定义了哪些属于Dao层接口 对所有的dao接口，根据动态代理的方式，生成一个Proxy类，由这个proxy类，将dao接口的方法与xml中定义的sql标签关联起来 dao接口的访问，实际由代理类执行，将xml定义的规则映射为对应的sql，然后交由底层封装好的jdbc来执行 实际上大致流程也是这样，从上面的描述，一个问题很容易抛出 dao层接口，不支持重载（因为会导致dao层接口与xml中的关联不上的问题） III. 其他项目工程 study-demo 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"https://zbang.online/hexblog/tags/mybatis/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mybatis","slug":"技术/DB/Mybatis","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mybatis/"}]},{"title":"Java实现邮件发送","slug":"Java实现邮件发送","date":"2018-04-10T02:43:42.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/10/Java实现邮件发送/","link":"","permalink":"https://zbang.online/hexblog/2018/04/10/Java实现邮件发送/","excerpt":"Java实现邮件发送在日常工作中，通过邮件或短信做报警或者信息推送的场景还是挺多的，而java中，常用的就是JavaMail来做这个事情了，到网上搜索了一把，发现apache有个commons email 的开源包，现在借助它来尝鲜一把","text":"Java实现邮件发送在日常工作中，通过邮件或短信做报警或者信息推送的场景还是挺多的，而java中，常用的就是JavaMail来做这个事情了，到网上搜索了一把，发现apache有个commons email 的开源包，现在借助它来尝鲜一把 简单使用添加pom依赖: 123456&lt;!--email 客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-email&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 查看使用帮助: http://commons.apache.org/proper/commons-email/userguide.html 1. 简单使用case1234567891011121314151617181920@Testpublic void testEmailSend() &#123; try &#123; Email email = new SimpleEmail(); email.setHostName(\"smtp.163.com\"); email.setSmtpPort(25); email.setAuthenticator(new DefaultAuthenticator(\"userName\", \"accessToken\")); email.setSSLOnConnect(true); email.setFrom(\"xhhuiblog@163.com\"); email.setCharset(\"utf-8\"); email.addTo(\"bangzewu@126.com\"); email.setSubject(\"邮件标题\"); email.setMsg(\"邮件内容\"); String ans = email.send(); System.out.println(ans); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 从实际的使用来看，还是比较简单的，设置一些必要的参数（host，端口，认证信息，fromEmail, toEmail, title, content） 额外需要注意的一点是，为了中文正常显示，请指定charset 2. html使用姿势更加常见的邮件发送是带有格式的，且有可能有附件，所以我们通常用的更多的是下面的方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private String template = \"&lt;html&gt;&lt;meta charset=utf-8&gt;\\n\" + \"\\n\" + \"&lt;style&gt;\\n\" + \"div.card &#123;\\n\" + \" background-color:white; \\n\" + \" box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\\n\" + \" text-align: center;\\n\" + \"&#125;\\n\" + \"\\n\" + \"div.header &#123;\\n\" + \" background-color: #4CAF50;\\n\" + \" box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);\\n\" + \" color: white;\\n\" + \" padding: 10px;\\n\" + \" font-size: 40px;\\n\" + \"&#125;\\n\" + \"\\n\" + \"div.container &#123;\\n\" + \" padding: 10px;\\n\" + \"&#125;\\n\" + \"&lt;/style&gt;\\n\" + \"\\n\" + \"&lt;div class=\\\"card\\\"&gt;\\n\" + \" &lt;div class=\\\"header\\\"&gt;\\n\" + \" &lt;h1&gt;星期一&lt;/h1&gt;\\n\" + \" &lt;/div&gt;\\n\" + \"\\n\" + \" &lt;div class=\\\"container\\\"&gt;\\n\" + \" &lt;p&gt;2016.04.10&lt;/p&gt;\\n\" + \" &lt;/div&gt;\\n\" + \"&lt;/div&gt;\\n\" + \"&lt;/html&gt;\";@Testpublic void testHtmlEmailSend() &#123; try &#123; // Create the attachment EmailAttachment attachment = new EmailAttachment(); attachment.setURL(new URL(\"http://s11.mogucdn.com/mlcdn/c45406/180410_256l2egkgj3lfdkjkbf41b1i09l3f_1280x1280.jpg\")); attachment.setDisposition(EmailAttachment.ATTACHMENT); attachment.setDescription(\"公众号\"); attachment.setName(\"logo.jpg\"); HtmlEmail email = new HtmlEmail(); email.setCharset(\"UTF-8\"); email.setHostName(\"smtp.163.com\"); email.setSmtpPort(25); email.setAuthenticator(new DefaultAuthenticator(\"username\", \"token\")); email.setSSLOnConnect(true); email.setFrom(\"xhhuiblog@163.com\"); email.setSubject(\"TestMail\"); // 添加附件 email.attach(attachment); // set the html message email.setHtmlMsg(template); // set the alternative message email.setTextMsg(\"Your email client does not support HTML messages\"); email.addTo(\"bangzewu@126.com\"); String ans = email.send(); System.out.println(ans); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 邮件结果如下: II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Email","slug":"Email","permalink":"https://zbang.online/hexblog/tags/Email/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"基于ForkJoin构建一个简单易用的并发组件","slug":"基于ForkJoin构建一个简单易用的并发组件","date":"2018-04-09T02:03:04.000Z","updated":"2018-04-09T02:15:04.862Z","comments":true,"path":"2018/04/09/基于ForkJoin构建一个简单易用的并发组件/","link":"","permalink":"https://zbang.online/hexblog/2018/04/09/基于ForkJoin构建一个简单易用的并发组件/","excerpt":"基于ForkJoin构建一个简单易用的并发组件在实际的业务开发中，需要用到并发编程的知识，实际使用线程池来异步执行任务的场景并不是特别多，而且一般真的遇到了需要并发使用的时候，可能更加常见的就是直接实现Runnable/Callable接口，丢到Thread中执行了；或者更高级一点，定义一个线程池，扔进去执行；本片博文，将从另一个角度，借助JDK提供的ForkJoin，来设计一个简单易用的并发框架","text":"基于ForkJoin构建一个简单易用的并发组件在实际的业务开发中，需要用到并发编程的知识，实际使用线程池来异步执行任务的场景并不是特别多，而且一般真的遇到了需要并发使用的时候，可能更加常见的就是直接实现Runnable/Callable接口，丢到Thread中执行了；或者更高级一点，定义一个线程池，扔进去执行；本片博文，将从另一个角度，借助JDK提供的ForkJoin，来设计一个简单易用的并发框架 I. 背景实际项目中，使用并发的一个case就是商品详情页的展示了，一个详情页的展示，除了基本的商品数据之外，还有销量，地址，评价，推荐，店铺信息，装饰信息等，用一段伪代码来描述拼装整个详情数据的过程 12345678910111213141516171819// 获取商品基本信息ItemInfo itemInfo = itemService.getInfo(itemId);// 获取销量int sellCount = sellService.getSellCount(itemId);// 获取评价信息RateInfo rateInfo = rateService.getRateInfo(itemId);// 获取店铺信息ShopInfo shopInfo = shopService.getShopInfo(shopId);// 获取装饰信息DecorateInfo decoreateInfo = decorateService.getDecorateInfo(itemId);// 获取推荐商品RecommandInfo recommandInfo = recommandService.getRecommand(itemId); 如果是正常的执行过程，那么就是上面的6个调用，串行的执行下来，假设每个服务的rt是10ms，那么光是这里六个服务执行下来，耗时就&gt;60ms了， 但从业务角度出发，上面6个服务调用，彼此之间没有什么关联，即一个服务的调用，并不依赖另一个服务返回的结果，她们完全可以并发执行，这样六个服务执行下来，耗时就是六个服务中耗时最久的一个了，可能也就10ms多一点了 两个一对比，发现这种场景下，使用并发的优势非常明显了，接下来的问题是，我们希望以最简单的方式，将上面的代码改成并发的 II. 设计与实现以上面的case为例，如果我们采用线程池的方式，可以怎么实现呢？ 1. 线程池方式因为线程池方式不是重点，所以就简单的演示以下，可以怎么实现，以及实现之后的效果如何 123456789101112131415161718192021// 1. 创建线程池ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"service-pool\"), new ThreadPoolExecutor.CallerRunsPolicy());// 2. 将服务调用，封装到线程任务中执行Future&lt;ItemInfo&gt; itemFuture = alarmExecutorService.submit(new Callable&lt;ItemInfo&gt;() &#123; @Override public ItemInfo call() throws Exception &#123; return itemService.getInfo(itemId); &#125;&#125;);// ... 其他的服务依次类推// 3. 获取数据ItemInfo = itemFutre.get(); // 阻塞，直到返回 上面这个实现可以说是一个非常清晰明了的实现方式了，我们接下来看一下，用Fork/Join框架可以怎么玩，又会有什么好处 2. ForkJoin方式首先可能需要简单的介绍下，这是个什么东西，Fork/Join框架是Java7提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架 简单来说，就是讲一个复杂的任务，拆分成很多小任务，并发去执行的机制，任务与任务的执行，可能并不会独占线程，采用了一种名为工作窃取的手段，详情可以参考 ForkJoin 学习使用笔记 借助ForkJoin的方式，又可以怎么支持上面的场景呢？一个简单的方案如下 1234567891011121314// 1. 创建池ForkJoinPool pool = new ForkJoinPool(10);// 2. 创建任务并提交ForkJoinTask&lt;ItemInfo&gt; future = joinPool.submit(new RecursiveTask&lt;ItemInfo&gt;() &#123; public ItemInfo compute() &#123; return itemService.getItemInfo(itemId); &#125;&#125;);// 3. 获取结果future.join(); 这样一对比，两者之间并没有什么区别，而且也没有用到传说中的任务拆解 3. 进阶如何能够充分的利用ForkJoin的任务拆解的思想来解决问题呢？ 将上面的实例，我们稍微变通一下，将整个详情页的数据返回，看做是一个任务，对于内部的服务调用，根据不同的应用提供放，再进行任务划分，假设可以变成如下的层次结构 从上图可以看出，前面的服务调用，还可以继续划分，比如我们常见的商品信息，就可以区分为基本商品信息，sku信息，库存信息，而这三个又是可以并发执行的，也就是说从，借助forjoin的任务拆解，我们完全可以做到更细粒度的并发场景 那么现在的目标就是，如何实现上面这个任务拆分的场景需求，而且还希望对既有的代码改动不太大，关键还在于写出来后，得容易看懂+维护（这点其实很重要，笔者接触过一个封装得特别好，导致业务交接的维护成本太大，以及排查问题难度飙升的情况） 4. 实现a. 设计思路首先是定义一个最基本的执行单元，也就是封装具体的业务逻辑，也就是我们常说的Task（最终的效果也就是一个一个的task进行执行任务） 因为考虑到任务的拆解的情况，所以我们需要一个特殊的task，这个task可以是多个task的集合（也就是大任务，先称为bigTask） 然后就是使用时，所有的task都封装在一个bigTask中，直接丢给forkJoinPool来执行（支持同步获取结果的invoke调用方式和异步获取结果的execute方式） 那么，核心就在与如何设计这个BigTask了，以及在执行时，将bigTask拆解成更细粒度的bigTask或者task，并最终将所有的task执行结果合并起来并返回 b. 实现基本task接口 1234567891011121314/** * Created by yihui on 2018/4/8. */public interface IDataLoader&lt;T&gt; &#123; /** * 具体的业务逻辑，放在这个方法里面执行，将返回的结果，封装到context内 * * @param context */ void load(T context);&#125; 一个抽象的实现类，继承forkjoin的RecuriAction，这个就对应上我们前面定义的基本Task了 123456789101112131415161718192021222324252627public abstract class AbstractDataLoader&lt;T&gt; extends RecursiveAction implements IDataLoader &#123; // 这里就是用来保存返回的结果，由业务防自己在实现的load()方法中写入数据 protected T context; public AbstractDataLoader(T context) &#123; this.context = context; &#125; public void compute() &#123; load(context); &#125; /** * 获取执行后的结果，强制等待执行完毕 * @return */ public T getContext() &#123; this.join(); return context; &#125; public void setContext(T context) &#123; this.context = context; &#125;&#125; 然后就是BigTask的实现了，也比较简单，内部维持一个List 12345678910111213141516171819202122232425262728293031323334353637383940public class DefaultForkJoinDataLoader&lt;T&gt; extends AbstractDataLoader&lt;T&gt; &#123; /** * 待执行的任务列表 */ private List&lt;AbstractDataLoader&gt; taskList; public DefaultForkJoinDataLoader(T context) &#123; super(context); taskList = new ArrayList&lt;&gt;(); &#125; public DefaultForkJoinDataLoader&lt;T&gt; addTask(IDataLoader dataLoader) &#123; taskList.add(new AbstractDataLoader(this.context) &#123; @Override public void load(Object context) &#123; dataLoader.load(context); &#125; &#125;); return this; &#125; // 注意这里，借助fork对任务进行了拆解 @Override public void load(Object context) &#123; this.taskList.forEach(ForkJoinTask::fork); &#125; /** * 获取执行后的结果 * @return */ public T getContext() &#123; this.taskList.forEach(ForkJoinTask::join); return this.context; &#125;&#125; 接下来就是比较简单的线程池的设计了，因为我们需要提供同步获取结果，和异步获取结果的两种姿势，所以对ForkJoinPool需要做个扩展 123456789101112131415161718192021222324public class ExtendForkJoinPool extends ForkJoinPool &#123; public ExtendForkJoinPool() &#123; &#125; public ExtendForkJoinPool(int parallelism) &#123; super(parallelism); &#125; public ExtendForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, Thread.UncaughtExceptionHandler handler, boolean asyncMode) &#123; super(parallelism, factory, handler, asyncMode); &#125; // 同步阻塞调用时，需要对每个task执行join，确保执行完毕 public &lt;T&gt; T invoke(ForkJoinTask&lt;T&gt; task) &#123; if (task instanceof AbstractDataLoader) &#123; super.invoke(task); return (T) ((AbstractDataLoader) task).getContext(); &#125; else &#123; return super.invoke(task); &#125; &#125;&#125; 然后就是创建Pool的工厂类，没什么特别的了 123456789101112131415161718192021222324252627282930313233public class ForkJoinPoolFactory &#123; private int parallelism; private ExtendForkJoinPool forkJoinPool; public ForkJoinPoolFactory() &#123; this(Runtime.getRuntime().availableProcessors() * 16); &#125; public ForkJoinPoolFactory(int parallelism) &#123; this.parallelism = parallelism; forkJoinPool = new ExtendForkJoinPool(parallelism); &#125; public ExtendForkJoinPool getObject() &#123; return this.forkJoinPool; &#125; public int getParallelism() &#123; return parallelism; &#125; public void setParallelism(int parallelism) &#123; this.parallelism = parallelism; &#125; public void destroy() throws Exception &#123; this.forkJoinPool.shutdown(); &#125;&#125; 到此，整个基本上算是完了，每个类都很简单，就那么点东西，接下来就是需要看怎么用了 III. 测试验证先来一个简单的case，演示下，应该怎么用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 @Datastatic class Context &#123; public int addAns; public int mulAns; public String concatAns; public Map&lt;String, Object&gt; ans = new ConcurrentHashMap&lt;&gt;();&#125;@Testpublic void testForkJoinFramework() &#123; ForkJoinPool forkJoinPool = new ForkJoinPoolFactory().getObject(); Context context = new Context(); DefaultForkJoinDataLoader&lt;Context&gt; loader = new DefaultForkJoinDataLoader&lt;&gt;(context); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.addAns = 100; System.out.println(\"add thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.mulAns = 50; System.out.println(\"mul thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.concatAns = \"hell world\"; System.out.println(\"concat thread: \" + Thread.currentThread()); &#125; &#125;); DefaultForkJoinDataLoader&lt;Context&gt; subTask = new DefaultForkJoinDataLoader&lt;&gt;(context); subTask.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; System.out.println(\"sub thread1: \" + Thread.currentThread() + \" | now: \" + System.currentTimeMillis()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.ans.put(Thread.currentThread().getName(), System.currentTimeMillis()); &#125; &#125;); subTask.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; System.out.println(\"sub thread2: \" + Thread.currentThread() + \" | now: \" + System.currentTimeMillis()); context.ans.put(Thread.currentThread().getName(), System.currentTimeMillis()); &#125; &#125;); loader.addTask(subTask); long start = System.currentTimeMillis(); System.out.println(\"------- start: \" + start); // 提交任务，同步阻塞调用方式 forkJoinPool.invoke(loader); System.out.println(\"------- end: \" + (System.currentTimeMillis() - start)); // 输出返回结果，要求3s后输出，所有的结果都设置完毕 System.out.println(\"the ans: \" + context);&#125; 使用起来就比较简单了，简单的四步骤即可： 创建Pool 指定保存结果的容器类ContextHolder 创建任务 创建根任务 new DefaultForkJoinDataLoader&lt;&gt;(context); 添加子任务 提交 上面这个实现中，对于需要将Task进行再次拆分，会变得非常简单，看下上面的输出 12345678------- start: 1523200221827add thread: Thread[ForkJoinPool-1-worker-50,5,main]concat thread: Thread[ForkJoinPool-1-worker-36,5,main]sub thread2: Thread[ForkJoinPool-1-worker-29,5,main] | now: 1523200222000sub thread1: Thread[ForkJoinPool-1-worker-36,5,main] | now: 1523200222000mul thread: Thread[ForkJoinPool-1-worker-43,5,main]------- end: 3176the ans: ForJoinTest.Context(addAns=100, mulAns=50, concatAns=hell world, ans=&#123;ForkJoinPool-1-worker-36=1523200222204, ForkJoinPool-1-worker-29=1523200222000&#125;) 首先是各个子任务执行的线程输出可以看出确实是不同线程执行的任务（并发） 3s后，输出结果，即invoke之后，会阻塞直到所有的任务执行完毕 subTask进行了任务拆解，两个子任务的执行时间相同，但是一个sleep，另一个则不受影响（子任务也是并行执行） 对于希望异步执行的情况，也比较简单了，仅仅是在提交任务的地方，稍微改动一下即可，然后在需要获取数据的时候，通过loader来获取结果即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Testpublic void testForkJoinFramework2() &#123; ForkJoinPool forkJoinPool = new ForkJoinPoolFactory().getObject(); Context context = new Context(); DefaultForkJoinDataLoader&lt;Context&gt; loader = new DefaultForkJoinDataLoader&lt;&gt;(context); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; context.addAns = 100; System.out.println(\"add thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.mulAns = 50; System.out.println(\"mul thread: \" + Thread.currentThread()); &#125; &#125;); loader.addTask(new IDataLoader&lt;Context&gt;() &#123; @Override public void load(Context context) &#123; context.concatAns = \"hell world\"; System.out.println(\"concat thread: \" + Thread.currentThread()); &#125; &#125;); long start = System.currentTimeMillis(); System.out.println(\"------- start: \" + start); // 如果暂时不关心返回结果，可以采用execute方式，异步执行 forkJoinPool.execute(loader); // .... 这里可以做其他的事情 此时，不会阻塞，addAns不会被设置 System.out.println(\"context is: \" + context); System.out.println(\"------- then: \" + (System.currentTimeMillis() - start)); loader.getContext(); // 主动调用这个，表示会等待所有任务执行完毕后，才继续下去 System.out.println(\"context is: \" + context); System.out.println(\"------- end: \" + (System.currentTimeMillis() - start));&#125; IV. 其他源码相关源码可在git上查看，主要在Quick-Alarm项目中 QuickAlarm 并发相关代码 个人博客： 一灰灰Blog个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://zbang.online/hexblog/tags/ForkJoin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"Css实战训练之图片点击放大","slug":"Css实战训练之图片点击放大","date":"2018-04-01T09:10:09.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/01/Css实战训练之图片点击放大/","link":"","permalink":"https://zbang.online/hexblog/2018/04/01/Css实战训练之图片点击放大/","excerpt":"Css实战训练之图片点击放大I. 背景非常常见的一个功能了，一般网站上显示的都是缩略图，等你点击缩略图之后，会在一个弹框中显示放大的图片 那么这个功能是怎么实现的呢? 正好学习了下css的基础知识，现在可以来实际的操作一把","text":"Css实战训练之图片点击放大I. 背景非常常见的一个功能了，一般网站上显示的都是缩略图，等你点击缩略图之后，会在一个弹框中显示放大的图片 那么这个功能是怎么实现的呢? 正好学习了下css的基础知识，现在可以来实际的操作一把 1. 思路首先对页面的结构进行拆分： 有一个弹窗，在弹窗中显示大图；且弹窗默认是隐藏的 主页面上可以放置很多图片，并添加点击事件 点击之后，弹窗显示，并展示大图 大图点击以下后，关闭弹窗 II. 实现根据上面的描述，我们先来实现一个基础版本的，先写HTML 1234567891011121314151617&lt;body&gt;&lt;!-- 先来实现弹窗 --&gt;&lt;div class='modal' id='modal'&gt; &lt;img id='bgImg' /&gt;&lt;/div&gt;&lt;!-- 下面则是主页内容，先只给几个图片 --&gt;&lt;div&gt; &lt;img class='thum-img' src='http://f.hiphotos.baidu.com/image/pic/item/80cb39dbb6fd5266cdb2ba16a718972bd4073612.jpg' /&gt;&lt;/div&gt;&lt;/body&gt; 然后就是添加对应的样式，要求modal默认是隐藏的，所以如下（为了可以较好的区分弹窗，所以加了背景色和边框） 12345678910111213141516171819202122232425262728&lt;style&gt;.modal &#123; display: none; margin: auto; width: 80%; height: 80%; background-color: rgb(0, 0, 0, 0.89); z-index: 1; border: 1px solid rgb(255,255,255,1);&#125;.modal&gt;img &#123; display: block; margin: auto; padding: 10%; max-width: 60%; max-height: 60%;&#125;.thum-img &#123; width: 200px; height: 200px; margin: auto; display: block; padding: 40px;&#125;&lt;/style&gt; 接下来就是点击显示大图的逻辑了，借助js来实现， 12345678910111213&lt;script&gt; var modal = document.getElementById('modal'); var bgImg = document.getElementById('bgImg'); var thumImg = document.getElementById('thumImg'); thumImg.onclick = function() &#123; modal.style.display = 'block'; bgImg.src = this.src; &#125; bgImg.onclick = function() &#123; modal.style.display = 'none'; &#125;&lt;/script&gt; 将上面的实现，组装成一个html之后，直接测试查看，演示效果如下 虽然说上面的实现了我们预期的结果，但是有几点却不太满意 不是我们预期的弹窗效果，原图被挤下去了 弹窗中如果有个放大的动画效果就更好了（正好可以用到之前学习的animation） 对于图强中有很多图片时，点击放大怎么做 III. 进阶首先是希望是真的弹窗，不影响既有的布局，则通常是设置position来做到, 如我们可以在modal外面再加一层，变成 12345&lt;div style='position:fixed'&gt; &lt;div class='modal' id='modal'&gt; &lt;img id='bgImg' /&gt; &lt;/div&gt;&lt;/div&gt; 其次就是弹窗的样式太丑，我们可以借助之前学习的边框阴影来实现美观的弹出效果， 改成图片全部填充背景 背景颜色去掉，加上阴影，加上白色边框 修改后的css如下 1234567891011121314151617181920.modal &#123; display: none; margin: auto; padding-top: 5%; width: 50%; height: 80%; z-index: 1; background-color: white;&#125;.modal img &#123; display: block; padding: 10px; margin: auto; max-width: 100%; max-height: 100%; box-shadow: 0 2px 6px rgb(0, 0, 0, 0.2), 0 10px 20px rgb(0, 0, 0, 0.2); border-radius: 12px; border: 1px solid white;&#125; 接下来考虑添加动画，加上一个放大的效果 123456789@keyframes zoom &#123; from &#123;transform: scale(0.1)&#125; to &#123;transform: scale(1)&#125;&#125;.modal img &#123; animation-name: zoom; animation-duration: 0.6s;&#125; 接下来看演示效果如下 接下来就是需要把这个变成通用的方案，支持多重图片的方式了，这个则主要是图片点击事件的修改了，将上面写死的地方，稍微变通一下即可 IV. 源码最后给出所有的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt; &lt;title&gt;小灰灰css学习笔记&lt;/title&gt; &lt;style&gt;.modal &#123; display: none; position:fixed; width:100%; height:100%; background-color:rgb(0,0,0,0.65)&#125;.modal-container &#123; margin: auto; padding-top: 5%; width: 50%; height: 80%; z-index: 1;&#125;.modal img &#123; animation-name: zoom; animation-duration: 0.6s; display: block; padding: 10px; margin: auto; max-width: 100%; max-height: 100%; box-shadow: 0 2px 6px rgb(0, 0, 0, 0.2), 0 10px 20px rgb(0, 0, 0, 0.2); border-radius: 12px; border: 1px solid white;&#125;@keyframes zoom &#123; from &#123;transform: scale(0.1)&#125; to &#123;transform: scale(1)&#125;&#125;.thum-img &#123; float: left; width: 200px; height: 200px; margin: auto; display: block; padding: 40px;&#125;&lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;!-- 先来实现弹窗 --&gt;&lt;div class='modal' id='modal'&gt;&lt;div class='modal-container'&gt; &lt;img id='bgImg' /&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 下面则是主页内容，先只给几个图片 --&gt;&lt;div&gt; &lt;img onclick='showBgImg(this)' class='thum-img' src='http://f.hiphotos.baidu.com/image/pic/item/80cb39dbb6fd5266cdb2ba16a718972bd4073612.jpg' /&gt; &lt;img class='thum-img' src='http://a.hiphotos.baidu.com/image/pic/item/e61190ef76c6a7ef5e886d03f1faaf51f3de666d.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='http://g.hiphotos.baidu.com/image/pic/item/730e0cf3d7ca7bcb747b4a5cb2096b63f624a845.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='http://c.hiphotos.baidu.com/image/pic/item/b21c8701a18b87d6657856e70c0828381f30fd14.jpg' onclick='showBgImg(this)'/&gt; &lt;img class='thum-img' src='https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png' onclick='showBgImg(this)'/&gt;&lt;/div&gt;&lt;script&gt; var modal = document.getElementById('modal'); var bgImg = document.getElementById('bgImg'); function showBgImg(e) &#123; modal.style.display = 'block'; bgImg.src = e.src; &#125; bgImg.onclick = function() &#123; modal.style.display = 'none'; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; V. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zbang.online/hexblog/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"Css学习手册之基本篇","slug":"Css学习手册之基本篇","date":"2018-04-01T01:29:21.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/04/01/Css学习手册之基本篇/","link":"","permalink":"https://zbang.online/hexblog/2018/04/01/Css学习手册之基本篇/","excerpt":"Css学习手册之基本篇每次写前端都是一个痛苦的过程，总是静不下来，彻底的研究下前端的技术，导致每次套页面都是直接采用一些封装好的控件，而有时对这些样式不满意时，又得百度一下该怎么用，低效且不愉快，强制自己好好的学习下基本功","text":"Css学习手册之基本篇每次写前端都是一个痛苦的过程，总是静不下来，彻底的研究下前端的技术，导致每次套页面都是直接采用一些封装好的控件，而有时对这些样式不满意时，又得百度一下该怎么用，低效且不愉快，强制自己好好的学习下基本功 I. 基本使用姿势0. 几种css使用姿势主要有下面三个使用姿势，其中优先级为 c &gt; b &gt; a a.直接引入css文件 b.在html中，直接写css: c.在标签中直接写css 123456789101112131415&lt;!-- 方式 a --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;!-- 方式 b --&gt;&lt;style&gt;p &#123; color: red&#125;&lt;/style&gt;&lt;!-- 方式 c --&gt;&lt;div style=\"color:red; font-size:12pt\"&gt;dd&lt;/div&gt; 对于标签的样式定义，特别是在引入css文件时，发现一个标签可能多重命中方式，有通过id进行设置的，有class设置的，也有标签设置的，他们之间的优先级是: 12341. 内联样式表的权值最高 1000；2. ID 选择器的权值为 1003. Class 类选择器的权值为 104. HTML 标签选择器的权值为 1 1. css使用方式a. 基本使用在实际的使用中，经常出现的定义class, 根据id或者直接对标签，来指定css属性 123456789101112131415161718&lt;style&gt;&lt;!-- 直接通过标签名 + &#123;&#125; 方式来确定标签对应的属性 --&gt;p &#123; background-color: yellow;&#125;&lt;!-- 通过id来确定css样式: # + id + &#123;&#125; --&gt;#tabId &#123; background-color: red;&#125;&lt;!-- 通过定义class方式: . + className + &#123;&#125;--&gt;.clzName &#123; background-color: blue;&#125;&lt;/style&gt; 上面是基本的使用姿势，往往我们经常会遇到组合的方式，如希望 设置: div标签内部的 p 标签中的文本颜色等，常见组合有四种 b. 后代选择器 （空格分割）如上面的case， div 标签内部所有的p标签中文本，都设置为红色 12345678910111213&lt;style&gt;div p &#123; color: red&#125;&lt;/style&gt;&lt;div&gt; &lt;span&gt; &lt;p&gt; 红色的文本内容 &lt;/p&gt; &lt;/span&gt; &lt;hr/&gt; &lt;p&gt; 红色的文本内容 &lt;/p&gt;&lt;/div&gt; c. 子元素选择器 (&gt;号分割)这个相比较与后代选择器，区别就是子元素只匹配直接关联的子元素（也就是中间不能有嵌套） 12345678910111213&lt;style&gt;div &gt; span &#123; color: red&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt; &lt;span&gt; 默认黑色的文本内容 &lt;/span&gt; &lt;/p&gt; &lt;hr/&gt; &lt;span&gt; 红色的文本内容 &lt;/span&gt;&lt;/div&gt; d. 相邻兄弟 (+号分割)可选择紧接在另一元素后的元素，且二者有相同父元素 1234567891011121314&lt;style&gt;div+p&#123; background-color:yellow;&#125;&lt;/style&gt;&lt;p&gt;(默认黑色的内容).&lt;/p&gt;&lt;div&gt;&lt;h2&gt;My name is Donald&lt;/h2&gt;&lt;p&gt;I live in Duckburg.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt; e. 普通兄弟 (~号分割)后续兄弟选择器选取所有指定元素之后的兄弟元素。 12345678910111213141516&lt;style&gt;div+p&#123; background-color:yellow;&#125;&lt;/style&gt;&lt;p&gt;(默认黑色的内容).&lt;/p&gt;&lt;div&gt;&lt;h2&gt;My name is Donald&lt;/h2&gt;&lt;p&gt;I live in Duckburg.&lt;/p&gt;&lt;/div&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt;&lt;span&gt;默认黑色&lt;/span&gt;&lt;p&gt;(黄色的内容).&lt;/p&gt; 2. 背景属性 background-color: 背景色 background-image: 背景图 background-repeat: 背景图重复的方式( no-repeat 不重复； repea-xt 水平重复; repeat-y 垂直重复) background-position: 背景的位置 ( left, top, center, right, bottom，可以组合使用) 支持简写方式: 123body &#123; background: #ffffff url('img_tree.png') no-repeat right top;&#125; 3. 文本属性 color: 设置颜色 direction: 文本方向 (ltr 左到右； rtl 右到左; inherit 从父元素继承) letter-spacing: 字符间距 text-align: 文本对齐方式 (left, center, right) line-height: 行高 text-decoration: 修饰 （none 标准； underline 下划线; overline 上划线; line-through 删除线; blink 闪烁） text-indent: 首行缩进 text-shadow: 阴影 text-transform: 控制字母 (capitalize 首字母大写; uppercase 全大写； lowercase 全小写) vertical-align：垂直对其 white-space: 设置元素中空白的处理方式 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的 标签。 5. 字体属性 font-size: 字体大小 16px == 1em font-family: 字体系列 Serif: 字符在行的末端拥有额外的装饰 Sans-serif: 这些字体在末端没有额外的装饰 Monospace: 所有的等宽字符具有相同的宽度 font-style: 字体样式 italic 浏览器会显示一个斜体的字体样式。 oblique 浏览器会显示一个倾斜的字体样式。 inherit 规定应该从父元素继承字体样式。 6. 链接 a:link {color:#000000;} / 未访问链接/ a:visited {color:#00FF00;} / 已访问链接 / a:hover {color:#FF00FF;} / 鼠标移动到链接上 / a:active {color:#0000FF;} / 鼠标点击时 / 注意： a:hover 必须在 a:link 和 a:visited 之后，需要严格按顺序才能看到效果。 注意： a:active 必须在 a:hover 之后。 7. 列表在html中，列表主要是 : li, ul, ol 等 默认 ol 是以数字排序； ul 是以符号排序； li 为列表内的元素标签 用的较多的属性 list-style-type: 设置列表项标志的类型。 none 无标记。 disc 默认。标记是实心圆。 circle 标记是空心圆。 square 标记是实心方块。 decimal 标记是数字。 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。) upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。) lower-greek 小写希腊字母(alpha, beta, gamma, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式(an, ban, gan, 等。) cjk-ideographic 简单的表意数字 hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文片假名） katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名） hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名） katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名） list-style-image: 用图片作为列表的前置，如 ( url(‘sqpurple.gif’);) list-style-position: （outside, inside）感觉不出太大的差别 8. box模型 Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 主要是用来控制一个标签和其他标签的位置，比如两个标签之间做间隔区分等，比较有用 padding与margin的区别 a. Margin 外边距主要是标签与周边的距离设置 margin-top:100px; margin-right:50px; margin-bottom:100px; margin-left:50px; b. padding 内边距定义元素边框与元素内容之间的空间 padding-top:25px; padding-bottom:25px; padding-right:50px; padding-left:50px; c. border 边框这个有些时候还是挺有用的，设置一个标签四周的边框，一般可以设置线粗细，样式，颜色等 border-width : 线的粗细 border-style dotted: dotted:定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 border-color: 边框的颜色 一个非常有意思的点是，边框支持分别设置上下左右四个线的形式，如只设置一个左右有颜色的 12345&lt;div&gt; &lt;p style=\"border-left-style:dashed; border-left-color:red; border-right-style:solid;\"&gt; 只有左右边框的情况&lt;/p&gt;&lt;/div&gt; d. outline 边缘轮廓outline主要作用在border上，绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 outline-color outline-style none dotted: dotted:定义一个点线边框 dashed: 定义一个虚线边框 solid: 定义实线边框 double: 定义两个边框。 两个边框的宽度和 border-width 的值相同 groove: 定义3D沟槽边框。效果取决于边框的颜色值 ridge: 定义3D脊边框。效果取决于边框的颜色值 inset:定义一个3D的嵌入边框。效果取决于边框的颜色值 outset: 定义一个3D突出边框。 效果取决于边框的颜色值 outline-width 从实际体验来讲，这个和border的效果差不多 9. 尺寸这个主要就是用来控制标签的宽高等相关尺寸的属性，常见的设置如下 width: 定宽 height: 定高 min-width: 最小宽 max-width: 最大宽 min-height: 最小高 max-height: 最大高 line-height: 行高 10. 显示控制标签的显示隐藏等 display属性设置一个元素应如何显示 visibility属性指定一个元素应可见还是隐藏 a. displaynone可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 块元素是一个元素，占用了全部宽度，在前后都是换行 内联元素只需要必要的宽度，不强制换行。 1234567891011121314151617181920211. 块级元素(block)特性：总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;2. 内联元素(inline)特性：和相邻的内联元素在同一行;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，就是里面文字或图片的大小;3. 块级元素主要有： address , blockquote , center , dir , div , dl , fieldset , form , h1 , h2 , h3 , h4 , h5 , h6 , hr , isindex , menu , noframes , noscript , ol , p , pre , table , ul , li4. 内联元素主要有：a , abbr , acronym , b , bdo , big , br , cite , code , dfn , em , font , i , img , input , kbd , label , q , s , samp , select , small , span , strike , strong , sub , sup ,textarea , tt , u , var5. 可变元素(根据上下文关系确定该元素是块元素还是内联元素)：applet ,button ,del ,iframe , ins ,map ,object , script b. visibilityhidden可以隐藏某个元素,但隐藏的元素仍需占用与未隐藏之前一样的空间,也就是说，该元素虽然被隐藏了，但仍然会影响布局。 11. 定位 positionposition 属性指定了元素的定位类型。在使用top, bottom, left, right之前，一般需要先确定position属性，明确具体的定位方式 static 默认值，即没有定位，元素出现在正常的流中 静态定位的元素不会受到 top, bottom, left, right影响。 relative 元素的位置相对于浏览器窗口是固定位置 即窗口是滚动的它也不会移动，常用来做悬浮按钮 fixed 相对定位元素的定位是相对其正常位置。 absolute 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 如一个测试 1234567891011121314&lt;style&gt;h2&#123; position:absolute; left:100px; top:150px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;这是一个绝对定位了的标题&lt;/h2&gt;&lt;p&gt;用绝对定位,一个元素可以放在页面上的任何位置。标题下面放置距离左边的页面100 px和距离页面的顶部150 px的元素。.&lt;/p&gt;&lt;/body&gt; 注意 当多个元素在同一个位置时，就会出现重叠的问题，特别是relative这种场景，在网页右下角添加悬浮窗时，经常会出现遮盖的问题，这时可以用 z-index 属性来指定覆盖顺序，越大，则越上面 12. float 浮动CSS 的 Float（浮动），会使元素向左或向右移动，其周围的元素也会重新排列。 往往是用于图像，但它在布局时一样非常有用。 元素的水平方向浮动，意味着元素只能左右移动而不能上下移动。 一个浮动元素会尽量向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。 浮动元素之后的元素将围绕它。 浮动元素之前的元素将不会受到影响。 如果图像是右浮动，下面的文本流将环绕在它左边 如果你把几个浮动的元素放到一起，如果有空间的话，它们将彼此相邻 12345678&lt;!-- 注意多个浮动的图片时，缩小浏览器窗口大小，布局会发生改变 --&gt;.thumbnail &#123; float:left; width:110px; height:90px; margin:5px;&#125; 13. 水平 &amp; 垂直对齐 css实现对齐方式 根据前面学习到的几个属性(text-align, margin, position)等来实现各种标签的对齐方式 text-align: left, right, center 通常是对于文本的对其方式，比如一个标签块内文本是如何对齐的，靠左，靠右还是居中 margin: auto 标签的对齐方式，如希望一个div标签水平居中，就可以这么玩 图片需要居中对齐，采用这种方案 (注意 在img使用时，一般需要指定 display:block;margin:auto，这样才会生效) 一个case如下 1234567&lt;div style=\"width:200px; border: 3px solid blue; padding: 4px\"&gt; &lt;div style=\"width:50%; border:3px solid red; margin: auto; padding: 20px\"&gt; 这是一个测试标签居中对其的示例 &lt;/div&gt;&lt;/div&gt;&lt;br/&gt;&lt;div style=\"width:200px; border: 3px solid blue; padding: 4px\"&gt; &lt;div style=\"width:50%; border:3px solid red; text-align: center; padding: 20px\"&gt; 这是一个测试标签内文本居中对齐的示例 &lt;/div&gt;&lt;/div&gt; II. CSS3高阶用法1. 边框 border前面介绍了边框的设置，主要还是线条类型，粗细以及颜色，现在则可以扩展，设置圆角、阴影，边框图 border-radius: 2px (四周圆角) 一个值： 四个圆角值相同 两个值: 第一个值为左上角与右下角，第二个值为右上角与左下角 三个值: 第一个值为左上角, 第二个值为右上角和左下角，第三个值为右下角 四个值: 第一个值为左上角，第二个值为右上角，第三个值为右下角，第四个值为左下角。 border-image: url(border.png) 30 30 round; （边框由图来替代） border-image-source 用于指定要用于绘制边框的图像的位置 border-image-slice 图像边界向内偏移 border-image-width 图像边界的宽度 border-image-outset 用于指定在边框外部绘制 border-image-area 的量 border-image-repeat 设置图像边界是否应重复（repeat）、拉伸（stretch）或铺满（round）。 box-shadow: 10px 10px 2px #bbbbbb (设置阴影) h-shadow 必需的。水平阴影的位置。允许负值 v-shadow 必需的。垂直阴影的位置。允许负值 blur 可选。模糊距离 spread 可选。阴影的大小 color 可选。阴影的颜色 一个实例，捷足 box-shadow 给图片加上一个白色背景边框 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;#boxshadow &#123; position: relative; &lt;!-- 添加边框阴影 --&gt; -moz-box-shadow: 1px 2px 4px rgba(0, 0, 0,0.5); -webkit-box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); box-shadow: 1px 2px 4px rgba(0, 0, 0, .5); padding: 10px; background: white;&#125;/* Make the image fit the box */#boxshadow img &#123; width: 100%; border: 1px solid #8a4419; border-style: inset;&#125;#boxshadow::after &#123; content: ''; position: absolute; z-index: -1; /* hide shadow behind image */ -webkit-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); box-shadow: 0 15px 20px rgba(0, 0, 0, 0.3); width: 70%; left: 15%; /* one half of the remaining 30% */ height: 20%; bottom: 0;&#125;&lt;/style&gt;&lt;div id=\"boxshadow\"&gt; &lt;img src=\"https://raw.githubusercontent.com/liuyueyi/Source/master/img/info/blogInfoV2.png\" alt=\"Norway\"&gt;&lt;/div&gt; 2. 文本除了前面说的文本颜色，大小，decorate, transform等之外，这里额外的加了一些特性 a. text-shadow5px 5px 5px #FF0000; 阴影，参数说明同 box-shadow b. text-overflow文字逸出时，怎么办（ 配合overflow:hidden，将逸出的隐藏掉） clip： 修剪文本 ellipsis: 用省略号代替逸出的文本 string: 用给出的字符串代替 一个实例： 123456789101112&lt;style&gt;div.ov &#123; width: 120px; white-space:nowrap; border: 1px solid black; overflow:hidden; text-overflow:ellipsis&#125;&lt;/style&gt;&lt;div class=\"ov\"&gt; 这是一个会移除的文本&lt;/div&gt; c. word-wrap &amp; word-breakword-wrap 文本太长时，换行的策略 normal 只在允许的断字点换行 break-word 在长单词或 URL 地址内部进行换行。 还有一个主要针对英文单词的换行策略 word-break normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 d. 字体@Font-face 指定特殊的字体 一般的使用姿势如下: 1234567891011121314&lt;style&gt; @font-face&#123; &lt;!-- 字体命名 --&gt; font-family: myFirstFont; &lt;!-- 指定字体文件路径 --&gt; src: url(sansation_light.woff);&#125; div&#123; font-family:myFirstFont;&#125;&lt;/style&gt; 3. 动画a. transform实现转换，最常见的就是旋转一定角度了 translate(x, y): 根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动 rotate(30deg): 表示顺时针渲染30° scale(2,3): 表示x轴扩大2倍，y抽扩大3倍 skew(30deg,20deg): X轴(水平方向)倾斜30°；Y轴(垂直方向)倾斜20° matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功 b. transition过渡，配合上面的transform可以实现旋转or放大的动画效果 如一个case，在鼠标放上去时，放大且旋转360° 12345678910111213141516171819&lt;style&gt; div &#123; width: 100px; height: 100px; background: red; -webkit-transition: width 2s, height 2s, -webkit-transform 2s; /* For Safari 3.1 to 6.0 */ transition: width 2s, height 2s, transform 2s, background 2s;&#125;div:hover &#123; width: 200px; height: 200px; background:blue; -webkit-transform: rotate(360deg); /* Chrome, Safari, Opera */ transform: rotate(360deg);&#125;&lt;/style&gt;&lt;div&gt;鼠标移动到 div 元素上，查看过渡效果。&lt;/div&gt; c. 动画通过 @keyframes 来创建动画的效果，通过 animation 来使用动画 一个实例 12345678910111213141516171819202122232425262728293031&lt;style&gt; div&#123; width:100px; height:100px; background:red; position:relative; animation:myfirst 5s; -webkit-animation:myfirst 5s; /* Safari and Chrome */&#125;@keyframes myfirst&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;@-webkit-keyframes myfirst /* Safari and Chrome */&#123; 0% &#123;background:red; left:0px; top:0px;&#125; 25% &#123;background:yellow; left:200px; top:0px;&#125; 50% &#123;background:blue; left:200px; top:200px;&#125; 75% &#123;background:green; left:0px; top:200px;&#125; 100% &#123;background:red; left:0px; top:0px;&#125;&#125;&lt;/style&gt;&lt;div&gt;哈哈&lt;/div&gt; 4. 图片支持图片圆角设置 border-radius: 8px; 自由缩放： max-width: 100%; height: auto; filter：滤镜 详细参数: filter参数 III. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zbang.online/hexblog/tags/css/"},{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Css","slug":"技术/前端/Css","permalink":"https://zbang.online/hexblog/categories/技术/前端/Css/"}]},{"title":"mysql之锁与事务详解","slug":"mysql之锁与事务详解","date":"2018-03-23T07:16:21.000Z","updated":"2018-04-11T03:48:34.956Z","comments":true,"path":"2018/03/23/mysql之锁与事务详解/","link":"","permalink":"https://zbang.online/hexblog/2018/03/23/mysql之锁与事务详解/","excerpt":"Mysql之锁与事务平时的业务中，顶多也就是写写简单的sql，连事务都用的少，对锁这一块的了解就更加欠缺了，之前一个大神分享了下mysql的事务隔离级别，感觉挺有意思的，正好发现一个很棒的博文，然后也收集了一些相关知识，正好来学习下，mysql中锁与事务的神秘面纱，主要内容包括 共享锁和排它锁的区别以及适合范围 mysql的表锁和行锁的区别 怎么判断一个sql是否执行了锁，执行的是表锁还是行锁 事务是什么，怎么用 事务的特性ACID 事务的隔离级别 (RU, RC, RR, SER) 如何查看mysql使用的隔离级别","text":"Mysql之锁与事务平时的业务中，顶多也就是写写简单的sql，连事务都用的少，对锁这一块的了解就更加欠缺了，之前一个大神分享了下mysql的事务隔离级别，感觉挺有意思的，正好发现一个很棒的博文，然后也收集了一些相关知识，正好来学习下，mysql中锁与事务的神秘面纱，主要内容包括 共享锁和排它锁的区别以及适合范围 mysql的表锁和行锁的区别 怎么判断一个sql是否执行了锁，执行的是表锁还是行锁 事务是什么，怎么用 事务的特性ACID 事务的隔离级别 (RU, RC, RR, SER) 如何查看mysql使用的隔离级别 I. 锁在学习多线程时，我们也经常会遇到锁这个东西，那个时候谈的比较多的是乐观锁和悲观锁，那这两种锁和DB中常说的共享锁和独占锁有什么区别呢？先给出我们已知的乐观锁和悲观锁定义 乐观锁：多线程中的CAS就是一种乐观锁，实际上不加锁，先尝试去执行，如果失败则重试（或者根据失败策略进行处理） 悲观锁：上锁，一次只能有一个线程访问，其他的都只能等待 1. 共享锁和排它锁a. 共享锁突出在共享这个关键词上，顾名思义，表示这个锁可以多人共享，一般又可以称为读锁(S锁) 在DB中，读锁表示所有的读取数据的小伙伴都不会被锁阻塞，可以放心大胆的获取数据，专业一点的说法就是同一时刻，允许多个连接并发的读取同一资源 b. 排它锁排它，表示当某个人持有这个锁之后，其他的人再来竞争锁就会失败，只能等待锁释放， 又称为写锁(X锁) 在DB中，写锁表示同一时刻，只能有一个小伙伴操作，其他的不管是读还是写，都得排队，专业说法是写锁会阻塞其他的读锁或写锁请求，确保同一时刻只能有一个连接可以写入资源，并防止其他连接读取或者写资源 c. gapLock 和 next key lock next key lock 主要是范围匹配的场景下，会锁某一个范围区间 gapLock 主要用来锁边界 如下面的case（说明，columnA是非唯一索引，RR隔离级别） where columnA between 10 and 30, next key lock 确保不会在10, 30 之内插入新的数据行 where columnA = 10, gap lock 确保不会再次插入一个columnA=10的行 2. 表锁和行锁对于DB的操作，通常会出现两种情况，一个是锁表，一个锁行 表锁：表示整个表被某一个连接占用了写锁，导致其他连接的读锁或者写锁都会阻塞；影响整个表的读写 行锁：表示表中某些行被某个连接占用了写锁，但是其他行，依然可以被其他的连接请求读锁、写锁；仅影响被锁的那些行数据 那么一个问题就来了，什么sql会导致行锁，什么会导致写锁？甚至我们如何判断一个sql是否会请求锁，请求的是读锁还是写锁呢？ 3. 如何使用锁上面一节抛出了问题，那么现在就是来看下如何使用和分析锁了，首先我们是我们最常见的几个sql select update delete insert 其中很容易得出的结论是 update, delete, insert 三个涉及到写锁；而且这种操作绝大部分的场景是操作具体的某些行（想想为什么?），所以更常见的是行锁 select读操作则有点特殊 a. select分析MVCC(multiple-version-concurrency-control）是个行级锁的变种，它在普通读情况下避免了加锁操作，因此开销更低。即下面这个没有读锁也没有写锁 快照读，不加锁 1select * from table ... 当前读，select 语句可以指定读锁和写锁，如下 12345-- 读锁select * from table lock in share mode;-- 写锁select * from table for update; 说明，insert, update, delete 也是当前读，理由如下： 1.update和delete操作流程分解： 首先通过where条件查询到第一个满足的记录，并加锁 对这条记录进行更新，再读取下一条记录 对记录更新，继续读下一条直到完毕 2.insert操作流程分解： unique key 冲突检测，会有一个当前读 无冲突时，插入 b. sql实例分析12345--- SQL1：select * from t1 where id = 10;--- SQL2：delete from t1 where id = 10; 在分析上面的sql之前，需要明确几个前提： id是否为主键（id是否有索引） 系统的隔离级别（隔离级别是什么东西可以先看下下文介绍） 分别说明: case1: 主键+RC级别 sql1不加锁，MySQL是使用多版本并发控制的，读不加锁 sql2加写锁（即X锁），只锁 id=10这一行 case2: 唯一索引+rc级别 sql2加写锁，如下图的case，就两把锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录 case3: id非唯一索引+RC sql2加写锁，如下图的case，会有四个写锁 case4: 无索引+RC sql2分析：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上写锁(X锁)。 但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省 case5: 主键+RR 加锁同case1 case6: 唯一索引+RR 加锁同case2 case7: 非唯一索引+RR RR级别不允许出现幻读，简单来说，在加锁的过程中，不允许在新增or修改满足条件的记录 即下图中，除了图三中类似的x锁之外，还会新增一个gap锁，这个gap锁主要确保那几个位置上不能插入新的记录 case8: 无索引+RR 在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作 case9: Serializable级别 sql2: Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致 SQL1: 在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC II. 事务事务可谓是db中非常重要的一个知识点了，接下来我们的目标就是弄懂什么是事务，怎么使用事务，以及事务与锁之间的关联是怎样的 说明：本文的分析主要是以mysql的innordb存储引擎为标准 1. 定义事务就是一组原子性的sql，或者说一个独立的工作单元。 事务就是说，要么mysql引擎会全部执行这一组sql语句，要么全部都不执行（比如其中一条语句失败的话）。 2. ACID特性a. A:atomiciy 原子性一个事务必须保证其中的操作要么全部执行，要么全部回滚，不可能存在只执行了一部分这种情况出现。 b. C:consistency一致性数据必须保证从一种一致性的状态转换为另一种一致性状态。 c. I:isolation 隔离性在一个事务未执行完毕时，通常会保证其他Session 无法看到这个事务的执行结果 d. D:durability 持久性事务一旦commit，则数据就会保存下来，即使提交完之后系统崩溃，数据也不会丢失 3. 隔离级别前面在分析锁的sql时，就提到了隔离级别，通常有四种： RU, RC, RR, Serializable 在说明这个之前，先了解几个概念 a. 基本概念 脏读：读取到一个事务未提交的数据，因为这个事务最终无法保证一定执行成功，那么读取到的数据就无法保证一定准确 不可重复读：简单来说就是在一个事务中读取的数据可能产生变化，同样的sql，在一个事务中执行多次，可能得到不同的结果 幻读：会话T1事务中执行一次查询，然后会话T2新插入一行记录，这行记录恰好可以满足T1所使用的查询的条件。然后T1又使用相同 的查询再次对表进行检索，但是此时却看到了事务T2刚才插入的新行 加锁读：select * from table ... 的执行是否加了读锁 (这个可以参考上面的sql加锁分析） b. RU: Read Uncommited 未提交读事务中的修改，即使没有提交，对其他会话也是可见的，即表示可能出现脏读，一般数据库都不采用这种方案 c. RC: Read Commited 提交读这个隔离级别保证了一个事务如果没有完全成功（commit执行完），事务中的操作对其他会话是不可见的，避免了脏读的可能 但是可能出现不可重复度的情况，举例说明： 会话T1, 执行查询 select * from where id=1，第一次返回一个结果 会话T2, 执行修改 update table set updated=xxx where id=1 并提交 会话T1，再次执行查询 select * from where id=1，这次返回的结果中update字段就和前面的不一样了 实际的生产环境中，这个级别用的比较多，特意查了下公司的db隔离级别就是这个 一个RC级别的演示过程： 会话1，开启事务，查询 会话2，开启事务，更新DB，提交事务 会话1，再次查询，提交事务 从下面的实际演示结果可以知道，会话1，同一个sql，两次执行的结果不同 相关的sql代码如下: 12345678910111213141516171819202122232425262728293031-- 设置会话隔离级别set session transaction ioslation read commited;-- 查看当前会话隔离级别select @@tx_isolation;-- 会话1的操作start transaction;select * from newuser where userId=1;-- 会话2开始操作start transaction;select * from newuser where userId=1;update newuser set updated=1521786092 where userId=1;select * from newuser where userId=1;commit;-- 再次进入会话1，同样执行上次的sql，对比两次输出结果select * from newuser where userId=1;-- 注意观察，会话1，前后两次这个sql的输出结果，特别是updated字段-- 正常情况会如上面的demo图，会发生改变-- 关闭会话commit;-- 再次查询select * from newuser where userId=1; d. RR: Repeatable Read 可重复度一个事务中多次执行统一读SQL,返回结果一样。 这个隔离级别解决了脏读的问题，幻读问题 实例演示解决脏读的过程(将上面的过程同样来一次） 发现不管会话1同一个sql，返回的结果都是相同的 e. Serializable 可串行化最强的隔离级别，通过给事务中每次读取的行加锁，写加写锁，保证不产生幻读问题，但是会导致大量超时以及锁争用问题。 f. 常用命令 查看当前会话隔离级别: select @@tx_isolation 查看系统当前隔离级别: select @@global.tx_isolation 设置当前会话隔离级别: set session transaction isolation level read committed; 设置系统当前隔离级别: set global transaction isolation level read committed; 命令行， 开始事务: start transactioin; 提交: commit; 4. 使用姿势前面演示事务隔离级别的时候，给出的实例就演示了事务的使用姿势，一般作为三步骤： 开始事务 start transaction; 执行你的业务sql 提交事务 commit; 我们现在演示以下一个事务中，读锁、写锁对另一个事务的影响 a. 读锁的影响我们采用mysql默认的RR级别进行测试，userId为主键 1234567891011121314151617-- 会话1start transaction;select * from newuser where userId=1 lock in share mode;-- 转入会话2start transaction;select * from newuser where userId=1; -- 会输出select * from newuser where userId=1 lock in share mode; -- 会输出update newuser set updated=1521787137 where userId=1; -- 会挂起-- 转入会话1-- 提交, 此时观察会话2的写是否完成commit;-- 转入会话2commit; 实际执行演示: b. 写锁的影响1234567891011121314151617-- 会话1start transaction;select * from newuser where userId=1 for update;-- 转入会话2start transaction;select * from newuser where userId=1; -- 会输出select * from newuser where userId=1 lock in share mode; -- 会挂住-- update newuser set updated=1521787137 where userId=1; -- 会挂住-- 转入会话1-- 提交, 此时观察会话2的写是否完成commit;-- 转入会话2commit; 实际执行演示: c. 小结 读锁，会阻塞其他请求写锁的sql执行 写锁，会阻塞其他读锁和写锁的sql执行 事务只有在提交之后，才会释放锁 额外注意，上面事务在提交之后才会释放锁，因此如果两个事务循环依赖锁时，可能发生死锁 III. 小结锁和事务可谓是db中非常重要的知识点了，在我们实际的编码过程中（一般针对mysql, innordb存储引擎，rr隔离级别），做出下面的一些总结 1. sql分析 select * from table where xxx; （读快照，一般不加锁） select * from table where xxx lock in share mode; (读锁，会阻塞其他的写锁请求，但其他的读锁请求没有影响） select * from table where xxx for update; (写锁，会阻塞其他的读写请求） update tableName set xxx (写锁） insert （写锁） delete （写锁） 2. 事务简单来讲，事务就是一组sql，要么全部执行成功，要么全部失败 四个特性： A(原子性)C(一致性)I(隔离性)D (持久性) 四种隔离级别：(mysql 默认采用的是RR级别) 隔离级别 脏读 不可重复读 幻读 加锁读 read uncommited 可能 可能 可能 无 read commited 不可能 可能 可能 无 repeatable read 不可能 不可能 不可能 无 serializable 不可能 不可能 不可能 有 使用姿势： 12345start transaction;-- xxx 具体的sqlcommit; IV. 其他参考 深入理解Mysql——锁、事务与并发控制 MySQL 加锁处理分析 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"},{"name":"锁","slug":"锁","permalink":"https://zbang.online/hexblog/tags/锁/"},{"name":"事务","slug":"事务","permalink":"https://zbang.online/hexblog/tags/事务/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"mysql之索引的工作机制","slug":"mysql之索引的工作机制","date":"2018-03-22T04:26:49.000Z","updated":"2018-04-11T03:48:34.955Z","comments":true,"path":"2018/03/22/mysql之索引的工作机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/22/mysql之索引的工作机制/","excerpt":"mysql之高性能索引当db的量达到一定数量级之后，每次进行全表扫描效率就会很低，因此一个常见的方案是建立一些必要的索引作为优化手段，那么问题就来了： 那么什么是索引呢？ 索引的实现原理是怎样的？ 我们通常说的聚集索引，非聚集索引的区别是什么？ 如何创建和使用索引呢？","text":"mysql之高性能索引当db的量达到一定数量级之后，每次进行全表扫描效率就会很低，因此一个常见的方案是建立一些必要的索引作为优化手段，那么问题就来了： 那么什么是索引呢？ 索引的实现原理是怎样的？ 我们通常说的聚集索引，非聚集索引的区别是什么？ 如何创建和使用索引呢？ I. 索引介绍MySQL官方对索引的定义为：索引是帮助MySQL高效获取数据的数据结构。简而言之,索引是数据结构 1. 几种树的结构a. B+树单来说就是一种为磁盘或者其他存储设备而设计的一种平衡二叉树,在B+tree中所有记录都按照key的大小存放在叶子结点上，各叶子结点直接用指针连接 b. 二叉树二叉树的规则是父节点大于左孩子节点，小于右孩子节点 c. 平衡二叉树首先是一个二叉树，但是要求任意一个节点的左右孩子节点的高度差不大于1 d. B树首先是一个平衡二叉树，但是又要求每个叶子节点到根节点的距离相等 那么B树和B+树的区别是什么呢？ B+树的叶子节点可以包含一个指针，指向另一个叶子节点 B+树键值的拷贝存在非叶子节点；键值+记录存储在叶子节点 2. InnoDB引擎之B+树mysql的InnnoDB引擎采用的B+树，只有叶子节点存储对应的数据列，有以下好处 叶子结点通常包含较多的记录，具有较高的扇出性(可理解为每个节点对应的下层节点较多)，因此树的高度较低(3~4)，而树的高度也决定了磁盘IO的次数，从而影响了数据库的性能。一般情况下，IO次数与树的高度是一致的 对于组合索引，B+tree索引是按照索引列名(从左到右的顺序)进行顺序排序的，因此可以将随机IO转换为顺序IO提升IO效率;并且可以支持order by \\group等排序需求;适合范围查询 3. hash索引hash索引，相比较于B树而言，不需要从根节点到叶子节点的遍历，可以一次定位到位置，查询效率更高，但缺点也很明显 仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询 因为是通过hash值进行计算，所以只能精确查询，hash值是没什么规律的，不能保证顺序和原来一致，所以范围查询不行 无法进行排序 原因同上 不支持部分索引 hash值的计算，是根据完整的几个索引列计算，如果少了其中一个乃至几个，这个hash值就没法计算了 hash碰撞 4. 聚集索引与非聚集索引a. 聚集索引InnoDB的数据文件本身就是索引文件，B+Tree的叶子节点上的data就是数据本身，key为主键，非叶子节点存放&lt;key,address&gt;，address就是下一层的地址 聚簇索引的结构图: b. 非聚集索引非聚簇索引，叶子节点上的data是主键(即聚簇索引的主键，所以聚簇索引的key，不能过长)。为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证 非聚簇索引结构图： 从非聚集索引的结构上，可以看出这种场景下的定位流程： 先通过非聚集索引，定位到对应的叶子节点，找到对应的主键 根据上面找到的主键，在聚集索引中，定位到对应的叶子节点（获取数据） 5. 索引的优点 避免全表扫描（当走不到索引时，就只能一个一个的去匹配；如果走索引，则可以根据B树来定位） 使用索引可以帮助服务器避免排序或者临时表 （叶子节点上的指针，可以有效的支持范围查询；此外叶子节点本身就是根据key进行排序的） 索引将随机IO变成顺序IO 6. 适用范围索引并不是适用于任何情况。对于中型、大型表适用。对于小型表全表扫描更高效。而对于特大型表，考虑”分区”技术 II. 索引的使用原则一般我们在创建表的时候，需要指定primary key, 这样就可以确定聚集索引了，那么如何添加非聚集索引呢？ 1. 索引的几个语法创建索引 12345-- 创建索引create index `idx_img` on newuser(`img`);-- 查看show create table newuser\\G; 输出 1234567891011121314151617181920212223show create table newuser\\G*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`), KEY `idx_img` (`img`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 另一种常见的添加索引方式 1234alter table newuser add index `idx_extra_img`(`isDeleted`, `img`);-- 查看索引show index from newuser; 输出结果 123456789101112+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| newuser | 0 | PRIMARY | 1 | userId | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_username | 1 | username | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_nickname | 1 | nickname | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_email | 1 | email | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_phone | 1 | phone | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_img | 1 | img | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_extra_img | 1 | isDeleted | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_extra_img | 2 | img | A | 3 | NULL | NULL | YES | BTREE | | |+---------+------------+---------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 删除索引 12345drop index `idx_extra_img` on newuser;drop index `idx_img` on newuser;-- 查看索引show index from newuser; 输出 12345678910show index from newuser;+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+| newuser | 0 | PRIMARY | 1 | userId | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_username | 1 | username | A | 3 | NULL | NULL | YES | BTREE | | || newuser | 1 | idx_nickname | 1 | nickname | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_email | 1 | email | A | 3 | NULL | NULL | | BTREE | | || newuser | 1 | idx_phone | 1 | phone | A | 3 | NULL | NULL | | BTREE | | |+---------+------------+--------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+ 强制走索引的一种方式 语法： select * from table force index(索引) where xxx 1234567891011121314explain select * from newuser force index(PRIMARY) where userId not in (3, 2, 5);-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | range | PRIMARY | PRIMARY | 8 | NULL | 4 | Using where |-- +----+-------------+---------+-------+---------------+---------+---------+------+------+-------------+explain select * from newuser where userId not in (3, 2, 5);-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | PRIMARY | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ 2. 索引使用规则当一个表内有多个索引时，如何判断自己的sql是否走到了索引，走的是哪个索引呢？ 可以通过 explain 关键字来进行辅助判断，当然在实际写sql时，我们也有必要了解下索引匹配的规则，避免设置了一些冗余的索引，或者写出一些走不到索引的sql 测试的表结构如下 12345678910111213141516171819*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname_email_phone` (`nickname`,`email`,`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 a. 最左前缀匹配原则这个主要是针对多列非聚簇索引而言，比如有下面这个索引idx_nickname_email_phone(nickname, email, phone), nickname 定义在email的前面，那么下面这几个语句对应的情况是 1234567891011121314151617181920212223-- 走索引explain select * from newuser where nickname='小灰灰' and email='greywolf@xxx.com';-- 1. 匹配nickname，可以走索引explain select * from newuser where nickname='小灰灰';-- 输出:-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- | 1 | SIMPLE | newuser | ref | idx_nickname_email | idx_nickname_email | 92 | const | 1 | Using index condition |-- +----+-------------+---------+------+--------------------+--------------------+---------+-------+------+-----------------------+-- 2. 虽然匹配了email, 但是不满足最左匹配，不走索引explain select * from newuser where email='greywolf@xxx.com';-- 输出-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | NULL | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ b. 无法跳过某个列使用后续索引列即对索引idx_nickname_email_phone(nickname, email, phone), 如果你的sql中，只有 nickname 和 phone, 那么phone走不到索引，因为不能跳过中间的email走索引 c. 范围查询后的列无法使用索引如 &gt;, &lt;, between, like这种就是范围查询，下面的sql中，email 和phone都无法走到索引，因为nickname使用了范围查询 1select * from newuser where nickname like '小灰%' and email='greywolf@xxx.com' and phone=15971112301 limit 10; d. 列作为函数参数或表达式的一部分12345678910-- 走不到索引explain select * from newuser where userId+1=2 limit 1;-- 输出-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+-- | 1 | SIMPLE | newuser | ALL | NULL | NULL | NULL | NULL | 3 | Using where |-- +----+-------------+---------+------+---------------+------+---------+------+------+-------------+ 3. 索引缺点 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 4. 注意事项 索引不会包含有NULL值的列 使用短索引 索引列排序 MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引 like语句操作 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引 不要在列上进行运算 select * from users where YEAR(adddate)&lt;2007; 尽量不使用NOT IN和&lt;&gt;操作 5. sql使用策略a. 使用一个sql代替多个sql通常建议是使用一个sql来替代多个sql的查询 当然若sql执行效率很低，或者出现delete等导致锁表的操作时，也可以采用多个sql，避免阻塞其他sql b. 分解关联查询将关联join尽量放在应用中来做，尽量执行小而简单的的sql 分解后的sql简单，利于使用mysql缓存 执行分解后的sql，减少锁竞争 更好的扩展性和维护性（sql简单） 关联sql使用的是内嵌循环算法nestloop，而应用中可以使用hashmap等结构处理数据，效率更高 c. count count(*) 统计的是行数 count(列名) 统计的是列不为null的数量 d. limit limit offset, size; 分页查询，会查询出 offset + size 条数据，获取最后的size条数据 如 limit 1000, 20 则会查询出满足条件的1020条数据，然后将最后的20个返回，所以尽量避免大翻页查询 e. union需要将where、order by、limit 这些限制放入到每个子查询，才能重分提升效率。另外如非必须，尽量使用Union all，因为union会给每个子查询的临时表加入distinct，对每个临时表做唯一性检查，效率较差。 6. mysql使用查询a. 查看索引123-- 单位为GBSELECT CONCAT(ROUND(SUM(index_length)/(1024*1024*1024), 6), ' GB') AS 'Total Index Size'FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; b. 查看表空间12SELECT CONCAT(ROUND(SUM(data_length)/(1024*1024*1024), 6), ' GB') AS 'Total Data Size' FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; c. 查看数据库中所有表的信息1234567SELECT CONCAT(table_schema,'.',table_name) AS 'Table Name', table_rows AS 'Number of Rows', CONCAT(ROUND(data_length/(1024*1024*1024),6),' G') AS 'Data Size', CONCAT(ROUND(index_length/(1024*1024*1024),6),' G') AS 'Index Size' , CONCAT(ROUND((data_length+index_length)/(1024*1024*1024),6),' G') AS'Total' FROM information_schema.TABLES WHERE table_schema LIKE 'databaseName'; IV. 其他参考 深入理解Mysql——高性能索引与高性能SQL 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"},{"name":"索引","slug":"索引","permalink":"https://zbang.online/hexblog/tags/索引/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"mysql基本语法学习小结","slug":"mysql基本语法学习小结","date":"2018-03-22T01:29:58.000Z","updated":"2018-04-11T03:48:34.956Z","comments":true,"path":"2018/03/22/mysql基本语法学习小结/","link":"","permalink":"https://zbang.online/hexblog/2018/03/22/mysql基本语法学习小结/","excerpt":"本篇将主要集中在mysql的使用上，包括如何创建标，如何进行insert,update,select,delete，以及一些常见的sql中关键字的使用姿势","text":"本篇将主要集中在mysql的使用上，包括如何创建标，如何进行insert,update,select,delete，以及一些常见的sql中关键字的使用姿势 I. 数据库管理相关首先是从结构上知晓，一般的关系型数据库，先创建database(数据库), 然后可以在database中创建多个table(表) 通常，在业务稍微大一点的公司而言，不会把所有的数据都放在一个database中，相反会根据不同的业务，创建不同的database，然后在各自的database中维护自己的表，好处就是不会相互影响，后续扩容也方便 1. 创建database1create database test 2. 切换databasae1user test 3. 删除database1drop databse test 4. 显示所有数据库1show databases II. 表相关主要的操作都是针对表来的，因为数据就是挂在这个下面的 1. 创建表12345678910111213141516171819CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='自定义表' 创建表的规则还是比较简单的，一般语法是： 123456create table tableName( 列名 + 列类型 + NOT NULL(可选，表示这个字段不能为空) + DEFAULT '' (可选，表示默认填充的数据) + COMMENT (后面加上这一列的注释), ... PRIMARY KEY (`id`), // 这个指定主键 KEY `idx_firstId` (`name`) // 这个是指定索引) ENGINE=InnoDB (指定存储引擎) AUTO_INCREMENT=1 （自增开始值） DEFAULT CHARSET=utf8 （默认编码） COMMENT='自定义表'; 需要注意一点，一个表的设计时，最好不要让某一列可以为null，而且良好的习惯是加上DEFALUT默认值，加上列的注释（特别是type的取值固定为1,2,3,4时，尽量在说明中写上每个值的含义） 2. 显示表信息如果我们是在控制台中来上mysql进行相关操作时，非常常见的一个命令就是如何查看表的数据结构，有几个命令 1desc table_name; 输出格式如下: 1234567891011121314151617+-----------+---------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+---------------------+------+-----+---------+----------------+| userId | bigint(20) | NO | PRI | NULL | auto_increment || username | varchar(30) | YES | MUL | | || nickname | varchar(30) | NO | MUL | | || password | varchar(50) | YES | | | || address | text | YES | | NULL | || email | varchar(50) | NO | MUL | | || phone | bigint(20) | NO | MUL | 0 | || img | varchar(100) | YES | | | || extra | text | YES | | NULL | || isDeleted | tinyint(1) unsigned | NO | | 0 | || created | int(11) | NO | | NULL | || updated | int(11) | NO | | NULL | |+-----------+---------------------+------+-----+---------+----------------+12 rows in set (0.00 sec) 如果我希望获取这个表的建表语句，方便直接创建表，也可以用下面的命令 1show create table tableName\\G 输出如下 12345678910111213141516171819202122*************************** 1. row *************************** Table: newuserCreate Table: CREATE TABLE `newuser` ( `userId` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '用户id', `username` varchar(30) DEFAULT '' COMMENT '用户登录名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '用户昵称', `password` varchar(50) DEFAULT '' COMMENT '用户登录密码 &amp; 密文根式', `address` text COMMENT '用户地址', `email` varchar(50) NOT NULL DEFAULT '' COMMENT '用户邮箱', `phone` bigint(20) NOT NULL DEFAULT '0' COMMENT '用户手机号', `img` varchar(100) DEFAULT '' COMMENT '用户头像', `extra` text, `isDeleted` tinyint(1) unsigned NOT NULL DEFAULT '0', `created` int(11) NOT NULL, `updated` int(11) NOT NULL, PRIMARY KEY (`userId`), KEY `idx_username` (`username`), KEY `idx_nickname` (`nickname`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf81 row in set (0.00 sec) 3. 修改表重命名表名 1rename table `oldTableName` to `newTableName` 新加字段 12-- 修改类型alter table newuser add newcol varchar(10) not null default '' comment '新加的列'; 修改列 123456-- 修改类型alter table newuser modify newcol text not null;-- 修改名alter table newuser change `newcol` `newcol2` text; 删除列 1alter table newuser drop newcol2; 删除表 1drop table newuser; 4. 增删改查对DB的操作，基本上就四种了，增删改查，甚至绝大多数的业务都可以用简单的db的增删改查来实现 a. 插入一条数据1234-- insert into table_name(`列名`, `列名`) values('插入值', '插入值');insert into newuser(`username`, `nickname`, `password`, `address`, `email`, `phone`, `img`, `extra`, `isDeleted`, `created`, `updated`) values('insert', 'insert', 'insert', 'test', 'test@test.com', 123, 'img', '', 0, 1521638764, 1521638764); b. 查询数据select用于查询，先给出一个最基本的，下面再详细说明 1select * from newuser where username='insert' limit 1; 上面表示查询 username为insert的记录，输出结果(也就是刚才插入的那一条数据) 12345+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| userId | username | nickname | password | address | email | phone | img | extra | isDeleted | created | updated |+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| 3 | insert | insert | insert | test | test@test.com | 123 | img | | 0 | 1521638764 | 1521638764 |+--------+----------+----------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+ c. 修改数据将之前插入的记录中，nickname 修改成 ‘newNickName’, 借助 update set 语法实现 12345update newuser set nickname='newNickName' where userId=3;-- 再次查询验证select * from newuser where username='insert' limit 1; 输出结果 12345+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| userId | username | nickname | password | address | email | phone | img | extra | isDeleted | created | updated |+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+| 3 | insert | newNickName | insert | test | test@test.com | 123 | img | | 0 | 1521638764 | 1521638764 |+--------+----------+-------------+----------+---------+---------------+-------+------+-------+-----------+------------+------------+ d. 将刚才的数据删掉说明，在实际的生产环境中，一般很少物理删除（即执行delete将记录彻底抹掉），更多的是采用逻辑删除的方案（至少还有恢复的可能，而且数据都是宝贵的，虽然大部分时候我们都没有去挖掘，但保存着总比丢掉好） 物理删除的语法比较简单，但是需要额外小心，一不小心删错了，说不准就得卷铺盖滚蛋了 1234567delete from newuser where userId=3 limit 1;-- 再次查询验证select * from newuser where username='insert' limit 1;-- 输出： Empty set (0.00 sec) III. 玩出花的查询语句1. 基本查询写sql而言，最常见的，也是最复杂的就是写各种查询了，根据各种不同的条件查询检索结果，大概可以区分以下几种 简单查询：知道确切的检索条件 where xxx=xxx 相等的判断 where xxx&lt;&gt;xxx 不等的判断 where id in (xxx, xxx, xxx) 满足集合的判断 where xxx=xxx and yyy=yyy 条件同时满足 where xxx=xxx or yyy=yyy 条件满足一个即可 where id&gt;10 or id&lt;5 范围判断 &gt;, &lt;, &gt;=, &lt;= where name is null 判空 is null, =’’, 非空 is not null, &lt;&gt;’’ 模糊查询: like 语法， %:替代任意个字符 _:替代一个字符 如: select userId,username from newuser where username like &#39;%灰%&#39;; 输出: 123456+--------+-----------+| userId | username |+--------+-----------+| 1 | 大灰狼 || 2 | 小灰灰 |+--------+-----------+ 条件限制 where 1=1 limit 10; 限制最多查询出来的条数 where 1=1 limit 1, 2; 分页查询 group by username; 分组 order by userId desc; 排序： desc倒排，asc 正排 select distinct(nickname) from xxx; 去重 having count(*) &gt; 2; 分组之后再筛选 执行计算 update phone=phone+1 limit 1; 直接实现数值计算 count(*) 统计总数 sum() 统计和 max() 最大值 min() 最小值 avg() 平均值 常用函数 abs() 返回绝对值 bin() 返回二进制 oct() 返回八进制， hex() 返回十六进制 exp() 返回e的n次方 greatest(x1, x2... xn) least(x1, x2, ...n) 返回最大最小 ln(x) 返回x的自然对数 log(x, y) mod(x, y) 返回x%y的模（余数） rand() 返回0-1内的随机值 floor(x) 反后小于x的最大整数 ceiling(x) 返回大于x的最小整数 round(x, y) 返回x的四舍五入的有y位小数的值 turncate(x,y) 截断为y位小数 sign(x) sqrt(x) 平方根 concat(s1, s2...) 字符串拼接 left(str, x) str的左x个字符 right(str, x) length(str) 返回字符串的长度 trim(str) 去掉空格 from_unixtime 将时间戳转日期 更多参考：MySQL常用函数 123456789select username,from_unixtime(created) from newuser limit 1;--- 下面为输出-- +-----------+------------------------+-- | username | from_unixtime(created) |-- +-----------+------------------------+-- | 大灰狼 | 2016-09-25 00:00:00 |-- +-----------+------------------------+ 2. 跨表查询当设计到查询多张表的结果时，往往是比较麻烦的 简单的多表查询方式 1select col1, col2 from table1, table2 where table1.col1 = table2.col2 limit 10; 主要就是利用两个表中的关联的列进行联合查询，也就是说，当查询涉及到多表时，那么这些表肯定是有沟通的桥梁的（一般是某一张表的主键是另一张表的某一列） 举个小例子，查询商品评价数为1的商品（假设评价是一张表，商品也是一张表），那么关联的主键就是商品ID了 如果是分开查询，那么应该是 1234567-- 查询出评价总数为1的10条评价select * from Rate group by itemId having count(*) =1 limit 10;-- 查询对应的商品信息, 上面的结果就是下面()中的内容select * from Item where itemId in (xxx, xxx); 那么换成一条sql，可以怎么写？ 简单的嵌套方案：（有点像是硬把多条语句写成一条） 12select * from Item where itemId in (select itemId from Rate group by itemId having count(*)=1 limit 10); 一般多表查询可划分为: a.交叉连接查询需求:查询员工及其部门名称 123SELECT employee.name,dept.nameFROM employee,dept; b.内连接查询(使用最多)多表查询的步骤: 1)确定查询哪些表2)确定查询哪些字段3)确定连接条件(规则:条件=表数量-1) 123SELECT employee.name,dept.nameFROM employee,deptWHERE employee.deptId=dept.id; 另一种语法 1234SELECT e.name,d.name FROM employee e INNER JOIN dept d ON e.deptId=d.id; c.左外连接查询(左表数据全部显示，如果右边不满足，则显示null)需求:查询部门及其部门的员工 1234SELECT d.name,e.name FROM dept d LEFT OUTER JOIN employee e ON d.id=e.deptId; d.右外连接查询(右表数据全部显示，如果左边不满足，则显示null)1234SELECT d.name,e.nameFROM employee eRIGHT OUTER JOIN dept dON e.deptId=d.id; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zbang.online/hexblog/tags/mysql/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"DB","slug":"技术/DB","permalink":"https://zbang.online/hexblog/categories/技术/DB/"},{"name":"Mysql","slug":"技术/DB/Mysql","permalink":"https://zbang.online/hexblog/categories/技术/DB/Mysql/"}]},{"title":"常用Alfred工具","slug":"常用Alfred插件","date":"2018-03-19T02:14:32.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Alfred插件/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Alfred插件/","excerpt":"","text":"I. Alfred工具alfred可以说是mac上必备的一个app了，可以极大的提高工作效率，再加上它支持自定义实现各种扩展，完全可以满足大部分的需求场景了 1. 安装首先下载安装包，推荐一个神奇的网站，下载各种mac的破解软件，工具下载链接: http://xclient.info/s/alfred.html 破解方式： 点击下载包里面的keygen 点击patch，会打开目录，选择alfred，点击激活 重启alfred即可 2. 几个插件下载包内直接包含了所有的流程和源码，也没什么好具体说的，下载完毕之后双击即可 a. 日期与时间戳点击下载：time.alfredworkflow demo: b. md5点击下载: md5.alfredworkflow demo: c. url编码点击下载: URL编码.alfredworkflow demo: d. 分库分表点击下载: table.alfredworkflow demo: II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"常用Popclip工具","slug":"常用Popclip工具","date":"2018-03-19T01:50:57.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Popclip工具/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Popclip工具/","excerpt":"","text":"I. PopClip工具PopClip是mac上的一个工具集，最大的特点就是扩展，复制一段文本，然后根据你的需求写插件，把赋值的文本作为输出，做一些你想干的事 基于PopClip，也写了一些小工具，主要是php写的，写插件的教程还是比较简单的，一个配置文件Config.plist和一个脚本文件xxx.php即可 1. 实现一个插件流程以JSON格式序列化为demo进行演示，如何从0到1创建一个popclip插件，先看一下最终的成品 一个插件的文件比较简单，主要有两个 Config.plist 具体的脚本文件 a. 配置文件下面是一个实际的配置，里面指定了两个脚本： 第一个是 json2str.php，这个脚本实现将json转换为单行字符串，在插件上显示的名字就是 JsonStr, 采用的php编写实现 第二个是 str2json.php 需要注意的是里面正则规则，这个主要是用来表示当你划中一段文本之后，是否会出现这个插件的规则（比如时间戳和日期的相互转换，只有选中纯数字时，才支持时间戳转日期） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;&lt;plist version=\"1.0\"&gt;&lt;dict&gt; &lt;key&gt;Actions&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;After&lt;/key&gt; &lt;string&gt;paste-result&lt;/string&gt; &lt;key&gt;Regular Expression&lt;/key&gt; &lt;!-- 正则匹配规则，*号表示任意选中的内容都会激活这个插件 --&gt; &lt;string&gt;*&lt;/string&gt; &lt;key&gt;Script Interpreter&lt;/key&gt; &lt;string&gt;/usr/bin/php&lt;/string&gt; &lt;key&gt;Shell Script File&lt;/key&gt; &lt;!-- 执行具体逻辑的脚本名 --&gt; &lt;string&gt;json2str.php&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;!-- 插件的name --&gt; &lt;string&gt;JsonStr&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;After&lt;/key&gt; &lt;string&gt;paste-result&lt;/string&gt; &lt;key&gt;Regular Expression&lt;/key&gt; &lt;string&gt;*&lt;/string&gt; &lt;key&gt;Script Interpreter&lt;/key&gt; &lt;string&gt;/usr/bin/php&lt;/string&gt; &lt;key&gt;Shell Script File&lt;/key&gt; &lt;string&gt;str2json.php&lt;/string&gt; &lt;key&gt;Title&lt;/key&gt; &lt;string&gt;StrJson&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;Extension Description&lt;/key&gt; &lt;!-- 描述 --&gt; &lt;string&gt;remove json space or stringfy json str&lt;/string&gt; &lt;key&gt;Extension Name&lt;/key&gt; &lt;string&gt;JSON&lt;/string&gt; &lt;key&gt;Credits&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;Link&lt;/key&gt; &lt;string&gt;mailto:bangzewu@126.com&lt;/string&gt; &lt;key&gt;Name&lt;/key&gt; &lt;string&gt;Json序列化&lt;/string&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;Extension Identifier&lt;/key&gt; &lt;string&gt;popclip.extension.json-covert&lt;/string&gt; &lt;key&gt;Required Software Version&lt;/key&gt; &lt;integer&gt;695&lt;/integer&gt;&lt;/dict&gt;&lt;/plist&gt; b. 脚本文件这个里面就是写具体的业务逻辑，一般是将粘贴板中的内容作为输入，然后进行一段业务逻辑，然后输出到粘贴板内 如str2json.php 12345678&lt;?php$input=getenv(\"POPCLIP_TEXT\");if(empty($input)) &#123; echo ''; &#125; else &#123; $param = json_decode($input); echo json_encode($param, JSON_UNESCAPED_UNICODE|JSON_PRETTY_PRINT|JSON_UNESCAPED_SLASHES);&#125; 注意第一行，获取输入 $input=getenv(&quot;POPCLIP_TEXT&quot;);, 不同的脚本有不同的获取方式 输出就比较简单了，传统的输出方法，会重写到粘贴板内 echo &#39;xxx&#39;; c. 打包上面完成之后，就是打包安装了，流程如下： 新建一个文件夹，后缀为.popclipext，将.plist和脚本文件拷贝到新的文件夹下 压缩： zip -r xxx.popclipextz xxx.popclipext/ 双击上面生成的文件，确认安装即可 说明： 上面新建的文件夹，一定要以.popclipext结尾 2. 我的插件a. base64编码作用：实现base64编码解码 源码地址: base64 demo: b. 日期&amp;时间戳作用：实现日期和时间戳的相互转换 源码地址： date demo: c. unicode字符转中文源码 : unicode d. json格式化源码: json e. url编码解码源码: url II. 其他工程地址所有的插件都可以访问： PopClip 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"常用Chrome工具","slug":"常用Chrome工具","date":"2018-03-19T01:47:47.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/19/常用Chrome工具/","link":"","permalink":"https://zbang.online/hexblog/2018/03/19/常用Chrome工具/","excerpt":"","text":"I. Chrome常用插件记录下使用到的Chrome插件，有些挺有意思的东西 1. Website IP在网页的右下角(or左下角)显示当前网页的服务器IP，用来判断当前的系统的工作环境非常有用，特别是在线下、预发和生产环境的切换时，判断host是否切换的时候 2. Adblock Plus拦截小广告 3. Adkill and Media download拦截视频广告，我常逛的优酷，腾讯视频，爱奇艺，芒果的视频广告都被可以被吃掉，节省两分钟的等待时间 4. GitCodeTree码云提供的gitee，侧边栏提供一个直接查看代码的树状结构 5. JSON Editor写json的插件 6. Json Handlerjson结构化，针对请求直接返回json串的场景用起来比较爽，除了结构化输出之外，还可以修改json串内容，个人感觉比JSONView好用 7. Octotreegithub源码视图工具，和前面的 GitCodeTree 差不多 8. Postman模拟各种http请求 9. Vimium以vim的方式操作浏览器页面，实现真正的无鼠标全键盘操作 10. 二维码(QR码)生成器(QR Code Generator)当前网页生成一个二维码，方便手机打开 11. 捕捉网页截图 - FireShot网页截图工具，可以截长图文，但是在网页特别长时，截取失败，有些时候用起来还可以 12. 掘金覆盖默认的新打开标签页，显示一些有意思的git项目和掘金上的优秀博文 13. Encoder(自定义实现)自己写的一个插件，主要是为了提供一些常见的转换， 源码&amp;下载地址: Chrome-Coder 时间戳和日期的相互转换 url编码解码 base64编码解码 unicode编码解码 14. Chrome-ImgRender自己写的插件，源码&amp;下载地址: Chrome-ImgRender 选择网页中的dom结构，输出图片的小工具，使用演示如： II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"小工具","slug":"杂记/小工具","permalink":"https://zbang.online/hexblog/categories/杂记/小工具/"}]},{"title":"Java学习之NIO相关","slug":"Java学习之NIO相关","date":"2018-03-18T12:54:24.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/18/Java学习之NIO相关/","link":"","permalink":"https://zbang.online/hexblog/2018/03/18/Java学习之NIO相关/","excerpt":"Java NIO学习小结前面一篇主要学习了下IO的流式操作，接下来就是重头戏了，NIO，又称为New IO 当然也是得抱着问题来学习这个东西了，希望可以通过本文，可以学习到： 什么是NIO NIO相比较与IO有什么特点 同步，非同步，阻塞，非阻塞是什么鬼 几种IO模型","text":"Java NIO学习小结前面一篇主要学习了下IO的流式操作，接下来就是重头戏了，NIO，又称为New IO 当然也是得抱着问题来学习这个东西了，希望可以通过本文，可以学习到： 什么是NIO NIO相比较与IO有什么特点 同步，非同步，阻塞，非阻塞是什么鬼 几种IO模型 I. 基本概念首先理解下什么是同步IO,非同步IO，什么是阻塞IO，非阻塞IO，它们两对的主要区别是什么；其次就是五种IO模型 1. 同步/非同步IOa. 同步IO同步，主要是多个线程的执行中，对彼此的执行结果有依赖，即某个线程的执行，必须要求他依赖的线程二执行完毕 同步IO，表示在发起IO操作之后，如果数据没有准备就绪，就需要用户线程轮询的去询问是否准备好，只有准备好之后，将数据从内核拷贝到用户线程 b. 异步IO异步，指多个任务可以并发的执行，他们比吃执行结果，是否执行完毕对其他都没有影响 异步IO，用户线程发起IO操作，该用户线程可以继续执行其他的事情；剩下的数据是否准备完毕，准备完毕之后从内核拷贝到用户都有内核自动完成 c. 区别同步IO和异步IO的主要区别就在于： 用户线程发起IO操作之后，是否可以干其他的事情（同步IO需要轮询判断数据是否准备就绪；异步IO不需关心） 数据从内核拷贝到用户线程 同步IO会阻塞用户线程；异步IO不会 2. 阻塞/非阻塞IO阻塞IO阻塞，指在执行过程中，没有获得预期的结果，就一直阻塞等待获取到结果 阻塞IO，在发起IO请求之后，若数据没有准备好，就一直阻塞等待数据准备完毕 非阻塞IO非阻塞，表示在执行过程中，若某个条件未满足，则直接返回个标识，它继续去干其他的事情 非阻塞IO，在发起IO请求之后，若数据没有准备好，就返回一个对应标识，它继续干其他的事情 3. 五种IO模型a. 阻塞IO模型最传统的IO模型，在读写数据时，未准备就绪，则阻塞用户线程，释放CPU资源，当数据准备就绪之后，内核将数据拷贝到用户线程，用户线程取消阻塞状态 b. 非阻塞IO模型在读写数据时，直接返回结果，如果没有准备好，则自己实现逻辑，轮询的去判断是否准备就绪 当准备完毕之后，再次轮组发起IO请求，就可以将数据拷贝到用户线程 这个过程中，虽然没有释放CPU资源，但是轮询的判断是非常消耗性能的 c. 多路复用IO模型Java NIO实际上就是多路复用IO。 在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用 在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。 d. 信号驱动IO模型在发起IO请求时，注册一个信号驱动钩子，然后自己干自己的事情 当数据准备就绪之后，发送一个信号给用户线程，然后用户线程执行自己注册的钩子，在内部实现真实的IO操作 e. 异步IO模型异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了 说明 前面四种都属于同步IO（在内核进行数据拷贝都会引起用户线程阻塞），只有最后一个是异步IO 异步IO和信号驱动IO的主要区别在于具体的数据处理上 II. NIO为了解决传统IO的阻塞问题引入的，主要原理如下: 一个专门的线程来处理所有的 IO 事件，并负责分发 事件驱动机制 线程通讯通过 wait/notify 等方式通讯，较少线程切换 1. 基础知识NIO新定义了三个基本角色：Channel, Buffer, Selector a. Channel类似IO中的流，但又有不同 支持读写（而流是单向的） 与Buffer进行交互（即写入到buffer，从buffer中读取） 支持异步 常见的Channel有四种 FileChannel ： 文件，不支持非阻塞方式 DatagramChannel：UDP网络数据 SocketChannel：TCP读写网络数据 ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 b. Buffer缓冲区，主要有8种: ByteBuffer CharBuffer FloatBuffer DoubleBuffer IntBuffer ShortBuffer LongBuffer MappedByteBuffer 管道的读写是需要借助Buffer来实现的，一般buffer的读写流程： 创建Buffer ByteBuffer buf = ByteBuffer.allocate(48); 写入数据到Buffer 从Channel写到Buffer: channel.read(buf); 直接塞入buffer: buf.put(12); flip() 切换读写模式 将写模式切换到读模式 从Buffer读取数据 从Buffer读数据到Channel：channel.write(buf); 直接读取数据: buf.get() 清空缓存区：clear() 或 compact() clear 清空，但是数据并未清除，会覆盖 compact 将所有未读的数据拷贝到Buffer起始处 额外方法： Buffer.rewind() 将position设回0，所以你可以重读Buffer中的所有数据 limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等） Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用 Buffer.reset()方法，恢复到Buffer.mark()标记时的position c. selector是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件 创建 Selector selector = Selector.open(); 注册通道 设置通道为非阻塞 channel.configureBlocking(false); 注册: SelectionKey key = channel.register(selector,Selectionkey.OP_READ); 监听事件 selector.select();当注册的事件到达时，方法返回；否则,该方法会一直阻塞 迭代：selector.selectedKeys().iterator() 获取通道: SelectionKey#channel 通过缓冲区读写数据 III. NIO与IO对比1. Java NIO提供了与标准IO不同的IO工作方式： Channels and Buffers（通道和缓冲区）：标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。 Asynchronous IO（异步IO）：Java NIO可以让你异步的使用IO，例如：当线程从通道读取数据到缓冲区时，线程还是可以进行其他事情。当数据被写入到缓冲区时，线程可以继续处理它。从缓冲区写入通道也类似。 Selectors（选择器）：Java NIO引入了选择器的概念，选择器用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。 2. 使用场景NIO 优势在于一个线程管理多个通道；但是数据的处理将会变得复杂； 如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种； 传统IO 适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的 如果需要管理同时打开不太多的连接，这些连接会发送大量的数据； 3. 区别 IO是面向流的，NIO是面向缓冲区的 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方； NIO则能前后移动流中的数据，因为是面向缓冲区的 IO流是阻塞的，NIO流是不阻塞的 Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 选择器 Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道 这些通道里已经有可以处理的输入，或者选择已准备写入的通道 这种选择机制，使得一个单独的线程很容易来管理多个通道。 IV. 其他参考 Java NIO：浅析I/O模型 Java NIO原理图文分析及代码实现 Java NIO系列教程（一） Java NIO 概述 Java NIO 与 IO之间的区别 JAVA IO 以及 NIO 理解 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://zbang.online/hexblog/tags/IO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}]},{"title":"Java学习之IO相关","slug":"Java学习之IO相关","date":"2018-03-18T07:19:55.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/18/Java学习之IO相关/","link":"","permalink":"https://zbang.online/hexblog/2018/03/18/Java学习之IO相关/","excerpt":"Java IO学习小结IO操作算是java的一个基本知识点了，比如我们常见的网络IO，文件读写等，而且这一块基本上大家并不会频繁的来操作，大多会用一些封装得好用的工具来代替，某些时候真的需要做的时候，基本上也很难一下子很顺利的写完 本篇将主要集中在： 几种IO分类 字节IO和字符IO的转换 装饰类IO是什么 序列化的实现机制","text":"Java IO学习小结IO操作算是java的一个基本知识点了，比如我们常见的网络IO，文件读写等，而且这一块基本上大家并不会频繁的来操作，大多会用一些封装得好用的工具来代替，某些时候真的需要做的时候，基本上也很难一下子很顺利的写完 本篇将主要集中在： 几种IO分类 字节IO和字符IO的转换 装饰类IO是什么 序列化的实现机制 I. IO分类Java中的IO操作，一般都是基于流进行，以输入输出流进行分类可以分为 字节流：InputStream, OutputStream 字符流：Reader, Writer 从数据源进行分类，又可以区分为： 文件读写： FileInputStream, FileOutputStream，FileReader 字符串流： StringBufferInputStream， StringReader 数组流： ByteArrayInputStream 网络： Socket 从去向分析，就是输入流和输出流： 输入流： xxxInputStream, xxxReader 输出流: xxxOutputStream, xxxWriter II. IO流的基本知识点IO操作，最主要的一点就是需要清晰如何使用了，一般来讲，网络或文件读写，都是基于字节进行交互的，但实际上为了能友好的读取或写入信息，一般都是字符方式，由字符到字节之间则需要一个编码规则的映射 所有，很简单就可以知晓，这里至少有三种不同应用场景的类和一种设计模式 字节流 字符流 字节映射字符流 （适配器模式） 1. 基本使用以常见的文件读写为例进行说明，一般的读写操作是啥样的 123456789101112131415161718@Testpublic void testPrintFile() throws IOException &#123; String fileName = \"/tmp/test.d\"; File file = new File(fileName); InputStream input = new FileInputStream(file); InputStreamReader reader = new InputStreamReader(input, Charset.forName(\"utf-8\")); BufferedReader bufferedReader = new BufferedReader(reader); String ans = bufferedReader.readLine(); while (ans !=null ) &#123; System.out.println(ans); ans = bufferedReader.readLine(); &#125; bufferedReader.close(); reader.close(); input.close();&#125; 上面的流程基本上就下面五步： 创建一个File对象 包装为IO流： new FileInputStream(new File(&quot;test.d&quot;)) 字节流转换为字符流: new InputStreamReader(input, Charset.forName(&quot;utf-8&quot;)) 字符流使用缓冲修饰，支持读一行 关闭流 基本上上面这个套路是比较适合常见的IO操作的，那么为什么是这么个流程呢？这个流程中又有些什么有意思的东西呢？ 2. IO流使用姿势分析 声明：下面这一段纯属个人理解，如有不误，请不吝指正 对操作系统而言（网络传输也一样），他们关心的是一个字节一个字节的行为，所以与它们打交道，就需要遵循他们的规则来办事，使用字节来操作，所以最开始我们都是采用字节流来定义与数据源的交互规则 然而字节流虽好，但是所有的数据最终都是为人服务的，而由于客观原因，不同的国家有不同的语言，为了面向人类的友好，出现了字符这个东西，所以一般我们的操作也更多的是基于字符进行操作 上面这两个出现之后，一个自然而然的东西–&gt;InputStreamReader就出现了，作为字节和字符转换的桥梁 上面这三个可算是一个基本的操作流程了，可以满足我们的输入输出需求，但依然不是特别友好，比如一个一个字符的操作不友好啊，比如我希望过滤某些东西，或者做其他的一些辅助操作之类的，因此就出现了各种装饰流，主要就是提供一些服务方法，增强接口的易用性 简单的使用姿势流图： 123456graph TDA(数据源)--&gt;B(字节流InputStream/OutputStream)B--&gt;C[InputStreamReader/OutputStreamWriter]C--&gt;D[Reader/Writer]D--&gt;E[装饰流]E--&gt;F(关闭) 3. 常见IO类a. 基本介质流与提供读写数据的数据源打交道的流 FileInputStream : 数据源为文件 ByteArrayInputStream: 数据源为byte数组 StringBufferInputStream: StringBuffer作为数据源，已废弃 PipedInputStream：管道，多线程协作使用 使用姿势 123456789101112// 数组byte[] bytes = new byte[]&#123;'a', 'b', 'c', '1', '2'&#125;;ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);int a = 0;while((a = byteArrayInputStream.read()) != -1) &#123; System.out.print(a + \" \");&#125;byteArrayInputStream.close();// 输出: 97 98 99 49 50// StringBufferInputStream 已经被废弃 b. 字节字符转换两个: InputStreamReader OutputStreamWriter 使用姿势也比较简单，标准的适配器模式，用构造方法传参即可，下面给出一个demo，结合上面的，实现将数组流的数据写入的文件(说明，下面的实现更多的是为了演示这种用法，实际编码中有较大的优化空间) 123456789101112131415byte[] bytes = new byte[]&#123;'a', 'b', 'c', '1', '2'&#125;;ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);File file = new File(\"/tmp/test.d\");OutputStream out = new FileOutputStream(file);Writer writer = new OutputStreamWriter(out);int a = 0;while((a = byteArrayInputStream.read()) != -1) &#123; writer.write(a);&#125;writer.flush();writer.close();byteArrayInputStream.close(); c. 装饰流主要是基于装饰模式，对IO流，增强一些操作方法，最明显的是特征是他们继承自 FilterInputStream，比如我们最常用的BufferedInputStream 和 DataInputStream 基本数据类型读写流: DataInputStream 8中基本类型的读入写出流，没什么好说的 缓存流： BufferedInputStream 为了提升性能引入，避免频繁的磁盘读写 对象流: ObjectInputStream 虽然没有继承自FilterInputStream，依然把它作为装饰流，后面单独说 这里面有必要好好的说到以下 BufferedInputStream，缓冲流的底层原理是什么，又有什么好处，为什么会引入这个？ API解释：在创建 BufferedInputStream时，会创建一个内部缓冲区数组。在读取流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。 也就是说，Buffered类初始化时会创建一个较大的byte数组，一次性从底层输入流中读取多个字节来填充byte数组，当程序读取一个或多个字节时，可直接从byte数组中获取，当内存中的byte读取完后，会再次用底层输入流填充缓冲区数组。 以文件读写为例，在实际的落盘和读取过程，这个是加锁阻塞的操作，如果每次都只读1个字节，在大量的读写情况下，这个性能就很脆了 加上这个缓冲之后呢？在一次加锁的过程中，尽量多的读取数据，放在本地内存，这样即便是在使用的地方一个一个的获取，也不会与其他的任务产生竞争，所有有效的提高了效率 III. 序列化在平常的工作中，基本上离不开序列化了，比如web应用中，最常见的基于JSON的数据结构交互，就算是一种JSON序列化方式；当然我们这里谈的序列化主要是JDK原生的方式 1. 背景出现序列化需求的背景比较清晰，我们希望某些对象可以更方便的共享，如即便程序over了，它们可以以某种方式存在（比如写在一个临时文件中），如RPC中传参和返回等 使用时注意事项 一个类需要序列化，需要实现 Serializable 这个空接口，会告知编译器对它进行特殊处理 一个友好的习惯是，在可序列化的类中，定义一个 static final long serialVersionUID transient变量可标识出来不被序列化的字段 2. 实现给出一个使用case 1234567891011121314151617181920212223242526272829303132333435363738394041public static class Demo implements Serializable &#123; private String name; private Integer age; private boolean isBoy; private transient String ignore; public Demo(String name, Integer age, boolean isBoy, String ignore) &#123; this.name = name; this.age = age; this.isBoy = isBoy; this.ignore = ignore; &#125; @Override public String toString() &#123; return \"Demo&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + \", isBoy=\" + isBoy + \", ignore='\" + ignore + '\\'' + '&#125;'; &#125;&#125;@Testpublic void testObjStream() throws IOException, ClassNotFoundException &#123; Demo demo = new Demo(\"测试\", 123, true, \"忽略的一段文本\"); // 将对象写入到文件中 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"/tmp/out.t\")); oos.writeObject(demo); oos.flush(); oos.close(); System.out.println(\"-------- over ----------\"); // 从文件读取 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"/tmp/out.t\")); Object obj = ois.readObject(); System.out.println(\"反序列化: \" + obj + \" \\n类型：\" + obj.getClass().getSimpleName());&#125; 输出结果 123-------- over ----------反序列化: Demo&#123;name=&apos;测试&apos;, age=123, isBoy=true, ignore=&apos;null&apos;&#125; 类型：Demo 对应的文本内容 IV. 小结io可以说是java中最基本的操作方式了，jdk本身设计是比较优雅的，从上面简单的学习就看到了两种设计模式：适配器+装饰器 提到IO，就不能跳过NIO，特别是在实际的工作中，用得非常多的网络交互，现在基本上是Netty占据主流，这个里面又是有不少东西可以学习的，放在下一篇，下面简单回顾下IO流的认知与使用 1. 流分类： 字节流： InputStream , OutputStream 字符流： Reader, Writer 2. 从设计角度分类 介质流：直接与数据源打交道 FileInputStream, StringBufferInputStream(已经不用，改StringBufferReader), ByteArrayInputStream （网络传输的二进制流，基本就是这个） 转换: 字节流和字符流的转换 InputStreamReader, OutputStreamWriter 装饰流: BufferedInputStream, DataInputStream, ObjectInputStream 3. 序列化和反序列化序列化是指将对象输出为二进制流的过程，反序列化则是指将二进制流反序列化为对象的过程 一般序列化的对象需要实现Serializable接口，内部不需要序列化的对象，用transient关键字进行声明 4. IO基本使用姿势介质流与数据源进行交互 –&gt; 转换流包装为字符流 –&gt; 装饰流进行实际操作 –&gt; 关闭流 以文件读写为例: 12345BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"test.txt\"), Chaset.forName(\"utf-8\")));String ans = reader.readLine();reader.close(); IV. 其他参考： 深入理解Java中的IO Java IO完全总结（转载） 编程语言的基础——搞定JavaIO 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"IO","slug":"IO","permalink":"https://zbang.online/hexblog/tags/IO/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"IO","slug":"技术/Java/IO","permalink":"https://zbang.online/hexblog/categories/技术/Java/IO/"}]},{"title":"JVM学习之垃圾回收机制","slug":"JVM学习之垃圾回收机制","date":"2018-03-15T12:18:44.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/15/JVM学习之垃圾回收机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/JVM学习之垃圾回收机制/","excerpt":"","text":"JVM学习之垃圾回收机制jvm的垃圾回收算法，除了我们熟悉的引用计数判断对象是否活着之外，其他还有那些有意思的东西呢？ 总是听到的年轻代年老代又是啥？ 传说中的YoungGC(MinorGC) 和 FullGC的时机是什么，又干了些啥？ I. 对象存活判断垃圾回收，回收的都是那些不在使用的对象（也就是没有存活的对象），因此怎么判断对象是否存活，就显得比较重要了 对这个映像最深刻的就是引用计数方式，一个对象被使用了，计数就+1；不用了，技术就-1；当计数为0的时候，就表示对象没人用了，简单粗暴，然而实际的情况中，大都不用这个方式，因为无法解决对象相互循环引用的问题 目前更多的是采用gc root可达性分析，简单来讲就是从一个根节点往下走，走的轨迹上所有的对象，都表示是存活的；也就是说，所有游离在这个之外的对象，都是需要回收的 那么什么是GC ROOT呢 ？ 虚拟机栈内引用的对象 方法区静态属性引用的对象 方法区常量引用的对象 本地方法栈中JNI引用的对象 II. 垃圾回收算法回收，主要指的是将堆和运行时方法区内没有存活的对象干掉；而通常我们所说的垃圾回收，则主要针对的就是堆内的回收 1. 标记-清除算法简单理解：根据可达性扫一遍，有用的对象打个标记；剩下来一次大清理，将没有标记的都ko掉 说明 看书和博文时，常感觉标记，是将需要回收的对象标记出来，但仔细想了下，从实现成本来讲，根据可达性分析对象是否存活，顺带的直接将存活的打个标记，比将所有没存活的上面打上标记要来的简单，而且这也能算是标记出需要回收的对象 缺点 缺点很明显，会出现大量的碎片空间 2. 复制算法将存储空间一分为二，每次回收就是将这一边的存活对象搬移到另一边 缺点 空间少了一半 对于存活时间比较久的对象，需要频繁的来回搬迁 3. 标记-压缩算法（或标记-整理算法）为了节省空间，这个的策略是将所有存活的对象，往某一边界进行复制，等复制完毕之后，将辩解之外的对象都ko掉 4. 分代收集算法分代收集，实际来说就是综合其他算法的优良特性，结合实际应用场景来处理 将存活时间久，占用空间大的对象，放在老年代 其他的对象可以放在年轻代 也就是说： 老年代中，基本上是老而弥坚的对象，更加适合标记-整理算法，移到一边之后，由于经常活着，也就避免了频繁的复制了 新生代中，常是一些朝生夕死的对象，可能用了一次就可以ko，因此可以采用复制算法，标记-清除也是ok的 分代的主要思想就是根据不同的情况，给予不同的策略 III. 简单说下垃圾收集器收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现 1. Serial收集串行收集器，也就是程序跑一会，停下，让我们的回收线程（只有一个）来实现垃圾回收 新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩 2. ParNew收集上面的多线程版本 新生代并行，老年代串行；新生代复制算法、老年代标记-压缩 3. Parallel收集类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例； 新生代复制算法、老年代标记-压缩 4. Parallel Old 收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供 5. CMS收集器这个是比较常用的，有必要好好了解下 Concurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标记-清除算法 a 步骤 初始标记：标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记：进行 GC Roots Tracing的过程 重新标记：为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除：并发干掉被回收的问题 初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 b. 优缺点优点：并发收集、低停顿 缺点：产生大量空间碎片、并发阶段会降低吞吐量 6. G1收集器传说中是最先进的收集器。。。。 用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合 a. 步骤 标记阶段：初始标记，会停顿，触发minorgc Root Region Scanning: 程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在minorGC之前完成 并发标记：若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)；并发执行，可能被minorgc打断 再标记：再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)，停顿 复制-整理：并发干掉死亡对象，G1将回收区域的存活对象拷贝到新区域 IV. GC分析这个日志主要针对的是CMS收集器的分析，因为我接触的应用，服务器上就是选择的这个… 看一张神奇的图 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区之间发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无需等Age达到阈值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC V. 小结1. 怎么判断对象是否存活两种方式，引用计数和可达性分析 引用计数: 循环依赖问题，没啥用 可达性：从gc roots出发，可达的都是存活的 2. 几种回收算法对比 算法 简述 缺点 标记-清除 标记对象，统一清楚可回收对象 大量碎片 复制算法 内存一分为二，将存活的移动到另一边 存活久的对象，频繁复制；空间变小 标记-整理 存活对象往一边界拷贝，边界外的都干掉 对于生命周期特别短的不太合适 分代 年轻代 + 年老代，不同代选用不同算法 - 3. CMS和G1阶段对比cms主要区分四个步骤： 标记：停顿 并发标记 重新标记：停顿，重新处理并发过程中新标记的对象 并发清除：并发回收 g1，从结构上而言，划分为一个个独立区域(region)，采用标记-整理算法，避免碎皮空间 4. 简述内存分配和回收基于CMS进行说明 优先分配edge区（不够则触发gc） 大对象，分配在old区 存活时间久的塞入old区 动态时间判断（某个age对象总和大于Survivor一半，则塞入old区） 分配担保（进入old区，但是old区空间不够的策略，决定是否触发gc） VI. 其他参考 jvm系列(三):java GC算法 垃圾收集器 JVM调优工具介绍 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://zbang.online/hexblog/tags/垃圾回收/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"熔断Hystrix使用尝鲜","slug":"熔断Hystrix使用尝鲜","date":"2018-03-15T04:13:15.000Z","updated":"2018-04-02T07:43:56.852Z","comments":true,"path":"2018/03/15/熔断Hystrix使用尝鲜/","link":"","permalink":"https://zbang.online/hexblog/2018/03/15/熔断Hystrix使用尝鲜/","excerpt":"","text":"熔断Hystrix使用尝鲜当服务有较多外部依赖时，如果其中某个服务的不可用，导致整个集群会受到影响（比如超时，导致大量的请求被阻塞，从而导致外部请求无法进来），这种情况下采用hystrix就很有用了 出于这个目的，了解了下hystrix框架，下面记录下，框架尝新的历程 I. 原理探究通过官网和相关博文，可以简单的说一下这个工作机制，大致流程如下 首先是请求过来 -&gt; 判断熔断器是否开 -&gt; 服务调用 -&gt; 异常则走fallback，失败计数+1 -&gt; 结束 下面是主流程图 12345678910graph LR A(请求)--&gt;B&#123;熔断器是否已开&#125; B --&gt; | 熔断 | D[fallback逻辑] B --&gt; | 未熔断 | E[线程池/Semphore] E --&gt; F&#123;线程池满/无可用信号量&#125; F --&gt; | yes | D F --&gt; | no | G&#123;创建线程执行/本线程运行&#125; G --&gt; | yes | I(结束) G --&gt; | no | D D --&gt; I(结束) 熔断机制主要提供了两种，一个是基于线程池的隔离方式来做；还有一个则是根据信号量的抢占来做 线程池方式 ： 支持异步，支持超时设置，支持限流 信号量方式 ： 本线程执行，无异步，无超时，支持限流，消耗更小 基本上有上面这个简单的概念之后，开始进入我们的使用测试流程 II. 使用尝鲜1. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt; &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt; &lt;version&gt;1.5.12&lt;/version&gt;&lt;/dependency&gt; 2. 简单使用从官方文档来看，支持两种Command方式，一个是基于观察者模式的ObserverCommand, 一个是基本的Command，先用简单的看以下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class HystrixConfigTest extends HystrixCommand&lt;String&gt; &#123; private final String name; public HystrixConfigTest(String name, boolean ans) &#123;// 注意的是同一个任务， super(Setter.withGroupKey(// CommandGroup是每个命令最少配置的必选参数，在不指定ThreadPoolKey的情况下，字面值用于对不同依赖的线程池/信号区分 HystrixCommandGroupKey.Factory.asKey(\"CircuitBreakerTestGroup\"))// 每个CommandKey代表一个依赖抽象,相同的依赖要使用相同的CommandKey名称。依赖隔离的根本就是对相同CommandKey的依赖做隔离. .andCommandKey(HystrixCommandKey.Factory.asKey(\"CircuitBreakerTestKey_\" + ans))// 当对同一业务依赖做隔离时使用CommandGroup做区分,但是对同一依赖的不同远程调用如(一个是redis 一个是http),可以使用HystrixThreadPoolKey做隔离区分 .andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(\"CircuitBreakerTest_\" + ans)) .andThreadPoolPropertiesDefaults( // 配置线程池 HystrixThreadPoolProperties.Setter() .withCoreSize(12) // 配置线程池里的线程数，设置足够多线程，以防未熔断却打满threadpool ) .andCommandPropertiesDefaults( // 配置熔断器 HystrixCommandProperties.Setter() .withCircuitBreakerEnabled(true) .withCircuitBreakerRequestVolumeThreshold(3) .withCircuitBreakerErrorThresholdPercentage(80)// .withCircuitBreakerForceOpen(true) // 置为true时，所有请求都将被拒绝，直接到fallback// .withCircuitBreakerForceClosed(true) // 置为true时，将忽略错误// .withExecutionIsolationStrategy(HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE) // 信号量隔离 .withExecutionIsolationSemaphoreMaxConcurrentRequests(20) .withExecutionTimeoutEnabled(true) .withExecutionTimeoutInMilliseconds(200) .withCircuitBreakerSleepWindowInMilliseconds(1000) //熔断器打开到关闭的时间窗长度// .withExecutionTimeoutInMilliseconds(5000) ) ); this.name = name; &#125; @Override protected String run() throws Exception &#123; System.out.println(\"running run():\" + name + \" thread: \" + Thread.currentThread().getName()); int num = Integer.valueOf(name); if (num % 2 == 0 &amp;&amp; num &lt; 10) &#123; // 直接返回 return name; &#125; else if (num &lt; 40) &#123; Thread.sleep(300); return \"sleep+\"+ name; &#125; else &#123; // 无限循环模拟超时 return name; &#125; &#125;//// @Override// protected String getFallback() &#123;// Throwable t = this.getExecutionException();// if(t instanceof HystrixRuntimeException) &#123;// System.out.println(Thread.currentThread() + \" --&gt; \" + ((HystrixRuntimeException) t).getFailureType());// &#125; else if (t instanceof HystrixTimeoutException) &#123;// System.out.println(t.getCause());// &#125; else &#123;// t.printStackTrace();// &#125;// System.out.println(Thread.currentThread() + \" --&gt; ----------over------------\");// return \"CircuitBreaker fallback: \" + name;// &#125; public static class UnitTest &#123; @Test public void testSynchronous() throws IOException, InterruptedException &#123; for (int i = 0; i &lt; 50; i++) &#123; if (i == 41) &#123; Thread.sleep(2000); &#125; try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute()); &#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\"); &#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause()); &#125; &#125; System.out.println(\"------开始打印现有线程---------\"); Map&lt;Thread, StackTraceElement[]&gt; map = Thread.getAllStackTraces(); for (Thread thread : map.keySet()) &#123; System.out.println(\"---&gt;name--&gt;\" + thread.getName()); &#125; System.out.println(\"thread num: \" + map.size()); System.in.read(); &#125; &#125;&#125; 使用起来还是比较简单的，一般步骤如下： 继承 HsytrixCommand 类 重载构造方法，内部需要指定各种配置 实现run方法，这个里面主要执行熔断监控的方法 写上面的代码比较简单，但是有几个地方不太好处理 配置项的具体含义，又是怎么生效的？ 某些异常不进入熔断逻辑怎么办？ 监控数据如何获取？ 如何模拟各种不同的case（超时？服务异常？熔断已开启？线程池满？无可用信号量？半熔断的重试？） 3. 实测理解根据上面那一段代码的删删改改，貌似理解了以下几个点，不知道对误 a. 配置相关 groupKey 用于区分线程池和信号量，即一个group对应一个 commandKey 很重要，这个是用于区分业务 简单来讲，group类似提供服务的app，command则对应app提供的service，一个app可以有多个service，这里就是将一个app的所有请求都放在一个线程池（or共享一个信号量） 开启熔断机制，指定触发熔断的最小请求数（10s内），指定打开熔断的条件（失败率） 设置熔断策略（线程池or信号量） 设置重试时间（默认熔断开启后5s，放几个请求进去，看服务是否恢复） 设置线程池大小，设置信号量大小，设置队列大小 设置超时时间，设置允许超时设置 b. 使用相关run方法是核心执行服务调用，如果需要某些服务不统计到熔断的失败率（比如因为调用姿势不对导致服务内部的异常抛上来了，但是服务本身是正常的），这个时候，就需要包装下调用逻辑，将不需要的异常包装到 HystrixBadRequestException 类里 如 12345678910111213@Overrideprotected String run() &#123; try &#123; return func.apply(route, parameterDescs); &#125; catch (Exception e) &#123; if (exceptionExcept(e)) &#123; // 如果是不关注的异常case， 不进入熔断逻辑 throw new HystrixBadRequestException(\"unexpected exception!\", e); &#125; else &#123; throw e; &#125; &#125;&#125; c. 如何获取失败的原因当发生失败时，hystrix会把原生的异常包装到 HystrixRuntimeException 这个类里，所以我们可以在调用的地方如下处理 1234567try &#123; System.out.println(\"===========\" + new HystrixConfigTest(String.valueOf(i), i % 2 == 0).execute());&#125; catch (HystrixRuntimeException e) &#123; System.out.println(i + \" : \" + e.getFailureType() + \" &gt;&gt;&gt;&gt; \" + e.getCause() + \" &lt;&lt;&lt;&lt;&lt;\");&#125; catch (Exception e) &#123; System.out.println(\"run()抛出HystrixBadRequestException时，被捕获到这里\" + e.getCause());&#125; 当定义了fallback逻辑时，异常则不会抛到具体的调用方，所以在 fallback 方法内，则有必要获取对应的异常信息 12// 获取异常信息Throwable t = this.getExecutionException(); 然后下一步就是需要获取对应的异常原因了，通过FailureType来表明失败的根源 1((HystrixRuntimeException) t).getFailureType() d.如何获取统计信息hystrix自己提供了一套监控插件，基本上公司内都会有自己的监控统计信息，因此需要对这个数据进行和自定义，目前还没看到可以如何优雅的处理这些统计信息 4. 小结主要是看了下这个东西可以怎么玩，整个用下来的感觉就是，设计的比较有意思，但是配置参数太多，很多都没有完全摸透 其次就是一些特殊的case（如监控，报警，特殊情况过滤）需要处理时，用起来并不是很顺手，主要问题还是没有理解清楚这个框架的内部工作机制的问题 III. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"hystrix","slug":"hystrix","permalink":"https://zbang.online/hexblog/tags/hystrix/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"JVM学习之内存结构","slug":"JVM学习之内存结构","date":"2018-03-13T08:00:31.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/13/JVM学习之内存结构/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之内存结构/","excerpt":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了","text":"JVM学习之内存结构java运行时对象创建在什么地方？堆和栈空间又有什么区别？听闻已久的Young,Old区又是什么鬼？听说有个常量池，这个又是啥 要想在脑海中清晰的布局一个java类在加载到使用的过程中，整个类生命周期中，各项数据究竟最终落在哪个板块上，就需要了解下JVM的内存区域了 I. 内存布局 简单来讲，内存可以划分为三块： 堆 最大的一块区域，创建的对象都在这个上面 方法区 加载类时对应的类信息，常量，静态变量 栈 虚拟机栈和本地方法栈，存储线程相关的信息 II. 分区详解1. 堆区所有线程共享，虚拟机启动时创建，存放对象实例 垃圾回收，主要就是针对堆区而言，一般划分为年轻代，年老代 Young区：Edge + From Survivor + To Sruvivor (8：1：1) Old区 对象开始在Young区，一般内存回收时，会有标记整理，就涉及到两个Survivor区的转移，对象存的时间够久之后，就会将对象塞入Old区 2. 方法区所有线程共享，存储JVM加载的类信息，常量，静态变量，即使编译代码 3. 程序计数器当前线程所执行的字节码的行号指示器，线程私有 字节码解释器，就是来改变这个计数器来选择下一条要执行的命令 4. Java虚拟机栈线程私有，描述java方法执行的内存模型，它的生命周期与线程相同 虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表（所占用空间，编译期间分配完成） 编译期可知的各种基本数据类型 对象引用 returnAddress类型（指向了一条字节码指令的地址） 操作栈 动态链接 方法出口 当栈深大于允许的高度时，会抛出StackOverflowError，常见于递归调用异常的情况 当无法申请到足够的空间时，会抛出OutOfMemoryError 5. 本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务 III. 其他参考: JVM内存结构 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"内存结构","slug":"内存结构","permalink":"https://zbang.online/hexblog/tags/内存结构/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JVM学习之Java类的加载机制","slug":"JVM学习之Java类的加载机制","date":"2018-03-13T06:26:40.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/13/JVM学习之Java类的加载机制/","link":"","permalink":"https://zbang.online/hexblog/2018/03/13/JVM学习之Java类的加载机制/","excerpt":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制","text":"JVM学习之Java类的加载机制平常我们使用java的多，深入到jvm层的机会却很少，平时若不关注，也不会清楚java文件编译后的class文件是如何被jvm加载到内存，如何进行初始化，如何进行运行的 因此这里主要学习的目标就是class文件的加载，会包含以下内容： 什么是类加载 类加载的过程 什么时候触发类加载 类加载器 双亲委托机制 I. 什么是类的加载简单来讲，类加载就是将class文件中的二进制，读取到内存中，解析其中定义的数据结构，然后在运行时方法区创建对应的数据结构，在堆内创建对应的class对象，而这个class对象，就是封装了对应的数据结构，和相关数据的访问操作方法； 上面的这一段简述中，却包含以下几个点： 1. 加载哪里的class文件？第一步就是要明确的获取到对应的class文件了，jvm支持以下几个case中获取 本地系统 从网络上获取 从数据库(or缓存等第三方存储)中获取 从jar，zip包获取（比如我们依赖的第三方jar，大部分都是这种方式了） 源码编译获取（如我们常用的Groovy脚本，源码方式存在，由GroovyEngine加载时就是源码编译成class文件之后由jvm加载的） 2. 数据结构将class文件加载到内存后，一是在堆内创建class对象，一是在运行时方法区内创建对应的数据结构，具体的数据结构主要应该是类型信息 类的方法代码，变量名，方法名，访问权限，返回值等 类(静态)变量也存储在方法区 这一块有必要在jvm的内存分配中详细的研究下，每个存储区间到底干嘛用的，内部存写啥，先留一个坑位 3. class对象class对象是在堆内创建，反射机制就是主要利用它来实现，通过class对象基本可以完全的操作这个类（包括创建对象，访问成员，调用方法） II. 类加载过程类加载过程主要包括： 加载 -&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 -&gt; 使用 -&gt; 卸载 用一张图来表示整个过程，且会带上每个过程主要干嘛用的 1. 加载加载作为类加载的第一个过程，主要就是将class文件代表的二进制，加载到内存中 获取class对应的二进制流（可以从任何能获取到的地方读取对应的二进制流） 将二进制流的静态存储结构转换为方法区的运行时数据结构 在堆内创建class对象 上面的三个过程中，最灵活的就是获取二进制的过程，可以按照你的实际场景，从各种地方捞出数据 2. 验证主要是验证class文件是否合法，有没有被篡改等，属于连接的一个过程 文件格式验证：魔数校验，jdk版本校验 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 3. 准备简单来说就是准备好静态变量的存储空间，并设置默认值，属于连接的一个过程 正式为类分配内存 为类变量设置默认的初始化值（不执行实际的赋值语句，这里专指基本类型的零值，对象的null） 对static final 变量赋与代码中实际的值 4. 解析简单来讲就是将常量池内的符号引用替换成实际引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，同样属于连接的一个过程 符号引用：是一组符号来描述目标，可以是任何字面量 直接引用：是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄 5. 初始化为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化 准备阶段为类变量赋上了默认值，这里则主要是初始化代码中的赋值，一般而言根据实际定义的顺序进行初始化 a. 初始化步骤 若类没有被加载连接，则优先加载 若父类没有被初始化，则优先初始化父类 执行类的初始化语句（直接赋值，静态代码块） b. 初始化的时机 new创建一个对象时 访问或修改类的静态变量，执行静态方法 反射调用 子类被使用 jvm启动时指定 6. 卸载简单来说就是用完了，收拾线程的过程 程序执行完成 异常 系统层面错误 System.exit() III. 类加载器可以理解为类加载器就是用来加载类的工具，同一个类被不同的类加载器加载之后，也认为他们是不同的 四种类加载器：自定义类加载器，应用类加载器，扩展类加载器，启动类加载器 1. 启动类加载器(BootStrap ClassLoader)源头，根，负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的 2. 扩展类加载器（Extension ClassLoader）该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器 3. 应用类加载器（Application ClassLoader）该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 4. 自定义类加载器（User ClassLoader）自己实现的继承ClassLoader的加载器，可以按照自己的意愿，从某些地方加载类 5.类加载机制 全盘负责 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入 父类委托 先尝试让父类加载器来加载，当父类做不到时，再自己来做 缓存机制 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效 6.类的加载类加载有三种方式： 1、命令行启动应用时候由JVM初始化加载 2、通过Class.forName()方法动态加载 加载class到内存，并执行static块 3、通过ClassLoader.loadClass()方法动态加载 只加载class文件到jvm，在class.newInstance()时，执行static块 IV. 双亲委托双亲委托，就是来了一个类加载，先扔给上面去处理，层层上传，只有上面处理不了时，才自己来决定 有啥好处？ 系统类防止内存中出现多份同样的字节码 保证Java程序安全稳定运行 说明：双亲委托机制是可以被破坏的 V. 其他参考: java类的加载机制 《深入理解Java虚拟机-JVM高级特性与最佳实践》 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"ClassLoader","slug":"ClassLoader","permalink":"https://zbang.online/hexblog/tags/ClassLoader/"},{"name":"双亲委托","slug":"双亲委托","permalink":"https://zbang.online/hexblog/tags/双亲委托/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"Chrome插件之DomToImage实现","slug":"Chrome插件之DomToImage实现","date":"2018-03-12T11:08:09.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/12/Chrome插件之DomToImage实现/","link":"","permalink":"https://zbang.online/hexblog/2018/03/12/Chrome插件之DomToImage实现/","excerpt":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片","text":"I. 说明有些时候，看到一些网页的信息时，想分享给小伙伴，一般直接用截图工具来做，但是当分享的内容比较长时，截图就比较蛋疼了，所以想着做了这么个插件 可以将网页中任意一个dom结构，渲染为图片 1. 实现 主要借助开源包: dom-to-image来实现 基本实现原理： 在网页中插入一段html代码，然后绑定上点击事件，核心逻辑如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(\"body\").append('&lt;div id=\"rendFloatDom\" class=\"NYwishes\"&gt;' + '&lt;div id=\"expandInputBtn\" class=\"send\"&gt;&lt;div class=\"send-btn\" style=\"float:right\"&gt;&lt;a onclick=\"document.getElementById(\\'expandInputBtn\\').style.display=\\'none\\';document.getElementById(\\'showRenderImgDiv\\').style.display=\\'block\\';\"&gt;展开&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;' + '&lt;div class=\"send\" id=\"showRenderImgDiv\" style=\"display:none\"&gt;' + '&lt;div class=\"input\"&gt;&lt;input id=\"choose-id\" name=\"content\" type=\"text\" placeholder=\"cid: | id: + 标签\" &gt;&lt;/div&gt;' + '&lt;div class=\"send-btn\" &gt;&lt;a id=\"RenderImgBtn\"&gt;渲染&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;' + '');function doRender() &#123; var chooseVal = document.getElementById('choose-id').value; var node; if(chooseVal.startsWith('cid:')) &#123; chooseVal = chooseVal.substring(4); node = document.getElementsByClassName(chooseVal)[0]; &#125; else &#123; if(chooseVal.startsWith(\"id:\")) &#123; chooseVal = chooseVal.substring(3); &#125; if (\"\" == chooseVal) &#123; return; &#125; node = document.getElementById(chooseVal); &#125; if(node == null || typeof(node) == undefined) &#123; alert(\"没有选中的dom结构\"); return; &#125; domtoimage.toPng(node) .then(function (dataUrl) &#123; var url = dataUrl; window.open().document.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;渲染图&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=\\'text-align:center\\'&gt;&lt;a download=\"out.png\" href=\"' + url + '\"&gt;&lt;img src=\"' + url + '\" /&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'); &#125;) .catch(function (error) &#123;&#125;);&#125;$(\"#choose-id\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; doRender(); &#125;&#125;);$('#RenderImgBtn').click(function() &#123; doRender();&#125;); 2. 使用演示 II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://zbang.online/hexblog/tags/Chrome/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Chrome","slug":"技术/前端/Chrome","permalink":"https://zbang.online/hexblog/categories/技术/前端/Chrome/"}]},{"title":"JQuery 实战笔记一","slug":"JQuery-实战笔记一","date":"2018-03-08T14:58:26.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/03/08/JQuery-实战笔记一/","link":"","permalink":"https://zbang.online/hexblog/2018/03/08/JQuery-实战笔记一/","excerpt":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应","text":"jquery实战笔记写前端控制台中，实际遇到的不会的，通过查询解决的记录，汇总记录下来，一期主要包括： 标签隐藏显示 时间戳转换 radio单选框选中获取 动态修改placeholder值 判断字符串是否为数字类型 tab标签页实现 标签点击事件 jquery跳转链接 jquery 修改图片url 图片加边框 实现一个可检索的table 表格内容固定 input回车响应 1. jquery控制div标签的显示隐藏123&lt;div id=\"queryExtend\"&gt; &lt;label&gt; hah &lt;/label&gt;&lt;/div jquery的用法, 判断是否隐藏，是则显示；否则隐藏 1234567function showQueryCondition() &#123; if($('#queryExtend').is(\":hidden\")) &#123; $('#queryExtend').show(); &#125; else &#123; $('#queryExtend').hide(); &#125;&#125; 2. 时间戳转日期1234// 获取当前时间戳var ns = Date.parse(new Date())/1000;var timestamp4 = new Date(parseInt(nS) * 1000);return timestamp4.toLocaleDateString().replace(/\\//g, \"/\") + \" \" + timestamp4.toTimeString().substr(0, 8); 3. 获取radio群的值123456789101112&lt;div class=\"col-md-10 input-group input-group-lg\"&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"1\" checked/&gt; &amp;nbsp;&amp;nbsp; 默认 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"2\"/&gt; &amp;nbsp;&amp;nbsp; 查主库 &lt;/div&gt; &lt;div class=\"col-md-2\"&gt; &lt;input type=\"radio\" name=\"queryType\" id=\"queryType\" value=\"3\"/&gt; &amp;nbsp;&amp;nbsp; 查从库 &lt;/div&gt;&lt;/div&gt; 对应的jquery获取选中值 1var queryDB = $(\"input[name='queryType']:checked\").val(); 4. 动态修改placeholder值1$('#itemId').attr('placeholder', '请输入商品ID '); 5. 判断字符串是否为数字类型123456var str = \"37\";var n = Number(str);if (!isNaN(n))&#123; alert(\"是数字\");&#125; 6. tab标签页的实现12345678910111213141516171819202122232425262728293031323334&lt;ul id=\"myTab\" class=\"nav nav-tabs\"&gt; &lt;li class=\"active\"&gt; &lt;a href=\"#home\" data-toggle=\"tab\"&gt; 菜鸟教程 &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"#ios\" data-toggle=\"tab\"&gt;iOS&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" id=\"myTabDrop1\" class=\"dropdown-toggle\" data-toggle=\"dropdown\"&gt;Java &lt;b class=\"caret\"&gt;&lt;/b&gt; &lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"myTabDrop1\"&gt; &lt;li&gt;&lt;a href=\"#jmeter\" tabindex=\"-1\" data-toggle=\"tab\"&gt;jmeter&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#ejb\" tabindex=\"-1\" data-toggle=\"tab\"&gt;ejb&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"home\"&gt; &lt;p&gt;菜鸟教程是一个提供最新的web技术站点，本站免费提供了建站相关的技术文档，帮助广大web技术爱好者快速入门并建立自己的网站。菜鸟先飞早入行——学的不仅是技术，更是梦想。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ios\"&gt; &lt;p&gt;iOS 是一个由苹果公司开发和发布的手机操作系统。最初是于 2007 年首次发布 iPhone、iPod Touch 和 Apple TV。iOS 派生自 OS X，它们共享 Darwin 基础。OS X 操作系统是用在苹果电脑上，iOS 是苹果的移动版本。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"jmeter\"&gt; &lt;p&gt;jMeter 是一款开源的测试软件。它是 100% 纯 Java 应用程序，用于负载和性能测试。&lt;/p&gt; &lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"ejb\"&gt; &lt;p&gt;Enterprise Java Beans（EJB）是一个创建高度可扩展性和强大企业级应用程序的开发架构，部署在兼容应用程序服务器（比如 JBOSS、Web Logic 等）的 J2EE 上。 &lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 借助bootstrap，主要点 myTab 标签表示的导航内容 href 指向的本标签对应的内容 myTagContent 对应的标签页内容 id 与 导航的锚点对应 class=&quot;tab-pane fade in active&quot; 表示生效的标签内容 class=&quot;tab-pane fade&quot; 未激活的标签属性 7. 标签点击事件1$('#btn').click(function()&#123;&#125;); 8. jquery跳转链接12345678910// 本页面直接打开urlwindow.location.href=url;// 新标签页打开urlwindow.open(url, \"_blank\")// 在demo窗口打开urlwindow.open(url, \"demo\"); 9. jquery 修改图片url1$('#img').attr(\"src\", newImgUrl); 10. 图片加边框1&lt;image id=\"data\" style=\"border:1px solid #b5b3b3;\"/&gt; 11. 实现一个可检索的table在一个bootstrap项目中，必要的 jquery, bootstrap.min.js需要依赖 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;div id=\"wrapper\"&gt;&lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"ibox float-e-margins\"&gt; &lt;div class=\"ibox-content\"&gt; &lt;input type=\"text\" class=\"form-control input-sm m-b-xs\" id=\"filter\" placeholder=\"Search in table\"&gt; &lt;table class=\"footable table table-stripped\" data-page-size=\"8\" data-filter=#filter&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Rendering engine&lt;/th&gt; &lt;th&gt;Browser&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Platform(s)&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;Engine version&lt;/th&gt; &lt;th data-hide=\"phone,tablet\"&gt;CSS grade&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr class=\"gradeX\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 4.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;4&lt;/td&gt; &lt;td class=\"center\"&gt;X&lt;/td&gt; &lt;/tr&gt; &lt;tr class=\"gradeC\"&gt; &lt;td&gt;Trident&lt;/td&gt; &lt;td&gt;Internet Explorer 5.0 &lt;/td&gt; &lt;td&gt;Win 95+&lt;/td&gt; &lt;td class=\"center\"&gt;5&lt;/td&gt; &lt;td class=\"center\"&gt;C&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=\"5\"&gt; &lt;ul class=\"pagination pull-right\"&gt;&lt;/ul&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"http://s11.mogucdn.com/mlcdn/c45406/1512464758975_footable.all.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function() &#123; $('.footable').footable(); $('.footable2').footable(); &#125;);&lt;/script&gt; 12. 表格内容固定1&lt;td style=\"word-break:break-all;width:20%\"&gt;dc:650|tp:1|ci:700004593373|st:1481299200|mk:9|ws:1480694400|et:1481558399|nm:活动价|&lt;/td&gt; 13. input回车响应12345678910111213141516171819202122232425262728293031323334353637383940414243444546$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 2.方法2$('#applyCertNum').on('keypress',function(event)&#123; if(event.keyCode == 13) &#123; alert('你输入的内容为1：' + $('#applyCertNum').val()); &#125; &#125;); 3.方法3$('#applyCertNum').bind('keypress',function(event)&#123; if(event.keyCode == \"13\") &#123; alert('你输入的内容为2：' + $('#applyCertNum').val()); &#125; &#125;);4.方法4$(\"#applyCertNum\").keydown(function(e) &#123; if (e.keyCode == 13) &#123; alert(\"12345....\"); &#125; &#125;); html中直接加入 1onkeydown=\"if(event.keyCode==13) &#123;queryAppAuthList();&#125;\" II. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"},{"name":"Jquery","slug":"Jquery","permalink":"https://zbang.online/hexblog/tags/Jquery/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"前端","slug":"技术/前端","permalink":"https://zbang.online/hexblog/categories/技术/前端/"},{"name":"Jquery","slug":"技术/前端/Jquery","permalink":"https://zbang.online/hexblog/categories/技术/前端/Jquery/"}]},{"title":"Java并发学习之线程池ThreadPoolExecutor的小结","slug":"Java并发学习之线程池ThreadPoolExecutor的小结","date":"2018-03-06T09:33:54.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","link":"","permalink":"https://zbang.online/hexblog/2018/03/06/Java并发学习之线程池ThreadPoolExecutor的小结/","excerpt":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制","text":"Java并发学习之线程池ThreadPoolExecutor的小结本篇博文将带着问题来回顾小结多线程池相关的知识点 线程池的几种创建方式 线程池的优点是什么 应用场景 如何使用 实现原理 异常状况怎么处理 线程池中任务的提交执行后，到线程执行，执行完成的整个流程逻辑 线程池中的线程回收机制 I. 什么是线程池1. 通俗讲解我们先举一个小例子来说一下什么是线程池，以及线程池的工作方式 首先在看一下线程池中提交一个任务的流程图 下面就是实际的case：基本上大家都去过银行，我们就以到银行的柜台上办理业务的流程来说明线程池，我们先假设这里有一个xx银行（这里是广告位，待租😉），总共有8个柜台，平时只开放4个柜台，大厅内总共有20个座位。 那么来一个办理业务的，如果开放的四个柜台上，有空的，直接上去办理业务即可 如果四个柜台都在处理业务了，那么办理业务则需要取一个号，到大厅的座位上等着叫号 如果大厅坐满了，银行经理决定开放所有的柜台，那么新来办理的人直接到新的柜台上处理 如果所有柜台都在处理，且大厅也满了，这个时候就告诉新来办理业务的现在已经满载了，你们到xxx地的银行去办理吧（或者回家等下午再来好了） 从流程上的对比来看，就很相似了，虽然实际上银行可不会因为人的太多来新增开放柜台的数量，下面简单的将上面的case映射到线程池的成员上 4个开放柜台 ： 对应线程池的corePoolSize(核心工作线程数) 8个总柜台：对应线程池的maximumPoolSize(最大工作线程数) 20个座位：对应线程池的workQueue(任务队列) 所以线程池中提交一个任务时，优先看核心工作线程数是否已满，未满时，直接创建线程执行；已满，则丢入队列；如果队列也满了，则判断工作线程数是否超过最大数，没有则直接创建线程执行；否则直接“丢弃”这个任务了 （注意这个丢弃不是真的丢弃，其处理策略可以由你自己定义） 上面是基本流程，并没有涉及到工作线程的回收，线程池的状态（比如银行是否打烊了），任务的执行策略等 2. 线程池说明线程池是一种多线程的处理机制，主要是为了减少线程的频繁创建和销毁，从而提升系统效率 使用线程池优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务 可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 线程池组成类定义： java.util.concurrent.ThreadPoolExecutor 构造 1234567891011121314151617181920212223// 线程池构造方法public ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 存活时间 TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, // 排队队列 ThreadFactory threadFactory, // 创建线程的工作类 RejectedExecutionHandler handler) // 线程数满，队列满时具体任务策略&#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; II. 线程池使用1. 构造参数详解构造参数较多，创建一个线程池，当然首先得搞清楚这些参数是干嘛用的 参数 含义 说明 corePoolSize 核心工作线程数 没有任务时，线程池中允许存在的最小空闲线程数 工作线程数 &lt; corePoolSize时，提交任务创建工作线程来执行任务 maximumPoolSize 最大工作线程数 线程池中允许出现的最大工作线程数量 当队列满 &amp;&amp; 工作线程数 &lt; maximumPoolSize时，新的队列将创建线程来执行； 如果队列没有边界，那么这个参数没有意义 workQueue 任务队列 保存待执行任务的阻塞队列； 当 (工作线程数 &gt;= corePoolSize) &amp;&amp; (任务数 &lt; 任务队列长度)时，任务会offer()入队等待 keepAliveTime 工作线程最大空闲时间 当线程数 &gt; corePoolSize时，这个参数表示空闲线程存活时间； 超时的空闲线程，会被回收掉，直到线程数==corePoolSzie; 当allowCoreThreadTimeOut=true时，则超时的核心工作线程也会被回收 unit 时间单位 keepAliveTime的时间单位 threadFactory 线程创建工厂 创建线程的工厂类，可以在这里指定创建线程的name，设置守护线程，异常case处理等 handler 饱和策略执行器 线程池和队列都已满时，新提交任务的处理策略 默认是Abort(直抛Reject异常)，包括Discard(LIFO规则丢弃)、DiscardOldest(LRU规则丢弃) 以及 CallerRuns(调用者线程执行)，允许自定义执行器 2. 线程池的创建直接调用构造方法创建最直观的方式，直接构造方法new一个 1234567891011121314151617181920212223242526272829303132333435// 报警线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"test-thread\"), new ThreadPoolExecutor.CallerRunsPolicy()); // 线程创建工厂，主要设置为非守护线程，指定线程名，设置优先级// 关于这个工厂类，推荐看netty的实现public class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; public DefaultThreadFactory(String poolName) &#123; if (null == poolName) &#123; poolName = \"pool\"; &#125; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = poolName + poolNumber.getAndIncrement() + \"-thread-\"; &#125; @Override public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 利用 Executors创建jdk1.5+ 中提供了 java.util.concurrent.Executors 来创建常见的集中线程池方式 关于各种线程池的说明可以参考: Java并发学习之玩转线程池 固定大小线程池 123456// 创建一个固定大小的线程池public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 工作窃取线程池 123456public static ExecutorService newWorkStealingPool(int parallelism) &#123; return new ForkJoinPool (parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, null, true);&#125; 创建单线程池 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; 缓存线程池 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 定时任务线程池 123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; 不可配置线程池 12345public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123; if (executor == null) throw new NullPointerException(); return new DelegatedExecutorService(executor);&#125; 3. 提交任务execute: 提交无须返回值的任务 submit(Runnable): 适用于提交需要返回值的任务 相比较于上面的，区别是这个会返回一个 Future 对象，通过调用future.get()可以获取线程的返回值， 其中这个方程是线程阻塞的，直到返回了结果之后，才会继续执行下去 4. 关闭线程池shutdown(): 有序地关闭线程池，已提交的任务会被执行(包含正在执行和任务队列中的)，但会拒绝新任务 shutdownNow(): 立即(尝试)停止执行所有任务(包含正在执行和任务队列中的)，并返回待执行任务列表 III. 线程池实现原理1. 线程池状态线程池状态流程如下： RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED 每个状态含义 1234567891011121314//高3位111，低29位为0 该状态下线程池会接收新提交任务和执行队列任务private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//高3位000，低29位为0 该状态下线程池不再接收新任务，但还会继续执行队列任务private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//高3位001，低29位为0 该状态下线程池不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务private static final int STOP = 1 &lt;&lt; COUNT_BITS;//高3位010，低29位为0 该状态下线程池的所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated()private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//高3位011，低29位为0 该状态下表明线程池terminated()方法已经调用完成private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 2. 任务提交逻辑最开始的流图就说明了任务提交后的流程，针对流程块也就不继续细说，只提一个注意点 若实际工作线程数workers&lt;核心工作线程数corePoolSize，则创建新工作线程来执行新任务execute(Runable) 若实际工作线程数workers&gt;=核心工作线程数corePoolSize(核心工作线程们都在执行任务)且任务队列workQueue未满，则将任务加入到任务队列workQueue中 若任务队列workQueue已满，则创建新工作线程来执行任务execute() 若实际工作线程数workers&gt;=最大工作线程数maximumPoolSize(所有线程都在执行任务)，此时任务数已饱和，需要根据饱和拒绝策略rejectedExecutionHandler执行相对应的饱和拒绝操作 线程池的总体设计是基于性能考虑，尽可能避免获取全局锁： 由于创建新线程时都需要获取全局锁，因此步骤1和步骤3必须加锁 为了避免多次获取全局锁(性能伸缩瓶颈)，当实际工作线程数&gt;=核心工作线程数时，之后会执行步骤2(入队时无须获取全局锁) 线程池内线程回收策略 若实际工作线程数workers&gt;核心工作线程数corePoolSize，回收空闲时间超过keepAliveTime的空闲的非核心线程(减少工作线程数直到&lt;=核心工作线程数即可) 若设置allowCoreThreadTimeOut为true时，则超过keepAliveTime的空闲的核心工作线程也会被回收 3. 任务执行说明，下面两段代码解析来自转载： 并发番@ThreadPoolExecutor execute() - 提交任务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * 1.若实际工作线程数 &lt; 核心工作线程数，会尝试创建一个工作线程去执行该 * 任务，即该command会作为该线程的第一个任务，即第一个firstTask * * 2.若任务入队成功，仍需要执行双重校验，原因有两点： * - 第一个是去确认是否需要新建一个工作线程，因为可能存在 * 在上次检查后已经死亡died的工作线程 * - 第二个是可能在进入该方法后线程池被关闭了， * 比如执行shutdown() * 因此需要再次检查state状态，并分别处理以上两种情况： * - 若线程池中已无可用工作线程了，则需要新建一个工作线程 * - 若线程池已被关闭，则需要回滚入队列(若有必要) * * 3.若任务入队失败(比如队列已满)，则需要新建一个工作线程； * - 若新建线程失败，说明线程池已停止或者已饱和，必须执行拒绝策略 */public void execute(Runnable command) &#123; //新任务不允许为空，空则抛出NPE if (command == null) throw new NullPointerException(); // ctl 为线程池状态控制器，用于保证线程池状态和工作线程数 // 低29位为工作线程数量，高3位为线程池状态 int c = ctl.get(); /** * case1：当实际工作线程数 &lt; 核心工作线程数时 * 执行方案：会创建一个新的工作线程去执行该任务 * 注意：此时即使有其他空闲的工作线程也还是会新增工作线程， * 直到达到核心工作线程数为止 */ if (workerCountOf(c) &lt; corePoolSize) &#123; /** * 新增工作线程，true表示要对比的是核心工作线程数 * 一旦新增成功就开始执行当前任务 * 期间也会通过自旋获取队列任务进行执行 */ if (addWorker(command, true)) return; /** * 需要重新获取控制器状态，说明新增线程失败 * 线程失败的原因可能有两种： * - 1.线程池已被关闭，非RUNNING状态的线程池是不允许接收新任务的 * - 2.并发时，假如都通过了workerCountOf(c) &lt; corePoolSize校验，但其他线程 * 可能会在addWorker前先创建出线程，导致workerCountOf(c) &gt;= corePoolSize， * 即实际工作线程数 &gt;= 核心工作线程数，此时需要进入case2 */ c = ctl.get(); &#125; /** * case2：当实际工作线程数&gt;=核心线程数时，新提交任务需要入队 * 执行方案：一旦入队成功，仍需要处理线程池状态突变和工作线程死亡的情况 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //双重校验 int recheck = ctl.get(); /** * recheck的目的是为了防止线程池状态的突变 - 即被关闭 * 一旦线程池非RUNNING状态时，除了从队列中移除该任务(回滚)外 * 还需要执行任务拒绝策略处理新提交的任务 */ if (!isRunning(recheck) &amp;&amp; remove(command)) //执行任务拒绝策略 reject(command); /** * 若线程池还是RUNNING状态 或 * 队列移除失败(可能正好被一个工作线程拿到处理了) * 此时需要确保至少有一个工作线程还可以干活 * 补充一句：之所有无须与核心工作线程数或最大线程数相比，而只是比较0的原因是 * 只要保证有一个工作线程可以干活就行，它会自动去获取任务 */ else if (workerCountOf(recheck) == 0) /** * 若工作线程都已死亡，需要新增一个工作线程去干活 * 死亡原因可能是线程超时或者异常等等复杂情况 * * 第一个参数为null指的是传入一个空任务， * 目的是创建一个新工作线程去处理队列中的剩余任务 * 第二个参数为false目的是提示可以扩容到最大工作线程数 */ addWorker(null, false); &#125; /** * case3：一旦线程池被关闭 或者 新任务入队失败(队列已满) * 执行方案：会尝试创建一个新的工作线程，并允许扩容到最大工作线程数 * 注意：一旦创建失败，比如超过最大工作线程数，需要执行任务拒绝策略 */ else if (!addWorker(command, false)) //执行任务拒绝策略 reject(command);&#125; 上面的代码虽然非常少，但是逻辑还是比较多的，创建线程是根据 addWorker方法来实现的，其主要逻辑为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204/** * 新增工作线程需要遵守线程池控制状态规定和边界限制 * * @param core core为true时允许扩容到核心工作线程数，否则为最大工作线程数 * @return 新增成功返回true，失败返回false */private boolean addWorker(Runnable firstTask, boolean core) &#123; //重试标签 retry: /*** * 外部自旋 -&gt; 目的是确认是否能够新增工作线程 * 允许新增线程的条件有两个： * 1.满足线程池状态条件 -&gt; 条件一 * 2.实际工作线程满足数量边界条件 -&gt; 条件二 * 不满足条件时会直接返回false，表示新增工作线程失败 */ for (;;) &#123; //读取原子控制量 - 包含workerCount(实际工作线程数)和runState(线程池状态) int c = ctl.get(); //读取线程池状态 int rs = runStateOf(c); /** * 条件一.判断是否满足线程池状态条件 * 1.只有两种情况允许新增线程： * 1.1 线程池状态==RUNNING * 1.2 线程池状态==SHUTDOWN且firstTask为null同时队列非空 * * 2.线程池状态&gt;=SHUTDOWN时不允许接收新任务，具体如下： * 2.1 线程池状态&gt;SHUTDOWN，即为STOP、TIDYING、TERMINATED * 2.2 线程池状态==SHUTDOWN，但firstTask非空 * 2.3 线程池状态==SHUTDOWN且firstTask为空，但队列为空 * 补充：针对1.2、2.2、2.3的情况具体请参加后面的\"小问答\"环节 */ if (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; /*** * 内部自旋 -&gt; 条件二.判断实际工作线程数是否满足数量边界条件 * -数量边界条件满足会对尝试workerCount实现CAS自增，否则新增失败 * -当CAS失败时会再次重新判断是否满足新增条件： * 1.若此期间线程池状态突变(被关闭)，重新判断线程池状态条件和数量边界条件 * 2.若此期间线程池状态一致，则只需重新判断数量边界条件 */ for (;;) &#123; //读取实际工作线程数 int wc = workerCountOf(c); /** * 新增工作线程会因两种实际工作线程数超标情况而失败： * 1.实际工作线程数 &gt;= 最大容量 * 2.实际工作线程数 &gt; 工作线程比较边界数(当前最大扩容数) * -若core = true，比较边界数 = 核心工作线程数 * -若core = false，比较边界数 = 最大工作线程数 */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; /** * 实际工作线程计数CAS自增: * 1.一旦成功直接退出整个retry循环，表明新增条件都满足 * 2.因并发竞争导致CAS更新失败的原因有三种: * 2.1 线程池刚好已新增一个工作线程 * -&gt; 计数增加，只需重新判断数量边界条件 * 2.2 刚好其他工作线程运行期发生错误或因超时被回收 * -&gt; 计数减少，只需重新判断数量边界条件 * 2.3 刚好线程池被关闭 * -&gt; 计数减少，工作线程被回收， * 需重新判断线程池状态条件和数量边界条件 */ if (compareAndIncrementWorkerCount(c)) break retry; //重新读取原子控制量 -&gt; 原因是在此期间可能线程池被关闭了 c = ctl.get(); /** * 快速检测是否发生线程池状态突变 * 1.若状态突变，重新判断线程池状态条件和数量边界条件 * 2.若状态一致，则只需重新判断数量边界条件 */ if (runStateOf(c) != rs) continue retry; &#125; &#125; /** * 这里是addWorker方法的一个分割线 * 前面的代码的作用是决定了线程池接受还是拒绝新增工作线程 * 后面的代码的作用是真正开始新增工作线程并封装成Worker接着执行后续操作 * PS:虽然笔者觉得这个方法其实可以拆分成两个方法的(在break retry的位置) */ //记录新增的工作线程是否开始工作 boolean workerStarted = false; //记录新增的worker是否成功添加到workers集合中 boolean workerAdded = false; Worker w = null; try &#123; //将新提交的任务和当前线程封装成一个Worker w = new Worker(firstTask); //获取新创建的实际工作线程 final Thread t = w.thread; /** * 检测是否有可执行任务的线程，即是否成功创建了新的工作线程 * 1.若存在，则选择执行任务 * 2.若不存在，则需要执行addWorkerFailed()方法 */ if (t != null) &#123; /** * 新增工作线程需要加全局锁 * 目的是为了确保安全更新workers集合和largestPoolSize */ final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; /** * 获得全局锁后，需再次检测当前线程池状态 * 原因在于预防两种非法情况： * 1.线程工厂创建线程失败 * 2.在锁被获取之前，线程池就被关闭了 */ int rs = runStateOf(ctl.get()); /** * 只有两种情况是允许添加work进入works集合的 * 也只有进入workers集合后才是真正的工作线程，并开始执行任务 * 1.线程池状态为RUNNING(即rs&lt;SHUTDOWN) * 2.线程池状态为SHUTDOWN且传入一个空任务 * (理由参见：小问答之快速检测线程池状态?) */ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; /** * 若线程处于活动状态时，说明线程已启动，需要立即抛出\"线程状态非法异常\" * 原因是线程是在后面才被start的，已被start的不允许再被添加到workers集合中 * 换句话说该方法新增线程时，而线程是新的，本身应该是初始状态(new) * 可能出现的场景：自定义线程工厂newThread有可能会提前启动线程 */ if (t.isAlive()) throw new IllegalThreadStateException(); //由于加锁，所以可以放心的加入集合 workers.add(w); int s = workers.size(); //更新最大工作线程数，由于持有锁，所以无需CAS if (s &gt; largestPoolSize) largestPoolSize = s; //确认新建的worker已被添加到workers集合中 workerAdded = true; &#125; &#125; finally &#123; //千万不要忘记主动解锁 mainLock.unlock(); &#125; /** * 一旦新建工作线程被加入工作线程集合中，就意味着其可以开始干活了 * 有心的您肯定发现在线程start之前已经释放锁了 * 原因在于一旦workerAdded为true时，说明锁的目的已经达到 * 根据最小化锁作用域的原则，线程执行任务无须加锁，这是种优化 * 也希望您在使用锁时尽量保证锁的作用域最小化 */ if (workerAdded) &#123; /** * 启动线程，开始干活啦 * 若您看过笔者的\"并发番@Thread一文通\"肯定知道start()后， * 一旦线程初始化完成便会立即调用run()方法 */ t.start(); //确认该工作线程开始干活了 workerStarted = true; &#125; &#125; &#125; finally &#123; //若新建工作线程失败或新建工作线程后没有成功执行，需要做新增失败处理 if (!workerStarted) addWorkerFailed(w); &#125; //返回结果表明新建的工作线程是否已启动执行 return workerStarted;&#125; 小问：快速检测线程状态时，情况1.2、2.1、2.3的意义是什么？ 小答：在阐明这个问题之前，我们先明确两个知识点： 新增Worker的目的是处理任务，任务来源分初始任务和队列任务(即剩余的待处理任务) 线程池在非RUNNING状态下是不允许接收新任务的，换句话说您都要下班了，难道还想接新需求？ 针对2.1 - &gt; 线程池状态==SHUTDOWN，但firstTask！= null，不允许新增Worker当线程池状态为SHUTDOWN时，由于不允许接收新任务，因此一旦firstTask！= null需要直接拒绝 针对2.2 - &gt; 线程池状态==SHUTDOWN，且firstTask == null， 但队列为空， 不允许新增Worker当firstTask为null时，说明调用addWorker()目的不是为了处理新增任务那么其目的应该是为了处理剩余任务，即队列中的任务，而一旦队列为空，那也没必要新增Worker了 针对1.2 - &gt; 若线程池状态==SHUTDOWN，必须满足firstTask为null且队列非空，才允许新增Worker当线程池状态为SHUTDOWN时(调用shutdown())，此时不允许接收新任务，因此firstTask必须为null但需要处理剩余任务，因此队列必须非空，否则新增的工作线程就无任务可做，那就没意义了结论：传入一个空任务的目的是为了新增工作线程去处理任务队列中的剩余任务 3. Worker类详解worker包装了任务的调度，用于封装工作线程和任务并管理工作线程的中断状态等功能 由于工作线程和worker实例是一对一的关系，因为可以简单的理解工作线程等价于worker，尤其是谈及数量时，比如创建工作线程实际上就是创建一个worker 线程在线程池执行任务的工作流程： 工作线程开始执行前，需先对worker加锁，任务完成解锁 任务执行前后分别执行beforeExecute()和afterExecute()方法 执行中遇到异常会向外抛出，线程是否死亡取决于您对于异常的处理 每个任务执行完后，当前工作线程任务完成数自增，同时会循环调用getTask()从任务队列中反复获取任务并执行，无任务可执行时线程会阻塞在该方法上 当工作线程因各种理由退出时，会执行processWorkerExit()回收线程(核心是将该worker从workers集合中移除，注意之前worker已经退出任务循环，因此已经不再做工了，从集合移除后就方便gc了) 问：worker中断如何控制的 当工作线程真正开始执行之前，不允许被中断 当工作线程正在执行任务时，不允许被中断 当工作线程正等待从任务队列中获取任务getTask()时才能被中断 调用interruptIdleWorkers()中断空闲线程时必须先获得worker锁 问：为什么Worker不被设计成可重入锁？ 由于在动态控制方法中可能会中断线程，比如调用interruptIdleWorkers()，由此该方法在执行interrupt()之前会调用worker.tryLock()，若此时允许重入，就会导致线程被意外中断，这跟当工作线程正在执行任务时，不允许被中断准则是相违背的 IV. 问题解答1. 如何创建线程池直接根据构造方法创建 12345java.util.concurrent.ThreadPoolExecutor#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue&lt;java.lang.Runnable&gt;, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler) 利用 Executors 创建线程池 12345678910111213java.util.concurrent.Executors#newFixedThreadPool(int)java.util.concurrent.Executors#newWorkStealingPool(int)java.util.concurrent.Executors#newSingleThreadExecutor()java.util.concurrent.Executors#newCachedThreadPool()java.util.concurrent.Executors#newSingleThreadScheduledExecutor()java.util.concurrent.Executors#newScheduledThreadPool(int)java.util.concurrent.Executors#unconfigurableExecutorService 2. 线程池的适用场景优点 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务可以根据系统的承受能力，调整线程池中工作线线程的数量 使用线程池场景 我们将线程进行拆分，创建线程耗时T1, 线程执行耗时T2, 销毁线程耗时T3 如果你的场景中，提交线程执行的任务非常频繁，且具体的执行耗时较短，即 T1 + T3 &gt; T2, 这种场景下使用线程池可以带来明显的性能提升 一般来说，如果不是你的任务只偶尔的运行几次，那么绝大部分场景都适合用线程池来处理 3. 如何使用线程池创建线程池，提交任务 execute 适用于提交没有返回结果的任务 submit 适用于提交有返回结果的任务， 返回一个Futrure的包装类 4. 线程池实现原理 &amp; 任务提交后的流程在实现原理中会穿插上任务提交后的流程，所以就放在一起了 首先从提交一个任务开始： 首先判断工作线程数是否小于核心工作线程数，是则直接创建工作线程执行 否，则将任务丢入任务队列中 若任务队列已满，且工作线程数 &lt; 最大工作线程数，则直接创建工作线程执行任务 若队列满，且工作线程数达到最大值，则采用拒绝任务策略 其中上面的任务进队or创建线程执行，都需要关注线程池的状态，每个状态对应的原则 状态 说明 限制 RUNNING 运行状态 线程池会接收新提交任务和执行队列任务 SHUTDOWN 关闭状态 线程池不再接收新任务，但还会继续执行队列任务 STOP 停止状态 不再接收新任务，不会再执行队列任务，并会中断正在执行中的任务 TIDYING 整理状态 所有任务都被终止，工作线程数为0，期间会调用钩子方法terminated() TERMINATED 终止状态 线程池terminated()方法已经调用完成 接着上面，工作线程执行完毕之后，会尝试从任务队列中获取任务来执行，如果队列为空，则阻塞；此时工作线程空闲 根据工作线程的回收机制 允许回收核心工作线程时，将所有空闲时间大于keepAliveTime的线程回收掉 不允许回收核心工作线程，回收空闲时间大于keepAliveTime的线程，知道工作线程数量为核心工作线程数 5. 异常状况处理submit()异常处理 异常会保存在Future对象的ExecutionException中，可以在调用get()使用try-catch方式捕获，有N个任务有异常就会抛出来N个异常，但不会终止当前工作线程 单独设置UncaughtExceptionHandler没卵用，但结合(3)使用就有效 允许在submit()方法内部用try-catch捕获该异常，同样不会终止当前线程 若想在内部处理异常，还可以重写afterExecute()方法， execute()异常处理 默认会在execute()方法内部直接抛出异常，注意这不会中断线程池运行，但会终止当前工作线程，并重新创建新的工作线程执行该任务 允许在execute()方法内部用try-catch捕获该异常，好处是不会终止当前线程并重新创建一个新的线程了 重写afterExecute()方法 还可以设置UncaughtExceptionHandler 一个实例如下: 1234567891011ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 2, 3, TimeUnit.SECONDS, new LinkedBlockingQueue(), //我们自定义一个线程工厂和重写线程的setUncaughtExceptionHandler方法 new ThreadFactory() &#123; final AtomicInteger threadNumber = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; Thread thread = new Thread(Thread.currentThread().getThreadGroup(), r, \"thread-\" + (threadNumber.getAndIncrement())); thread.setUncaughtExceptionHandler((t,e) -&gt; System.out.println(e)); return thread; &#125;&#125;); 6. 线程池关闭关闭线程池主要有两种方式，两者的区别是： shutdown() : 队列剩余任务全部执行完毕再终止 shutdownNow() : 放弃执行队列剩余任务，但会将它们返回 两者的共性在于： 正在执行中的任务会继续执行，不会被终止或放弃 新提交的任务会被直接拒绝 V. 其他参考 Java-线程池专题（什么是线程池，如何使用，为什么要用） 并发番@ThreadPoolExecutor 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"https://zbang.online/hexblog/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"7. 报警系统QuickAlarm之默认报警规则扩展","slug":"报警系统QuickAlarm之默认报警规则扩展","date":"2018-03-05T04:25:00.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","link":"","permalink":"https://zbang.online/hexblog/2018/03/05/报警系统QuickAlarm之默认报警规则扩展/","excerpt":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度","text":"本篇主要是扩展默认的报警规则，使其能更加友好的支持同时选择多种报警方式 扩展遵循两个原则 不影响原有的配置文件格式 简化规则解析复杂度 I. 配置文件的扩展先看一下原有的配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;&#125; 我们希望是能够支持多重报警方式同时选中，那么上面的配置中， threshold中只定义了一个阀值参数显然是不合适的，主要问题在于 单一阀值，不允许不同报警方式存在交叉 两个报警方式的threshold值相等时，选中的具体是哪个不可预期 所以我们的目标是将上面的参数中，新增一个指定上限的值max 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; \"default\": &#123; \"level\": \"NONE\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE,SELFDEFINE\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"小灰灰Blog\", \"greyBlog\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"ZZZ\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"max\": 27, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 9, \"max\": 14, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; 向上面这般改动之后，相当于每个报警方式都可以定义自己的区间，因此允许多重报警方式存在区间的交叉，计数在交叉区间即表示选中这多重方式 II. 扩展的实现支持从配置文件的变动来看，改动很小，只是新增一个参数而已，且这个参数不是必填的，那么对应的do应该为 123456789101112131415161718192021222324public class BasicAlarmThreshold &#123; private String level; /** * 启用定义的报警方式的阀值下限， * * 当报警计数 count &gt;= min * - max 非null, count &lt; max 则选择本报警方式; * count &gt;= max 则不选择本报警方式 * - max 为null（即表示为定义时）， * 则max赋值为:恰好大于 min 的 &#123;@link BasicAlarmThreshold#threshold&#125;值 * */ private int threshold; /** * 报警上限值，注意这是包装类型，允许为null */ private Integer max; private List&lt;String&gt; users;&#125; 然后顺带着，优化一把我们的映射规则，将配置规则的DO对象，映射为业务对象 主要的映射规则如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990/** * 将配置项转换为业务DO对象, 会做一些兼容, 保证 level. min, max, users, thresholds 都不会为null * * @param basicAlarmConfig * @return */private static AlarmConfig parse2BizConfig(BasicAlarmConfig basicAlarmConfig) &#123; if (basicAlarmConfig.getUsers() == null || basicAlarmConfig.getUsers().isEmpty()) &#123; // 如果没有填写用户, 则直接抛弃 return null; &#125; AlarmConfig alarmConfig = new AlarmConfig(); // 如果配置的报警类型是异常的, 则下面会兼容一把，设置为 NONE, 避免因为配置的原因导致系统异常 alarmConfig.setExecutor(SimpleExecuteFactory.getExecute(basicAlarmConfig.getLevel())); alarmConfig.setAutoIncEmergency(basicAlarmConfig.isAutoIncEmergency()); // 报警用户, 要求用户必须存在 alarmConfig.setUsers(basicAlarmConfig.getUsers()); // 报警上限, 如果用户没有填写，采用默认的（因为短信报警按条数要钱, 没必要一直无上限的报） alarmConfig.setMaxLimit(basicAlarmConfig.getMax() == null ? AlarmConfig.DEFAULT_MAX_NUM : basicAlarmConfig.getMax()); // 报警下限, 如果用户没有填写, 采用默认的最小值0 alarmConfig.setMinLimit(basicAlarmConfig.getMin() == null ? AlarmConfig.DEFAULT_MIN_NUM : basicAlarmConfig.getMin()); // 获取配置中的阀值列表，并排序 List&lt;BasicAlarmThreshold&gt; basicAlarmThresholdList = basicAlarmConfig.getThreshold(); if(basicAlarmThresholdList == null) &#123; basicAlarmThresholdList = Collections.emptyList(); &#125; basicAlarmThresholdList.sort(Comparator.comparingInt(BasicAlarmThreshold::getThreshold)); List&lt;AlarmThreshold&gt; alarmThresholdList = new ArrayList&lt;&gt;(basicAlarmThresholdList.size() + 2); AlarmThreshold tmpAlarmThreshold; BasicAlarmThreshold tmpBasicAlarmThreshold; boolean containDefaultExecute = false; for (int i = 0; i &lt; basicAlarmThresholdList.size(); i++) &#123; tmpBasicAlarmThreshold = basicAlarmThresholdList.get(i); tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(SimpleExecuteFactory.getExecute(tmpBasicAlarmThreshold.getLevel())); tmpAlarmThreshold.setUsers(tmpBasicAlarmThreshold.getUsers()); tmpAlarmThreshold.setMin(tmpBasicAlarmThreshold.getThreshold()); if (tmpBasicAlarmThreshold.getMax() == null || tmpBasicAlarmThreshold.getMax() &lt;= tmpBasicAlarmThreshold.getThreshold()) &#123; if (i == basicAlarmThresholdList.size() - 1) &#123; // 最后一个，则使用默认的上限阀值 tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); &#125; else &#123; tmpAlarmThreshold.setMax(basicAlarmThresholdList.get(i + 1).getThreshold()); &#125; &#125; else &#123; tmpAlarmThreshold.setMax(tmpBasicAlarmThreshold.getMax()); &#125; if (!containDefaultExecute) &#123; containDefaultExecute = tmpBasicAlarmThreshold.getLevel().equals(basicAlarmConfig.getLevel()); &#125; alarmThresholdList.add(tmpAlarmThreshold); &#125; int thresholdSize = alarmThresholdList.size(); if (thresholdSize == 0) &#123; // 没有配置阀值列表，直接使用默认 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; else if (!containDefaultExecute) &#123; // 不包含时默认时，补全 tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmConfig.getMinLimit()); tmpAlarmThreshold.setMax(alarmThresholdList.get(0).getMin()); alarmThresholdList.add(0, tmpAlarmThreshold); if (alarmThresholdList.get(thresholdSize).getMax() &lt; alarmConfig.getMaxLimit()) &#123; tmpAlarmThreshold = new AlarmThreshold(); tmpAlarmThreshold.setExecutor(alarmConfig.getExecutor()); tmpAlarmThreshold.setUsers(alarmConfig.getUsers()); tmpAlarmThreshold.setMin(alarmThresholdList.get(thresholdSize).getMax()); tmpAlarmThreshold.setMax(alarmConfig.getMaxLimit()); alarmThresholdList.add(tmpAlarmThreshold); &#125; &#125; alarmConfig.setAlarmThreshold(alarmThresholdList); return alarmConfig;&#125; 在映射为业务对象的逻辑中，直接保障了AlarmThreshold列表中的顺序为最终的需求顺序，映射规则为 123456789101112131415161718192021222324252627/** * 如果配置的basicAlarmThresholdList列表中包含默认的报警方式 * - 则报警方式完全按照basicAlarmThresholdList的定义来 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Log, min=6 &#125;, &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=6, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - count : [6, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * * 如果不包含默认报警方式 * - 则需要补全最外层定义的Min-Max区间中的空余位 * - eg: 默认报警为 Log, min=5, max=30 * - basicAlarmThresholdList 中定义为 : &#123; Email, min=8 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125; * - 则转换后的 alarmThresholdList为: * - &#123; Log, min=5, max=8 &#125;, &#123; Email, min=8, max=10 &#125;, &#123; WeiXin, min=10, max=16 &#125;, &#123; SMS, min=14, max=26 &#125;, &#123; Log, min=26, max=30 &#125; * - count : [5, 8) Log * - count : [8, 10) Email * - count : [10, 16) WeiXin * - count : [14, 26) SMS * - count : [26, 30) Log * * * 上面改造后，很容易得知，支持多重报警方式同时工作，即当技术为14，15 时，同时发起WeiXin和SMS报警 */ 相应的就可以干掉原来不太好懂的Executor选择逻辑，对应的代码为 123456789101112131415161718192021222324252627282930// com.hust.hui.alarm.core.execut.AlarmExecuteSelector#getExecutepublic static List&lt;ExecuteHelper&gt; getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return Collections.singletonList(new ExecuteHelper(alarmConfig.getExecutor(), alarmConfig.getUsers())); &#125; if (count &lt; alarmConfig.getAlarmThreshold().get(0).getMin()) &#123; // 未达到报警的下限 return Collections.singletonList(new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers())); &#125; List&lt;ExecuteHelper&gt; list = new ArrayList&lt;&gt;(); for(AlarmThreshold alarmThreshold: alarmConfig.getAlarmThreshold()) &#123; if (alarmThreshold.getMin() &lt;= count &amp;&amp; count &lt; alarmThreshold.getMax()) &#123; list.add(new ExecuteHelper(alarmThreshold.getExecutor(), alarmThreshold.getUsers())); &#125; if(alarmThreshold.getMin() &gt; count) &#123; break; &#125; &#125; return list;&#125; III. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"借助GitHub搭建属于自己的maven仓库教程","slug":"借助GitHub搭建属于自己的maven仓库教程","date":"2018-02-12T06:01:13.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","link":"","permalink":"https://zbang.online/hexblog/2018/02/12/借助GitHub搭建属于自己的maven仓库教程/","excerpt":"","text":"I. 背景在Github上也写了不少的项目了，然后经常遇到的一个问题就是，很多自己写的项目，希望在另外一个项目中使用时，只能把这个项目下载下来，相当之不方便 因为大多数的java后端项目都是基于maven管理依赖的，所以就希望能有一个公共的maven仓库，可以把自己的项目扔进去，然后再应用就方便很多了 基于此，就有了本文这个教程了 II. 实现步骤1. github仓库建立新建一个repository的前提是有github帐号，默认看到本文的是有帐号的 首先是在github上新建一个仓库，命令随意，如我新建项目为 https://github.com/liuyueyi/maven-repository 2. 配置本地仓库本地指定一个目录，新建文件夹 maven-repository, 如我的本地配置如下 1234567891011121314## 进入目录cd /Users/yihui/GitHub## 新建目录mkdir maven-repository; cd maven-repository## 新建repository目录# 这个目录下面就是存放我们deploy的项目相关信息# 也就是说我们项目deploy指定的目录，就是这里mkdir repository## 新增一个readme文档# 保持良好的习惯，每个项目都有一个说明文档touch README.md 这个目录结构为什么是这样的？ 我们直接看maven配置中默认的目录结构，同样拷贝一份出来而已 3. 仓库关联将本地的仓库和远程的github仓库关联起来，执行的命令也比较简单了 1234git add .git commit -m 'first comit'git remote add origin https://github.com/liuyueyi/maven-repository.gitgit push -u origin master 接着就是进行分支管理了 约定将项目中的snapshot版，deploy到仓库的 snapshot分支上 约定将项目中的release版，deploy到仓库的 release分支上 master分支管理所有的版本 所以需要新创建两个分支 12345678## 创建snapshot分支git checkout -b snapshot git push origin snapshot# 也可以使用 git branch snapshot , 我通常用上面哪个，创建并切换分支## 创建release分支git checkout -b releasegit push origin release 4. 项目deploy项目的deploy，就需要主动的指定一下deploy的地址了，所以我们的deploy命令如下 12## deploy项目到本地仓库mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository 上面的命令就比较常见了，主要需要注意的是file后面的参数，根据自己前面设置的本地仓库目录来进行替换 5. deploy脚本每次进行上面一大串的命令，不太好记，特别是不同的版本deploy到不同的分支上，主动去切换分支并上传，也挺麻烦，所以就有必要写一个deploy的脚本了 由于shell实在是不太会写，所以下面的脚本只能以凑合能用来说了 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/bin/bashif [ $# != 1 ];then echo 'deploy argument [snapshot(s for short) | release(r for short) ] needed!' exit 0fi## deploy参数，snapshot 表示快照包，简写为s， release表示正式包，简写为rarg=$1DEPLOY_PATH=/Users/yihui/GitHub/maven-repository/CURRENT_PATH=`pwd`deployFunc()&#123; br=$1 ## 快照包发布 cd $DEPLOY_PATH ## 切换对应分支 git checkout $br cd $CURRENT_PATH # 开始deploy mvn clean deploy -Dmaven.test.skip -DaltDeploymentRepository=self-mvn-repo::default::file:/Users/yihui/GitHub/maven-repository/repository # deploy 完成,提交 cd $DEPLOY_PATH git add -am 'deploy' git push origin $br # 合并master分支 git checkout master git merge $br git commit -am 'merge' git push origin master cd $CURRENT_PATH&#125;if [ $arg = 'snapshot' ] || [ $arg = 's' ];then ## 快照包发布 deployFunc snapshotelif [ $arg = 'release' ] || [ $arg = 'r' ];then ## 正式包发布 deployFunc releaseelse echo 'argument should be snapshot(s for short) or release(r for short). like: `sh deploy.sh snapshot` or `sh deploy.sh s`'fi 将上面的脚本，考本到项目的根目录下，然后执行 12345678chmod +x deploy.sh## 发布快照包./deploy.sh s# sh deploy.sh snapshot 也可以## 发布正式包./deploy.sh r 基于此，整个步骤完成 III. 使用上面仓库的基本搭建算是ok了，然后就是使用了，maven的pom文件应该怎么配置呢？ 首先是添加仓库地址 添加仓库 如果要区分snapshot和release的话，如下配置 12345678910&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-snap&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/snapshot/repository&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo-release&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/release/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 如果不care的话，直接添加下面的即可 123456&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yihui-maven-repo&lt;/id&gt; &lt;url&gt;https://raw.githubusercontent.com/liuyueyi/maven-repository/master/repository&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 仓库配置完毕之后，直接引入依赖即可，如依赖我的Quick-Alarm包，就可以添加下面的依赖配置 12345&lt;dependency&gt; &lt;groupId&gt;com.hust.hui.alarm&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt;&lt;/dependency&gt; IV. 其他个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Github","slug":"Github","permalink":"https://zbang.online/hexblog/tags/Github/"},{"name":"Maven","slug":"Maven","permalink":"https://zbang.online/hexblog/tags/Maven/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Git","slug":"技术/Shell/Git","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/"},{"name":"Maven","slug":"技术/Shell/Git/Maven","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Git/Maven/"}]},{"title":"6. 报警系统QuickAlarm使用手册","slug":"报警系统QuickAlarm使用手册","date":"2018-02-11T10:53:33.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm使用手册/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm使用手册/","excerpt":"","text":"本文将主要说明QuickAlarm该如何使用，以及使用时需要注意事项 1. 基本使用姿势首先我们不做任何的自定义操作，全部依靠系统默认的实现，我们的使用步骤如下 1. 添加注册文件首先在项目的资源目录下，添加注册文件 alarm.properties，文件内容如下 12345678910111213## 应用名，必填appName=test## 报警规则文件所在的路径，如果采用系统默认加载方式，必填## / 开头，表示存的是绝对路径## 非/开头，表示存的是系统相对路径，一般是放在资源目录下alarmConfPath=/tmp/alarmConfig## 最大的报警类型，非必填maxAlarmType=1000## 默认报警用户，必填defaultAlarmUsers=yihui 具体存放的位置，可以参考下图，放在resources目录下（源码中，是放在测试资源目录下的） 2. 添加报警规则根据注册文件中指定的路径，设置报警规则文件，如我们的报警规则文件 内容为json串格式，支持格式化的json串解析，为了节省篇幅，下面压缩成一行，点击获取json格式化小工具 /tmp/alarmConig: 1&#123;\"default\":&#123;\"level\":\"LOG\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"LOG\",\"threshold\":5,\"users\":[\"yihui\",\"erhui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"NPE\":&#123;\"level\":\"WEIXIN\",\"autoIncEmergency\":false,\"max\":30,\"min\":0,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"3h ui\",\"4hui\"]&#125;],\"users\":[\"yihui\"]&#125;,\"XXX,YYY\":&#123;\"level\":\"EMAIL\",\"autoIncEmergency\":true,\"max\":30,\"min\":3,\"threshold\":[&#123;\"level\":\"SMS\",\"threshold\":20,\"users\":[\"345345345345\",\"123123123123\"]&#125;,&#123;\"level\":\"WEIXIN\",\"threshold\":10,\"users\":[\"yihui\",\"erhui\"]&#125;,&#123;\"level\":\"EMAIL\",\"threshold\":5,\"users\":[\"yihui@xxx.com\",\"erhui@xxx.com\"]&#125;],\"users\":[\"yihui@xxx.com\"]&#125;&#125; 3. 测试类一个简单的使用测试 123456789101112@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; II. 报警执行机器扩展前面的报警规则配置中，有WEIXIN, SMS, EMAIL的报警，但是系统只提供了两个NONE和LOG，所以我们可以看下如何自定义实现上面的三个 1. 实现IExecute接口邮件报警 123456public class EmailExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 短信报警 12345678910/** * Created by yihui on 2018/2/7. */public class SmsExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 微信报警 123456789/** * Created by yihui on 2018/2/7. */public class WeiXinExecute extends LogExecute &#123; @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; super.sendMsg(users, title, msg); &#125;&#125; 说明，因为没有具体的实现，所以我们直接用日志输出来模拟，所以就都继承了LogExecute, 实际使用中，可以在上面补上相应的实现代码 2. 添加SPI定义在 resources 目录下，新增 目录：META-INF/services/ 文件：com.hust.hui.alarm.core.execut.api.IExecute 文件内容为上面几个实现类的全路径 123com.hust.hui.alarm.core.test.execute.EmailExecutecom.hust.hui.alarm.core.test.execute.SmsExecutecom.hust.hui.alarm.core.test.execute.WeiXinExecute 目录结构如： 3. 测试1234567891011121314151617181920public static void main(String[] args) throws InterruptedException &#123; // 测试异常升级的case // 计数 [1 - 2] 默认报警（即无日志） （其中 &lt; 3 的是因为未达到下限, 采用的默认报警） // 计数 [3 - 4] 默认邮件报警（其中 &lt; 5 采用的默认报警, 与下面的区别是报警用户） // 计数 [5 - 9] 邮件报警 （大于5小于10根据上升规则,还是选择邮件报警） // 计数 [10 - 19] 微信报警 // 计数 [20 - 30] 短信报警 // 计数 [31 -] 默认报警 （超过上限, 不报警） for (int i = 0; i &lt; 40; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; AlarmWrapper.getInstance().sendMsg(\"YYY\", \"异常报警升级测试\"); &#125; &#125;).start(); &#125; Thread.sleep(1000 * 600);&#125; 实测输出结果如下: 1234567891011121314151617181920212223242526272818:36:28.997 [Thread-12] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 26 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-24] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 16 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-33] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 6 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-22] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 18 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-26] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-23] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 17 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-35] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 4 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-3] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 5 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-18] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 27 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-11] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 28 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-21] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 19 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [sms-sender1-thread-2] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 9 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-14] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 24 &gt;&gt;&gt; 异常报警升级测试18:36:28.997 [Thread-10] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 29 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-15] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 22 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-16] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 23 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 15 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-9] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 30 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-13] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 25 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-19] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 21 &gt;&gt;&gt; 异常报警升级测试18:36:28.998 [Thread-34] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 3 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-4] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 7 &gt;&gt;&gt; 异常报警升级测试18:36:29.010 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:36:29.011 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui, erhui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-5] INFO alarm - Do send msg by EMAIL to user:[yihui@xxx.com, erhui@xxx.com], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 8 &gt;&gt;&gt; 异常报警升级测试18:36:29.014 [sms-sender1-thread-1] INFO alarm - Do send msg by SMS to user:[345345345345, 123123123123], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 20 &gt;&gt;&gt; 异常报警升级测试 III. 报警规则加载自定义1. 实现IConfLoader接口自定义加载器，给了一个最基本的 12345678910111213141516171819202122232425262728293031323334public class SelfAlarmConfLoader implements IConfLoader &#123; @Override public RegisterInfo getRegisterInfo() &#123; RegisterInfo registerInfo = new RegisterInfo(); registerInfo.setMaxAlarmType(100); registerInfo.setDefaultAlarmUsers(\"yihui\"); registerInfo.setAppName(\"test\"); return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public int order() &#123; return 0; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; //db 查询，获取对应的配置信息 // 下面是模拟，返回一个固定的配置 AlarmConfig alarmConfig = new AlarmConfig(); alarmConfig.setAlarmLevel(\"WEIXIN\"); alarmConfig.setAutoIncEmergency(false); alarmConfig.setMinLimit(10); alarmConfig.setMaxLimit(14); alarmConfig.setUsers(Arrays.asList(\"yihui\")); alarmConfig.setAlarmThreshold(Collections.emptyList()); return alarmConfig; &#125;&#125; 2. 添加SPI配置在resources目录下新增 目录： META-INF/services 文件： com.hust.hui.alarm.core.loader.api.IConfLoader 文件内容 1com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader 3. 测试同样是上面的代码，输出结果 1234518:43:04.275 [sms-sender1-thread-2] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 10 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-4] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 12 &gt;&gt;&gt; 异常报警升级测试18:43:04.276 [sms-sender1-thread-1] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 11 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-5] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 14 &gt;&gt;&gt; 异常报警升级测试18:43:04.275 [sms-sender1-thread-3] INFO alarm - Do send msg by WEIXIN to user:[yihui], title: [test], msg: ip:172.17.13.18 &gt;&gt;&gt; key:YYY &gt;&gt;&gt; 异常数: 13 &gt;&gt;&gt; 异常报警升级测试 4. 说明系统默认的order是10，所以如果在测试上面的第二步时，不妨把com.hust.hui.alarm.core.test.loader.SelfAlarmConfLoader#order返回值，改成大于10，这样就会走到默认的配置加载类 采用 SelfAlarmConfLoader 时，前面说的两个基础配置文件，是可以没有的，完全不会有任何影响，因为对应的注册类和报警规则，都是右这个类内部提供了 IV. 小结所有测试相关数据，均可以在测试工程中获取，请主要关注: 测试case 注册文件：alarmConfig 报警规则配置文件：alarm.properties V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"5. 报警系统QuickAlarm之频率统计及接口封装","slug":"报警系统QuickAlarm之频率统计及接口封装","date":"2018-02-11T08:59:47.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之频率统计及接口封装/","excerpt":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦","text":"前面将报警规则的制定加载解析，以及报警执行器的定义加载和扩展进行了讲解，基本上核心的内容已经完结，接下来剩下内容就比较简单了 报警频率的统计 报警线程池 对外封装统一可用的解耦 I. 报警频率统计1. 设计前面在解析报警规则时，就有一个count参数，用来确定具体选择什么报警执行器的核心参数，我们维护的方法也比较简单： 针对报警类型，进行计数统计，没调用一次，则计数+1 每分钟清零一次 2. 实现因为每种报警类型，都维护一个独立的计数器 定义一个map来存储对应关系 1private ConcurrentHashMap&lt;String, AtomicInteger&gt; alarmCountMap; 每分钟执行一次清零 1234567// 每分钟清零一把报警计数ScheduledExecutorService scheduleExecutorService = Executors.newScheduledThreadPool(1);scheduleExecutorService.scheduleAtFixedRate(() -&gt; &#123; for (Map.Entry&lt;String, AtomicInteger&gt; entry : alarmCountMap.entrySet()) &#123; entry.getValue().set(0); &#125;&#125;, 0, 1, TimeUnit.MINUTES); 注意上面的实现，就有什么问题？ 有没有可能因为map中的数据过大（或者gc什么原因），导致每次清零花不少的时间，而导致计数不准呢？ （先不给出回答） 计数加1操作 1234567891011121314151617/** * 线程安全的获取报警总数 并自动加1 * * @param key * @return */private int getAlarmCount(String key) &#123; if (!alarmCountMap.containsKey(key)) &#123; synchronized (this) &#123; if (!alarmCountMap.containsKey(key)) &#123; alarmCountMap.put(key, new AtomicInteger(0)); &#125; &#125; &#125; return alarmCountMap.get(key).addAndGet(1);&#125; II. 报警线程池目前也只是提供了一个非常简单的线程池实现，后面的考虑是抽象一个基于forkjoin的并发框架来处理（主要是最近接触到一个大神基于forkjoin写的并发器组件挺厉害的，所以等我研究透了，山寨一个） 123456// 报警线程池private ExecutorService alarmExecutorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(10), new DefaultThreadFactory(\"sms-sender\"), new ThreadPoolExecutor.CallerRunsPolicy()); 任务提交执行 12345678private void doSend(final ExecuteHelper executeHelper, final AlarmContent alarmContent) &#123; alarmExecutorService.execute(() -&gt; executeHelper.getIExecute().sendMsg( executeHelper.getUsers(), alarmContent.getTitle(), alarmContent.getContent()));&#125; III. 接口封装这个就没什么好说的了 123456789101112131415161718192021222324252627282930313233343536373839404142public void sendMsg(String key, String content) &#123; sendMsg(new AlarmContent(key, null, content));&#125;public void sendMsg(String key, String title, String content) &#123; sendMsg(new AlarmContent(key, title, content));&#125;/** * 1. 获取报警的配置项 * 2. 获取当前报警的次数 * 3. 选择适当的报警类型 * 4. 执行报警 * 5. 报警次数+1 * * @param alarmContent */private void sendMsg(AlarmContent alarmContent) &#123; try &#123; // get alarm config AlarmConfig alarmConfig = confLoader.getAlarmConfig(alarmContent.key); // get alarm count int count = getAlarmCount(alarmContent.key); alarmContent.setCount(count); ExecuteHelper executeHelper; if (confLoader.alarmEnable()) &#123; // get alarm execute executeHelper = AlarmExecuteSelector.getExecute(alarmConfig, count); &#125; else &#123; // 报警关闭, 则走空报警流程, 将报警信息写入日志文件 executeHelper = AlarmExecuteSelector.getDefaultExecute(); &#125; // do send msg doSend(executeHelper, alarmContent); &#125; catch (Exception e) &#123; logger.error(\"AlarmWrapper.sendMsg error! content:&#123;&#125;, e:&#123;&#125;\", alarmContent, e); &#125;&#125; 接口封装完毕之后如何使用呢？ 我们使用单例模式封装了唯一对外使用的类AlarmWrapper，使用起来也比较简单，下面就是一个测试case 12345678910111213@Testpublic void sendMsg() throws InterruptedException &#123; String key = \"NPE\"; String title = \"NPE异常\"; String msg = \"出现NPE异常了!!!\"; AlarmWrapper.getInstance().sendMsg(key, title, msg); // 微信报警 // 不存在异常配置类型, 采用默认报警, 次数较小, 则直接部署出 AlarmWrapper.getInstance().sendMsg(\"zzz\", \"不存在xxx异常配置\", \"报警嗒嗒嗒嗒\"); Thread.sleep(1000);&#125; 使用起来比较简单，就那么一行即可，从这个使用也可以知道，整个初始化，就是在这个对象首次被访问时进行 构造函数内容如下: 12345678910private AlarmWrapper() &#123; // 记录每种异常的报警数 alarmCountMap = new ConcurrentHashMap&lt;&gt;(); // 加载报警配置信息 confLoader = ConfLoaderFactory.loader(); // 初始化线程池 initExecutorService();&#125; 所有如果你希望在自己的应用使用之前就加载好所有的配置，不妨提前执行一下 AlarmWrapper.getInstance() IV. 小结基于此，整个系统设计基本上完成，当然代码层面也ok了，剩下的就是使用手册了 再看一下我们的整个逻辑，基本上就是下面这个流程了 提交报警 封装报警内容（报警类型，报警主题，报警内容） 维护报警计数（每分钟计数清零，每个报警类型对应一个报警计数） 选择报警 根据报警类型选择报警规则 根据报警规则，和当前报警频率选择报警执行器 若不开启区间映射，则返回默认执行器 否则遍历所有执行器的报警频率区间，选择匹配的报警规则 执行报警 封装报警任务，提交线程池 报警执行器内部实现具体报警逻辑 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"4. 报警系统QuickAlarm之报警规则解析","slug":"报警系统QuickAlarm之报警规则解析","date":"2018-02-11T08:08:04.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/11/报警系统QuickAlarm之报警规则解析/","link":"","permalink":"https://zbang.online/hexblog/2018/02/11/报警系统QuickAlarm之报警规则解析/","excerpt":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器","text":"前面两篇分别说了报警执行器和报警规则的定义及用户扩展加载，接下来就是比较核心的一块了，如何将报警规则和报警执行器关联起来，即当发生报警时，应该call哪一个报警执行器 I. 背景知识点0. 声明在正式进入之前，有必要额外声明一下，因为目前的v1版本，没有开放报警规则的自定义，也就是说，目前只支持默认的报警规则，所以接下来的主要内容将集中在 系统默认的报警规则的解析 即基于报警频率阀值，自动选择报警执行器的规则解析 1. 报警规则如果对于报警规则，依然不是很清晰的，可以阅读一下《报警系统QuickAlarm之报警规则的设定与加载》 这里简单的进行说明，系统中默认的报警规则结构为： key为报警类型（即用户执行报警时，传进来的报警类型参数） value为具体报警规则 每个报警执行器拥有一个报警频率区间，通过报警频率映射到报警执行器的区间来选择对应的AlarmExecutor，这就是系统定义的报警规则 II. 报警规则解析通过前面的报警规则的简单说明，基本上也可以捞出报警规则的解析原则了 每种报警类型，对应一个报警规则 每个报警规则中，可以有多个报警执行器 每个报警执行器都有一个对应的报警频率的阀值 根据阀值对所有的报警执行器排序 计算报警频率，映射到哪个区间，则选择哪个报警执行器 上面是一个简单的解析规则，当然实际上和这个差不多，但有一些问题需要额外注意 只想选择一种报警方式，是否可以支持？ 多重报警方式同时调用怎么处理？（如我希望用短信提示说有问题，同时用邮件包含详细的异常堆栈） 频率限制 报警类型没有设置报警规则如何处理？ 报警规则中使用了一个未注册的报警执行器会怎样？ 1. 实现方案说明再次将报警规则类拿出来看一下 12345678910111213141516171819202122232425262728293031323334/** * 报警用户 */private List&lt;String&gt; users;/** * 报警的阀值 */private List&lt;AlarmThreshold&gt; alarmThreshold;/** * 最小的报警数 */private int minLimit;/** * 最大的报警数 */private int maxLimit;/** * 报警类型 &#123;@link IExecute#getName()&#125; */private String alarmLevel;/** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */private boolean autoIncEmergency; 针对上面的问题，逐一说明 首先是 autoIncEmergency 这个参数，如果为true，则表示可以走上面的哪个区间映射的规则；否则就全部走AlarmConfig中默认的报警类型了 minLimit : 表示发生报警的频率下限值，小于这个值就不会执行具体的报警逻辑 maxLimit : 最大的报警频率，超过了也不报警（简单的频率控制） alarmLevel: 对应的就是具体的报警类型 alarmThreshold: 这个只有在autoIncEmergency=true时，才有小，也就是我们前面说的不同的报警执行器，根据阀值区间进行排序，开启之后，遍历，判断频率是否在这个区间内，若在，则表示可以选择它了 如果不存在报警规则，则采用默认的兜底规则 若报警执行器也不存在，就直接采用系统定义的日志报警执行器 2. 实现基本上前面已经将整个逻辑都说了，所以实际的编码反而比较清晰了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 获取具体的报警执行器 * &lt;p&gt; * 1. 未开启严重等级上升时, 直接返回 * 2. 开启之后, 判断当前的计数 范围 * * @param alarmConfig 报警配置项, 内部所有的参数都不可能为null */public static ExecuteHelper getExecute(final AlarmConfig alarmConfig, int count) &#123; // 未达到报警的下限 or 超过报警的上限时 if (count &lt; alarmConfig.getMinLimit() || count &gt; alarmConfig.getMaxLimit()) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(NoneExecute.NAME), alarmConfig.getUsers()); &#125; // 未开启报警升级, 直接返回 if (!alarmConfig.isAutoIncEmergency()) &#123; return new ExecuteHelper(SimpleExecuteFactory. getExecute(alarmConfig.getAlarmLevel()), alarmConfig.getUsers()); &#125; // 报警等级开启上升之趋势 // 1. 获取设置的默认等级 // 2. 判断当前的报警次数, 选择对应的报警类型 // 3. 选择具体的报警类型 String defaultLevel = alarmConfig.getAlarmLevel(); String selectLevel = null; List&lt;String&gt; selectUser = alarmConfig.getUsers(); List&lt;AlarmThreshold&gt; list = alarmConfig.getAlarmThreshold(); boolean useNew = false; boolean containDefaultLevel = false; for (AlarmThreshold alarmThreshold : list) &#123; if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; containDefaultLevel = true; &#125; &#125; for (AlarmThreshold alarmThreshold : list) &#123; // 表示当前的报警等级已经赶上默认的报警等级了, 所以要选择新的报警类型 if (Objects.equals(alarmThreshold.getAlarmLevel(), defaultLevel)) &#123; useNew = true; &#125; if (count &lt; alarmThreshold.getThreshold()) &#123; break; &#125; selectLevel = alarmThreshold.getAlarmLevel(); // 选择新的报警类型时, 需要更新报警用户 selectUser = alarmThreshold.getUsers(); &#125; // 阀值列表中不包含默认报警类型，则根据新的来 if (!containDefaultLevel &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; // 如果阀值列表中包含了默认报警类型, 且已经超过默认阀值 if (useNew &amp;&amp; selectLevel != null) &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(selectLevel), selectUser); &#125; else &#123; return new ExecuteHelper(SimpleExecuteFactory.getExecute(defaultLevel), alarmConfig.getUsers()); &#125;&#125; 具体的实现基本和我们前面分析的一样，但有一个地方需要额外注意 默认报警阀值，可以直接决定是否需要报警 因此定义的其他报警方式的阀值，应该在默认的阀值区间内 当然AlarmThreshold中不包含默认报警方式时，优先选择阀值区间的报警方式 当然AlarmThreshold中包含默认报警方式时，根据新的规则做处理 （吐槽：上面这个实现有点绕，后面想办法规避下，搞得不太好理解了） 另外一个问题就是，上面的实现没有支持可以同时选择多个报警执行器的情况 因为考虑到后面肯定会对报警规则的定义和解析放开，所以先实现了一个简单的场景，具体的放在后面处理 III. 小结到这里报警规则和报警执行器之间的解析关系已确定，剩下的东西就简单了，一个维持报警频率计数，一个报警线程池，再加上一个对外接口的封装而言 基本上，到这里主要的核心逻辑已经完成，小结一下本系统中的核心设计理念 – 一切可自定义（当然目前差得有点远） 1. 报警执行器 通过SPI机制支持用户自定义扩展 要求 Executor 拥有唯一标识 因为报警执行器支持扩展，所以Executor的内部实现，完全可以由用户决定 2. 报警规则 目前报警规则只提供默认的基于频率区间的选择方案 报警规则通过报警执行器的name与之唯一对应，若对应不上，则选择默认执行器 报警规则的加载同样基于SPI，支持自定义，因此报警规则可以存在任何地方 报警规则加载器，提供一个报警规则变动的钩子(load()),若采用自定义的加载类，则确保规则变动时，主动回调这个方法 默认的报警规则加载类，是基于系统的配置文件实现，内部托管了文件的变动更新事件（使用commons-io实现） IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目: QuickAlarm 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"3. 报警系统QuickAlarm之报警规则的设定与加载","slug":"报警系统QuickAlarm之报警规则的设定与加载","date":"2018-02-09T11:39:43.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警规则的设定与加载/","excerpt":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择","text":"前面一篇是报警执行器的定义与加载已经完成，但与之对应的报警规则有是如何定义和加载的呢？ 此外，既然命名为规则，那么就需要有对应的解析器，以根据报警规则和报警类型等相关输入条件，来选择对应的报警执行器，因此本文主要包括的内容就比较清晰了 报警规则的定义 报警规则的加载 报警规则的解析以及报警执行器选择 I. 报警规则定义 目前针对报警规则没有给出自定义配置的入口，即完全采用了默认的方案，后续可以考虑支持适用方来自定义报警规则以及解析器，这样扩展性就更强了 首先说明下我们的设计规则，我们针对不同的AlarmExecute定义了一个优先级，我们的目标是 针对报警频率设置不同区间，每个区间对应一种报警类型 当实际调用的报警频率达到这个区间，就选择这种报警类型 同时也允许关闭根据频率选择报警器的功能，全程用一个默认 每种报警类型的用户都可以自定义 针对上面的目标，我们设计的类就比较明确了 阀值类： 1234567891011121314151617181920212223242526272829303132@Getter@Setter@ToStringpublic class AlarmThreshold implements Comparable&lt;AlarmThreshold&gt; &#123; /** * 报警类型，对应 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * 晋升此报警的阀值 */ private int threshold; /** * 对应的报警用户 */ private List&lt;String&gt; users; @Override public int compareTo(AlarmThreshold o) &#123; if (o == null) &#123; return -1; &#125; return threshold - o.getThreshold(); &#125;&#125; 配置类： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Getter@Setter@ToStringpublic class AlarmConfig &#123; public static final int DEFAULT_MIN_NUM = 0; public static final int DEFAULT_MAX_NUM = 30; /** * 报警用户 */ private List&lt;String&gt; users; /** * 报警的阀值 */ private List&lt;AlarmThreshold&gt; alarmThreshold; /** * 最小的报警数 */ private int minLimit; /** * 最大的报警数 */ private int maxLimit; /** * 报警类型 &#123;@link IExecute#getName()&#125; */ private String alarmLevel; /** * true 表示当报警超过当前的阀值之后, 将提升报警的程度 */ private boolean autoIncEmergency;&#125; 一个报警类型对应一个AlarmConfig，这样当执行报警时，就可以很容易的获取对应的规则 同样根据定义，也可以看出报警规则比较简单，直接根据阀值区间来选择 II. 报警规则加载关于如何加载报警规则，想了很久，选择把这块放开，因为我们无法确定，使用方的配置是存在什么地方的，而且使用的配置是否能和我们的设计的DO兼容也是个问题，因此干脆放手，同样是通过SPI的方式来做的 我们定义规则加载接口： IConfLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public interface IConfLoader &#123; /** * 加载配置到内存的操作，启动时，被调用 * * @return true 表示加载成功; false 表示加载失败 */ default boolean load() &#123; return true; &#125; /** * 排序，越小优先级越高 * &lt;p&gt; * 说明： 当系统中多个Loader存在时，会根据优先级来选择order最小的一个作为默认的Loader * * @return */ default int order() &#123; return 10; &#125; /** * 获取注册信息 * * @return */ RegisterInfo getRegisterInfo(); /** * 是否开启报警 * * @return */ boolean alarmEnable(); /** * 根据报警类型，获取对应的报警规则 * * @param alarmKey * @return */ AlarmConfig getAlarmConfig(String alarmKey);&#125; 上面的方法，可以划分为两类: 加载时使用 load 为具体的执行加载配置到内存的方法，返回true表示加载成功 order 排序 getRegisterInfo 获取基础的配置信息（包括应用名等相关配置） 业务运行时使用 alarmEnable ： 是否开启报警 （当大量报警时，可以先关闭报警，然后再查问题） getAlarmConfig：核心方法，根据报警类型，返回对应的报警规则 系统默认提供一个从配置文件中加载报警规则的方案，主要会依赖两个配置文件 alarm.properties : 初始化注册信息，内部保存 RegisterInfo 所需要的属性 alarmConfig : 保存具体的报警规则，json格式 1. 配置加载配置加载的实现逻辑，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class PropertiesConfLoader implements IConfLoader &#123; private RegisterInfo registerInfo; private Map&lt;String, AlarmConfig&gt; cacheMap; public boolean load() &#123; // 获取注册信息 registerInfo = RegisterInfoLoaderHelper.load(); if (registerInfo == null) &#123; return false; &#125; // 获取报警的配置类 File file; String path = registerInfo.getAlarmConfPath(); if (path.startsWith(\"/\")) &#123; file = new File(path); &#125; else &#123; URL url = this.getClass().getClassLoader().getResource(path); file = new File(url.getFile()); &#125; // 加载成功，才替换 cacheMap的内容； 主要是为了防止修改配置出现问题 Map&lt;String, AlarmConfig&gt; tmp = init(file); boolean ans = tmp != null; // 注册配置文件的变动 ans = ans &amp;&amp; PropertiesConfListenerHelper.registerConfChangeListener(file, this::init); if (ans) &#123; cacheMap = tmp; &#125; return ans; &#125; private Map&lt;String, AlarmConfig&gt; init(File file) &#123; try &#123; // 正常来讲，是一个完整的json串 List&lt;String&gt; list = IOUtils.readLines(new FileInputStream(file), \"utf-8\"); String config = Joiner.on(\"\").join(list); return AlarmConfParse.parseConfig(config, Splitter.on(\",\").splitToList(registerInfo.getDefaultAlarmUsers())); &#125; catch (IOException e) &#123; log.error(\"load config into cacheMap error! e: &#123;&#125;\", e); return null; &#125; &#125; @Override public RegisterInfo getRegisterInfo() &#123; return registerInfo; &#125; @Override public boolean alarmEnable() &#123; return true; &#125; @Override public AlarmConfig getAlarmConfig(String alarmKey) &#123; AlarmConfig config = cacheMap.get(alarmKey); if (config == null) &#123; return cacheMap.get(AlarmConfParse.DEFAULT_ALARM_KEY); &#125; else &#123; return config; &#125; &#125;&#125; 主要查看默认的load方法即可, alarmEnable 和 getAlarmConfig还是比较简单的，看一下就知道怎么玩的 2. RegisterInfo 加载上面的实现中，第一步就是从 alarm.properteis 文件中读取对应的配置，然后初始化 RegisterInfo对象 1234567891011@Datapublic class RegisterInfo implements Serializable &#123; // 报警规则文件的路径，系统默认加载时，必填；否则选填 private String alarmConfPath; // 最大报警类型数，非必填，默认1000 private Integer maxAlarmType; // 默认报警用户， 必须 private String defaultAlarmUsers; // 应用名， 必须 private String appName;&#125; 一个配置文件实例 1234appName=testalarmConfPath=/tmp/alarmConfigmaxAlarmType=1000defaultAlarmUsers=yihui 从配置文件中读取信息，然后初始化对象的过程就比较简单了，我这里做了一个小简化，使用反射的方式实现对象拷贝 123456789101112131415161718public static void copy(Properties source, Object dest) throws IllegalAccessException &#123; Field[] fields = dest.getClass().getDeclaredFields(); for (Field f : fields) &#123; // 不修改静态变量 if (Modifier.isStatic(f.getModifiers())) &#123; continue; &#125; f.setAccessible(true); // 值拷贝，因为不同数据类型的问题，所以需要对properties中获取的String类型转换一把 f.set(dest, parseObj(source.getProperty(f.getName()), f.getType())); &#125;&#125;// 强制类型转换private static &lt;T&gt; T parseObj(String obj, Class&lt;T&gt; clz) &#123; return ParseFuncEnum.getFunc(clz).apply(obj);&#125; 上面的实现目前比较简单，没有考虑父类的情况，没有考虑复杂的数据类型转换，目前只支持了基本类型的转换，后续可考虑抽象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public enum ParseFuncEnum &#123; INT_PARSE(Arrays.asList(int.class, Integer.class)) &#123; @Override public Function&lt;String, Integer&gt; getFunc() &#123; return Integer::valueOf; &#125; &#125;, LONG_PARSE(Arrays.asList(long.class, Long.class)) &#123; @Override public Function&lt;String, Long&gt; getFunc() &#123; return Long::valueOf; &#125; &#125;, BOOLEAN_PARSE(Arrays.asList(boolean.class, Boolean.class)) &#123; @Override public Function&lt;String, Boolean&gt; getFunc() &#123; return Boolean::valueOf; &#125; &#125;, FLOAT_PARSE(Arrays.asList(float.class, Float.class)) &#123; @Override public Function&lt;String, Float&gt; getFunc() &#123; return Float::valueOf; &#125; &#125;, DOUBLE_PARSSE(Arrays.asList(double.class, Double.class)) &#123; @Override public Function&lt;String, Double&gt; getFunc() &#123; return Double::valueOf; &#125; &#125;, SHORT_PARSE(Arrays.asList(short.class, Short.class)) &#123; @Override public Function&lt;String, Short&gt; getFunc() &#123; return Short::valueOf; &#125; &#125;, BYTE_PARSE(Arrays.asList(byte.class, Byte.class)) &#123; @Override public Function&lt;String, Byte&gt; getFunc() &#123; return Byte::valueOf; &#125; &#125;, CHAR_PARSE(Arrays.asList(char.class, Character.class)) &#123; @Override public Function&lt;String, Character&gt; getFunc() &#123; return s -&gt; s.charAt(0); &#125; &#125;, STRING_PARSE(Arrays.asList(String.class)) &#123; @Override public Function&lt;String, String&gt; getFunc() &#123; return s -&gt; s; &#125; &#125;,; private List&lt;Class&gt; clzList; public abstract &lt;T&gt; Function&lt;String, T&gt; getFunc(); private static Map&lt;Class, ParseFuncEnum&gt; map = new ConcurrentHashMap&lt;&gt;(20); static &#123; for (ParseFuncEnum enu : ParseFuncEnum.values()) &#123; for (Class clz : enu.clzList) &#123; map.put(clz, enu); &#125; &#125; &#125; ParseFuncEnum(List&lt;Class&gt; clz) &#123; this.clzList = clz; &#125; public static &lt;T&gt; Function&lt;String, T&gt; getFunc(Class&lt;T&gt; clz) &#123; return map.get(clz).getFunc(); &#125;&#125; 3. 报警规则加载注册信息加载完毕之后，就可以获取报警规则的文件地址了，因此首先是读取配置规则的内容（我们要求是JSON格式），然后反序列化即可 将json串格式配置，反序列化为 BaseAlarmConf 对象 12345678910111213141516171819202122232425262728293031323334353637private static final TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt; typeReference = new TypeReference&lt;Map&lt;String, BasicAlarmConfig&gt;&gt;() &#123;&#125;;/** * 将json串格式的报警规则配置，映射为对应实体类 * &lt;p&gt; * 如果传如的是null, 则采用默认的兜底配置 * 如果传入的是非法的配置，直接返回null， 这样做的目的如下 * &lt;p&gt; * - 启动时，直接获知配置有问题，需要修改 * - 启动中，修改配置，此时新配置有问题，依然使用旧的配置 * * @param configs * @return */private static Map&lt;String, BasicAlarmConfig&gt; parseStrConfig2Map(String configs) &#123; Map&lt;String, BasicAlarmConfig&gt; map = null; if (configs != null) &#123; try &#123; map = JSON.parseObject(configs, typeReference); &#125; catch (Exception e) &#123; logger.error(\"ConfigWrapper.parseStrConfig2Map() init config error! configs: &#123;&#125;, e:&#123;&#125;\", configs, e); return null; &#125; &#125; if (map == null) &#123; map = new HashMap&lt;&gt;(1); &#125; if (!map.containsKey(DEFAULT_ALARM_KEY)) &#123; map.put(DEFAULT_ALARM_KEY, DEFAULT_ALARM_CONFIG); &#125; return map;&#125; 需要额外说明一下，json串并没有直接的映射我们前面定义的 AlarmConfig 对象，因为在原型版本的设计的过程中，考虑到配置与内部的使用对象，可能不是特别匹配，最初的设计中，是希望直接将AlarmConfig中的alarmLevel直接替换成 AlarmExecute 实例对象的，然而在实际实现中没有这么干…，所以看源码时，这里就有点奇怪，后面完全可以干掉这个无用的逻辑 此外，就是需要给一个默认的配置项，当报警类型匹配不到对应的报警规则时，就选择默认的了 下面是一个报警配置的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&#123; \"default\": &#123; \"level\": \"LOG\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"LOG\", \"threshold\": 5, \"users\": [ \"yihui\", \"erhui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"NPE\": &#123; \"level\": \"WEIXIN\", \"autoIncEmergency\": false, \"max\": 30, \"min\": 0, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"3h ui\", \"4hui\" ] &#125; ], \"users\": [ \"yihui\" ] &#125;, \"XXX,YYY\": &#123; \"level\": \"EMAIL\", \"autoIncEmergency\": true, \"max\": 30, \"min\": 3, \"threshold\": [ &#123; \"level\": \"SMS\", \"threshold\": 20, \"users\": [ \"345345345345\", \"123123123123\" ] &#125;, &#123; \"level\": \"WEIXIN\", \"threshold\": 10, \"users\": [ \"yihui\", \"erhui\" ] &#125;, &#123; \"level\": \"EMAIL\", \"threshold\": 5, \"users\": [ \"yihui@xxx.com\", \"erhui@xxx.com\" ] &#125; ], \"users\": [ \"yihui@xxx.com\" ] &#125;&#125; III. ConfLoader选择并初始化前面说明，为了确保报警规则的多样性存储与加载，我们支持用户自定义加载类，所以就会有这么个ConfLoaderFactory, 来创建系统中使用的ConfLoader 12345678910111213141516171819202122232425262728293031323334353637383940public class ConfLoaderFactory &#123; private static IConfLoader currentAlarmConfLoader; public static IConfLoader loader() &#123; if (currentAlarmConfLoader == null) &#123; synchronized (ConfLoaderFactory.class) &#123; if (currentAlarmConfLoader == null) &#123; initConfLoader(); &#125; &#125; &#125; return currentAlarmConfLoader; &#125; private static void initConfLoader() &#123; Iterator&lt;IConfLoader&gt; iterator = ServiceLoader.load(IConfLoader.class).iterator(); List&lt;IConfLoader&gt; list = new ArrayList&lt;&gt;(); // 根据优先级进行排序，选择第一个加载成功的Loader while (iterator.hasNext()) &#123; list.add(iterator.next()); &#125; list.sort(Comparator.comparingInt(IConfLoader::order)); for (IConfLoader iConfLoader : list) &#123; if (iConfLoader.load()) &#123; currentAlarmConfLoader = iConfLoader; break; &#125; &#125; if (currentAlarmConfLoader == null) &#123; throw new NoAlarmLoaderSpecifyException(\"no special alarmConfLoader selected!\"); &#125; &#125;&#125; 实现逻辑依旧采取了SPI机制，不够我们定义了一个优先级，默认从最高优先级的开始加载，加载成功之后，就选择这个东西了；否则继续加载下一个，当所有的ConfLoader加载完毕，都没有一个成功的，就抛出一个异常 IV. 小结鉴于篇幅问题，关于报警规则与报警执行器之间的关系，对应的解释器放在下一篇进行说明，简要小结一下本文内容 报警规则： 采用阀值区间方式，将报警频率与报警执行器关联起来 规则加载： 支持SPI方式注入用户加载器，默认提供基于配置文件的加载器，且优先级最低 基本上本文说的就是下面这张图的内容了 V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"2. 报警系统QuickAlarm之报警执行器的设计与实现","slug":"报警系统QuickAlarm之报警执行器的设计与实现","date":"2018-02-09T11:38:59.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm之报警执行器的设计与实现/","excerpt":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现","text":"根据前面一篇总纲的博文，将整体结构划分为了四大块，本文则主要目标集中在第一块，报警执行器（AlarmExecute）的设计与加载上了 主要的关注点无外乎 定义-》加载-》实现逻辑三块了： AlarmExecute 的接口定义 如何加载用户自定义的AlarmExecute AlarmExecute的内部实现 I. AlarmExecute接口定义在定义接口之前，先来根据几个问题来加深下这个概念的理解： 1. 基础知识 说一下这个报警执行器到底是干嘛的？ 执行具体的报警逻辑（感觉说了依据废话） 因此不同的报警方式，可以选择不同的实现，这个强业务关联的逻辑可以交由适用方自己来把控 多个alarmExecute之间如何区分？ 给一个类似身份证的标识，将标识与alarmExecute绑定，则可以报警规则中，用这个标识来表示对应的报警执行器 标识要求全局唯一，否则就没法找到对应的执行器 2. 接口定义根据上面的基础知识，那么很容易给出接口的定义了 123456789101112131415161718192021public interface IExecute &#123; /** * 报警的具体实现 * * @param users 报警用户，支持批量 * @param title 报警信息的title * @param msg 报警的主题信息 */ void sendMsg(List&lt;String&gt; users, String title, String msg); /** * 获取报警单元唯一标识 * * @return name 要求全局唯一 */ default String getName() &#123; return ExecuteNameGenerator.genExecuteName(this.getClass()); &#125;&#125; 第一个方法sendMsg也就是需要使用者来实现的具体执行报警代码的核心模块了，比较清晰，其中用户是列表，因此，支持同时报警给多个用户（但是报警内容都是相同的） 第二个方法getName表示获取标识，默认给了一个实现，规则如下 获取类的 SimpleName 干掉类名后面的 Execute （如果不是以这个结尾的就不需要了） 剩下的全部转大写 实例： SmsExecute -&gt; SMS; LogExecute -&gt; LOG; 3. 额外说明上面接口定义中的sendMsg中，支持给多个用户发送报警信息，如果要求每个报警信息都不同，比如最常见的是: 发送一段文本，其中通知人地方根据报警人来替换，其他的不变 当然这样的场景完全可以自己在实现中来做 传入的content作为一个话术模板 然后利用 String#format() 来实现参数代替 当然更激进一点就是，穿进来的title或者content作为一个key，然后我可以通过这个key，到其他的地方（如db，缓存等）获取报警内容，甚至我连传进来的报警人都不care，直接从其他地方来获取 简单来说，这个实现委托给用户自己实现，你完全可以随意的控制，做任何你想做的事情 II. AlarmExecute的加载1. 问题分析加载AlarmExecut，貌似没有什么特别复杂的东西，一般的思路是创建一个简单工厂类，然后实例化对应的Executor返回，（再多一点确保只有一个实例对象，加以缓存） 这样有什么问题？ 很简单的实现，但是我们需要加载用户自定义的执行器，要怎么支持呢？ 几种可行的解决手段 1. 开放一个注册接口这个可算是最容易想到的了，直接让用户把自己的Executor实例，主动的扔进来 2. 抽象工厂将前面说的简单工厂，改成抽象工厂类，让后具体的加载委托给用户自己来做 3. 借助Spring容器来加载如果所有的AlarmExecute都委托给Spring容器来管理，那么就很简单了，直接通过ApplicationContext#getBean来获取所有的执行器即可 4. SPI加载方式通过JDK的spi机制来实现（详细后面来说） 针对上面的几个手段，首先排除掉前面两个，因为不满足我们的设计目标一： 简单 （只有报警这个接口进行交互，不需要额外的接口调用） 然后也排除掉spring容器，因为我们希望这个东西，可以较独立的被引用到java工程中，后面可以看情况实现一个spring版 从使用来讲，由spring容器来托管的方式，对使用者而言，是最简单，成本最低的，因为不需要额外添加SPI配置 2. 实现我们采用SPI方式来实现加载，对于SPI是什么东西，这里不详细展看，有兴趣的童鞋可以看我之前的一个系类博文：自定义SPI框架设计 实现方式，可说是非常简单了 1234567891011121314151617181920212223242526272829303132333435363738394041public class SimpleExecuteFactory &#123; private static Map&lt;String, IExecute&gt; cacheMap; private static void loadAlarmExecute() &#123; Map&lt;String, IExecute&gt; map = new HashMap&lt;&gt;(); Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); IExecute tmp; while (iExecutes.hasNext()) &#123; tmp = iExecutes.next(); if (!map.containsKey(tmp.getName())) &#123; map.put(tmp.getName(), tmp); &#125; else &#123; throw new DuplicatedAlarmExecuteDefinedException( \"duplicated alarm execute defined!\" + \"\\n\" + \"&gt;&gt;name:\" + tmp.getName() + \"&gt;&gt;&gt;clz:\" + tmp.getClass() + \"&gt;&gt;&gt;clz:\" + map.get(tmp.getName()) ); &#125; &#125; cacheMap = map; &#125; public static IExecute getExecute(String execute) &#123; if (cacheMap == null) &#123; synchronized (SimpleExecuteFactory.class) &#123; if (cacheMap == null) &#123; loadAlarmExecute(); &#125; &#125; &#125; // 如果不存在，则降级为 LogExecute IExecute e = cacheMap.get(execute); return e == null ? cacheMap.get(LogExecute.NAME) : e; &#125;&#125; 上面对外就暴露一个方法，内部比较简单，如果传入标识对应的报警器没有，则返回一个默认的，确保不会因此挂掉 通过SPI加载所有的执行器的逻辑就一行 1Iterator&lt;IExecute&gt; iExecutes = ServiceLoader.load(IExecute.class).iterator(); 然后需要关注的是循环内部，做了name的唯一性判断，不满足就直接抛出异常了 III. AlarmExecute内部实现内部提供了两个基本的报警实现，比较简单 日志报警执行器 123456789101112131415/** * 有些报警,不需要立即上报,但是希望计数, 当大量出现时, 用于升级 * &lt;p/&gt; * Created by yihui on 2017/4/28. */public class LogExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(LogExecute.class); private static final Logger logger = LoggerFactory.getLogger(\"alarm\"); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; logger.info(\"Do send msg by &#123;&#125; to user:&#123;&#125;, title: &#123;&#125;, msg: &#123;&#125;\", getName(), users, title, msg); &#125;&#125; 空报警执行器 12345678910111213/** * 空报警执行器, 什么都不干 * &lt;p&gt; * Created by yihui on 2017/5/12. */public class NoneExecute implements IExecute &#123; public static final String NAME = ExecuteNameGenerator.genExecuteName(NoneExecute.class); @Override public void sendMsg(List&lt;String&gt; users, String title, String msg) &#123; &#125;&#125; IV. 小结AlarmExecute 的定义，加载以及实现规则目前都已经完成 定义：两个方法，一个执行报警方法，一个返回唯一标识方法 加载：通过SPI方式加载所有定义的alarmExecute 实现：由用户自定义实现IExecute接口，内部逻辑无任务特殊要求，只是需要确保每个executor的name唯一 整个系统的第一步已经迈出，但是有个问题就是什么时候，才会来调用 com.hust.hui.alarm.core.execut.SimpleExecuteFactory#getExecute 从而触发执行器的加载呢？ V. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"1. 报警系统QuickAlarm设计总纲","slug":"报警系统QuickAlarm总纲","date":"2018-02-09T11:37:29.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/02/09/报警系统QuickAlarm总纲/","link":"","permalink":"https://zbang.online/hexblog/2018/02/09/报警系统QuickAlarm总纲/","excerpt":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了","text":"背景日常的系统中，报警是不可缺少的一环，目前报警方式很多，最常见的有直接打日志，微信报警，短信报警，邮件报警等；而涉及到报警，一般不可避免的需要提前设置一些基本信息，如报警方式，报警频率，报警用户，开关等； 另外一个常见的问题是一般采用的是单一的报警方式，比如不管什么类型的报警全部都用短信方式触达，然后就会发现手机时常处于被淹没的状态了，久而久之对报警短信就不会敏感了 目标因此我们准备设计一个通用的报警框架 可以自由选择报警方式， 支持用户自定义报警方式拓展 支持动态的报警配置， 支持用户自定义报警规则拓展 支持报警方式自动切换规则设定 支持报警方式自定义自动切换规则拓展 设计整体来说，报警主要可以划分为三个步骤，如下： 提交报警：对外部使用者提供的接口 选择报警：根据报警相关信息，选择具体的报警执行单元 执行报警：实现具体的报警逻辑 从任务划分上来看，比较清晰简单，但是每一块的内容又必须可以拓展， 选择报警： 报警规则的制定 报警规则加载器 ConfLoader 报警规则变更的触发器 ConfChangeTrigger 报警规则解析器 ConfParse ： 解析文本格式报警规则为业务对象 AlarmSelector ：根据报警规则和报警类型，选择具体报警执行器 AlarmExecute 执行报警： 线程池执行（以防止影响主业务流程） AlarmExecute的动态拓展（支持用户自定义的报警器实现） 实际的报警逻辑 根据上面的拆解，在应用启动的时候，就有一些事情必须去做了 ConfLoader的选择 报警规则加载 AlarmExecute的加载（包括默认的+自定义实现的） 下图显示在应用启动时，报警规则解析的相关步骤 至于报警执行器的加载就比较简单了，如下图 因此，整个的工作流程如下图 任务拆解通过前面的任务设计之后，对需要做的东西有了一个大概的脉络了，因此在正式操刀实现之前，下对整个架构进行任务拆解，看下可以具体的执行步骤可以怎么来 最直接的就是设计报警执行器AlarmExecute 定义基本接口 制定自定义扩展规则 接下来就是设计报警规则 如何加载报警规则？ 报警规则具体的定义细则 报警规则的解析：即根据报警类型来获取报警执行器 报警规则动态更新支持 报警线程池 维护报警队列 报警的计数与频率控制 封装对外使用接口 所以，通过上面的分析可以看出，这个系统的结构还是蛮简单的，整个只需要四个部分就可以搞定，其中最主要的就是前面两个了，后面将分别说明 小结做一个东西，当然是希望可以带来一些用处，或者能学习到什么东西，才不枉花费精力来折腾一下，那么我们这个报警系统，究竟有什么用，或者可以从中学习到什么东西呢？ 用途： 支持灵活可配的报警规则，以及具体报警业务的自定义拓展 目标就是统一报警的使用姿势，也就是不管什么报警，都一个姿势，但是内部可以玩出各种花样，对使用者而言就方便简洁了 学习： 抛开特有的知识点，可以抽象一些公共可用的地方，大概就下面这两点了 我们可以如何支持功能的动态可拓展 线程池的使用 IV. 其他相关博文 报警系统QuickAlarm总纲 报警系统QuickAlarm之报警执行器的设计与实现 报警系统QuickAlarm之报警规则的设定与加载 报警系统QuickAlarm之报警规则解析 报警系统QuickAlarm之频率统计及接口封装 报警系统QuickAlarm使用手册 报警系统QuickAlarm之默认报警规则扩展 项目 项目地址： Quick-Alarm 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"},{"name":"QuickAlarm","slug":"QuickAlarm","permalink":"https://zbang.online/hexblog/tags/QuickAlarm/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickAlarm","slug":"技术/Quick系列项目/QuickAlarm","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickAlarm/"}]},{"title":"Java可以如何实现文件变动的监听","slug":"Java可以如何实现文件变动的监听","date":"2018-02-08T04:01:58.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/02/08/Java可以如何实现文件变动的监听/","link":"","permalink":"https://zbang.online/hexblog/2018/02/08/Java可以如何实现文件变动的监听/","excerpt":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？","text":"Java可以如何实现文件变动的监听应用中使用logback作为日志输出组件的话，大部分会去配置 logback.xml 这个文件，而且生产环境下，直接去修改logback.xml文件中的日志级别，不用重启应用就可以生效 那么，这个功能是怎么实现的呢？ I. 问题描述及分析针对上面的这个问题，首先抛出一个实际的case，在我的个人网站 Z+中，所有的小工具都是通过配置文件来动态新增和隐藏的，因为只有一台服务器，所以配置文件就简化的直接放在了服务器的某个目录下 现在的问题时，我需要在这个文件的内容发生变动时，应用可以感知这种变动，并重新加载文件内容，更新应用内部缓存 一个最容易想到的方法，就是轮询，判断文件是否发生修改，如果修改了，则重新加载，并刷新内存，所以主要需要关心的问题如下： 如何轮询？ 如何判断文件是否修改？ 配置异常，会不会导致服务不可用？（即容错，这个与本次主题关联不大，但又比较重要…） II. 设计与实现问题抽象出来之后，对应的解决方案就比较清晰了 如何轮询 ？ –》 定时器 Timer, ScheduledExecutorService 都可以实现 如何判断文件修改？ –》根据 java.io.File#lastModified 获取文件的上次修改时间，比对即可 那么一个很简单的实现就比较容易了: 12345678910111213141516171819202122232425262728293031public class FileUpTest &#123; private long lastTime; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); // 首先文件的最近一次修改时间戳 lastTime = file.lastModified(); // 定时任务，每秒来判断一下文件是否发生变动，即判断lastModified是否改变 ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); &#125; &#125; &#125;,0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 上面这个属于一个非常简单，非常基础的实现了，基本上也可以满足我们的需求，那么这个实现有什么问题呢？ 定时任务的执行中，如果出现了异常会怎样？ 对上面的代码稍作修改 12345678910111213141516171819202122232425262728293031323334public class FileUpTest &#123; private long lastTime; private void ttt() &#123; throw new NullPointerException(); &#125; @Test public void testFileUpdate() &#123; File file = new File(\"/tmp/alarmConfig\"); lastTime = file.lastModified(); ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1); scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; if (file.lastModified() &gt; lastTime) &#123; System.out.println(\"file update! time : \" + file.lastModified()); lastTime = file.lastModified(); ttt(); &#125; &#125; &#125;, 0, 1, TimeUnit.SECONDS); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实际测试，发现只有首次修改的时候，触发了上面的代码，但是再次修改则没有效果了，即当抛出异常之后，定时任务将不再继续执行了，这个问题的主要原因是因为 ScheduledExecutorService 的原因了 直接查看ScheduledExecutorService的源码注释说明 If any execution of the task encounters an exception, subsequent executions are suppressed.Otherwise, the task will only terminate via cancellation or termination of the executor.即如果定时任务执行过程中遇到发生异常，则后面的任务将不再执行。 所以，使用这种姿势的时候，得确保自己的任务不会抛出异常，否则后面就没法玩了 对应的解决方法也比较简单，整个catch一下就好 III. 进阶版前面是一个基础的实现版本了，当然在java圈，基本上很多常见的需求，都是可以找到对应的开源工具来使用的，当然这个也不例外，而且应该还是大家比较属性的apache系列 首先maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt;&lt;/dependency&gt; 主要是借助这个工具中的 FileAlterationObserver, FileAlterationListener, FileAlterationMonitor 三个类来实现相关的需求场景了，当然使用也算是很简单了，以至于都不太清楚可以再怎么去说明了，直接看下面从我的一个开源项目quick-alarm中拷贝出来的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PropertiesConfListenerHelper &#123; public static boolean registerConfChangeListener(File file, Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; try &#123; // 轮询间隔 5 秒 long interval = TimeUnit.SECONDS.toMillis(5); // 因为监听是以目录为单位进行的，所以这里直接获取文件的根目录 File dir = file.getParentFile(); // 创建一个文件观察器用于过滤 FileAlterationObserver observer = new FileAlterationObserver(dir, FileFilterUtils.and(FileFilterUtils.fileFileFilter(), FileFilterUtils.nameFileFilter(file.getName()))); //设置文件变化监听器 observer.addListener(new MyFileListener(func)); FileAlterationMonitor monitor = new FileAlterationMonitor(interval, observer); monitor.start(); return true; &#125; catch (Exception e) &#123; log.error(\"register properties change listener error! e:&#123;&#125;\", e); return false; &#125; &#125; static final class MyFileListener extends FileAlterationListenerAdaptor &#123; private Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func; public MyFileListener(Function&lt;File, Map&lt;String, AlarmConfig&gt;&gt; func) &#123; this.func = func; &#125; @Override public void onFileChange(File file) &#123; Map&lt;String, AlarmConfig&gt; ans = func.apply(file); // 如果加载失败，打印一条日志 log.warn(\"PropertiesConfig changed! reload ans: &#123;&#125;\", ans); &#125; &#125;&#125; 针对上面的实现，简单说明几点： 这个文件监听，是以目录为根源，然后可以设置过滤器，来实现对应文件变动的监听 如上面registerConfChangeListener方法，传入的file是具体的配置文件，因此构建参数的时候，捞出了目录，捞出了文件名作为过滤 第二参数是jdk8语法，其中为具体的读取配置文件内容，并映射为对应的实体对象 一个问题，如果 func方法执行时，也抛出了异常，会怎样？ 实际测试表现结果和上面一样，抛出异常之后，依然跪，所以依然得注意，不要跑异常 那么简单来看一下上面的实现逻辑，直接扣出核心模块 1234567891011121314151617181920212223public void run() &#123; while(true) &#123; if(this.running) &#123; Iterator var1 = this.observers.iterator(); while(var1.hasNext()) &#123; FileAlterationObserver observer = (FileAlterationObserver)var1.next(); observer.checkAndNotify(); &#125; if(this.running) &#123; try &#123; Thread.sleep(this.interval); &#125; catch (InterruptedException var3) &#123; ; &#125; continue; &#125; &#125; return; &#125;&#125; 从上面基本上一目了然，整个的实现逻辑了，和我们的第一种定时任务的方法不太一样，这儿直接使用线程，死循环，内部采用sleep的方式来来暂停，因此出现异常时，相当于直接抛出去了，这个线程就跪了 JDK版本jdk1.7，提供了一个WatchService，也可以用来实现文件变动的监听，之前也没有接触过，看到说明，然后搜了一下使用相关，发现也挺简单的，同样给出一个简单的示例demo 1234567891011121314151617181920212223242526272829303132333435@Testpublic void testFileUpWather() throws IOException &#123; // 说明，这里的监听也必须是目录 Path path = Paths.get(\"/tmp\"); WatchService watcher = FileSystems.getDefault().newWatchService(); path.register(watcher, ENTRY_MODIFY); new Thread(() -&gt; &#123; try &#123; while (true) &#123; WatchKey key = watcher.take(); for (WatchEvent&lt;?&gt; event : key.pollEvents()) &#123; if (event.kind() == OVERFLOW) &#123; //事件可能lost or discarded continue; &#125; Path fileName = (Path) event.context(); System.out.println(\"文件更新: \" + fileName); &#125; if (!key.reset()) &#123; // 重设WatchKey break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); try &#123; Thread.sleep(1000 * 60 * 10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; IV. 小结使用Java来实现配置文件变动的监听，主要涉及到的就是两个点 如何轮询： 定时器（Timer, ScheduledExecutorService）, 线程死循环+sleep 文件修改： File#lastModified 整体来说，这个实现还是比较简单的，无论是自定义实现，还是依赖 commos-io来做，都没太大的技术成本，但是需要注意的一点是： 千万不要在定时任务 or 文件变动的回调方法中抛出异常！！！ 为了避免上面这个情况，一个可以做的实现是借助EventBus的异步消息通知来实现，当文件变动之后，发送一个消息即可，然后在具体的重新加载文件内容的方法上，添加一个 @Subscribe注解即可，这样既实现了解耦，也避免了异常导致的服务异常 （如果对这个实现有兴趣的可以评论说明） V. 其他参考项目 项目： quick-alarm 测试类： FileUpTest.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"File","slug":"File","permalink":"https://zbang.online/hexblog/tags/File/"},{"name":"ScheduledExecutorService","slug":"ScheduledExecutorService","permalink":"https://zbang.online/hexblog/tags/ScheduledExecutorService/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Java中变量的初始化顺序","slug":"Java中变量的初始化顺序","date":"2018-02-07T04:28:12.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/02/07/Java中变量的初始化顺序/","link":"","permalink":"https://zbang.online/hexblog/2018/02/07/Java中变量的初始化顺序/","excerpt":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因","text":"Java中变量的初始化顺序 在写一个通用的报警模块时，遇到一个有意思的问题，在调用静态方法时，发现静态方法内部对静态变量引用时，居然抛出了npe，仿佛是因为这个静态变量的初始化在静态方法被调用时，还没有触发，从而导致这个问题，因此今天专门来学习下静态成员的初始化顺序，以及上面这个问题导致的原因 I. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） II. 静态变量初始化顺序类初始化时，会优先初始化静态成员，那么一个类中有多个静态成员时，如何处理的？ 下面是一个使用静态成员，静态代码块，静态方法的测试类，那么下面的输出应该是怎样的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 输出如下 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 从实际的输出结果来看： 初始化的顺序比较清晰了，压根就是根据初始化代码的先后顺序来的， 且在调用静态方法时，静态方法内部的静态成员已经被初始化 那么问题来了，如果在某个静态成员初始化的时候抛出了异常，会怎样？ 那么稍稍改一下上面的代码，加一个主动抛异常的case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class StaticTest &#123; static class A &#123; public A(int i) &#123; System.out.println(\"a init! \" + i); &#125; &#125; static class B &#123; public B(int i) &#123; System.out.println(\"b init! \" + i); &#125; &#125; private static A a1 = new A(1); private static B b1; private static int num; private static B b2 = new B(2); private static A a2 = genA(2); static &#123; b1 = new B(1); &#125; private static A genA(int i) &#123; System.out.println(\"gen A: \" + i); return new A(i); &#125; private static B genB(int i) &#123; System.out.println(\"gen B: \" + i); return new B(i); &#125; private static A aError = genError(); private static A genError() &#123; System.out.println(\"gen error!\"); throw new RuntimeException();// return new A(10); &#125; public static void doSome() &#123; System.out.println(\"static function doSome called! a3!=null : \" + (a3 != null) + \" | num &gt; 0 : \" + num); &#125; private static A a3; private static B b3; static &#123; System.out.println(\"num : \" + num); num = 10; a3 = genA(3); b3 = genB(3); &#125; public static void main(String[] args) &#123; doSome(); &#125;&#125; 此时输出： 12345678a init! 1b init! 2gen A: 2a init! 2b init! 1gen error!Exception in thread \"main\" java.lang.ExceptionInInitializerErrorCaused by: java.lang.RuntimeException 也就是说，初始化异常之后的代码将不会在继续执行 那么第二个问题来了，前面说到哪个问题是什么情况 最开始说到，在调用类的静态方法时，发现本该被初始化的静态成员，依然是null，从上面的分析来说，唯一的可能就是在成员变量初始化的过程中，出现了异常 那么，就有另一个问题了，初始化就报错了，这个类的静态方法还能被调用执行么（加入这个静态方法不依赖内部的静态成员）？ 将前面的 genA()方法的private去掉，改成默认的访问范围，然后下面给出一个演示： 通过这个演示，也挺有意思的，第一次访问，会抛出一个初始化异常；但是再调用一次，结果发现居然正常执行了；但是调用public方法时，每次都是抛异常 导致这个问题的原因，还有待考究，但是前面这个问题的答案，估摸着和下面差不多了（但是不敢确定，有待大神指点） 理论上类初始化失败，应该就不允许被调用了 但是某些情况下，可以绕过这个限制 III. 成员变量的初始化测试case也比较简单，把前面的代码中的static去掉即可， 输出 1234567891011a init! 1b init! 2gen A: 2a init! 2b init! 1num : 0gen A: 3a init! 3gen B: 3b init! 3static function doSome called! a3!=null : true | num &gt; 0 : 10 依然是根据初始化代码的先后顺序进行的 当然如果出现异常的情况，和前面的结果类似，不再赘述 IV. 小结1. 初始化顺序类的初始化顺序 静态变量, 静态代码快 -》 实例变量（属性，实例代码块，构造方法） 继承关系初始化顺序 父类静态成员，静态代码块 -》 子类静态成员，静态代码块 -》 父类实例变量（属性，实例代码块，构造方法）-》子类实例变量（属性，实例代码块，构造方法） 相同等级的初始化的先后顺序，是直接依赖代码中初始化的先后顺序 2. 初始化异常时理论上，类初始化中抛出了异常，那么这个类将无法被classLoader正确的加载，因此也无法有效的使用这个类 但是不排除某些情况下，依然强行的使用了这个类（如上面gif图中的演示），这个原理还不太清晰，也有可能是idea的debug功能有什么黑科技？ 注意 因此，请格外注意，在初始化代码中，请确保不会有抛出异常，如果无法把控，不妨新建一个init()方法来实现初始化各种状态，然后在代码中主动调用好了 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"https://zbang.online/hexblog/tags/JDK/"},{"name":"Initialize","slug":"Initialize","permalink":"https://zbang.online/hexblog/tags/Initialize/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"SpringMVC统一异常处理","slug":"SpringMVC统一异常处理","date":"2018-02-04T11:21:15.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/02/04/SpringMVC统一异常处理/","link":"","permalink":"https://zbang.online/hexblog/2018/02/04/SpringMVC统一异常处理/","excerpt":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题","text":"统一异常拦截处理方式 项目中不可避免会出现一些异常情况，而一个web项目，若不拦截异常，糟糕的情况下可能直接将堆栈抛给前端，从而导致各种鬼畜的问题 I. 借助@ControllerAdvice拦截异常给一个简单的demo，便可以很容易的了解这种手段如何处理了 1234567891011121314151617181920@ControllerAdvice@Slf4j@ResponseBodypublic class ActionExceptionHandler &#123; @ExceptionHandler(value = Exception.class) public String defaultHandler(HttpServletRequest request, Exception e) &#123; log.error(\"unexpected exception! request: &#123;&#125;, params: &#123;&#125; refer: &#123;&#125;, e: &#123;&#125;\", request.getRequestURI(), request.getParameterMap(), request.getHeader(\"referer\"), e); if (StringUtils.isBlank(e.getMessage())) &#123; return ResponseWrapper.errorReturn(new Status(500, \"内部异常\")); &#125; else &#123; return ResponseWrapper.errorReturn(new Status(500, e.getMessage())); &#125; &#125;&#125; 这里主要借助两个注解来实现，ControllerAdvice 和 ExceptionHandler II. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Exception","slug":"Exception","permalink":"https://zbang.online/hexblog/tags/Exception/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":" JavaWeb三大组件之Filter学习详解","slug":"JavaWeb三大组件之Filter学习详解","date":"2018-01-26T10:02:01.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/01/26/JavaWeb三大组件之Filter学习详解/","link":"","permalink":"https://zbang.online/hexblog/2018/01/26/JavaWeb三大组件之Filter学习详解/","excerpt":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项","text":"JavaWeb三大组件之Filter学习详解 Filter基本上可以说存在所有的JavaWeb项目中，比如最基本的一个请求参数的编码CharacterEncodingFilter，大家一般都会配置下，那么filter是干嘛的呢？ 本篇将主要集中在fitler的以下几个知识点: 干嘛的 怎么用 多个Filter执行的先后顺序 注意事项 I. 基本知识Filter称之为过滤器，是用来做一些拦截的任务， 在Servlet接受请求之前，做一些事情，如果不满足限定，可以拒绝进入Servlet 从上面的图，可以看出一个Filter的工作流程: 一个http请求过来之后 首先进入filter，执行相关业务逻辑 若判定通行，则进入Servlet逻辑，Servlet执行完毕之后，又返回Filter，最后在返回给请求方 判定失败，直接返回，不需要将请求发给Servlet 通过上面的流程，可以推算使用场景： 在filter层，来获取用户的身份 可以考虑在filter层做一些常规的校验（如参数校验，referer校验等） 可以在filter层做稳定性相关的工作（如全链路打点，可以在filter层分配一个traceId；也可以在这一层做限流等） 1. 基本使用姿势要使用一个Filter，一半需要两步，实现Filter接口的自定义类，web.xml中对filter的定义 1234567891011public interface Filter &#123; public void init(FilterConfig filterConfig) throws ServletException; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException; public void destroy();&#125; 主要就三个方法，从命名来看， 也比较清晰，在创建Filter对象的时候，调用 init 方法 销毁Filter对象的时候，调用 destroy 方法 当请求过来之后，调用 doFilter，也就是主要的业务逻辑所在了 详细case后面再说 接下来就是xml的配置了，和Servlet类似，每自定义一个，都需要在xml中加上一个配置（挺繁琐的操作的） 123456789101112131415161718&lt;!-- 解决乱码的问题 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置也比较简单了，一个 一个 前者定义具体的Filter，后者表示这个Filter拦截的URL （看起来和Servlet的配置规则没什么两样） II. 实例我们的实例，就拿大名鼎鼎的CharacterEncodingFilter来说明，顺带膜拜下Spring的大神的优秀源码 123456789101112131415161718192021222324252627282930313233343536373839404142public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; public CharacterEncodingFilter() &#123; &#125; public CharacterEncodingFilter(String encoding) &#123; this(encoding, false); &#125; public CharacterEncodingFilter(String encoding, boolean forceEncoding) &#123; Assert.hasLength(encoding, \"Encoding must not be empty\"); this.encoding = encoding; this.forceEncoding = forceEncoding; &#125; public void setEncoding(String encoding) &#123; this.encoding = encoding; &#125; public void setForceEncoding(boolean forceEncoding) &#123; this.forceEncoding = forceEncoding; &#125; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); System.out.printl(\"servelt 执行完成，又返回filter\"); &#125;&#125; 上面的实现比较简单，主要将视线集中在 doFilterInternal 方法内部，如果要设置编码参数，则直接修改 HttpServletRequest, HttpServletResponse 两个参数，操作完成之后，执行下面这一行 1filterChain.doFilter(request, response); 注意 上面这一行执行，表示Filter层已经通过了，请求可以转发给下一个Filter或者直接传给Servlet 而下一个Filter, Servlet执行完成之后，还会继续往下走，就是上面的那一行输出，也会被调用（那一行是我加的，源码中没有） 所以，如果你不希望继续往下走，那么就简单了，不执行上面的那一行即可 疑问问题一：看了上面的源码，一个很明显的问题就是，参数怎么设置的？ 仔细看上面的源码，发现自定义Filter是继承 org.springframework.web.filter.OncePerRequestFilter 而不是直接实现的 Filter 接口，而且方法内也没有显示的实现 init()方法，所有很容易猜到是父类中实现了参数的初始化过程 具体的实现逻辑是在 org.springframework.web.filter.GenericFilterBean#init 中，同样是Spring实现的，主要代码捞出来 12345678910111213141516171819202122232425262728293031public final void init(FilterConfig filterConfig) throws ServletException &#123; Assert.notNull(filterConfig, \"FilterConfig must not be null\"); if (logger.isDebugEnabled()) &#123; logger.debug(\"Initializing filter '\" + filterConfig.getFilterName() + \"'\"); &#125; this.filterConfig = filterConfig; // Set bean properties from init parameters. try &#123; PropertyValues pvs = new FilterConfigPropertyValues(filterConfig, this.requiredProperties); BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(filterConfig.getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, this.environment)); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; String msg = \"Failed to set bean properties on filter '\" + filterConfig.getFilterName() + \"': \" + ex.getMessage(); logger.error(msg, ex); throw new NestedServletException(msg, ex); &#125; // Let subclasses do whatever initialization they like. initFilterBean(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Filter '\" + filterConfig.getFilterName() + \"' configured successfully\"); &#125;&#125; 看上面一大串的代码，到底干了嘛？ 简单来讲，就是获取xml中配置的参数，然后填充到Filter对象中（对Srping而言，CharacterEncodingFilter就是一个bean），这个具体的逻辑和本篇关系不大，就直接跳过了 问题二：在Filter层中可以获取参数么 从doFilter的方法签名中看，既然有Request参数，那么应该是可以获取到请求参数的，那么实际验证一下 先实现一个最最最简单的Filter 123456789101112131415161718public class TestFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in filter\"); System.out.println(\"args: \" + JSON.toJSONString(request.getParameterMap())); chain.doFilter(request, response); System.out.println(\"out filter\"); &#125; @Override public void destroy() &#123; &#125;&#125; 开始测试 1curl -d 'name=Hello&amp;password=world' http://127.0.0.1:8088/123 输出如下 123in filterargs: &#123;\"name\":[\"Hello\"],\"password\":[\"world\"]&#125;out filter 注意 在Filter中获取参数时，最好不要直接使用获取请求流的方式，如果获取请求流，那么Servlet就获取不到请求参数了 问题三：多个filter的顺序怎么定 前面学习Servlet的时候，也有这个问题，一个URL被多个Servlet命中了，那么先后顺序是怎样的呢？ 精确匹配 &gt; 最长匹配 &gt; 其他模糊匹配 &gt; 没有匹配的则是404 那么Filter呢，他们的区别还是比较明显的，很多Filter都是拦截所有的请求，即很多Filter的命中规则都是一样的，那么怎么办？ 先执行带有url-pattern标签的filter，再执行带有servlet-name标签的filter 如果同为url-pattern或servlet-name，则会按照在web.xml中的声明顺序执行 测试case如下，我们定义三个Filter： TestFilter: 匹配所有路径 ATestFilter: 匹配所有路径 ServletFilter: 匹配 mvc-servlet 123456789101112131415161718192021// ATestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ATestFilter\"); chain.doFilter(request, response);&#125;// TestFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in TestFilter\"); chain.doFilter(request, response);&#125;// ServletFilter@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"in ServletFilter\"); chain.doFilter(request, response);&#125; 对应的xml配置如下 123456789101112131415161718192021222324252627282930&lt;filter&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ServletFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;servletFilter&lt;/filter-name&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.TestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.test.ATestFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;atestFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 输出结果 123in TestFilterin ATestFilterin ServletFilter III. 小结Filter 通常用于JavaWeb的过滤使用，通过doFilter方法中执行 chain.doFilter(request, response);，进入下一个Filter或者Servlet执行逻辑，当执行完成之后，依然会回到Filter这一层，继续走下去 针对上面的逻辑，Filter的常见应用场景有： 用户信息获取，身份校验 安全校验（referer校验失败，直接拒绝） 稳定性相关（限流，监控埋点，全链路日志埋点） Filter的执行顺序： url-mapping 的优先执行，其次是 servlet-mapping 同一个匹配方式（如都是url-mapping）中，根据在xml中定义的先后顺序来确定 Filter的注意事项： 正常业务，请记得一定执行 chain.doFilter(request, response)， 最后把它放在finnal块中，防止你在Filter中的代码抛异常导致进入不到后续的逻辑 在Filter中不要直接获取请求数据流（请求流被读取完之后，Servlet就get不到了!） IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Filter","slug":"Filter","permalink":"https://zbang.online/hexblog/tags/Filter/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"JavaWeb三大组件之Servlet学习","slug":"JavaWeb三大组件之Servlet学习","date":"2018-01-24T01:55:49.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2018/01/24/JavaWeb三大组件之Servlet学习/","link":"","permalink":"https://zbang.online/hexblog/2018/01/24/JavaWeb三大组件之Servlet学习/","excerpt":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置","text":"JavaWeb三大组件之Servlet学习 平时直接用springmvc较多，都没怎么接触底层的Servlet，导致对一些基本的知识点了解都不够，所以今天专门的抽出时间来学习一下 带着问题出发，看下可以怎么玩 如何自定义一个Servlet 自定义的Serlvet如何工作 servlet的优先顺序怎么判定 servlet匹配是怎样的 (url-mapping…） 如何获取参数（get请求参数，post请求参数，上传文件） 如何返回数据（返回页面，返回文件，返回二进制） 请求头和返回头的设置 I. 基本知识点1. 什么是ServletServlet是JavaWeb的三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要： 接受请求 处理请求 完成响应 2. 怎么玩Servlet一般来讲，创建一个自定义的Servlet有两个步骤，在web.xml中配置serverlt的声明；实现Servlet接口，实现自定义的Servlet逻辑 一个简单的case如下 web.xml中，添加配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实现自定义Servlet 1234567891011public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125;&#125; 上面这个Servlet，实现了拦截 /study 下的所有请求， 然后返回一段文本，上面作为演示，具体的展开下面说明 3. Servlet接口说明上面是直接继承了HttpServlet，可能没法完全的暴露一个Servlet的具体接口有哪些，以及它的生命周期是怎样的，接下来则直接针对源头进行说明 1234567891011121314151617public interface Servlet &#123; // 初始化 public void init(ServletConfig config) throws ServletException; // 获取配置信息 public ServletConfig getServletConfig(); // 处理请求 public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException; // Returns information about the servlet, such as author, version, and copyright public String getServletInfo(); // 销毁 public void destroy();&#125; 五个方法，从命名也可以看出对应的生命周期 首先是创建： init() 方法被创建 创建完毕之后，请求来了，分给 service方法，执行对应的业务逻辑 最后不想玩了，就销毁掉，此时触发 destroy方法 说明 在Servlet被创建后，服务器会马上调用Servlet的void init(ServletConfig)方法。请记住， Servlet出生后马上就会调用init()方法，我们可以把一些对Servlet的初始化工作放到init方法中，今后所有分配到这个Servlet的请求，都是公用这个Servlet的 4. ServletConfig init()方法的参数 ServletConfig对象对应web.xml文件中的元素。例如你想获取当前Servlet在web.xml文件中的配置名，那么可以使用servletConfig.getServletName()方法获取 1234String getServletName()：获取Servlet在web.xml文件中的配置名称，即指定的名称； ServletContext getServletContext()：用来获取ServletContext对象，ServletContext会在后面讲解； String getInitParameter(String name)：用来获取在web.xml中配置的初始化参数，通过参数名来获取参数值； Enumeration getInitParameterNames()：用来获取在web.xml中配置的所有初始化参数名称； 5. ServletRequest 请求对象，可以从其中获取请求数据，请求头等 内部提供的方法挺多，通常我们最关心的有: 获取参数: javax.servlet.ServletRequest#getParameter 获取头 : javax.servlet.http.HttpServletRequest#getHeader 获取cookie: javax.servlet.http.HttpServletRequest#getCookies 获取请求 : javax.servlet.http.HttpServletRequest#getRequestURI … 还有一个比较重要的就是指定字符编码，如我们通常要求提交的参数满足utf8编码，这时就可以如下设置 12// javax.servlet.ServletRequest#setCharacterEncodingrequest.setCharacterEncoding(&quot;utf-8&quot;); 如我们最常用的一个spring的fitler，关键代码如下 123456789101112131415// org.springframework.web.filter.CharacterEncodingFilter#doFilterInternal// @Overrideprotected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response);&#125; 6. ServletResponse 返回对象，返回响应给调用方的结构，设置返回头 返回数据给调用方，主要就是利用这个东西了，内部提供的方法也不少，我们主要关心的其实也并不太多 设置返回头：javax.servlet.http.HttpServletResponse#setHeader 添加cookie: javax.servlet.http.HttpServletResponse#addCookie 重定向 : javax.servlet.http.HttpServletResponse#sendRedirect 异常 : javax.servlet.http.HttpServletResponse#sendError 设置ContentType: javax.servlet.ServletResponse#setContentType 设置返回流: javax.servlet.ServletResponse#getOutputStream, javax.servlet.ServletResponse#getWriter 设置编码: javax.servlet.ServletResponse#setCharacterEncoding II. 进阶1. web.xml中配置 这个配置，主要针对 Servlet 的顺序指定，URL匹配这两个问题，所以有必要研究下这个配置中的说明 通常web.xml的配置，下面两个是必须的 1234567891011121314&lt;!-- servlet的配置 --&gt;&lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;com.xxx.ServletDemo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!-- servlet的映射配置 --&gt;&lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;ServletDemo&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 其中 servlet-mapping 指定映射的路径，满足条件的会匹配对应的Servlet，匹配规则有以下几个定义 必须 / 开头 /servlet 表示精确匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlets 不匹配 http://localhost:8088/servlet/123 不匹配 /servlet/* 表示目录匹配，所有servlet路径开头的都可以匹配 http://localhost:8088/servlet 匹配 http://localhost:8088/servlet/123 匹配 http://localhost:8088/servlet/123/123 匹配 http://localhost:8088/servlets 不匹配 /*.do 表示扩展名匹配，所有以 .do 结尾的匹配 既然这个url匹配支持模糊匹配，那么问题来了，如果两个servlet都匹配了这个path路径，那么到底是哪个处理呢？ 注意到前面有个配置参数：load-on-startup 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet； 当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载 正数的值越小，启动该servlet的优先级越高 注意 这个参数是加载顺序，而不是最终的匹配顺序 那么匹配顺序的优先级是： 精确路径匹配 比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先 进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的servlet了 最长路径匹配 servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源，即匹配defaultServlet 2. 参数获取 参数获取，则主要区分get请求参数，post提交表单，上传的文件了 a. 通过 getQueryString这种获取参数的方式，只能获取url上面的参数，无法获取到post的表单内容 1String str = req.getQueryString(); b. 通过 getParameter12// 返回所有的请求参数javax.servlet.ServletRequest#getParameterMap 这种使用姿势，和我们在SpringMVC中常见的基本一致 c. 通过 getInputStream获取请求流，一般的使用姿势如下 1234InputStream stream = req.getInputStream();byte[] bytes = new byte[stream.available()];stream.read(bytes);String str = new String(bytes); 然后就需要自己对上面的请求参数进行处理了；两厢对比，常规的获取方法，直接使用 getParameter方式更加优雅 注意 通过getInputStream方式获取了请求数据之后，再通过 getParameter获取不到参数的，也好理解，请求的流，被你读取之后，其他的地方就无法获取流中的数据了 d. 获取上传的文件从请求参数中获取上传的文件，网上随意搜索了一下，发现大部分都使用apache的fileupload包， 其实处理的依然是inputstream这个请求流，只是逻辑比较复杂，粗略的翻看了一下源码，发现这一块还挺有意思的，准备单独的深入看一下 3. 数据返回返回数据，前面介绍HttpServletResponse的时候，就给出了两个方法 a. getWriter1public PrintWriter getWriter() throws IOException; b. getOutputStream1public ServletOutputStream getOutputStream() throws IOException; 下面简单说一下上面的区别 PrintWriter ServletOutputStream 字符流返回 字节流返回 需要字符编码 字节流直接返回（返回文件就很占优势了） 说明 上面两种方式互斥，只能使用其中一种case Servlet程序向ServletOutputStream或PrintWriter对象中写入的数据将被Servlet引擎获取，Servlet引擎将这些数据当作响应消息的正文，然后再与响应状态行和各响应头组合后输出到客户端 Serlvet的service方法结束后，Servlet引擎将检查getWriter或getOutputStream方法返回的输出流对象是否已经调用过close方法，如果没有，Servlet引擎将调用close方法关闭该输出流对象 4. 返回头设置常见的请求头和返回头设置，对于servlet而言也是比较常见的，一般常见的几个设置 是否缓存，缓存时间 设置cookie 设置 corss-origin 相关，以支持跨域 设置 content-type… 而实际的使用也比较简单了，如下即可 12# javax.servlet.http.HttpServletResponse#addHeaderresponse.addHeader(\"Content-Type\", \"text/html; charset=UTF-8\"); III. 实例测试创建一个自定义的嗯Servlet，然后拦截所有 /study 下面的请求 1234567891011121314151617public class DocServlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setCharacterEncoding(\"utf-8\"); PrintWriter writer = resp.getWriter(); writer.append(\"这是一个自定义servlet\") .append(\"emoj😄==\").flush(); System.out.println(\"hereher!!!!\"); &#125; protected void doPost(HttpServletRequest req, HttpServletResponse res) throws IOException &#123; Map map = req.getParameterMap(); System.out.println(\"arg: \" + map); res.getWriter().append(\"success\").flush(); &#125;&#125; 对应的xml配置如下 123456789 &lt;servlet&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.yihui.study.DocServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;doc-servlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/study/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 实测演示： IV. 其他参考 servlet详解(第一篇) 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://zbang.online/hexblog/tags/JavaWeb/"},{"name":"Servlet","slug":"Servlet","permalink":"https://zbang.online/hexblog/tags/Servlet/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JavaWeb","slug":"技术/Java/JavaWeb","permalink":"https://zbang.online/hexblog/categories/技术/Java/JavaWeb/"}]},{"title":"Android学习之旅1D:首屏页的开发","slug":"Android学习之旅1D-首屏页的开发","date":"2018-01-22T12:16:18.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/22/Android学习之旅1D-首屏页的开发/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/Android学习之旅1D-首屏页的开发/","excerpt":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程","text":"Android学习之旅：第一天 采用依葫芦画瓢的方式来学习android的开发，准备逐步的开发出《一封》这个app 本片主要记录了SplashActivity的开发过程 I. 前置主要copy两个开源项目 JianshuApp SUESNews 上面两个工程，第二个用到的依赖比较少，实现的基本功能也都很ok，而第一个里面则用了很多有意思的第三方框架，但是目前我看不太懂，所以第一版以SUESNews作为主要的学习目标 所以，第一版的目标是： 实现基本功能 完成主体业务逻辑 II. Splash页面开发一般来将，进入app之前，会进入一个类似首屏页的页面（比如12306的显示广告啥的），那么第一件事情就是做这个了 1. 做什么这个页面，主要显示的东西比较简单了 上边是一个图片，右上角一个倒计时 下边显示的应用信息，版本等 业务逻辑： 显示广告（😄），点击进入相应的详情页 判断是否登录，若未登录，则进入登录页 若已经登录，则进入主APP 2. 开动a. 全屏进入的首页，所以状态栏，标题啥的都不要，主要的逻辑如下 styles.xml 文件中新增 1234&lt;style name=\"AppTheme.FullScreen\"&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowFullscreen\"&gt;true&lt;/item&gt;&lt;/style&gt; 其次，就是在定义的Activity中，使用对应的style AndroidManifest.xml 1234567&lt;activity android:name=\".ui.SplashActivity\" android:theme=\"@style/AppTheme.FullScreen\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; b. xml实现activity_splash.xml 对应的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" tools:context=\"com.yihui.yifeng.ui.SplashActivity\"&gt; &lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignBottom=\"@+id/title_text\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt; &lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; &lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt; &lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:textStyle=\"bold\" tools:text=\"Copyright @2017-2018 一封 | 小灰灰技术支持\" /&gt;&lt;/RelativeLayout&gt; 运行截图如下： 上面这个布局，是直接使用可视化的拖拽的，所以操作起来挺蛋疼的，而且最终的结果也不太好，下面单独的开一节来研究下这个布局的东西了 c. Activity的实现上面是xml的配置，当然还得有对应的实体类了，大部分逻辑是直接从参考的工程中copy过来的，所以相关的动画配置，图片也是直接扣过来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class SplashActivity extends Activity &#123; private ImageView mBackgroundImage; private ImageView infoBgImg; private TextView mTitleText; private TextView mVersionText; private int[] ary = new int[] &#123;R.drawable.pic_background_1, R.drawable.pic_background_2, R.drawable.pic_background_3, R.drawable.pic_background_4&#125;; private int getBgDrawable() &#123; return ary[new Random().nextInt(ary.length)]; &#125; private void initInfoBg() &#123; infoBgImg = findViewById(R.id.image_info_bg); infoBgImg.setImageDrawable(getResources().getDrawable(ary[0])); &#125; private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome); mBackgroundImage.startAnimation(animImage); animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; &#125;); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_splash); // 下半的提示文案信息 initInfoBg(); // 上半的广告动画 initAdBg(); &#125;&#125; todo登录状态判断，如果未登录，则应该跳转到登录页面；否则才是跳转到主页 III. 知识点小结上面只是实现了一个简单的应用开启页面，但也涉及了几个有趣的知识点，下面来深入一下 1. RelativeLayout 布局控件的位置是按照相对位置来计算的，后一个控件在什么位置依赖于前一个控件的基本位置，是布局最常用，也是最灵活的一种布局 常见的属性值 123456789101112131415161718192021222324第一类:属性值为true或falseandroid:layout_centerHrizontal 水平居中android:layout_centerVertical 垂直居中android:layout_centerInparent 相对于父元素完全居中android:layout_alignParentBottom 贴紧父元素的下边缘android:layout_alignParentLeft 贴紧父元素的左边缘android:layout_alignParentRight 贴紧父元素的右边缘android:layout_alignParentTop 贴紧父元素的上边缘 第二类：属性值必须为id的引用名“@id/id-name”android:layout_below 在某元素的下方android:layout_above 在某元素的的上方android:layout_toLeftOf 在某元素的左边android:layout_toRightOf 在某元素的右边android:layout_alignTop 本元素的上边缘和某元素的的上边缘对齐android:layout_alignLeft 本元素的左边缘和某元素的的左边缘对齐android:layout_alignBottom 本元素的下边缘和某元素的的下边缘对齐android:layout_alignRight 本元素的右边缘和某元素的的右边缘对齐第三类：属性值为具体的像素值，如30dip，40pxandroid:layout_marginBottom 离某元素底边缘的距离android:layout_marginLeft 离某元素左边缘的距离android:layout_marginRight 离某元素右边缘的距离android:layout_marginTop 离某元素上边缘的距离 所以可以简单的修改一下上面的布局，相对布局的样式就两个，上面一个图，下面一个图 1234567891011121314151617181920&lt;ImageView android:id=\"@+id/image_background\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行 --&gt; android:layout_alignBottom=\"@+id/image_info_bg\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_marginBottom=\"52dp\" android:scaleType=\"centerCrop\" /&gt;&lt;ImageView android:id=\"@+id/image_info_bg\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!-- 注意这一行，确保背景图可以包含文本信息 --&gt; android:layout_alignTop=\"@+id/title_text\" android:layout_centerHorizontal=\"true\" android:scaleType=\"centerCrop\" /&gt; 那么剩下的两个文本显示就可以直接指定下边距来确定位置了 123456789101112131415161718192021222324&lt;TextView android:id=\"@+id/title_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@+id/version_text\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"17dp\" android:text=\"@string/app_name\" android:textColor=\"@color/text_color\" android:textSize=\"@dimen/text_size_title_bigger\" android:textStyle=\"bold\" /&gt;&lt;TextView android:id=\"@+id/version_text\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentBottom=\"true\" android:layout_centerHorizontal=\"true\" &lt;!-- 这里确定了高度 --&gt; android:layout_marginBottom=\"11dp\" android:textColor=\"@color/secondary_text\" android:textSize=\"@dimen/text_size_subhead\" android:text=\"@string/splash_copyright\" /&gt; 2. 获取组件在Activity中，先要绑定视图，然后再获取view进行相关的操作（如修改值，绑定事件等） 12345678910// Activity 的 oncreate方法中，进行初始化// 绑定视图super.onCreate(savedInstanceState);setContentView(R.layout.activity_splash);// 获取组件findViewById(R.id.image_info_bg);// 获取资源，如图片Drawable drawable = getResources().getDrawable(R.drawable.pic_background_1) 有一个非常有名的工具叫做 butterknife, 可以通过注解的方式来解决 findViewById这种频繁的调用姿势，这个放在后续的进阶版中使用 3. 设置动画开屏使用了一个图片放大的动画，持续3s，动画播放完毕之后跳转主页；所以这里有个有趣的知识点就是如何使用xml来配置动画效果，从实现来看也挺简单的 123456789101112131415161718192021222324// 解析xml配置为 Animation 对象Animation animImage = AnimationUtils.loadAnimation(this, R.anim.image_welcome);// 设置组件的动画属性mBackgroundImage.startAnimation(animImage);// 配置监听事件animImage.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; // 动画结束后的回调 @Override public void onAnimationEnd(Animation animation) &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;); 对应的xml配置如下 image_welcome.xml 1234567891011&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:fromXScale=\"1.0\" android:toXScale=\"1.3\" android:fromYScale=\"1.0\" android:toYScale=\"1.3\" android:duration=\"3000\" android:pivotY=\"50%\" android:pivotX=\"50%\" /&gt;&lt;/set&gt; 那么，我们需要实现开头说的，这个图片如果是个广告，点击时展开详情页；右上角显示一个倒计时的小控件，可以怎么处理？（看最后） 4. 页面跳转从一个Activity跳转到另一个，常见的使用姿势如下 1startActivity(new Intent(SplashActivity.this, MainActivity.class)); IV. 倒计时改进如何使用倒计时来替换前面的动画呢？最容易想到的就是用Timer或者ScheduleService来实现一个计时器，当然这是一个后端java的想法，对于Android呢，特意查了一下，发现有个 CountDownTimer 的类，专门干这个的，所以简单的改造一下 12345678910111213141516171819202122232425262728private void initAdBg() &#123; mBackgroundImage = findViewById(R.id.image_background); mBackgroundImage.setImageDrawable(getResources().getDrawable(getBgDrawable())); mBackgroundImage.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 点击 Toast.makeText(SplashActivity.this, \"点击了\", Toast.LENGTH_SHORT).show(); &#125; &#125;); final TextView countDown = findViewById(R.id.splash_timedown); CountDownTimer timer = new CountDownTimer(10000, 1000) &#123; @Override public void onTick(long l) &#123; countDown.setText(\"倒计时:\" + (l / 1000) + \"s\"); &#125; @Override public void onFinish() &#123; //动画结束时打开首页 startActivity(new Intent(SplashActivity.this, MainActivity.class)); overridePendingTransition(R.anim.activity_slide_in, R.anim.no_anim); finish(); &#125; &#125;; timer.start();&#125; 改造后的输出图, 注意右上角的时间，已经下面分割处，不会有前面的空白了 V. 其他额外话感觉最近不太能专心下来学习一门技术，有点浮躁了，所以决定学习下andorid，锻炼下自己，初步规划，先入门，然后接收一些有趣的第三方框架，最后再试一下kotalin Android学习第一天，总感觉这将是个漫长的过程，也不晓得最终会完成得怎么样，努力坚持吧 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://zbang.online/hexblog/tags/Android/"},{"name":"一封","slug":"一封","permalink":"https://zbang.online/hexblog/tags/一封/"},{"name":"RelativeLayout","slug":"RelativeLayout","permalink":"https://zbang.online/hexblog/tags/RelativeLayout/"},{"name":"CountDownTimer","slug":"CountDownTimer","permalink":"https://zbang.online/hexblog/tags/CountDownTimer/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Android","slug":"技术/Android","permalink":"https://zbang.online/hexblog/categories/技术/Android/"},{"name":"一封","slug":"技术/Android/一封","permalink":"https://zbang.online/hexblog/categories/技术/Android/一封/"}]},{"title":"兼容ImageIO读取jpeg图片变红","slug":"兼容ImageIO读取jpeg图片变红","date":"2018-01-22T06:38:39.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/01/22/兼容ImageIO读取jpeg图片变红/","link":"","permalink":"https://zbang.online/hexblog/2018/01/22/兼容ImageIO读取jpeg图片变红/","excerpt":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case","text":"兼容ImageIO读取jpeg图片变红 使用ImageIO.read()方法，加载图片为BufferedImage对象时，对于某些图片，会出现变红的case 问题重现有问题的图片： 测试验证代码 123456789101112/** * 图片读取之后，颜色变红的测试 */@Testpublic void testLoadRedImg() throws IOException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); BufferedImage bf = ImageIO.read(u); ImageIO.write System.out.println(\"--over--\");&#125; debug截图如下： 问题兼容不实用ImageIO来加载图片，改用Toolkit来实现图片读取，然后再将读取到的图片绘制到BufferedImage对象上 1234567891011121314151617181920212223242526272829303132333435363738394041@Testpublic void testLoadRedImg2() throws MalformedURLException &#123; String url = \"http://s17.mogucdn.com/mlcdn/c45406/170418_68lkjddg3bll08h9c9bk0d8ihkffi_800x1200.jpg\"; URL u = new URL(url); Image img = Toolkit.getDefaultToolkit().getImage(u); BufferedImage bf = toBufferedImage(img); System.out.println(\"eeee\");&#125;static BufferedImage toBufferedImage(Image image) &#123; if (image instanceof BufferedImage) &#123; return (BufferedImage) image; &#125; // This code ensures that all the pixels in the image are loaded image = new ImageIcon(image).getImage(); BufferedImage bimage = null; GraphicsEnvironment ge = GraphicsEnvironment .getLocalGraphicsEnvironment(); try &#123; int transparency = Transparency.OPAQUE; GraphicsDevice gs = ge.getDefaultScreenDevice(); GraphicsConfiguration gc = gs.getDefaultConfiguration(); bimage = gc.createCompatibleImage(image.getWidth(null), image.getHeight(null), transparency); &#125; catch (HeadlessException e) &#123; // The system does not have a screen &#125; if (bimage == null) &#123; // Create a buffered image using the default color model int type = BufferedImage.TYPE_INT_RGB; bimage = new BufferedImage(image.getWidth(null), image.getHeight(null), type); &#125; // Copy image to buffered image Graphics g = bimage.createGraphics(); // Paint the image onto the buffered image g.drawImage(image, 0, 0, null); g.dispose(); return bimage;&#125; 实测验证 为什么会出现这个问题： ImageIO.read()方法读取图片时可能存在不正确处理图片ICC信息的问题，ICC为JPEG图片格式中的一种头部信息，导致渲染图片前景色时蒙上一层红色。 其他参考 Java处理某些图片红色问题 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"BugFix","slug":"BugFix","permalink":"https://zbang.online/hexblog/tags/BugFix/"},{"name":"BufferedImage","slug":"BufferedImage","permalink":"https://zbang.online/hexblog/tags/BufferedImage/"},{"name":"Jpeg","slug":"Jpeg","permalink":"https://zbang.online/hexblog/tags/Jpeg/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"Batik渲染png图片异常的bug修复","slug":"Batik渲染png图片异常的bug修复","date":"2018-01-20T12:36:56.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/20/Batik渲染png图片异常的bug修复/","link":"","permalink":"https://zbang.online/hexblog/2018/01/20/Batik渲染png图片异常的bug修复/","excerpt":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程","text":"Batik渲染png图片异常的bug修复batik是apache的一个开源项目，可以实现svg的渲染，后端借助它可以比较简单的实现图片渲染，当然和java一贯处理图片不太方便一样，使用起来也有不少坑 下面记录一个bug的修复过程 I. 问题重现svg文件: 123456&lt;svg width=\"200\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;&lt;image y=\"0\" width=\"100%\" height=\"100%\" x=\"0\" xlink:href=\"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"/&gt; &lt;!--xlink:href=\"https://s17.mogucdn.com/mlcdn/c45406/180119_46ld8kkb54d3el06hela5d61e18f5_1024x966.png\"/&gt;--&gt; &lt;!--xlink:href=\"http://avatar.csdn.net/A/8/B/3_u010889145.jpg\"/&gt;--&gt;&lt;/svg&gt; 依次测试了三个图片，两个png，一个jpg，很不幸第一个png会抛异常 输出的堆栈信息如 12345678910111213141516The URI \"http://image.uc.cn/o/wemedia/s/upload/2017/39c53604fe3587a4876396cf3785b801x200x200x13.png\"on element &lt;image&gt; can't be opened because:PNG URL is corrupt or unsupported variant at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) at org.apache.batik.bridge.SVGImageElementBridge.buildImageGraphicsNode(SVGImageElementBridge.java:180) at org.apache.batik.bridge.SVGImageElementBridge.createGraphicsNode(SVGImageElementBridge.java:122) at org.apache.batik.bridge.GVTBuilder.buildGraphicsNode(GVTBuilder.java:213) at org.apache.batik.bridge.GVTBuilder.buildComposite(GVTBuilder.java:171) at org.apache.batik.bridge.GVTBuilder.build(GVTBuilder.java:82) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:208) at org.apache.batik.transcoder.image.ImageTranscoder.transcode(ImageTranscoder.java:92) at org.apache.batik.transcoder.XMLAbstractTranscoder.transcode(XMLAbstractTranscoder.java:142) at org.apache.batik.transcoder.SVGAbstractTranscoder.transcode(SVGAbstractTranscoder.java:156) ... II. 问题定位及分析既然出现了这个问题，那么就要去修复解决了，当然遇到这么鬼畜的问题，最常见的几个步骤： 其他人遇到过么 （问百度） – 结果度娘没有给出任何有效的建议，也没有搜到任何有用的信息 然后问谷歌，靠谱了一点，至少有些相关的主题了，但建设性的意见也没收到 外援实在找不到，只能debug查问题了 1. DEBUG的一路通过上面的堆栈信息，可以想见，debug的几个地方也和明确了，首先定位到下面这一行 1at org.apache.batik.bridge.UserAgentAdapter.getBrokenLinkDocument(UserAgentAdapter.java:448) 为什么这么干？因为首先得确认下这个异常是怎么抛出来的，逆向推，直接看源码，发现直接抛出异常 再往上走 1at org.apache.batik.bridge.SVGImageElementBridge.createRasterImageNode(SVGImageElementBridge.java:642) 所以说因为这个if条件判断成立，导致进入了这个异常逻辑，判断的逻辑也没啥好说的，现在的关键是这个参数对象img是怎么来的 1at org.apache.batik.bridge.SVGImageElementBridge.createImageGraphicsNode(SVGImageElementBridge.java:340) 然后就稍微清晰一点了，直接将火力放在下面的方法中 12345org.apache.batik.ext.awt.image.spi.ImageTagRegistry#readURL(java.io.InputStream, org.apache.batik.util.ParsedURL, org.apache.xmlgraphics.java2d.color.ICCColorSpaceWithIntent, boolean, boolean) 在这个方法内部，也没什么好说的，单步多调几次，就能发现异常的case是怎么来的了，省略掉中间各种单步debug的过程，下面直接进入关键链路 2. 火力全开，问题定位1org.apache.batik.ext.awt.image.codec.imageio.AbstractImageIORegistryEntry 通过上面的一路之后，发现最终的关键就是上面这个抽象类，顺带也可以看下这个抽象类的几个子类，有JPEGxxx, PNGxxx, TIFFxxx，然后问题来了，都已经有相关实现了，所以png讲道理应该是会支持的才对吧，但和实际的表现太不一样了吧，所以有必要撸一把源码了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public Filter handleStream(InputStream inIS, ParsedURL origURL, boolean needRawData) &#123; final DeferRable dr = new DeferRable(); final InputStream is = inIS; final String errCode; final Object [] errParam; if (origURL != null) &#123; errCode = ERR_URL_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName(), origURL&#125;; &#125; else &#123; errCode = ERR_STREAM_FORMAT_UNREADABLE; errParam = new Object[] &#123;getFormatName()&#125;; &#125; Thread t = new Thread() &#123; @Override public void run() &#123; Filter filt; try&#123; Iterator&lt;ImageReader&gt; iter = ImageIO.getImageReadersByMIMEType( getMimeTypes().get(0).toString()); if (!iter.hasNext()) &#123; throw new UnsupportedOperationException( \"No image reader for \" + getFormatName() + \" available!\"); &#125; ImageReader reader = iter.next(); ImageInputStream imageIn = ImageIO.createImageInputStream(is); reader.setInput(imageIn, true); int imageIndex = 0; dr.setBounds(new Rectangle2D.Double (0, 0, reader.getWidth(imageIndex), reader.getHeight(imageIndex))); CachableRed cr; //Naive approach possibly wasting lots of memory //and ignoring the gamma correction done by PNGRed :-( //Matches the code used by the former JPEGRegistryEntry, though. BufferedImage bi = reader.read(imageIndex); cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image); filt = new RedRable(cr); &#125; catch (IOException ioe) &#123; // Something bad happened here... filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; catch (ThreadDeath td) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); dr.setSource(filt); throw td; &#125; catch (Throwable t) &#123; filt = ImageTagRegistry.getBrokenLinkImage (AbstractImageIORegistryEntry.this, errCode, errParam); &#125; dr.setSource(filt); &#125; &#125;; t.start(); return dr;&#125; 看上面的实现是一个非常有意思的事情， 开了一个线程做事情，而且直接就返回了，相当于给了别人一个储物箱的钥匙，虽然现在储物箱是空的，但是回头我会填满的 言归正传，主要的业务逻辑就在这个线程里了，核心的几行代码就是 123456789101112// 加载图片，转为BufferedImage对象BufferedImage bi = reader.read(imageIndex);cr = GraphicsUtil.wrap(bi);// 下面实现对图片的ARGB进行修改cr = new Any2sRGBRed(cr);cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre);WritableRaster wr = (WritableRaster)cr.getData();ColorModel cm = cr.getColorModel();BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null);cr = GraphicsUtil.wrap(image);filt = new RedRable(cr); debug上面的几行代码，发现问题比较明显了，就是这个图片的转换跪了，至于为啥？ java的图片各种蛋疼至极，这里面的逻辑，真心搞不进去，so深挖到此为止 III. 兼容逻辑问题定位到了，当然就是想办法来修复了，简单来说，需要兼容的就是图片的类型转换上了，直接用原来的可能会抛异常，所以做了一个简单的兼容逻辑 12345678910111213141516if(bi.getType() == BufferedImage.TYPE_BYTE_INDEXED) &#123; BufferedImage image = new BufferedImage(bi.getWidth(), bi.getHeight(), BufferedImage.TYPE_INT_ARGB); Graphics2D g2d = image.createGraphics(); g2d.drawImage(bi, 0, 0, null); g2d.dispose(); cr = GraphicsUtil.wrap(image);&#125; else &#123; cr = GraphicsUtil.wrap(bi); cr = new Any2sRGBRed(cr); cr = new FormatRed(cr, GraphicsUtil.sRGB_Unpre); WritableRaster wr = (WritableRaster)cr.getData(); ColorModel cm = cr.getColorModel(); BufferedImage image = new BufferedImage (cm, wr, cm.isAlphaPremultiplied(), null); cr = GraphicsUtil.wrap(image);&#125; 再次验证，ok 注意： 一个问题来了，上面的兼容是需要修改源码的，我们可以怎么办？有几种解决方法 猥琐方法一：down下源码，修改版本，然后传到自己的私服，使用自己的vip包 猥琐方法二：把 batik-codec 工程原样拷贝到自己的项目中，就可以随意的使用改了 猥琐方法三：写一个完全相同的类（包路径完全相同），然后构造一个自定义类加载器，加载这个自己的这个兼容版本的，替换原来的（未测试，不确定是否能行） 至于我的选择，就是使用了猥琐方法二 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}],"tags":[{"name":"Bugfix","slug":"Bugfix","permalink":"https://zbang.online/hexblog/tags/Bugfix/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"batik","slug":"batik","permalink":"https://zbang.online/hexblog/tags/batik/"},{"name":"Png","slug":"Png","permalink":"https://zbang.online/hexblog/tags/Png/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"BugFix","slug":"技术/BugFix","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/"},{"name":"Java","slug":"技术/BugFix/Java","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/"},{"name":"Image","slug":"技术/BugFix/Java/Image","permalink":"https://zbang.online/hexblog/categories/技术/BugFix/Java/Image/"}]},{"title":"SpringMVC支持跨域的几种姿势","slug":"SpringMVC支持跨域的几种姿势","date":"2018-01-19T07:43:38.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/19/SpringMVC支持跨域的几种姿势/","link":"","permalink":"https://zbang.online/hexblog/2018/01/19/SpringMVC支持跨域的几种姿势/","excerpt":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数","text":"SpringMVC支持跨域的几种姿势 跨域好像是一个前端的问题，通常是a域名下向b域名的服务发起请求，然后处于浏览器的安全原则，被拦截了，而这种场景，在实际的项目中并不少见，那么作为后端可以怎么去支持跨域的case呢？ 后端需要支持跨域，一个是支持jsonp请求；还有一个就是设置responseHeader中crossOrigin等相关参数 I. Jsonp的支持jsonp的请求表现方式就是url里面会多一个参数 callback，一般如下 1callback=jQuery21105810685605043302_1516257942328 jsonp的返回与一般调用方式的返回也会有点区别，会在外面包装一层，如 1jQuery21105810685605043302_1516257942328(...); springmvc中，jsonp的支持却是比较简单了，不需要对现有的接口进行任何处理，只需要像下面这么玩即可 123456@ControllerAdvicepublic class JsonpAdvice extends AbstractJsonpResponseBodyAdvice &#123; public JsonpAdvice() &#123; super(\"callback\"); &#125;&#125; 分析说明首先是利用了注解 @ControllerAdvice ， 这个注解在后面说到的统一异常处理时，也会用到，从命名也可以看出，就是为Controller添加一个切面，简单来讲，就是在直接返回数据前，对返回的结果包装一把；从实现也可以看出，主要的逻辑就在 AbstractJsonpResponseBodyAdvice 里面，所以有必要看一下这个东西是怎么支持的了 核心的代码逻辑就是 123456789101112131415161718192021222324@Overrideprotected void beforeBodyWriteInternal(MappingJacksonValue bodyContainer, MediaType contentType, MethodParameter returnType, ServerHttpRequest request, ServerHttpResponse response) &#123; HttpServletRequest servletRequest = ((ServletServerHttpRequest) request).getServletRequest(); for (String name : this.jsonpQueryParamNames) &#123; String value = servletRequest.getParameter(name); if (value != null) &#123; if (!isValidJsonpQueryParam(value)) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Ignoring invalid jsonp parameter value: \" + value); &#125; continue; &#125; // 下面三行是主要的逻辑 MediaType contentTypeToUse = getContentType(contentType, request, response); response.getHeaders().setContentType(contentTypeToUse); bodyContainer.setJsonpFunction(value); break; &#125; &#125;&#125; 直接看可能看不太明白究竟做了什么，写了个测试，debug下相关的参数如下 即，修改返回的 content-type 为： application/javascript 返回的Container里面设置了jsonpFunction，为请求参数的value，至于是在什么时候封装的返回结果呢？这个有待后续补全 II. 支持cors跨域 Cross-Origin Resource Sharing（CORS）跨来源资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求 1. 背景CORS背后的基本思想是使用自定义的HTTP头部允许浏览器和服务器相互了解对方，从而决定请求或响应成功与否 所以问题就来了，安全如何保证？ 一般而言，为了避免夸站点攻击(csrf)，常见的手段无非： 身份校验（比如要求用户登录） token验证 ip白名单 来源referer校验 频率限制 2. 实现方式要支持csrf，也比较简单了，无非就是设置下responseHeader了, 一般需要设置以下几项 Access-Control-Allow-Origin: *; // 允许的来源 Access-Control-Allow-Methods: GET, POST, PUT, DELETE Access-Control-Allow-Credentials: true Access-Control-Allow-Headers: Content-Type Access-Control-Max-Age: 1800 //30 min 所以实现起来的方式就比较多了，一个是新增一个filter，主动设置下返回头，当然spring mvc提供了更友好的方式了 常见的几种手段如下: a. xml配置方式12345&lt;mvc:cors&gt; &lt;mvc:mapping path=\"/ajax/*\" allowed-origins=\"*\" max-age=\"3600\" /&gt;&lt;/mvc:cors&gt; b. 注解方式在controller方法上，添加下面这个注解即可 12345@CrossOrigin(origins = \"*\")@RequestMapping(value = &#123;\"xx\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)public ResponseWrapper&lt;WxBaseResponse&gt; create(HttpServletRequest httpServletRequest) &#123;&#125; c. 直接修改返回的responseHeader123response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"origin\"));response.setHeader(\"Access-Control-Allow-Methods\", \"*\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); III. 小结上面介绍了两种方式，支持起来都比较简单 jsonp: 通过ControllerAdvice拦截Controller，然后继承AbstractJsonpResponseBodyAdvice即可 cors: 通过xml配置或者直接使用 @CrossOrigin注解 IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Jsonp","slug":"Jsonp","permalink":"https://zbang.online/hexblog/tags/Jsonp/"},{"name":"CORS","slug":"CORS","permalink":"https://zbang.online/hexblog/tags/CORS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"SpringMVC返回图片的几种方式","slug":"SpringMVC返回图片的几种方式","date":"2018-01-18T03:13:22.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/18/SpringMVC返回图片的几种方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/18/SpringMVC返回图片的几种方式/","excerpt":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？","text":"SpringMVC返回图片的几种方式 后端提供服务，通常返回的json串，但是某些场景下可能需要直接返回二进制流，如一个图片编辑接口，希望直接将图片流返回给前端；如果要求返回base64，此时可以怎么处理？ I. 返回二进制图片主要借助的是 HttpServletResponse这个对象，实现case如下 1234567891011121314@RequestMapping(value = &#123;\"/img/render\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@CrossOrigin(origins = \"*\")@ResponseBodypublic String execute(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) &#123; // img为图片的二进制流 byte[] img = xxx; httpServletResponse.setContentType(\"image/png\"); OutputStream os = httpServletResponse.getOutputStream(); os.write(img); os.flush(); os.close(); return \"success\";&#125; 注意事项 注意ContentType定义了图片类型 将二进制写入 httpServletResponse#getOutputStream 写完之后，flush(), close()请务必执行一次 II. 返回图片的几种方式封装一般来说，一个后端提供的服务接口，往往是返回json数据的居多，前面提到了直接返回图片的场景，那么常见的返回图片有哪些方式呢？ 返回图片的http地址 返回base64格式的图片 直接返回二进制的图片 其他…（我就见过上面三种，别的还真不知道） 那么我们提供的一个Controller，应该如何同时支持上面这三种使用姿势呢？ 1. bean定义因为有几种不同的返回方式，至于该选择哪一个，当然是由前端来指定了，所以，可以定义一个请求参数的bean对象 123456789101112131415161718192021222324252627282930@Datapublic class BaseRequest &#123; private static final long serialVersionUID = 1146303518394712013L; /** * 输出图片方式: * * url : http地址 （默认方式） * base64 : base64编码 * stream : 直接返回图片 * */ private String outType; /** * 返回图片的类型 * jpg | png | webp | gif */ private String mediaType; public ReturnTypeEnum returnType() &#123; return ReturnTypeEnum.getEnum(outType); &#125; public MediaTypeEnum mediaType() &#123; return MediaTypeEnum.getEnum(mediaType); &#125;&#125; 为了简化判断，定义了两个注解，一个ReturnTypeEnum, 一个 MediaTypeEnum， 当然必要性不是特别大，下面是两者的定义 12345678910111213141516171819202122232425262728293031public enum ReturnTypeEnum &#123; URL(\"url\"), STREAM(\"stream\"), BASE64(\"base\"); private String type; ReturnTypeEnum(String type) &#123; this.type = type; &#125; private static Map&lt;String, ReturnTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(3); for(ReturnTypeEnum e: ReturnTypeEnum.values()) &#123; map.put(e.type, e); &#125; &#125; public static ReturnTypeEnum getEnum(String type) &#123; if (type == null) &#123; return URL; &#125; ReturnTypeEnum e = map.get(type.toLowerCase()); return e == null ? URL : e; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637@Datapublic enum MediaTypeEnum &#123; ImageJpg(\"jpg\", \"image/jpeg\", \"FFD8FF\"), ImageGif(\"gif\", \"image/gif\", \"47494638\"), ImagePng(\"png\", \"image/png\", \"89504E47\"), ImageWebp(\"webp\", \"image/webp\", \"52494646\"), private final String ext; private final String mime; private final String magic; MediaTypeEnum(String ext, String mime, String magic) &#123; this.ext = ext; this.mime = mime; this.magic = magic; &#125; private static Map&lt;String, MediaTypeEnum&gt; map; static &#123; map = new HashMap&lt;&gt;(4); for (MediaTypeEnum e: values()) &#123; map.put(e.getExt(), e); &#125; &#125; public static MediaTypeEnum getEnum(String type) &#123; if (type == null) &#123; return ImageJpg; &#125; MediaTypeEnum e = map.get(type.toLowerCase()); return e == null ? ImageJpg : e; &#125;&#125; 上面是请求参数封装的bean，返回当然也有一个对应的bean 1234567891011121314151617181920@Datapublic class BaseResponse &#123; /** * 返回图片的相对路径 */ private String path; /** * 返回图片的https格式 */ private String url; /** * base64格式的图片 */ private String base;&#125; 说明： 实际的项目环境中，请求参数和返回肯定不会像上面这么简单，所以可以通过继承上面的bean或者自己定义对应的格式来实现 2. 返回的封装方式既然目标明确，封装可算是这个里面最清晰的一个步骤了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected void buildResponse(BaseRequest request, BaseResponse response, byte[] bytes) throws SelfError &#123; switch (request.returnType()) &#123; case URL: upload(bytes, response); break; case BASE64: base64(bytes, response); break; case STREAM: stream(bytes, request); &#125;&#125;private void upload(byte[] bytes, BaseResponse response) throws SelfError &#123; try &#123; // 上传到图片服务器，根据各自的实际情况进行替换 String path = UploadUtil.upload(bytes); if (StringUtils.isBlank(path)) &#123; // 上传失败 throw new InternalError(null); &#125; response.setPath(path); response.setUrl(CdnUtil.img(path)); &#125; catch (IOException e) &#123; // cdn异常 log.error(\"upload to cdn error! e:&#123;&#125;\", e); throw new CDNUploadError(e.getMessage()); &#125;&#125;// 返回base64private void base64(byte[] bytes, BaseResponse response) &#123; String base = Base64.getEncoder().encodeToString(bytes); response.setBase(base);&#125;// 返回二进制图片private void stream(byte[] bytes, BaseRequest request) throws SelfError &#123; try &#123; MediaTypeEnum mediaType = request.mediaType(); HttpServletResponse servletResponse = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse(); servletResponse.setContentType(mediaType.getMime()); OutputStream os = servletResponse.getOutputStream(); os.write(bytes); os.flush(); os.close(); &#125; catch (Exception e) &#123; log.error(\"general return stream img error! req: &#123;&#125;, e:&#123;&#125;\", request, e); if (StringUtils.isNotBlank(e.getMessage())) &#123; throw new InternalError(e.getMessage()); &#125; else &#123; throw new InternalError(null); &#125; &#125;&#125; 说明： 请无视上面的几个自定义异常方式，需要使用时，完全可以干掉这些自定义异常即可；这里简单说一下，为什么会在实际项目中使用这种自定义异常的方式，主要是有以下几个优点 配合全局异常捕获(ControllerAdvie)，使用起来非常方便简单 所有的异常集中处理，方便信息统计和报警 1如，在统一的地方进行异常计数，然后超过某个阀值之后，报警给负责人，这样就不需要在每个出现异常case的地方来主动埋点了 避免错误状态码的层层传递 12- 这个主要针对web服务，一般是在返回的json串中，会包含对应的错误状态码，错误信息- 而异常case是可能出现在任何地方的，为了保持这个异常信息，要么将这些数据层层传递到controller；要么就是存在ThreadLocal中；显然这两种方式都没有抛异常的使用方便 有优点当然就有缺点了： 异常方式，额外的性能开销，所以在自定义异常中，我都覆盖了下面这个方法，不要完整的堆栈 1234@Overridepublic synchronized Throwable fillInStackTrace() &#123; return this;&#125; 编码习惯问题，有些人可能就非常不喜欢这种使用方式 III. 项目相关只说不练好像没什么意思，上面的这个设计，完全体现在了我一直维护的开源项目 Quick-Media中，当然实际和上面有一些不同，毕竟与业务相关较大，有兴趣的可以参考 QuickMedia: https://github.com/liuyueyi/quick-media : BaseAction: com.hust.hui.quickmedia.web.wxapi.WxBaseAction#buildReturn IV. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"Response","slug":"Response","permalink":"https://zbang.online/hexblog/tags/Response/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"2017年全年回顾小结","slug":"2017年全年回顾小结","date":"2018-01-17T12:23:52.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2018/01/17/2017年全年回顾小结/","link":"","permalink":"https://zbang.online/hexblog/2018/01/17/2017年全年回顾小结/","excerpt":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。","text":"一月都过了快一半了，现在写17年的总结确实有点小晚，之前就准备好好的写一下的，却是因为各种琐碎的事情耽搁了，好在最近清闲了不少，基本上没啥事情可做，干脆好好的总结下17年的工作生活吧。 15年开始工作，17年呢，不再是职场新人，但是说到老鸟，却也相差甚远，工作的第二个年度，总感觉有些不温不火的，仔细看看这一年，尝试了很多东西，也做了一些事情，但总的来说，依然是达不到预期。 一个比较好的坚持下去的习惯就是每周一次的锻炼，虽然是因为小团队内的要求，不达标就罚款的前提定在这，所以努力的坚持了下来，还是值得表扬的。唯一和预期不一致的就是锻炼的效果好像不太明显，比去去年，体重确实又增加了不少。从工作来，体重可算是算着工作时长线性增加，有点可怕，感觉再这么下去，就没法玩了。坚持锻炼，努力运动，健康生活，依然是18年需要去维持的事情；此外也有必要，增加下运动的类型，除了跑步、骑车，还有那么多可以去尝试的活动，有必要去探索一下。 17年，与之前那么多年，最不同的有两件事，一个是入了王者荣耀的坑、变成了一个手游爱好者；还有一个就是写博客，每周最少一篇博文。然后这一年的常态就变成了每天晚上抱着手机玩游戏，每个周末跑到公司吭哧吭哧的写博文（当然有不少时候是为了写而写，所以有些内容比较难入眼）。这两件事情，则有必要好好的谈一下了。 首先是玩游戏这个，之前不怎么玩，挺浪费时间的，而且也没有什么特别有意思的，不知道什么时候开始接触农药，期间卸载了又重装了n次，现在水平依然很烂，仔细想了想自己，对于玩游戏有个奇怪的地方，不愿意去研究，到现在玩耍了大半年，依然不知道装备怎么出，不知道铭文怎么组合，反正都是随意玩，不管什么场景，顺风逆风，都是那么一套玩法，玩来玩去也就是那一个英雄（芈月）；一起玩的小伙伴已经荣升星曜，而我依然在黄金白银徘徊，简直了。其实从这个玩游戏的状态中也可以看出，我属于那种一旦熟悉了某种事务之后，不太愿意去更改、去变动的性格（总是玩一个英雄），主动专研能力不够（不看教程，不看视频…），脾气还不错（被坑了也不骂人）,还有就是定力不足（多次卸载游戏又重装）; (再次不得不说一句，感谢温柔漂亮的美人姣，非常理性的对待我玩游戏这一点） 另一个就是写博文了，这一年的写作，感觉比我上大学之后写的东西都要多了，差不多有八九十篇的样子了，之前抽空整理了个gitbook，挂在了私人服务器上: 小灰灰博文Book。写博文的收获其实挺大的，很多时候对于一个知识点，如果不尝试着去像其他人分享，你都不知道你到底掌握到什么程度了。而且如何才能写出一个漂亮的博文，真的没那么简单，这一年看了不少，有见过写的特别漂亮的，也看过写的不知道什么鬼的东西，当然现在我自己水平也不怎么样，但对比下前后的质量，发现还是有长进的。很多东西写着写着，会忽然发现一些平时没有注意的点。在这一块，感觉最主要的就是勤于总结，善于思考了。18年，这个坚持还是得继续下去的。因为写博文，当然为了避免玩单机，开通了头条号和公众号, 下面是链接，欢迎关注 谈到公众号，就有必要说一下与之相关的小程序了，小程序大火的时候，也进来玩了一下，做了两个，一个是《古诗选》，每天会推送十条古诗，而且可以根据关键词搜索相关古诗的小程序，感觉还蛮有意思的，结果等做完之后，告诉类目不对个人开放，简直了…；然后开始做第二个了，这个纯粹是为了实例验证我之前推的一个开源项目Quick-Media，主要提供图片、二维码、音视频处理服务，目前处于非常简陋的状态，通过写着两个小程序，最大的一个感受是，对于布局和样式这一块，实在是太不敏感了。 既然说到了开源项目，那也有必要提一下了，17年的一个收获就是做了几个有意思的开源项目，虽然不怎么成功，没什么人关注，但对个人的学习和收获还是很不错的。比如 提供SPI服务的Quick-Spi:https://github.com/liuyueyi/quick-spi，通过这个项目的实现，算是理解了spi到底是个什么东西，又可以怎么去玩； Quick-Crawle爬虫框架:https://github.com/liuyueyi/quick-crawler，很久很久以前就对爬虫感兴趣了，然后就从0到1构建了一个非常简单的爬虫框架，前面说的《古诗选》的内容，就是通过这个爬虫框架从网上爬下来的，从玩票的性质来看，还不错； Quick-Media多媒体服务:https://github.com/liuyueyi/quick-media，目前算是个人最多star的项目了，里面深度的刨析了一下二维码的生成，完全可以替换二维码上各种元素，当然还有一些其他的东西，这个项目算是工作的附属品，因为实际的工作中，很多服务都是不需要的，但是偶尔我个人会对某一块比较感兴趣，所以干脆新搞了一个，把自己平时的各种想法都丢上去尝试一下； quick-doraemon，一个基于redis实现的配置中心框架:https://github.com/liuyueyi/quick-doraemon，了解阿里的Diaemond的同学大概可以猜到这个是干嘛的，做这个，纯粹是为了探究一下一个配置中心的实现，到底需要些什么东西，最关键的是，这个实现简不简单； 另外还有两个小工具包，一个是基于PopClip的 https://github.com/liuyueyi/PopClip， 一个基于Alfred的小工具集合（目前没有对外开放，主要扔在了公司内网，有较多的内部信息） 出去跑了个步，都接不下来上面写的东西了，干脆直接换个话题，谈谈生活。然而仔细想了想，好像没啥好说的，基本上就是上班，晚上加班，回家睡觉，第二天继续上班；这日子，过得有点单调啊。自勉，18年不能这么下去了，好歹也得有点业务生活，出去逛逛圈，到处走走也好过每天死宅 17年，家庭新增了两个成员，不到一岁的小朋友，老大已经会走路了，而老二则处于只晓得吃吃喝喝的状态；小外甥的成就已经远远超过他们老舅我的状态了，听我妈说两岁多我都还不会走路，也是尴尬; 多了小朋友之后，还挺不错的，最近没什么事情就喜欢在淘宝，京东上看一些小朋友的玩具，各种积木，玩具车之类的，发现还蛮有意思的，小时候没有玩过的东西，完全可以借着小朋友的名头买来自己耍，也是不错；一直都不太喜欢小孩子，总觉得难以沟通，还挺麻烦，但看着老爸老妈，每天教他们的大外甥一些东西的时候，还是蛮有趣的，陪伴与成长，如果可以的话，父母还是需要和小孩子一起 17年花了所有的积蓄，借了一些，方才勉强凑够首付，贷款了个小破房，生活艰辛，唉，啥时候房价才能平民，千年前的“安得广厦千万间，大庇天下寒士俱欢颜”放在现在，依然有效；脑子不够灵活，只能拿点死工资，得开拓下自己的思路了。 感谢@美人姣的这一路的相伴，虽然生活过得比较平淡，没有那么多的惊喜，没有那么多的浪漫，这些主要都是我的原因了，得改正，该有的小惊喜还是得有的，拓宽一下思路，改变一下习性，让生活变得有意思起来，这个需要在18年好好培养。 最后，再憧憬下18年，定个小目标，该结婚过小日子了!!! @美人姣","categories":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}],"tags":[{"name":"日记","slug":"日记","permalink":"https://zbang.online/hexblog/tags/日记/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://zbang.online/hexblog/categories/生活/"},{"name":"随笔","slug":"生活/随笔","permalink":"https://zbang.online/hexblog/categories/生活/随笔/"}]},{"title":"胡思乱想123","slug":"胡思乱想123","date":"2018-01-15T06:10:27.000Z","updated":"2018-04-02T07:43:56.852Z","comments":true,"path":"2018/01/15/胡思乱想123/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/胡思乱想123/","excerpt":"一些异想天开的小想法","text":"一些异想天开的小想法 1. 俄罗斯方块俄罗斯方块堆积后，总会有空格留下，那么如何去填空就是个问题，从这里可以引入一个新的game思路 在一堆由方格拼成的墙面上，有很多的空个，现在需要你去填空，然后消去相同色，得分；或者拼成一排则得分或者是自由移动方块，来拼接最长的相连方块； 或者是移动，组成各种有趣的图案","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://zbang.online/hexblog/tags/随笔/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"idea","slug":"杂记/idea","permalink":"https://zbang.online/hexblog/categories/杂记/idea/"}]},{"title":"基于OkHttp封装一个简单易用的http工具","slug":"基于OkHttp封装一个简单易用的http工具","date":"2018-01-15T05:15:03.000Z","updated":"2018-04-02T07:43:56.851Z","comments":true,"path":"2018/01/15/基于OkHttp封装一个简单易用的http工具/","link":"","permalink":"https://zbang.online/hexblog/2018/01/15/基于OkHttp封装一个简单易用的http工具/","excerpt":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析","text":"基于OkHttp封装一个简单易用的http工具 okHtt更常见的是用在android项目上实现http交互，而java后端，可能更多的使用httpclient；一般来讲，android的包，大部分也是可以用到java后端的，本片博文则主要是介绍如何使用okhttp实现http交互，并会做一个简单的封装，以达到更好的使用体验 本篇为纯工具封装，无原理分析 I. 封装后测试效果一览基本上，最常见的http交互有两个，一个get请求，一个post请求，因此这里也就封装了这两种请求方式，并额外增加一个上传文件的功能，我们可以通过使用case，来看一下我们最终封装后的使用姿势 123456789101112131415161718192021222324252627282930313233343536// 简单的get请求@Testpublic void testGet() &#123; String url = \"https://zbang.online/wx/list\"; try &#123; okhttp3.Response res = HttpWrapper.of(url).get(); if (res.isSuccessful()) &#123; String ans = res.body().string(); System.out.println(\"ans : \" + ans); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; @Testpublic void testUpload() &#123; String url = \"https://zbang.online/wx/qrcode/encode\"; String path = \"/Users/yihui/Desktop/img/test.jpg\"; File file = new File(path); try &#123; Response res = HttpWrapper.of(url) .file(\"image\", file.getName(), \"image/jpeg\", file) .addParam(\"content\", \"http://www.baidu.com\") .addParam(\"size\", \"400\") .upload(); if (res.isSuccessful()) &#123; String str = res.body().string(); System.out.println(\"ans: \" + str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 上面给出的是一个上传文件的case，实现主要是借助了builder模式，可以很简单的传递个中参数和配置，最后获取返回的结果，这样设计的好处很明显： 使用简单 阅读方便 II. 封装实现接下来进入正题，如何封装这个工具类呢，一般而言，发起http请求，需要设置请求参数，设置请求头，所以builder内部的元素可以很清晰的定义了 首先是引入依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt;&lt;/dependency&gt; 当然由于整个使用都比较简单，下面就直接贴出封装后的代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class HttpWrapper &#123; private static OkHttpClient client = new OkHttpClient(); private static final String DEFAULT_USER_AGENT = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\"; public static Builder of(String url) &#123; return new Builder(url); &#125; public static class Builder &#123; private String url; private Map&lt;String, String&gt; params; private List&lt;MultipartBody.Part&gt; uploadParts; Request.Builder reqBuilder; Builder(String url) &#123; this.url = url; params = new HashMap&lt;&gt;(); uploadParts = new ArrayList&lt;&gt;(); reqBuilder = new Request.Builder(); // 默认添加上user-agent addHeader(\"User-Agent\", DEFAULT_USER_AGENT); &#125; // 添加参数 public Builder addParam(String key, String value) &#123; params.put(key, value); return this; &#125; // 添加头 public Builder addHeader(String key, String value) &#123; reqBuilder.addHeader(key, value); return this; &#125; public Builder file(String key, String fileName, String fileMime, byte[] bytes) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), bytes)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, File file) &#123; MultipartBody.Part part = MultipartBody.Part.createFormData( key, fileName, RequestBody.create(MediaType.parse(fileMime), file)); uploadParts.add(part); return this; &#125; public Builder file(String key, String fileName, String fileMime, InputStream stream) throws IOException &#123; int size = stream.available(); byte[] bytes = new byte[size]; stream.read(bytes); return file(key, fileName, fileMime, bytes); &#125; /** * 发送get请求 * * @return * @throws IOException */ public Response get() throws IOException &#123; StringBuilder urlBuilder = new StringBuilder(url); if (!params.isEmpty()) &#123; urlBuilder.append(\"?\").append(Joiner.on('&amp;').withKeyValueSeparator('=').join(params)); &#125; return client.newCall(reqBuilder.url(urlBuilder.toString()).build()).execute(); &#125; /** * post表单数据 * * @return */ public Response post() throws IOException &#123; // 创建表单 FormBody.Builder formBodyBuilder = new FormBody.Builder(); if (!params.isEmpty()) &#123; params.forEach(formBodyBuilder::add); &#125; return client.newCall(reqBuilder.url(url) .post(formBodyBuilder.build()) .build()) .execute(); &#125; /** * 文件上传 * * @return * @throws IOException */ public Response upload() throws IOException &#123; MultipartBody.Builder bodyBuilder = new MultipartBody.Builder() .setType(MultipartBody.FORM); uploadParts.forEach(bodyBuilder::addPart); // 添加参数 params.forEach(bodyBuilder::addFormDataPart); return client.newCall(reqBuilder.url(url) .post(bodyBuilder.build()) .build()) .execute(); &#125; &#125;&#125; 针对上面的实现，有几个需要注意的地方 get请求时，将参数拼装到url上（需要考虑是否要编码？） post请求时，主要借助 FormBody 来存储请求参数 文件上传时， 主要利用Part来封装上传的文件，借助 MultipartBody来包装Part和请求参数 上传文件，需要指定其 MIME（即 Content-Type, 如 image/jpeg, audio/mp3, file/txt等） 传文件的同时，也可以传递post参数，当然url参数也是可以的 III. 测试验证前面给出的是一个传文件的case，下面则给出一个提交post表单的测试用例 这个http接口主要功能是实现markdown输出图片 12345678910111213141516171819202122232425262728293031323334@Testpublic void testPost() &#123; String url = \"https://zbang.online/wx/md2img\"; String content = \"h1 header\\n\" + \"============\\n\" + \"\\n\" + \"Paragraphs are separated by a blank line.\\n\" + \"\\n\" + \"2nd paragraph. *Italic*, **bold**, and `monospace`. Itemized lists\\n\" + \"look like:\\n\" + \"\\n\" + \" * this one\\n\" + \" * that one\\n\" + \" * the other one\"; String token = \"0xdahdljk3u8eqhrjqwer90e\"; String noborder = \"true\"; try &#123; Response res = HttpWrapper.of(url) .addParam(\"content\", content) .addParam(\"token\", token) .addParam(\"noborder\", noborder) .addParam(\"type\", \"stream\") .post(); if (res.isSuccessful()) &#123; BufferedImage bf = ImageIO.read(res.body().byteStream()); System.out.println(\"over\"); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 测试演示 V. 其他源码相关源码可以参见： HttpWrapper.java 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"工具","slug":"工具","permalink":"https://zbang.online/hexblog/tags/工具/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://zbang.online/hexblog/tags/Okhttp/"}],"keywords":[{"name":"工作","slug":"工作","permalink":"https://zbang.online/hexblog/categories/工作/"},{"name":"技术尝鲜","slug":"工作/技术尝鲜","permalink":"https://zbang.online/hexblog/categories/工作/技术尝鲜/"}]},{"title":"Redis实现分布式锁相关注意事项","slug":"Redis实现分布式锁相关注意事项","date":"2018-01-14T08:12:29.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2018/01/14/Redis实现分布式锁相关注意事项/","link":"","permalink":"https://zbang.online/hexblog/2018/01/14/Redis实现分布式锁相关注意事项/","excerpt":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题","text":"Redis实现分布式锁相关注意事项 查看了不少关于redis实现分布式锁的文章，无疑要设计一个靠谱的分布式并不太容易，总会出现各种鬼畜的问题；现在就来小述一下，在设计一个分布式锁的过程中，会遇到一些什么问题 I. 背景知识借助redis来实现分布式锁（我们先考虑单机redis的模式），首先有必要了解下以下几点： 单线程模式 setnx : 当不存在时，设置value，并返回1； 否则返回0 getset : 设置并获取原来的值 expire : 设置失效时间 get : 获取对应的值 del : 删除 ttl : 获取key对应的剩余时间，若key没有设置过超时时间，或者压根没有这个key则返回负数（可能是-1，-2） watch/unwatch : 事务相关 II. 方案设计1. 设计思路获取锁： 调用 setnx 尝试获取锁，如果设置成功，表示获取到了锁 设置失败，此时需要判断锁是否过期 未过期，则表示获取失败；循环等待，并再次尝试获取锁 已过期，getset再次设置锁，判断是否获取了锁（根据返回的值进行判断，后面给出具体的方案） 若失败，则重新进入获取锁的逻辑 释放锁： 一个原则就是确保每个业务方释放的是自己的锁 2. getset的实现方案网上一种常见的case，主要思路如下 setnx 尝试获取锁 失败，则 get 获取锁的value （一般是 uuid_timstamp） 判断是否过期，若没有过期，则表示真的获取失败 若过期，则采用 getset设置，尝试获取锁 实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940public class DistributeLock &#123; private static final Long OUT_TIME = 30L; public String tryLock(Jedis jedis, String key) &#123; while (true) &#123; String value = UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; String getsetOldVal = jedis.getSet(key, value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 jedis.set(key, getsetOldVal); &#125; &#125; &#125; public void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); &#125; &#125;&#125; 观察获取锁的逻辑，特别是获取超时锁的逻辑，很容易想到有一个问题 getSet 方法会不会导致写数据混乱的问题，简单来说就是多个线程同时判断锁超时时，执行 getSet设置锁时，最终获取锁的线程，能否保证和redis中的锁的value相同 上面的实现方式，一个混乱的case如下: 三个线程a,b,c 都进入到了锁超时的阶段 线程a, 获取原始值 oldVal, 并设置 t1 线程b, 获取线程a设置的 t1, 并重设为 t2 线程c, 获取线程b设置的 t2, 并重设为 t3 线程a，判断，并正式获取到锁 线程b，判断失败，恢复原来锁的内容为t1 线程c, 判断失败，恢复原来锁的内容为t2 问题出现了，获取锁的线程a，期望所得内容为t1, 但是实际为t2; 导致无法释放锁 实际验证 在上面的代码中，配合测试case，加上一些日志输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static String tryLock(Jedis jedis, String key) throws InterruptedException &#123; String threadName = Thread.currentThread().getName(); while (true) &#123; String value = threadName + \"_\" + UUID.randomUUID().toString() + \"_\" + System.currentTimeMillis(); Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 return value; &#125; // 锁获取失败, 判断是否超时 String oldLock = jedis.get(key); if (oldLock == null) &#123; continue; &#125; long oldTime = Long.parseLong(oldLock.substring(oldLock.lastIndexOf(\"_\") + 1)); long now = System.currentTimeMillis(); if (now - oldTime &lt; OUT_TIME) &#123; // 没有超时 continue; &#125; // 强制使所有的线程都可以到这一步 Thread.sleep(50); System.out.println(threadName + \" in getSet!\"); // 人工接入，确保t1 获取到锁， t2 获取的是t1设置的内容， t3获取的是t2设置的内容 if (\"t2\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(20); &#125; else if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; String getsetOldVal = jedis.getSet(key, value); System.out.println(threadName + \" set redis value: \" + value); if (Objects.equals(oldLock, getsetOldVal)) &#123; // 返回的正好是上次的值，表示锁获取成功 System.out.println(threadName + \" get lock!\"); if (\"t1\".equalsIgnoreCase(threadName)) &#123; // t1获取到锁，强制sleep40ms， 确保线t2,t3也进入了 getSet逻辑 Thread.sleep(40); &#125; return value; &#125; else &#123; // 表示返回的是其他业务设置的锁，赶紧的设置回去 // 人肉介入，确保t2优先执行，并设置回t1设置的值, t3后执行设置的是t2设置的值 if (\"t3\".equalsIgnoreCase(threadName)) &#123; Thread.sleep(40); &#125; else if (\"t2\".equalsIgnoreCase(threadName))&#123; Thread.sleep(20); &#125; jedis.set(key, getsetOldVal); System.out.println(threadName + \" recover redis value: \" + getsetOldVal); &#125; &#125;&#125; 测试case 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Testpublic void testLock() throws InterruptedException &#123; // 先无视获取jedis的方式 JedisPool jedisPool = cacheWrapper.getJedisPool(0); Jedis jedis = jedisPool.getResource(); String lockKey = \"lock_test\"; String old = DistributeLock.tryLock(jedis, lockKey); System.out.println(\"old lock: \" + old); // 确保锁超时 Thread.sleep(40); // 创建三个线程 Thread t1 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t1 &gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t1\"); Thread t2 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t2 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t2\"); Thread t3 = new Thread(() -&gt; &#123; try &#123; Jedis j =jedisPool.getResource(); DistributeLock.tryLock(j, lockKey); System.out.println(\"t3 &gt;&gt;&gt;&gt;&gt; \" + j.get(lockKey)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;, \"t3\"); t1.start(); t2.start(); t3.start(); Thread.sleep(10000);&#125;; 部分输出结果: 1234567891011121314main in getSet!main set redis value: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130main get lock!old lock: main_d4cc5d69-5027-4550-abe1-10126f057779_1515643763130t1 in getSet!t2 in getSet!t1 set redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t1 get lock!t3 in getSet!t2 set redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341t3 set redis value: t3_9aa5d755-43b2-43bd-9a0b-2bad13fa31f6_1515643763345t2 recover redis value: t1_105974db-7d89-48bf-9669-6f122a3f9fb6_1515643763341t3 recover redis value: t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341 重点关注 t1 &gt;&gt;&gt;&gt; t2_be06f80a-9b70-4a0e-a86d-44337abe8642_1515643763341，表示t1线程过去了锁，但是锁的内容不是其value，即便t2去恢复，也会被t3给覆盖 如何解决上面这个问题呢？ 上面是典型的并发导致的问题，当然可以考虑从解决并发问题的角度出发来考虑，一个常见的方式就是加锁了，思路如下：（不详细展开了） 在判断超时之后，加锁 再次获取对应的值，判断是否超时，是则执行上面的操作 否则退出逻辑，继续循环 这种实现方式，会有以下的问题： getset 这个方法执行，可能导致写入脏数据 基于服务器时钟进行超时判断，要求所有服务器始终一致，否则有坑 3. expire实现方式相比于前面一种直接将value设置为时间戳，然后来比对的方法，这里则直接借助redis本身的expire方式来实现超时设置，主要实现逻辑相差无几 123456789101112131415161718192021222324252627282930313233public class DistributeExpireLock &#123; private static final Integer OUT_TIME = 3; public static String tryLock(Jedis jedis, String key) &#123; String value = UUID.randomUUID().toString(); while(true) &#123; Long ans = jedis.setnx(key, value); if (ans != null &amp;&amp; ans == 1) &#123; // 获取锁成功 jedis.expire(key, OUT_TIME); // 主动设置超时时间为3s return value; &#125; // 获取失败，先确认下是否有设置国超是时间 // 防止锁的超时时间设置失效，导致一直竞争不到 if(jedis.ttl(key) &lt; 0) &#123; jedis.expire(key, OUT_TIME); &#125; &#125; &#125; public static void tryUnLock(Jedis jedis, String key, String uuid) &#123; String ov = jedis.get(key); if (uuid.equals(ov)) &#123; // 只释放自己的锁 jedis.del(key); System.out.println(Thread.currentThread() +\" del lock success!\"); &#125; else &#123; System.out.println(Thread.currentThread() +\" del lock fail!\"); &#125; &#125;&#125; 获取锁的逻辑相比之前的，就简单很多了，接下来则需要简单的分析下，上面这种实现方式，会不会有坑呢？我们主要看一下获取锁失败的场景 如果获取锁失败 表示有其他的业务方已经获取到了锁 此时，只能等持有锁的业务方主动释放锁 判断锁是否设置了超时时间，若没有则加一个（防止设置超时时间失败导致问题） 从上面这个逻辑来看问题不大，但是有个问题，case ： 如某个业务方setnx获取到了锁，但是因为网络问题，过了很久才获取到返回，此时锁已经失效并被其他业务方获取到了，就会出现多个业务方同时持有锁的场景 III. 小结说明想基于redis实现一个相对靠谱的分布式锁，需要考虑的东西还是比较多的，而且这种锁并不太适用于业务要求特别严格的地方，如 一个线程持有锁时，如果发生gc，导致锁超时失效，但是自己又不知道，此时就会出现多个业务方同时持有锁的场景 对于锁超时的场景，需要仔细考虑，是否会出现并发问题 确保只能释放自己的锁（以防止释放了别人的锁，出现问题） 参考链接 基于Redis的分布式锁到底安全吗? 利用redis实现的分布式锁 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zbang.online/hexblog/tags/Redis/"},{"name":"distributeLock","slug":"distributeLock","permalink":"https://zbang.online/hexblog/tags/distributeLock/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Redis","slug":"技术/Redis","permalink":"https://zbang.online/hexblog/categories/技术/Redis/"}]},{"title":"SpringMVC之请求参数的获取方式","slug":"SpringMVC之请求参数的获取方式","date":"2018-01-04T08:48:39.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/04/SpringMVC之请求参数的获取方式/","link":"","permalink":"https://zbang.online/hexblog/2018/01/04/SpringMVC之请求参数的获取方式/","excerpt":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE","text":"SpringMVC之请求参数的获取方式 常见的一个web服务，如何获取请求参数？ 一般最常见的请求为GET和POST，get请求的参数在url上可以获取，post请求参数除了url上还有可能在表单中，文件上传时，获取方式又和一般的参数获取不一样 本篇则主要集中在不同请求方式下，获取参数的使用姿势 首先需要搭建一个后端的请求，为了快速演示 利用spring-boot创建了一个机器简单的工程，依赖版本 1.5.4.RELEASE I. GET请求参数获取get请求参数，一般都是直接挂在请求的url上，所以获取这些参数还是比较简单的 1. 通过 HttpServletRequest获取参数这个可以说是最基本最常见的的方式了，javax.servlet.ServletRequest#getParameter 来获取对应的参数，下面各处一个实例 1234567891011@RestController@RequestMapping(path = \"webs/demo\")public class DemoController &#123; @RequestMapping(path = \"req1\") public String req1(HttpServletRequest request) &#123; String user = request.getParameter(\"user\"); String password = request.getParameter(\"password\"); return \"req1 user: \" + user + \" pwd: \" + password; &#125;&#125; 根据上面暴露的接口，我们测试的case就很简单了 12345http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog&amp;password=123456## 输出 req1 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req1?user=小灰灰Blog## 输出 req1 user: 小灰灰Blog pwd: null 说明 这是一个最基本的获取参数的方式，get，post请求都适用的，通常在filter,intercepter中也是可以通过HttpServletRequest对象来获取请求参数 除了获取常见的请求参数之外，HttpServletRequest可以获取请求头的完整信息 在一次请求的生命周期内，可以通过下面的方式获取Request对象(当然也可以获取response对象) 12HttpServletRequest httpServletRequest = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest(); 2. 直接方法参数获取直接给出case, 这个方法依然是放在上面的DemoController下面的 1234@RequestMapping(path = \"req2\")public String req2(String user, String password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 请求验证 12345678910http://127.0.0.1:8080/webs/demo/req2?user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog&amp;password=123456## 输出： req2 user: 小灰灰Blog pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456## 输出： req2 user: null pwd: 123456http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;User=blog## 输出： req2 user: null pwd: 123456 注意： 上面这种使用方式，相当于直接将url参数映射到了Controller方法的参数上了 方法参数名必须和url参数名完全一致（区分大小写） 顺序无关 若参数没传，则默认为null 一个疑问 上面的demo中Controller的方法参数都是String还好，如果将password改成int，会出现什么情况 代码稍作修改 1234@RequestMapping(path = \"req2\")public String req2(String user, int password) &#123; return \"req2 user: \" + user + \" pwd: \" + password;&#125; 实际测试 12345678910111213# case1 http://127.0.0.1:8080/webs/demo/req2?password=123456&amp;user=blog## 输出： req2 user: blog pwd: 123456# case 2http://127.0.0.1:8080/webs/demo/req2?password2=123456&amp;user=blog## 输出: 报错, Optional int parameter 'password' is present but cannot be translated into a null value due to being declared as a primitive type. Consider declaring it as object wrapper for the corresponding primitive type# case 3http://127.0.0.1:8080/webs/demo/req2?password=abc&amp;user=blog## 输出：报错, \"Failed to convert value of type 'java.lang.String' to required type 'int'; nested exception is java.lang.NumberFormatException: For input string: \"abc\"\" 结果说明 如果请求参数与方法参数类型不一致，会抛出转换异常 如果方法参数为非封装基本类型，则url参数必须存在，否则报错 3. RequestParam注解方式获取请求参数通过@RequestParam注解获取参数的方式和上面的一种比较类似，case如下 12345@RequestMapping(path = \"req3\", method = RequestMethod.GET)public String req3(@RequestParam(\"user\") String username, @RequestParam(\"password\") String pwd) &#123; return \"req3 user: \" + username + \" pwd: \" + pwd;&#125; 测试case 12345678# case1 http://127.0.0.1:8080/webs/demo/req3?password=123456&amp;user=blog## 输出: req3 user: blog pwd: 123456# case2http://127.0.0.1:8080/webs/demo/req3?password=123456## 输出：报错， Required String parameter 'user' is not presen 说明 不指定注解的name或value属性时，等同于第二种使用姿势 注解的name属性或value属性，用实际的参数名来指定 controller的参数名与url参数名没有强关联（区别第二种方式） 参数类型需要保证一致（通第二种方式） 如果url参数可选，请设置require属性为false，如下1@RequestParam(name = \"user\", required = false) String username 4. Bean方式获取参数对于请求参数比较复杂的情况下，我比较喜欢这种使用姿势，管理起来方便简单 12345678910@Datapublic static class UserDO &#123; String user; String password;&#125;@RequestMapping(path = \"req4\", method = RequestMethod.GET)public String req4(UserDO userDO) &#123; return \"req4 userDO: \" + userDO;&#125; 测试case 12345678# case1http://127.0.0.1:8080/webs/demo/req4?password=123456&amp;user=%E5%B0%8F%E7%81%B0%E7%81%B0Blog## 输出: req4 userDO: DemoController.UserDO(user=小灰灰Blog, password=123456)# case2http://127.0.0.1:8080/webs/demo/req4?password=123456## 输出: req4 userDO: DemoController.UserDO(user=null, password=123456) 说明 定义一个bean，内部属性和请求参数对应 允许参数不存在的情况，会使用null代替（所以，尽量不要使用非封装基本类型，否则参数不传时，会抛异常） bean的属性，可以根据实际情况指定类型 5. ModelAttribute注解方式@ModelAttribute注解的方法，会优于Controller之前执行，一般更常见于向视图传输数据使用，此处不详细展开，正常来讲，专门的获取参数不太会用这这种方式来玩 6. Path参数Path参数，专指的是请求路径的参数，如 1http://127.0.0.1:8080/webs/demo/req4?password=123456 上面这个url中，password是我们传统意义上的请求参数，其中path参数则是指其中 req4, demo这种path路径中的一环；对此，最常见的一个case就是常见的博客中,如开源中国的一个博客链接 1https://my.oschina.net/u/566591/blog/1601400 566591 : 这个参数主要用来区分用户 1601400 : 这个参数则主要是表示对应的博文 一般path参数的获取方式如下 1234@RequestMapping(path = \"req6/&#123;user&#125;/info\")public String req6(@PathVariable(name = \"user\") String user) &#123; return \"req6 user: \" + user;&#125; 测试case 1234567891011# case1 http://127.0.0.1:8080/webs/demo/req6/blog/info?user=haha## 输出：req6 user: blog# case2http://127.0.0.1:8080/webs/demo/req6/blog?user=haha## 输出: 404# case3http://127.0.0.1:8080/webs/demo/req6/info?user=haha## 输出: 404 注意: path参数的使用，需要确保参数存在且类型匹配 path参数和url参数不会相互影响 II. POST请求参数获取POST请求参数，更多的是看提交表单参数是否可以获取到，以及如何获取，主要的手段依然是上面几种方式，下面验证下是否ok 1. HttpServletRequest方式获取参数测试case，可以借助curl来实现post请求 123456789101112# case1 curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req1\"## 输出： req1 user: 小灰灰Blog pwd: 123456# case2curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?password=123456\"## 输出：req1 user: 小灰灰Blog pwd: 12345# case3curl -d \"user=小灰灰Blog\" \"http://127.0.0.1:8080/webs/demo/req1?user=greyBlog\"## 输出：req1 user: greyBlog pwd: null curl也可以换成js请求测试方式 1234567891011var formData = new FormData();formData.append(\"user\", \"小灰灰Blog\");$.ajax(&#123; url: 'http://127.0.0.1:8080/webs/demo/req1?password=123456', type: 'post', cache: false, data: formData, processData: false, contentType: false&#125;); 说明 对于HttpServletReuqest方式获取参数时，get和post没什么区别 若url参数和表单参数同名了，测试结果显示使用的是url参数（待确认，当然最好不要这么干） 2. 方法参数获取几个测试demo如下 12345678910111213# case 1curl -d \"user=小灰灰Blog&amp;password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出： req2 user: 小灰灰Blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2\"## 输出：req2 user: null pwd: 123456# case 3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req2?user=blog\"## 输出： req2 user: blog pwd: 123456 基本上使用姿势和get没什么区别 3. RequestParam注解方式12345678910111213# case 1curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3\"## 输出： req3 user: blog pwd: 123456# case 2curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req3?user=blog\"## 输出： req3 user: blog pwd: 123456# case 3curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req3?password=900\"## 输出：req3 user: blog pwd: 900,123456 注意 和前面的两种方式不同的是，当post表单的参数和url参数同名时，会合并成一个字符串 4. Bean方式12345678910111213## case1 curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4?password=900\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=900,123456)## case2curl -d \"password=123456&amp;user=blog\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=blog, password=123456)## case3curl -d \"password=123456\" \"http://127.0.0.1:8080/webs/demo/req4\"## 输出 req4 userDO: DemoController.UserDO(user=null, password=123456) 这种方式不区分get,post，所以完全复杂的交互接口，完全可以考虑用bean的方式来定义请求参数 5. PathVariable这个没法玩… III. 多媒体上传参数获取 上传文件的支持，对于传统的spring-mvc来说，可能需要一些添加一些相关配置，不在本文的范畴内，下面默认已经配置好 1. 实例支持1234567891011121314@RequestMapping(path = &#123;\"wx/upload\", \"wx/wx/upload\"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS&#125;)@ResponseBodypublic String upload(HttpServletRequest request) &#123; MultipartFile file = null; if (request instanceof MultipartHttpServletRequest) &#123; file = ((MultipartHttpServletRequest) request).getFile(\"image\"); &#125; if (file == null) &#123; throw new IllegalArgumentException(\"图片不能为空!\"); &#125; return \"success\";&#125; 简单来说，主要是利用HttpServletRequest来获取上传的文件 注意： 如果接口必须要求上传文件，可以直接把参数声明为 MultipartHttpServletRequest， 此时调用方如果不传参数，会被异常拦截（可以通过@ControllerAdvice来拦截全局异常） 如果可以不上传文件，则可以用上面的这种猥琐姿势，内部进行判断 ((MultipartHttpServletRequest) request).getFile(xxx)来获取指定名的上传文件 IV. 小结1. 五种获取参数的姿势 方式 注意事项 HttpServletRequest获取参数 最常见通用 方法参数与请求参数同名 注意参数名统一，注意类型一致，尽量不用非包装基本类型 @RequestParam注解 同上，可注解内指定http参数名 Bean方式 定义一个bean，会将同名的http参数赋值进去，推荐 @PathVariable 注解 请求url参数 2. 传文件使用姿势使用MultipartHttpServletRequest来获取上传的文件，当然也可以获取基本的请求参数 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://zbang.online/hexblog/tags/Spring/"},{"name":"RequestParam","slug":"RequestParam","permalink":"https://zbang.online/hexblog/tags/RequestParam/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"Spring","slug":"技术/Java/Spring","permalink":"https://zbang.online/hexblog/categories/技术/Java/Spring/"}]},{"title":"jvm调优的工具介绍","slug":"jvm调优的工具介绍","date":"2018-01-03T06:18:35.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2018/01/03/jvm调优的工具介绍/","link":"","permalink":"https://zbang.online/hexblog/2018/01/03/jvm调优的工具介绍/","excerpt":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能","text":"jvm调优实战笔记之基础知识简介I. 背景 java后端，提供了一个svg渲染的服务，在qps较大时，会出现频繁的gc，而此时的服务器性能本身并没有达到瓶颈（cpu,load,io都不太高）因此考虑调整一下jvm的相关参数，看是否可以提升服务性能 jvm相关参数记录 12-XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=80 -XX:CMSMaxAbortablePrecleanTime=5000 -XX:+CMSParallelRemarkEnabled -XX:+CMSScavengeBeforeRemark -XX:+ExplicitGCInvokesConcurrent -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/xxx/java.hprof -XX:InitialCodeCacheSize=134217728 -XX:InitialHeapSize=4294967296 -XX:MaxDirectMemorySize=1073741824 -XX:MaxHeapSize=4294967296 -XX:MaxMetaspaceSize=268435456 -XX:MaxNewSize=2147483648 -XX:MetaspaceSize=268435456 -XX:NewSize=2147483648 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ReservedCodeCacheSize=268435456 -XX:SurvivorRatio=10 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 2. 监控工具使用tsar作为服务器性能监控工具，所以前提是先安装tsar 12345wget -O tsar.zip https://github.com/alibaba/tsar/archive/master.zip --no-check-certificateunzip tsar.zipcd tsarmakemake install 监控命令 1tsar --cpu --swap -i1 -l 说明 tsar相关可以参考： Linux系统性能监控工具介绍之-tsar II. 相关知识点简介截取几条gc日志 1234562018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs]2018-01-02T10:49:25.374+0800: 13.999: [GC (Allocation Failure) 2018-01-02T10:49:25.374+0800: 13.999: [ParNew: 1881830K-&gt;93708K(1922432K), 0.0910714 secs] 1949062K-&gt;197949K(4019584K), 0.0911833 secs] [Times: user=0.26 sys=0.01, real=0.09 secs]2018-01-02T10:55:53.013+0800: 401.639: [GC (GCLocker Initiated GC) 2018-01-02T10:55:53.013+0800: 401.639: [ParNew: 1841429K-&gt;142552K(1922432K), 0.0629031 secs] 1945670K-&gt;246793K(4019584K), 0.0630512 secs] [Times: user=0.14 sys=0.01, real=0.06 secs]2018-01-02T10:55:55.076+0800: 403.701: [GC (GCLocker Initiated GC) 2018-01-02T10:55:55.076+0800: 403.701: [ParNew: 1890281K-&gt;59983K(1922432K), 0.0661778 secs] 1994522K-&gt;201875K(4019584K), 0.0663176 secs] [Times: user=0.15 sys=0.01, real=0.07 secs]2018-01-02T11:47:25.271+0800: 3493.897: [GC (Allocation Failure) 2018-01-02T11:47:25.271+0800: 3493.897: [ParNew: 1807695K-&gt;20975K(1922432K), 0.0193077 secs] 1949587K-&gt;162867K(4019584K), 0.0195351 secs] [Times: user=0.04 sys=0.00, real=0.02 secs]2018-01-02T11:56:50.621+0800: 4059.247: [GC (GCLocker Initiated GC) 2018-01-02T11:56:50.622+0800: 4059.247: [ParNew: 1774543K-&gt;108899K(1922432K), 0.0401606 secs] 1916434K-&gt;250791K(4019584K), 0.0403586 secs] [Times: user=0.10 sys=0.00, real=0.04 secs] 1. CMS GC日志格式分析截取上面日志中的第一条，分别说明每一项是什么意思 2018-01-02T10:49:20.390+0800: 9.015: [GC (Allocation Failure) 2018-01-02T10:49:20.390+0800: 9.015: [ParNew: 1922431K-&gt;134118K(1922432K), 0.1486593 secs] 1934749K-&gt;201350K(4019584K), 0.1487460 secs] [Times: user=0.33 sys=0.05, real=0.14 secs] 2018-01-02T10:49:20.390+0800 ：发生gc的时间 9.015 - GC开始，相对JVM启动的相对时间，单位是秒 GC - 区别FullGC和MinorGC的标识，此处表示为MinorGC (Allocation Failure) - 发生gc的原因，此处表示空间不足，导致分配失败 ParNew – 收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器 1922431K-&gt;134118K – 收集前后年轻代的使用情况，未回收之前，大小为1922431K, 回收完毕之后，大小为134118K, 所以回收大小为: 1922431K - 134118K (1922432K) - 整个年轻代的容量 0.1486593 secs - 这个解释用原滋原味的解释：Duration for the collection w/o final cleanup. 1934749K-&gt;201350K - 收集前后整个堆的使用情况 (4019584K) - 整个堆的容量 0.1487460 secs – ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的花销）； [Times: user=0.78 sys=0.01, real=0.11 secs] – GC事件在不同维度的耗时，具体的用英文解释起来更加合理: user – Total CPU time that was consumed by Garbage Collector threads during this collection sys – Time spent in OS calls or waiting for system event real – Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount. 2. CMS简介 后端服务选用的就是CMS，那么就有必要看一下这个CMS到底是个什么东西 CMSConcurrent Mark Sweep 收集器，是一种以获取最短回收停顿时间为目标的收集器，核心就是标签-清除算法 步骤划分 初始标记 (CMS initial mark) : 标记GC Roots能直接关联到的对象，速度很快，会暂停 并发标记 (CMS concurrent mark) : 进行 GC Roots Tracing的过程 重新标记 (CMS remark) : 为了修正并发标记期间，因为程序继续运作导致标记变动的那一部分对象的标记记录，一般会长于初始标记时间，远小于并发标记的时间 并发清除 (CMS concurrent sweep) : 说明，初始标记和重新标记的时候，会暂停服务；后面两个则是并发修改 标记清除算法一句话描述： 标记所有需要回收的对象，在标记完成后，统一回收所有被标记的对象 常见的两个问题： 效率不高；回收后大量的碎片 3. 内存分配和回收策略a. 对象优先在Eden分配大多数场景下，对象在新生代Eden区分配，当Eden去没有足够的空间进行分配时，虚拟机发起一次 Minor GC 新生代MinorGC ： 发生在新生代的垃圾收集动作，因为java对象大多都具备朝生夕灭的特性是，所以一般MinorGC非常频繁，一般回收速度也很快 老年代MajorGC(FullGC) : 发生在老年代的GC，通常就伴随至少一次的MinorGC（非绝对），一般较慢，是MinorGC的十倍以上 b. 大对象直接进入老年代需要大量连续内存空间的Java对象，通常是数组，同构 -XX:PretenuresizeThreshold 参数，来设置大对象的阀值，超过这个阀值的直接分配在年老代，避免在Eden区及两个Survivor区指尖发生大量的内存复制 c. 长期存活的对象将进入老年代既然虚拟机采用分代收集的思想来管理内存，在回收时，就必须能识别哪些对象应放在新生代，那些对象应放在老年代中 每个对象都有个Age的计数器，对象在Eden出生并经过第一次MinorGC后仍存在，且可以被Survivor容纳的话，会被移动到Survivor空间中，并设置Age为1 对象在Survivor区没多经过一次MinorGC，则age+1 当age超过阀值（默认15），就会晋升到老年代 阀值可以通过 -XX:MaxTenuringThreshold来设置 d. 动态对象年龄判定如果在Survivor空间中相同年龄所有对象的大小的总和，大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代，无序等Age达到阀值 e. 空间分配担保在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则Minor GC可以确保总是安全的； 否则，查看 HandlePromotionFailure参数，是否允许担保失败 若允许，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，则尝试MinorGC 否则进行FullGC 3. jstat 命令简介 既然问题是频繁的gc引起的，那么观察新生代，老年代对象占用空间的情况就不可避免了，所以jstat命令不得不出现了 截一个线程图 1234567$ jstat -gcutil 11573 1000 5 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 34.39 24.68 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 26.29 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 27.45 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 28.32 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 0.00 34.39 29.93 68.01 98.12 96.30 3051 170.096 242 18.429 188.525 a. 参数说明 -gcutil ： 监视Java对状况，包括Eden区、两个survivor区，老年代，永久代等，已用空间，gc时间等 11573： java进程号 1000： 每1s刷新一次 5： 一共查询5次 b. 输出说明 S0, S1: 表示两个 survivor区 E(Eden) : 新生代Eden O(Old) : 老年代Old M(metaspace) : 元空间,本地内存， 在1.8移除了永久代改成这个 YGC : 程序运行以来，发生Minor GC(Young GC)次数 YGCT : Minor GC 总耗时（单位s) FGC : Full GC的总次数 FGCT : Full GC的总耗时 （单位s) GCT : 所有GC的总耗时 （单位s) III. 监控测试0. 准备a. 首先是获取对应的进程号12jps -ljinfo xxx 抓图 123$ jps -l30916 sun.tools.jps.Jps2909 org.apache.catalina.startup.Bootstrap b. 服务器性能监控命令12## 主要查看cpu和nginx访问的监控tsar --cpu --nginx -i1 -l 抓图: 12345678Time -----------------------cpu---------------------- ----------------------------------nginx---------------------------------Time user sys wait hirq sirq util accept handle reqs active read write wait qps rt03/01/18-11:29:37 16.54 1.50 0.00 0.00 0.00 18.05 2.00 2.00 6.00 15.00 0.00 1.00 14.00 6.00 89.5003/01/18-11:29:38 26.07 1.75 0.00 0.00 0.00 27.82 3.00 3.00 10.00 15.00 0.00 1.00 14.00 10.00 47.1003/01/18-11:29:39 19.60 1.01 0.00 0.00 0.00 20.60 4.00 4.00 11.00 15.00 0.00 1.00 14.00 11.00 37.8203/01/18-11:29:40 28.75 2.50 0.00 0.00 0.25 31.50 2.00 2.00 10.00 15.00 0.00 1.00 14.00 10.00 79.3003/01/18-11:29:41 14.07 1.51 0.00 0.00 0.00 15.58 1.00 1.00 10.00 15.00 0.00 3.00 12.00 10.00 51.3003/01/18-11:29:42 20.60 1.01 0.00 0.00 0.00 21.61 6.00 6.00 13.00 15.00 0.00 1.00 14.00 13.00 44.69 c. jvm内存的监控1jstat -gcutil 4354 1000 抓图: 123456$ jstat -gcutil 2909 1000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 29.03 0.00 66.34 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.37 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.50 16.34 98.57 96.32 200 6.393 0 0.000 6.393 29.03 0.00 66.54 16.34 98.57 96.32 200 6.393 0 0.000 6.393 d. 查看内存中对象的个数和大小1jmap -histo 4354 抓图 123456789101112num #instances #bytes class name---------------------------------------------- 1: 78179 181546608 [I 2: 1259 175880312 [S 3: 35915 65527520 [B 4: 242125 40558408 [C 5: 571604 13718496 java.util.concurrent.atomic.AtomicLong 6: 233282 5598768 java.lang.String 7: 55177 5296992 java.util.jar.JarFile$JarFileEntry 8: 119906 3836992 java.util.HashMap$Node 9: 33327 2932776 java.lang.reflect.Method 10: 1147 2303216 [Ljava.util.concurrent.atomic.AtomicLong; e. 压测模拟工具Jmetter 添加线程组 新增http请求 添加监听器中，结果的监控：图形结果，聚合报告，查看结果树，用表格查看结果 http请求中配置参数 协议 域名or IP + 端口号 编码: utf-8 请求方法 + 请求路径 请求参数，支持文件上传，注意编码方式 IV. 参考 Linux系统性能监控工具介绍之-tsar tsar使用说明 JVM调优——之CMS GC日志分析 jvm的GC日志分析 JVM 运行时内存使用情况监控 《深入理解JVM虚拟机》 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://zbang.online/hexblog/tags/JVM/"},{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JVM","slug":"技术/Java/JVM","permalink":"https://zbang.online/hexblog/categories/技术/Java/JVM/"}]},{"title":"JDK学习之反射的使用姿势一览","slug":"JDK学习之反射的使用姿势一览","date":"2017-12-29T12:26:51.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2017/12/29/JDK学习之反射的使用姿势一览/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/JDK学习之反射的使用姿势一览/","excerpt":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景","text":"反射的学习使用 日常的学习工作中，可能用到反射的地方不太多，但看看一些优秀框架的源码，会发现基本上都离不开反射的使用；因此本篇博文将专注下如何使用反射 本片博文布局如下: 反射是什么，有什么用，可以做什么 如何使用反射 实例： 利用反射方式，获取一个类的所有成员变量的name及值 通过反射方式，修改对象的私有成员变量 会通过写一个BeanUtils实现对象的成员变量值拷贝来覆盖上面两个场景 I. 反射定义 指程序可以访问、检测和修改它本身状态或行为的一种能力 直接说定义的话，可能并不能非常清晰的解释说明，结合作用进行描述 反射可以干什么？ 1234在运行时构造任意一个类的对象。在运行时判断任意一个对象所属的类。在运行时判断任意一个类所具有的成员变量和方法。在运行时调用任意一个对象的方法 有了上面四点，基本上你想干嘛就可以干嘛，比如我现在就有下面这个类 1234567891011121314151617181920212223242526272829public class RefectTest extends MyRefect implements IRefect &#123; private static String s1 = \"hello\"; private static int s2 = 100; private int s3 = 200; private boolean ans; protected RefectTest next; public RefectTest() &#123; &#125; public RefectTest(int s3, boolean ans, RefectTest next) &#123; this.s3 = s3; this.ans = ans; this.next = next; &#125; public RefectTest next() &#123; return next; &#125; private int count(int a, int b) &#123; return a + b; &#125;&#125; 现在我有了clz,其赋值语句为 Class clz = RefectTest.class， 那么我可以干啥？ 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 上面给出了可以干些什么，并给了对应的简单示例，引入了几个新的类Constructor, Field, Method， 下面将详细解释这三个类是什么，怎么用 II. 反射的使用努力结合实际的应用场景，给出每种利用反射的实现对应需求的使用姿势，有些场景可能并不是特别贴切，欢迎提出给合适的场景以此进行替换 1. 通过反射创建对象 这是个比较常见的场景，我在使用了自定义注解时，通常会这么晚 应用场景： 我定义了一个校验器的注解ValDot，注解中有个校验规则class对象，如下 1234567891011121314151617public interface ICheckRule &#123; boolean check(Object ... obj);&#125;public class DefaultCheckRule implements ICheckRule &#123; @Override public boolean check(Object... obj) &#123; return false; &#125;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface CheckDot &#123; // 校验规则 Class&lt;? extends ICheckRule&gt; check() default DefaultCheckRule.class;&#125; 上面定义了注解和校验条件，接着进入整体，在切面中，需要获取 1234567891011121314@Aspect@Componentpublic class CheckAspect &#123; @Before(\"@annotation(checkDot)\") public void process(JoinPoint joinPoint, CheckDot checkDot) throws IllegalAccessException, InstantiationException &#123; // 注意，这里获取注解上的校验规则类，并获取实例 ICheckRule rule = checkDot.check().newInstance(); if(rule.check(joinPoint.getArgs())) &#123; throw new IllegalStateException(\"check argument error!\"); &#125; &#125;&#125; 上面是一个较好的利用反射获取实例的应用场景，想一想，如果不用反射，这个校验规则怎么传进来呢，这个时候就没那么方便了（当然也不是不可以，最简单的就是拿一个Holder持有类名到类对象的映射关系，然后在注解中传类名，也可以达到上面的效果） 还有一种场景可能就比较蛋疼了，如果一个类没有默认构造方法，通过反射就没法直接用class.newInstanace()了 Constructor构造器类 根据Class优先获取到 Constructor 对象，然后传入需要的构造参数, 测试如下 1234567891011121314151617181920212223public class ConTest &#123; private int a,b; public ConTest(int a, int b) &#123; this.a = a; this.b = b; &#125; @Override public String toString() &#123; return \"ConTest&#123;\" + \"a=\" + a + \", b=\" + b + '&#125;'; &#125; public static void main(String[] args) throws Exception &#123; Class clz = ConTest.class; // 获取对应的构造器（注意参数类型） Constructor constructor = clz.getConstructor(int.class, int.class); // 创建实例（注意参数要匹配） ConTest test = (ConTest) constructor.newInstance(10, 20); System.out.println(test.toString()); &#125;&#125; 输出 1ConTest&#123;a=10, b=20&#125; 一般常用下面四种方式获取 1234567891011// 根据参数类型获取匹配的构造器Constructor getConstructor(Class[] params)// 获取所有的Constructor[] getConstructors()// 相比较前面的，这里可以获取私有方法Constructor getDeclaredConstructor(Class[] params)// 可以获取私有方法Constructor[] getDeclaredConstructors() 2. 判断class的继承关系判断是否为基础数据类型基本类型较为特殊，所以JDK很人性化的给封装了一个方法，Class#isPrimitive 因此返回true的类型有: int long short byte char boolean 封装后的类型，返回的依然是false 附带一句，是没有null.class这种用法的 判断是否为另一个类的子类，另一个接口的实现类通常我们利用 instanceof 关键字来判断继承关系，但是这个是针对对象来的，现在给一个class，要怎么玩？ 看下面，主要就是 Class#isAssignableFrom() 的功劳了 1234567891011121314151617181920212223public class ExtendTest &#123; interface ITest &#123;&#125; abstract class ATest &#123; abstract public void print(); &#125; class TestClz extends ATest implements ITest &#123; @Override public void print() &#123; System.out.println(\"TestClz\"); &#125; &#125; public static void main(String[] args) &#123; Class clz = TestClz.class; System.out.println(ATest.class.isAssignableFrom(clz)); System.out.println(ITest.class.isAssignableFrom(clz)); &#125;&#125; 需要注意一点，父类作为调用方，子类作为参数 结合泛型时，获取泛型的实际类型泛型，又是一个有意思的功能，这里不多说，继承一个泛型基类，然后问题是如何通过反射获得泛型签名中的类型，一般会在继承或实现泛型接口时会用到它。 123456789class A&lt;T, ID&gt; &#123;&#125;class B extends A&lt;String, Integer&gt; &#123;&#125;public static void main(String[] args) &#123; System.out.println(B.class.getGenericSuperclass());&#125; 换成泛型接口呢 ? 12345678910111213interface A&lt;T, ID&gt; &#123; &#125; class B implements A&lt;String, Integer&gt; &#123; &#125;public static void main(String[] args) &#123; ParameterizedType parameterizedType = (ParameterizedType) B.class.getGenericInterfaces()[0]; Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument); &#125;&#125; 3. 获取成员变量获取成员变量，主要是根据 B.class.getDeclaredFields() 来获取所有声明的变量，这个应用场景会和下面的获取方法并执行联合一起说明 1234567891011// 获取指定的公共成员变量Field getField(String name)// 获得所有公共字段Field[] getFields()// 获取指定声明的成员变量（包括prive）Field getDeclaredField(String name)// 获取所有声明的成员变量Field[] getDeclaredFields() 这个主要返回 Field对象，现在有了Field，可以做些啥？ 判断成员的修饰 Field#getModifiers() 12345678int modify = field.getModifiers();// 是否是静态变量boolean ans = Modifier.isStatic(modifier);// 是否是公共变量boolean ans = Modifier.isPublic(modifier);// 是否不可变boolean ans = Modifier.isFinal(modifier);// ... 获取成员的变量名 : field#getName() 获取成员对应的value: field#get(instance) 对于静态成员，instance可以为null 对于非静态成员，instance必须为一个实例对象 获取注解: field#getAnnotations() 这个就厉害了，hibernate的校验框架，在成员变量上加一个注解Max,就可以设置参数的最大值，其实就是通过反射获取到注解，然后进行相应的逻辑 4. 获取方法获取方法，同上面的差不多，也有四种方式 1234567891011// 根据方法名，参数类型获取公共方法Method getMethod(String name, Class[] params)// 获取所有的公共方法Method[] getMethods()// 根据方法名，参数类型，获取声明的方法（包括私有）Method getDeclaredMethod(String name, Class[] params)// 获取所有声明的方法Method[] getDeclaredMethods() 返回了一个Method类，那么这个东西又有一些什么功能？ 获取方法名 Method#getName() 获取方法所在的类 : Method#getDeclaringClass() 获取方法返回类型 : Method#getReturnType() 获取方法上的注解 : Method#getAnnotations() 执行方法 有了这个就可以做很多事情了，实例中给出说明 1234// 设置方法可访问（即私有方法也可以被调用）method.setAccessible(true);// instance为实例对象， args为传入参数method.invoke(instance, args) III. 实例DEMO通过反射的方式，实现一个 BeanUtils，实现Bean的拷贝 当一个Bean有较多的成员变量时，如果我们采用最原始的setXXX()来一次赋值的时候，一是实现比较繁琐，其次就是当Bean的字段发生变动之后，也需要同步的修改，那么我们借助反射的方式，实现一个优雅的 BeanUtils 工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BeanUtils &#123; public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125; &#125; private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; // 没有匹配到，这里返回null实际上是不合适的 // 因为如果原属性为基本数据类型，赋值null为报错 throw new Exception(); &#125;&#125; IV. 小结反射的四种用途 创建一个 RefectTest 对象 123456// 若有默认构造方法RefectTest instance = clz.newIntance();// 若需要传参数Constructor con = clz.getConstructor(int.class, boolean.class, RefectTest.class);RefectTest instance2 = con.newInstance(10, true, new RefectTest()); 判断父类是否是 MyRefect 12// 判断MyRefect是否为clz的父类boolean ans = MyRefect.class.isAssignableFrom(clz); 获取所有的成员变量 12// 获取所有的成员变量（包括私有的）Field[] fields = clz.getDeclaredFields(); 获取所有的方法 12// 获取所有的成员方法（包括私有方法）Method[] methods = clz.getDeclaredMethods(); 使用注意事项 操作私有变量，私有方法时，先设置field.setAccessible(true);确保可访问 反射会带来额外的性能开销 可以用 Class#isAssignableFrom() 来判断类继承关系 可以用 Class#isPrimitive()判断是否为基本数据类型 可以用 Class#getGenericSuperclass() 获取泛型类型 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"Reflect","slug":"Reflect","permalink":"https://zbang.online/hexblog/tags/Reflect/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"Centos 安装hexo博客","slug":"Centos-安装hexo博客","date":"2017-12-29T10:10:43.000Z","updated":"2018-04-02T07:43:56.847Z","comments":true,"path":"2017/12/29/Centos-安装hexo博客/","link":"","permalink":"https://zbang.online/hexblog/2017/12/29/Centos-安装hexo博客/","excerpt":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选","text":"Centos安装hexo博客根据官网来安装: hexo why hexo支持markdown，简单，主题可选 安装步骤12345678910## 1. nodejs安装sudo yum install nodejs## 2. 安装 hexosudo npm install -g hexo-clisudo npm install## 3. 创建hexohexo init xxxnpm install 测试验证 hexo server 使用说明1. 创建一个page执行下面的命令之后，就可以创建一个menu菜单 1hexo new page about 2. 新建一个博文1hexo new 'new blog' 新建一个草稿 12345hexo new draft '草稿博文'# 启动服务，预览草稿hexo server --drafts 3. 显示简介在md文件中，某一个地方地方添加 1&lt;!-- more --&gt; 则后面的内容都不会显示在首页了 4. 启动12345## 编译hexo g## 启动一个serverhexo s 5. deploy打开 _config.yml 文件，添加配置 1234deploy: type: git repository: https://github.com/liuyueyi/blogs.git branch: master 开始发布: 1hexo d -g 说明 如果github上，访问网页时，提示js或者css 404，则需要注意下面的配置 1234567# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://liuyueyi.github.io/hexblogroot: /hexblog/permalink: :year/:month/:day/:title/permalink_defaults: lang: zh-cn 其中URL，和root是关键的设置属性，root最后的/不能漏掉 如果提示git没有，则需要安装 1npm install hexo-deployer-git --save","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zbang.online/hexblog/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Nginx 路由转发配置笔记","slug":"Nginx-路由转发配置笔记","date":"2017-12-27T09:57:18.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/12/27/Nginx-路由转发配置笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/12/27/Nginx-路由转发配置笔记/","excerpt":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html）","text":"Nginx 路由转发配置笔记 由于预算有限，只有一台服务器，想要玩的东西不少，所以这个台服务器上会提供多重服务，因此涉及到的nginx转发就必有重要了 由nginx做请求代理，提供多种服务 php搭建的网站 hexo创建的博客系统 spring-boot &amp; tomcat搭建的后台 静态网页 本片配置笔记中，主要集中以下几个内容 location的匹配规则是怎样的 如何实现路由转发（反向代理） 如何修改请求的路径（如请求的是 a/index.html 改为 a/public/index.html） I. location匹配规则1. 语法123location [=|~|~*|^~|@] /uri/ &#123; ...&#125; 2. 说明从上面的语法出发，可以了解到location可以区分为三个部分，接下来一个一个的研究一下 a. PartOne: [=|~|~*|^~|@] = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 上面定义了几个不同的符号，表示不同的匹配规则，那么先后顺序呢？ =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 直接看这个可能不太好理解，写几个case实际测试一下 测试case1: 123456789101112131415location = /world &#123; return 600;&#125;location = /hello &#123; return 600;&#125;location ~ /hellowo &#123; return 602;&#125;location ^~ /hello &#123; return 601;&#125; 12345678- 请求 localhost/world 返回600- 请求 localhost/world2 localhost/test/world 返回其他- 请求 localhost/hello 返回600- 请求 localhost/hello/123 返回601- 请求 localhost/hellow 返回601- 请求 localhost/hellowo 返回601- 请求 localhost/test/hellowo 返回602- 请求 localhost/test/hello 返回其他 因此可以知道 = 是精确完整匹配, 且优秀最高 正则匹配时，如果 ~ 和 ^~ 同时匹配规则，则 ^~ 优先 ^~ 这个不会匹配请求url中后面的路径, 如上面的 /test/hello 没有匹配上 ^~ 不支持正则，和=相比，范围更广， hellowo 是可以被^~匹配，但是 = 不会匹配 ~ 路径中只要包含就可以匹配，如上面的 /test/hellowo 返回了602 测试case2: 1234567location ~ /hello &#123; return 602;&#125;location ~ /helloworld &#123; return 601;&#125; 12- 请求 localhost/world/helloworld 返回 602- 请求 localhost/helloworld 返回 602 调整一下上面的顺序之后 1234567location ~ /helloworld &#123; return 601;&#125;location ~ /hello &#123; return 602;&#125; 123- 请求 localhost/helloworld 返回601- 请求 localhost/world/helloworld 返回601- 请求 localhost/helloWorld 返回602 所以同时正则匹配时 放在前面的优先匹配 注意如果不区分大小写时，使用~* 尽量将精确匹配的放在前面 测试case3: 1234567location ^~ /hello/ &#123; return 601;&#125;location /hello/world &#123; return 602;&#125; 这种场景中，存在一个没有符号的路由规则，那么实际的测试是怎样呢？ 1234- http://localhost/hello/wor 返回601- http://localhost/hello/world 返回602- http://localhost/hello/world23 返回602- http://localhost/hello/world/123 返回602 从上面case可以看出 没有符号时，全匹配是优先于^~的 b. PartTwo: [uri]这里主要填的就是需要匹配的path路径，根据前面的符号，这里可以填写精确的path路径，也可以填正则表达式，下面则主要针对正则进行说明 123456789101112. ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的介绍&#123;n&#125; ： 重复n次&#123;n,&#125; ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 c. PartThree: {}匹配完毕之后内部定义一些列的处理动作，这个涉及到的点比较多，这里不详细展开，后面有空单独捞出 II. 路由转发 请求path匹配只是第一步，匹配完了之后，如何将请求转发给其他的web服务呢？ 0. 反向代理通常可见的一种使用姿势就是使用nginx，代理请求，转发到内部的tomact服务上 主要是通过 proxy_pass 这个来实现 123location ^~ /webs &#123; proxy_pass http://127.0.0.1:8080/webs;&#125; 将所有以 webs开头的请求，转发给8080端口的tomcat服务上 上面是直接写死转发到一个ip上，如果是多个机器提供服务呢？可以这么玩 12345678910## 下面放在http的括号内，作为第一层upstream test.online &#123; server 120.11.11.11:8080 weight=1; server 120.11.11.12:8080 weight=1;&#125;location ^~ /webs &#123; proxy_pass http://test.online; proxy_redirect default;&#125; 1. Rewrite命令rewrite功能就是，使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。 rewrite只能放在server{},location{},if{}中， 并且只能对域名后边的除去传递的参数外的字符串起作用, 如 http://zbang.online/a/we/index.php?id=1&amp;u=str 只对/a/we/index.php重写。 语法rewrite regex replacement [flag]; 一个case，通过rewrite实现对url的重写，将下面的 12345678location ^~ /hexo &#123; root &apos;/Users/yihui/GitHub/&apos;;&#125;location ~ /hello &#123; rewrite ^(/hello).*$ /hexo/public/index.html last; return 603;&#125; 将hello开头的，全部转发到/hexo/public/index.html III. 小结1. demo将所有以blog开头的请求，全部转发到某个地方 123location ^~ /blog &#123; root &apos;/var/www/html/blog&apos;;&#125; 2. 路径匹配规则 = : 表示精确匹配后面的url ~ : 表示正则匹配，但是区分大小写 ~* : 正则匹配，不区分大小写 ^~ : 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录 @ : “@” 定义一个命名的 location，使用在内部定向时，例如 error_page 匹配顺序如下： =前缀的指令严格匹配这个查询。如果找到，停止搜索。 所有剩下的常规字符串，最长的匹配。如果这个匹配使用^〜前缀，搜索停止。 正则表达式，在配置文件中定义的顺序。 如果第3条规则产生匹配的话，结果被使用。否则，使用第2条规则的结果。 3. 路由转发 通过 proxy_pass 可以实现反向代理 通过 rewrite 可以实现路由转发 IV. 参考 location匹配顺序 nginx 常见正则匹配符号表示 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如有问题，请不吝指正，感激 扫描关注，不定时分享各种java学习笔记","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://zbang.online/hexblog/tags/Nginx/"},{"name":"配置","slug":"配置","permalink":"https://zbang.online/hexblog/tags/配置/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"Nginx","slug":"技术/Shell/Nginx","permalink":"https://zbang.online/hexblog/categories/技术/Shell/Nginx/"}]},{"title":"Centos 安装gitbook","slug":"Centos-安装gitbook","date":"2017-12-25T03:26:00.000Z","updated":"2017-12-29T04:16:00.000Z","comments":true,"path":"2017/12/25/Centos-安装gitbook/","link":"","permalink":"https://zbang.online/hexblog/2017/12/25/Centos-安装gitbook/","excerpt":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务","text":"安装说明 主要记录在centos环境下如何搭建一个gitbook的服务 1. nodejs安装1sudo yum install nodejs 2. gitbook安装12npm install gitbook -gnpm install gitbook-cli -g 上面执行完毕，可能出现一个问题 1npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl 解决方法 1yum update openssl 3. calibre安装直接到官网上下载 ； ·https://calibre-ebook.com/download· 1sudo -v &amp;&amp; wget -nv -O- https://download.calibre-ebook.com/linux-installer.py | sudo python -c &quot;import sys; main=lambda:sys.stderr.write(&apos;Download failed\\n&apos;); exec(sys.stdin.read()); main()&quot; 4. 测试1gitbook build . 执行完毕之后，会出现一个 _book 目录， 里面就是生成的静态网页，直接加上去即可 5. 输出pdf如果报错 1ImportError: libGL.so.1: cannot open shared object file: No such file or directory 则安装 1yum install mesa-libGL.x86_64 如果报错 1ImportError: libXrender.so.1: cannot open shared object file: No such file or directory 1yum install libXrender.so.1 -y 参考文档 基于centos6构建私有gitbook平台","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"Gitbook","slug":"Gitbook","permalink":"https://zbang.online/hexblog/tags/Gitbook/"},{"name":"Centos","slug":"Centos","permalink":"https://zbang.online/hexblog/tags/Centos/"},{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","slug":"Java学习之深拷贝浅拷贝及对象拷贝的两种方式","date":"2017-12-17T11:53:51.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/Java学习之深拷贝浅拷贝及对象拷贝的两种方式/","excerpt":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来","text":"I. Java之Clone0. 背景对象拷贝，是一个非常基础的内容了，为什么会单独的把这个领出来讲解，主要是先前遇到了一个非常有意思的场景 有一个任务，需要解析类xml标记语言，然后生成document对象，之后将会有一系列针对document对象的操作 通过实际的测试，发现生成Document对象是比较耗时的一个操作，再加上这个任务场景中，需要解析的xml文档是固定的几个，那么一个可以优化的思路就是能不能缓存住创建后的Document对象，在实际使用的时候clone一份出来 1. 内容说明看到了上面的应用背景，自然而言的就会想到深拷贝了，本篇博文则主要内容如下 介绍下两种拷贝方式的区别 深拷贝的辅助工具类 如何自定义实现对象拷贝 II. 深拷贝和浅拷贝0. 定义说明深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 看到上面两个简单的说明，那么问题来了 浅拷贝中，是所有的内容公用呢？还是某些内容公用？ 从隔离来将，都不希望出现浅拷贝这种方式了，太容易出错了，那么两种拷贝方式的应用场景是怎样的？ 1. 浅拷贝一般来说，浅拷贝方式需要实现Cloneable接口，下面结合一个实例，来看下浅拷贝中哪些是独立的，哪些是公用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Datapublic class ShallowClone implements Cloneable &#123; private String name; private int age; private List&lt;String&gt; books; public ShallowClone clone() &#123; ShallowClone clone = null; try &#123; clone = (ShallowClone) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125; public static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(28); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.clone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(20); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); &#125;&#125; 输出结果: 12345falsesource: ShallowClone(name=newName, age=20, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript])source: ShallowClone(name=newName, age=20, books=[hello])clone:ShallowClone(name=SourceName, age=28, books=[java, c++, javascript]) 结果分析： 拷贝后获取的是一个独立的对象，和原对象拥有不同的内存地址 基本元素类型，两者是隔离的（虽然上面只给出了int，String） 基本元素类型包括: int, Integer, long, Long, char, Charset, byte,Byte, boolean, Boolean, float,Float, double, Double, String 非基本数据类型（如基本容器，其他对象等），只是拷贝了一份引用出去了，实际指向的依然是同一份 其实，浅拷贝有个非常简单的理解方式： 浅拷贝的整个过程就是，创建一个新的对象，然后新对象的每个值都是由原对象的值，通过 = 进行赋值 这个怎么理解呢？ 上面的流程拆解就是： 1234- Object clone = new Object();- clone.a = source.a- clone.b = source.b- ... 那么=赋值有什么特点呢？ 基本数据类型是值赋值；非基本的就是引用赋值 2. 深拷贝深拷贝，就是要创建一个全新的对象，新的对象内部所有的成员也都是全新的，只是初始化的值已经由被拷贝的对象确定了而已 那么上面的实例改成深拷贝应该是怎样的呢？ 可以加上这么一个方法 1234567891011121314151617181920212223242526272829303132333435363738public ShallowClone deepClone() &#123; ShallowClone clone = new ShallowClone(); clone.name = this.name; clone.age = this.age; if (this.books != null) &#123; clone.books = new ArrayList&lt;&gt;(this.books); &#125; return clone;&#125;// 简单改一下测试casepublic static void main(String[] args) &#123; ShallowClone shallowClone = new ShallowClone(); shallowClone.setName(\"SourceName\"); shallowClone.setAge(new Integer(1280)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"java\"); list.add(\"c++\"); shallowClone.setBooks(list); ShallowClone cloneObj = shallowClone.deepClone(); // 判断两个对象是否为同一个对象（即是否是新创建了一个实例） System.out.println(shallowClone == cloneObj); // 修改一个对象的内容是否会影响另一个对象 shallowClone.setName(\"newName\"); shallowClone.setAge(2000); shallowClone.getBooks().add(\"javascript\"); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString()); shallowClone.setBooks(Arrays.asList(\"hello\")); System.out.println(\"source: \" + shallowClone.toString() + \"\\nclone:\" + cloneObj.toString());&#125; 输出结果为： 12345falsesource: ShallowClone(name=newName, age=2000, books=[java, c++, javascript])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++])source: ShallowClone(name=newName, age=2000, books=[hello])clone:ShallowClone(name=SourceName, age=1280, books=[java, c++]) 结果分析： 深拷贝独立的对象 拷贝后对象的内容，与原对象的内容完全没关系，都是独立的 简单来说，深拷贝是需要自己来实现的，对于基本类型可以直接赋值，而对于对象、容器、数组来讲，需要创建一个新的出来，然后重新赋值 3. 应用场景区分深拷贝的用途我们很容易可以想见，某个复杂对象创建比较消耗资源的时候，就可以缓存一个蓝本，后续的操作都是针对深clone后的对象，这样就不会出现混乱的情况了 那么浅拷贝呢？感觉留着是一个坑，一个人修改了这个对象的值，结果发现对另一个人造成了影响，真不是坑爹么？ 假设又这么一个通知对象长下面这样 12345private String notifyUser;// xxxprivate List&lt;String&gt; notifyRules; 我们现在随机挑选了一千个人，同时发送通知消息，所以需要创建一千个上面的对象，这些对象中呢，除了notifyUser不同，其他的都一样 在发送之前，突然发现要临时新增一条通知信息，如果是浅拷贝的话，只用在任意一个通知对象的notifyRules中添加一调消息，那么这一千个对象的通知消息都会变成最新的了；而如果你是用深拷贝，那么苦逼的得遍历这一千个对象，每个都加一条消息了 III. 对象拷贝工具上面说到，浅拷贝，需要实现Clonebale接口，深拷贝一般需要自己来实现，那么我现在拿到一个对象A，它自己没有提供深拷贝接口，我们除了主动一条一条的帮它实现之外，有什么辅助工具可用么？ 对象拷贝区别与clone，它可以支持两个不同对象之间实现内容拷贝 Apache的两个版本：（反射机制） 1234org.apache.commons.beanutils.PropertyUtils.copyProperties(Object dest, Object orig)org.apache.commons.beanutils.BeanUtils#cloneBean Spring版本：（反射机制） 1org.springframework.beans.BeanUtils.copyProperties(Object source, Object target, Class editable, String[] ignoreProperties) cglib版本：（使用动态代理，效率高） 1net.sf.cglib.beans.BeanCopier.copy(Object paramObject1, Object paramObject2, Converter paramConverter) 从上面的几个有名的工具类来看，提供了两种使用者姿势，一个是反射，一个是动态代理，下面分别来看两种思路 1. 借助反射实现对象拷贝通过反射的方式实现对象拷贝的思路还是比较清晰的，先通过反射获取对象的所有属性，然后修改可访问级别，然后赋值；再获取继承的父类的属性，同样利用反射进行赋值 上面的几个开源工具，内部实现封装得比较好，所以直接贴源码可能不太容易一眼就能看出反射方式的原理，所以简单的实现了一个, 仅提供思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void copy(Object source, Object dest) throws Exception &#123; Class destClz = dest.getClass(); // 获取目标的所有成员 Field[] destFields = destClz.getDeclaredFields(); Object value; for (Field field : destFields) &#123; // 遍历所有的成员，并赋值 // 获取value值 value = getVal(field.getName(), source); field.setAccessible(true); field.set(dest, value); &#125;&#125;private static Object getVal(String name, Object obj) throws Exception &#123; try &#123; // 优先获取obj中同名的成员变量 Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); return field.get(obj); &#125; catch (NoSuchFieldException e) &#123; // 表示没有同名的变量 &#125; // 获取对应的 getXxx() 或者 isXxx() 方法 name = name.substring(0, 1).toUpperCase() + name.substring(1); String methodName = \"get\" + name; String methodName2 = \"is\" + name; Method[] methods = obj.getClass().getMethods(); for (Method method : methods) &#123; // 只获取无参的方法 if (method.getParameterCount() &gt; 0) &#123; continue; &#125; if (method.getName().equals(methodName) || method.getName().equals(methodName2)) &#123; return method.invoke(obj); &#125; &#125; return null;&#125; 上面的实现步骤还是非常清晰的，首先是找同名的属性，然后利用反射获取对应的值 123Field field = obj.getClass().getDeclaredField(name);field.setAccessible(true);return field.get(obj); 如果找不到，则找getXXX, isXXX来获取 2. 代理的方式实现对象拷贝Cglib的BeanCopier就是通过代理的方式实现拷贝，性能优于反射的方式，特别是在大量的数据拷贝时，比较明显 代理，我们知道可以区分为静态代理和动态代理，简单来讲就是你要操作对象A，但是你不直接去操作A，而是找一个中转porxyA, 让它来帮你操作对象A 那么这种技术是如何使用在对象拷贝的呢？ 我们知道，效率最高的对象拷贝方式就是Getter/Setter方法了，前面说的代理的含义指我们不直接操作，而是找个中间商来赚差价，那么方案就出来了 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy 在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 实际上BeanCopier的思路大致如上，具体的方案当然就不太一样了, 简单看了一下实现逻辑，挺有意思的一块，先留个坑，后面单独开个博文补上 说明 从实现原理和通过简单的测试，发现BeanCopier是扫描原对象的getXXX方法，然后赋值给同名的 setXXX 方法，也就是说，如果这个对象中某个属性没有get/set方法，那么就无法赋值成功了 IV. 小结1. 深拷贝和浅拷贝深拷贝 相当于创建了一个新的对象，只是这个对象的所有内容，都和被拷贝的对象一模一样而已，即两者的修改是隔离的，相互之间没有影响 完全独立 浅拷贝 也是创建了一个对象，但是这个对象的某些内容（比如A）依然是被拷贝对象的，即通过这两个对象中任意一个修改A，两个对象的A都会受到影响 等同与新创建一个对象，然后使用=，将原对象的属性赋值给新对象的属性 需要实现Cloneable接口 2. 对象拷贝的两种方法通过反射方式实现对象拷贝 主要原理就是通过反射获取所有的属性，然后反射更改属性的内容 通过代理实现对象拷贝 将原SourceA拷贝到目标DestB 创建一个代理 copyProxy在代理中，依次调用 SourceA的get方法获取属性值，然后调用DestB的set方法进行赋值 V. 其他声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见解不全，如有问题，欢迎批评指正 扫描关注，java分享","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"clone","slug":"clone","permalink":"https://zbang.online/hexblog/tags/clone/"},{"name":"beancopy","slug":"beancopy","permalink":"https://zbang.online/hexblog/tags/beancopy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"JDK","slug":"技术/Java/JDK","permalink":"https://zbang.online/hexblog/categories/技术/Java/JDK/"}]},{"title":"图片合成支持的前世今生","slug":"图片合成支持的前世今生","date":"2017-12-17T09:50:31.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2017/12/17/图片合成支持的前世今生/","link":"","permalink":"https://zbang.online/hexblog/2017/12/17/图片合成支持的前世今生/","excerpt":"图片合成的前世今生 作为一个后端，为什么要做图片合成？为什么要实现类xml标记语言的渲染？ 本片博文准备详细的记录一下，一个java后端如何去支持图片合成，在这个过程中采用了哪些猥琐的方案，又遇到了哪些鬼畜的问题","text":"图片合成的前世今生 作为一个后端，为什么要做图片合成？为什么要实现类xml标记语言的渲染？ 本片博文准备详细的记录一下，一个java后端如何去支持图片合成，在这个过程中采用了哪些猥琐的方案，又遇到了哪些鬼畜的问题 I. 背景0. 无聊的技术研究最开始萌发支持图片合成的想法，那时候还是在做二维码的时候，用了一些awt的画图工具，感觉还挺有意思的，这是一个和当前的电商主流完全不搭边的技术分支，开始用的时候感慨，这东西牛逼了，什么都可以干（虽然操作非常不友好），再加上用到有道云，它的会员功能支持加功能将笔记以图片方式生成，所以就有个想法，java后端能不能支持markdown输出图片呢？ 1. 蛋疼的小程序不是一个专业的小程序开发者，虽然写过一个小程序，但是很多特性依然不知道； 突然很多前端突然提了这么一个需求，要求后端支持图片合成，用于分享到朋友圈 至于原因: 有的说小程序没有提供截屏接口 小程序不支持绘图（这个我不太确定真实性） 小程序绘图的api不可控（如果他们有bug，我们就没法玩了；对此我的看法是，你整个东西都是在小程序的体系里了，要是有个严重bug，那我们的小程序干脆就不玩好了…） 前端这么多，每个人都去绘制一遍低效，有个后端通用的，各个平台都释放了，都可以直接用… (对此我也没啥好说的，如果我是前端我也挺这一点；然而我不是，所以我拒绝😢) 声明 上面括号的内容纯粹是个人吐槽，没有任何偏向性， 2. 开动有需求了，就必须去支持了，而且从技术角度出发，这是一个非常有意思的点，新的挑战，可以一试 II. 技术尝试为了支持这个需求，尝试了不少的手段，接下来一一说明，当然由于个人见识有限，最终选择的也不一定是啥好东西，目前也只是处于可用的状态，离友好支持，还比较遥远 0. java的html渲染库 最先想到的就是这个，有没有直接可以渲染的库，大Java号称是在github上拥有最多开源工具的语言 查了一些开源库，也主动去尝试过一些，下面给出使用姿势 a. html2image直接在Github上搜，找一个最多star的就可以了，测试的框架 java-html2image 接入及测试方式 pmo 依赖引入 12345678910111213&lt;dependency&gt; &lt;groupId&gt;gui.ava&lt;/groupId&gt; &lt;artifactId&gt;html2image&lt;/artifactId&gt; &lt;version&gt;0.9&lt;/version&gt;&lt;/dependency&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;yoava&lt;/id&gt; &lt;name&gt;AOL yoava&lt;/name&gt; &lt;url&gt;http://yoava.artifactoryonline.com/yoava/repo&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 测试代码也比较简单 123456789@Testpublic void testRenderHtml() &#123; String url = \"http://www.baidu.com\"; HtmlImageGenerator generator = new HtmlImageGenerator(); generator.loadUrl(url); BufferedImage img = generator.getBufferedImage(); System.out.println(\"---\");&#125; 接下来就是看输出的图片了，看下是否和我们预期相同 这个颜色，样式有点鬼畜，折腾了一番，实际验证这个框架挺不错的，就是有以下几个问题 很久很久很久很久很久以前的产物了 没人维护 css样式支持不友好 换个复杂点的url，比如淘宝or蘑菇街商品详情页，返回就更鬼畜了，有兴趣的童鞋可自己尝试一下 b. xhtml渲染包这个也可以实现html渲染，又是一个老古董级别的东西，已经忘记从哪里捞出来的，最初实现markdown渲染成图片，就是采用的这个包，对简单的css的支持还算友好 pom依赖 12345678910111213&lt;!--html to image render--&gt;&lt;dependency&gt; &lt;groupId&gt;org.xhtmlrenderer&lt;/groupId&gt; &lt;artifactId&gt;core-renderer&lt;/artifactId&gt; &lt;version&gt;R8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt; &lt;artifactId&gt;nekohtml&lt;/artifactId&gt; &lt;version&gt;1.9.14&lt;/version&gt;&lt;/dependency&gt;&lt;!--html to image render--&gt; 测试case 12345678910@Testpublic void testRender() &#123; try &#123; String url = \"http://www.baidu.com\"; BufferedImage buf = ImageRenderer.renderToImage(url, \"/Users/yihui/html2image.pdf\", 800); System.out.println(\"---\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用起来还是比较简单的，但是，上面这种直接执行，会抛异常，说访问的html有些语法有问题; 然后做了一些修改和调整，修正后的测试代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private static DOMParser domParser;static &#123; domParser = new DOMParser(new HTMLConfiguration()); try &#123; domParser.setProperty(\"http://cyberneko.org/html/properties/names/elems\", \"lower\"); &#125; catch (Exception e) &#123; throw new RuntimeException(\"Can't create HtmlParserImpl\", e); &#125;&#125;private Document parseDocument(String content) throws Exception &#123; domParser.parse(new InputSource(new StringReader(content))); return domParser.getDocument();&#125;private String readHtmlContent(String url) throws Exception &#123; InputStream in = HttpUtil.downFile(url); StringBuilder out = new StringBuilder(); byte[] b = new byte[4096]; for (int n; (n = in.read(b)) != -1; ) &#123; out.append(new String(b, 0, n)); &#125; return out.toString();&#125;@Testpublic void testRender() &#123; try &#123; String url = \"http://www.baidu.com\"; Document doc = parseDocument(readHtmlContent(url)); int width = 800; int height = 1024; Graphics2DRenderer renderer = new Graphics2DRenderer(); renderer.setDocument(doc, doc.getDocumentURI()); BufferedImage bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics2D graphics2D = GraphicUtil.getG2d(bufferedImage); // do layout with temp buffer renderer.layout(graphics2D, new Dimension(width, height)); graphics2D.dispose(); Rectangle size = renderer.getMinimumSize(); final int autoWidth = width; final int autoHeight = (int) size.getHeight(); bufferedImage = new BufferedImage(autoWidth, autoHeight, BufferedImage.TYPE_INT_RGB); Dimension dimension = new Dimension(autoWidth, autoHeight); graphics2D = GraphicUtil.getG2d(bufferedImage); renderer.layout(graphics2D, dimension); renderer.render(graphics2D); graphics2D.dispose(); System.out.println(\"---------\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 结果输出图片为空白的页面，为啥？ 仔细去看百度的网页，发现没有dom结构，一堆的js和css代码，换个本地的html来试一下，输出效果还不错，我之前做了一个小工具，实现markdown转image，就是用的这个框架做中转，将markdown生成的html渲染为图片，当然复杂一点的css就不行了 相信看到这里，这个库的缺陷也好很明显了，不适合生产环境，自己玩玩还行 过于古老，基本没人维护 对html的格式有要求 复杂的css没法玩 指定宽度也比较恶心 c. 借助转pdf的包java中，提供html转pdf的包还不少，借助这些工具，也是可以间接实现这个功能的，具体的就不贴了，可以用的不少，收钱的，免费的都有 推荐几个搞标记的 flyingsaucer openhtmltopdf itext d. 小结基本上，没有找到合乎心意的转换包，其实有些包也不错，如果深入进去改一波，应该也能使用，然实际就是深入进去，基本上挖不动 1. imagemagic的合成大名鼎鼎的图片处理工具，c++的，可以提供图片的各种姿势的操作，当然也包括了图片合成，要玩这个，首先得搭建这个环境（这个成本比上面会大一点） a. 环境准备简单搭建方式： 12345678yum install libjpeg-develyum install libpng-devel# 本地环境搭建sudo brew install jpegsudo brew install libpngsudo brew install GraphicsMagick 搭建完毕后，测试先是否可用 1234## 搭建完毕，开始测试gm convert input.jpg -thumbnail &apos;100x100&apos; output_1.jpggm convert -crop 640x960+0+0 test.jpg output.jpg 如果上面的搞不定，也可以用下面的下载包的方式安装 12345678910111213141516安装jpeg 包 `wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz`安装webp 包 `wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz`安装png 包 `wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz`安装 graphicsmagick `wget http://nchc.dl.sourceforge.net/project/graphicsmagick/graphicsmagick/1.3.22/GraphicsMagick-1.3.22.tar.gz`## ----------make distclean ## 清楚上次make的东西imagemagick ：`wget http://www.imagemagick.org/download/ImageMagick.tar.gz`安装命令 `sudo ./configure; sudo make; sudo make install`裁图命令 `convert test.jpg -crop 640x960+0+0 output.jpg` linux 安装imagemagick 发现一直找不到 png的依赖， linux 安装之后，可能有两个问题 imagemagick 依然无法读取png图片 查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz 执行 convert 提示linux shared libraries 不包含某个库 临时解决方案： export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 一劳永逸的方案：https://my.oschina.net/guanyue/blog/220264 vi /etc/ld.so.conf 在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置 然后再执行/sbin/ldconf b. java调用当然，我们是java的后端，现在就需要用java来调用imagemagic的执行了 依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.im4java&lt;/groupId&gt; &lt;artifactId&gt;im4java&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 下面给一个图片裁剪的测试 123456789101112131415161718192021222324252627282930313233/** * 裁剪图片 * * @param imagePath 源图片路径 * @param outPath 处理后图片路径 * @param x 起始X坐标 * @param y 起始Y坐标 * @param width 裁剪宽度 * @param height 裁剪高度 * @return 返回true说明裁剪成功, 否则失败 */public static boolean cut(String imagePath, String outPath, int x, int y, int width, int height) &#123; boolean flag; try &#123; IMOperation op = new IMOperation(); op.addImage(imagePath); /** width：裁剪的宽度 * height：裁剪的高度 * x：裁剪的横坐标 * y：裁剪纵坐标 */ op.crop(width, height, x, y); op.addImage(outPath); // 传true到构造函数中,则表示使用GraphicMagic, 裁图时,图片大小会变 ConvertCmd convert = new ConvertCmd(); convert.run(op); flag = true; &#125; catch (IOException e) &#123; flag = false; &#125; catch (InterruptedException e) &#123; flag = false; &#125; catch (IM4JavaException e) &#123; flag = false; &#125; return flag;&#125; 具体使用姿势就不说了，这个框架本身是支持简单的图片合成的，几张图和一下，加上文字水印啥的，主要说一下有什么问题 图片合成参数不是一般的复杂，想实现一个模板的合成，这个命令可以说很难完美的写出来 性能一般般 总得来说，这个用来做图片的基本操作还很好，真心不太合适复杂点的图片合成，分分钟虐哭 c. 其他一些不得不说的故事说到imagemagic，就不得不说graphicmagic，两者基本差不多，有说法是 graphicmagic的性能要高与imagemagic，那么我们为什么选择 imagemagic graphicmagic 处理jpg图片，会有精度丢失的问题（不知道是不是我的使用姿势不对，同样的case，imagemagic不会） 公司的基线是支持imagemagic的 很久以前写了一篇博文，就是如何利用 imagegraphic 搭建一个图片处理服务器的 im4java + imagemagic 搭建一个图片处理服务 2. awt的绘制利用java的awt包，也是可以实现绘图的，而且功能也比较强大，完全可以实现各种姿势的绘图场景, 一个case如 : 上面这个图的合成，就是基于awt做到的，这一张图，我们需要做些什么？ 图片的绘制 圆角图片 文字输出 文字对其方式 直线 矩形 纯色背景 一般来将，上面几种场景的支持，可以满足绝大多数的合图要求，接下来看一下是如何支持上面的几种case的 o. 接口定义定义一个基本的绘图单元接口 12public interface IDrawBO &#123;&#125; a. 图片 ： ImgBO图片的定义比较简单，一般只需要知道坐标，和宽高就ok了，所以我们的定义如下 123456789101112131415@Data@NoArgsConstructor@AllArgsConstructorpublic class ImgBO implements IDrawBO &#123; private BufferedImage image; private int x; private int y; private int w; private int h;&#125; b. 文字：FontBO文字相比较图片就有些额外的区别，有字体，样式、颜色，坐标，删除线 1234567891011121314151617@Data@NoArgsConstructor@AllArgsConstructorpublic class FontBO implements IDrawBO &#123; private String msgs; private Font font; private Color color; private int x; private int y; private boolean deleted = false;&#125; c. 直线: LineBO直线，除了我们常规的起点坐标，末尾坐标之外，颜色的设置，虚线样式也是常见的属性 123456789101112131415161718192021222324@Datapublic class LineBO implements IDrawBO &#123; public static final Stroke DEFAULT_STROKE = new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 3.5f, new float[]&#123;12, 6, 6, 6&#125;, 0f); private Color color; private int x1; private int y1; private int x2; private int y2; /** * 是否是虚线 */ private boolean dashed;&#125; d. 矩形： RoundRectBO和直线的属性差不多, 但是会多一些有意思的东西，如是否为圆角矩形 1234567891011121314151617181920212223242526272829public class RoundRectBO implements IDrawBO &#123; public static final Stroke DEFAULT_DASH = new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 3.5f, new float[]&#123;4, 2,&#125;, 0f); private int x; private int y; private int w; private int h; private Color color; /** * 是否为虚线 */ private boolean dashed; /** * 圆角弧度 */ private int radius;&#125; e. 纯色： ColorBgBO纯色背景，相比较其他的会多一个透明度的属性，主要是因为很多场景下，会做一层纯色的浮层 1234567891011121314151617@Datapublic class ColorBgBO implements IDrawBO &#123; private Color color; private int w; private int h; private int x; private int y; private int radius; private boolean transparence;&#125; 上面定义了这些BO对象，仅仅是定义又什么用？接下来就需要实现对BO对象的绘制，也是核心的逻辑层了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * Created by yihui on 2017/9/21. */public interface IShareModule &#123; void draw(Graphics2D g2d); default void drawFont(Graphics2D g2d, FontBO fontBo) &#123; if (fontBo != null) &#123; g2d.setFont(fontBo.getFont()); g2d.setColor(fontBo.getColor()); g2d.drawString(fontBo.getMsgs(), fontBo.getX(), fontBo.getY()); if (fontBo.isDeleted()) &#123; // 删除时，需要在文字上绘制一条删除线 FontMetrics fontMetrics = FontUtil.getFontMetric(fontBo.getFont()); int y = fontBo.getY() - (fontBo.getFont().getSize() &gt;&gt; 1) + fontMetrics.getDescent(); int w = fontMetrics.stringWidth(fontBo.getMsgs()); g2d.drawLine(fontBo.getX(), y, fontBo.getX() + w, y); &#125; &#125; &#125; default void drawImage(Graphics2D g2d, ImgBO imgBo) &#123; if (imgBo != null) &#123; g2d.drawImage(imgBo.getImage(), imgBo.getX(), imgBo.getY(), imgBo.getW(), imgBo.getH(), null); &#125; &#125; default void drawLine(Graphics2D g2d, LineBO lineBO) &#123; if(lineBo == null) return; g2d.setColor(lineBO.getColor()); if (lineBO.isDashed()) &#123; Stroke stroke = g2d.getStroke(); g2d.setStroke(LineBO.DEFAULT_STROKE); g2d.drawLine(lineBO.getX(), lineBO.getY(), lineBO.getX() + lineBO.getW(), lineBO.getY()); g2d.setStroke(stroke); &#125; else &#123; g2d.drawLine(lineBO.getX(), lineBO.getY(), lineBO.getX() + lineBO.getW(), lineBO.getY()); &#125; &#125; default void drawRoundRect(Graphics2D g2d, RoundRectBO roundRectBO) &#123; if(roundRectBO == null) return; g2d.setColor(roundRectBO.getColor()); if (!roundRectBO.isDashed()) &#123; g2d.drawRoundRect(roundRectBO.getX(), roundRectBO.getY(), roundRectBO.getW(), roundRectBO.getH(), roundRectBO.getRadius(), roundRectBO.getRadius()); &#125; else &#123; Stroke stroke = g2d.getStroke(); g2d.setStroke(RoundRectBO.DEFAULT_DASH); g2d.drawRoundRect(roundRectBO.getX(), roundRectBO.getY(), roundRectBO.getW(), roundRectBO.getH(), roundRectBO.getRadius(), roundRectBO.getRadius()); g2d.setStroke(stroke); &#125; if (roundRectBO.getSpaceW() &gt; 0) &#123; // 上边距空白的宽度 int x = roundRectBO.getX() + (roundRectBO.getW() - roundRectBO.getSpaceW() &gt;&gt; 1); int y = roundRectBO.getY() - 2; int w = roundRectBO.getSpaceW(); int h = 4; g2d.setColor(roundRectBO.getSpaceColor()); g2d.fillRect(x, y, w, h); &#125; &#125; default void drawColorBG(Graphics2D g2d, ColorBgBO color) &#123; if(color == null) return; g2d.setColor(color.getColor()); Composite composite = null; if (color.isTransparence()) &#123; composite = g2d.getComposite(); g2d.setComposite(AlphaComposite.Src); &#125; if (color.getRadius() == 0) &#123; g2d.fillRect(color.getX(), color.getY(), color.getW(), color.getH()); &#125; else &#123; g2d.fill(new RoundRectangle2D.Float(color.getX(), color.getY(), color.getW(), color.getH(), color.getRadius(), color.getRadius())); &#125; if (color.isTransparence()) &#123; g2d.setComposite(composite); &#125; &#125;&#125; 上面配合起来使用，就可以实现基本的模板图片的合成需求了，当然我们提供的服务比上面列出的要丰富一些，我们还支持 图片的处理：圆角，裁剪贴图 文字对齐：三种对齐方式，自动换行 小结&amp;问题上面虽然说可以支持合图的需求，但有个最大的问题，就是对后端的工作太多，每个模板，都需要后端来配合，进行参数指定，联调，极其繁琐和费时费力，分分钟搞死人 对这种方式，想的一个方法是，采用搭积木的方式支持，事先定义一系列的基本绘图组建，然后前端自己填入参数来组装 当然没有做，原因也很简单，接口太复杂，对前端不友好，没人愿意这么用，换成我也是不想这么干的 3. html 转 图片接着又来的是一个猥琐的方案，html转图，到github上一搜，发现还是js靠谱，比较多，一种常见的思路是： 采用无界面浏览器加载html页面，然后截图 在无界面浏览器中，非常有名的是 phantomjs，以及后起之秀chrome，这里主要说一下phantomjs的接入方式，简单提起chrmoe的无界面使用方式 a. 环境准备phantomjs 安装 12345678910111213141516171819202122232425262728293031# 1. 下载## mac 系统wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-macosx.zip## linux 系统wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2## windows 系统## 就不要玩了，没啥意思# 2. 解压sudo su tar -jxvf phantomjs-2.1.1-linux-x86_64.tar.bz2# 如果解压报错，则安装下面的# yum -y install bzip2# 3. 安装## 简单点，移动到bin目录下cp phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin# 4. 验证是否okphantomjs --version# 输出版本号，则表示ok pom依赖 1234567891011121314151617181920&lt;!--phantomjs --&gt;&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.53.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.detro&lt;/groupId&gt; &lt;artifactId&gt;ghostdriver&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; b. 实测思路比较清晰，在服务器上搭建一个phantomjs服务，然后java来调用，主要借助的是selenium和ghostdriver两个开源包，额外提一句，selenium在自动化测试和爬虫使用中非常有名，有兴趣的可以自己搜索相关资料，非常有意思的一个东西 图片渲染的主要业务逻辑： 12345678910111213141516171819202122232425262728public class Html2ImageByJsWrapper &#123; private static PhantomJSDriver webDriver = getPhantomJs(); private static PhantomJSDriver getPhantomJs() &#123; //设置必要参数 DesiredCapabilities dcaps = new DesiredCapabilities(); //ssl证书支持 dcaps.setCapability(&quot;acceptSslCerts&quot;, true); //截屏支持 dcaps.setCapability(&quot;takesScreenshot&quot;, true); //css搜索支持 dcaps.setCapability(&quot;cssSelectorsEnabled&quot;, true); //js支持 dcaps.setJavascriptEnabled(true); //驱动支持（第二参数表明的是你的phantomjs引擎所在的路径，which/whereis phantomjs可以查看） // fixme 这里写了执行， 可以考虑判断系统是否有安装，并获取对应的路径 or 开放出来指定路径 dcaps.setCapability(PhantomJSDriverService.PHANTOMJS_EXECUTABLE_PATH_PROPERTY, &quot;/usr/local/bin/phantomjs&quot;); //创建无界面浏览器对象 return new PhantomJSDriver(dcaps); &#125; public static BufferedImage renderHtml2Image(String url) throws IOException &#123; webDriver.get(url); File file = webDriver.getScreenshotAs(OutputType.FILE); return ImageIO.read(file); &#125;&#125; 那么测试case就很好写了 12345@Testpublic void testRender() throws IOException &#123; String url = &quot;https://www.baidu.com&quot;; BufferedImage img = Html2ImageByJsWrapper.renderHtml2Image(url);&#125; 输出图片 看到这个结果之后，是否会觉得已经完美了？ 然而并不是，测试一些需要异步请求的接口，比较渣，性能差，返回的样式会错乱 c. 分析小结这个方案从实现来讲，是没有什么问题的，从支持情况来说，问题其实也不太大，那为什么不用这个方案呢？ 这个方案的支持，原本我的希望是前端传给我们需要渲染的html 是直出好的页面 所有的dom结构已经很清晰了， 尽量不要有什么js， 不要有异步请求， 不要又复杂的css依赖， 没有大量的图片 然而事与愿违，至于为什么不实现这样的html，我也不太懂前端的技术难点在哪，不好多评，那么也就只好转方案了 还有一点，对这个方案我不太满意的就是性能太渣，而且我也不知道可以怎么去优化，简单来讲，就是这个js渲染，完全不在我的把控之内，有什么问题、如何去优化、如何防止ssrf攻击，我都没有好的解决办法，所以我本人也是不喜欢这个方案的 d. chrome 方式chrome浏览器，大家都知道，chrome还有一种无界面启动方式，可能知道的比较少了 只要你本机安装了chrome浏览器，打开控制台就可以愉快的玩耍了，html输出图片的指令为 12345## 输出pdf/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --headless --print-to-pdf http://www.baidu.com## 输出图片/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --headless --screenshot http://www.baidu.com 输出截图 说明 chrome headless有很多指令，可设置窗口的大小解决上面的边框问题，有兴趣的可以百度 4. svg 转 图片然后万能的前端同学又提出了svg渲染图片，在提这个之前，完全没接触过svg，也不知道svg是个什么鬼，更不知道svg能不能渲染出图片（最重要的是java有没有现成可用的库） 查了一番，不错，发现apace有个batik，就是干这个事情的 插播一句，感觉无论多偏的东西，apache或者是google都至少有那么一个可以支持的开源项目，虽然有不少都已经不怎么维护了 a. 依赖整理依赖包有那么点多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!--batik svg to image--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-svggen&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-bridge&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-dom&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;xalan&lt;/groupId&gt; &lt;artifactId&gt;xalan&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-parser&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-svg-dom&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-transcoder&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-util&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-xml&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.xmlgraphics/xmlgraphics-commons --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;xmlgraphics-commons&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.xmlgraphics/batik-codec --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.xmlgraphics&lt;/groupId&gt; &lt;artifactId&gt;batik-codec&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt;&lt;/dependency&gt; &lt;!-- 此处不能使用2.9.1版本，使用2.9.1生成png会失败 --&gt;&lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;xerces&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;xercesImpl&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;2.5.0&lt;/version&gt;--&gt;&lt;!--&lt;/dependency&gt;--&gt;&lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xmlParserAPIs&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.axsl.org.w3c.dom.svg&lt;/groupId&gt; &lt;artifactId&gt;svg-dom-java&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;xml-apis&lt;/groupId&gt; &lt;artifactId&gt;xml-apis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.w3c.css&lt;/groupId&gt; &lt;artifactId&gt;sac&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt; b. 实测一个简单的接口支持 12345678910111213141516171819202122232425262728293031323334public static void convertToPngByFile(String path, OutputStream outputStream, Map&lt;String, String&gt; parmMap) throws TranscoderException, IOException &#123; try &#123; // 1. 加载document File file = new File(path); String parser = XMLResourceDescriptor.getXMLParserClassName(); SAXSVGDocumentFactory f = new SAXSVGDocumentFactory(parser); Document doc = f.createDocument(file.toURI().toString()); // 2. 遍历参数，填充渲染的svg节点 Set&lt;String&gt; keySet = parmMap.keySet(); for (Map.Entry&lt;String, String&gt; entry : parmMap.entrySet()) &#123; doc.getElementById(entry.getKey()).setTextContent(entry.getValue()); &#125; // 3. 输出图片 PNGTranscoder t = new PNGTranscoder(); TranscoderInput input = new TranscoderInput(doc); TranscoderOutput output = new TranscoderOutput(outputStream); t.transcode(input, output); outputStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 上面主要是为了演示下使用姿势，实际的项目中肯定不会这么简陋，官方使用链接: https://xmlgraphics.apache.org/batik/using/transcoder.html 分析下主要流程 解析svg文件，加载Document对象 根据传入的参数，填充Document中的节点 渲染输出图片 测试演示就不来了，最终方案就是这个，成品也没啥好说的 c. 问题 文本的边框支持问题: 即 outline属性 测试了好久，发现不支持这个属性 图片内容替换与文本内容替换是不一样的，需要区分对待 多个标签填充同样的内容时 从接口上来看，支持一个根据Name来获取节点功能，但是实际测试，发现标签name属性，并没有什么鸟用；不知道是使用姿势问题还是别的 然后翻看源码，发现当多个标签的id相同时，在Document的底层存储单元中，elementById 这个Map结构中，value会是一个数组 然后自然而然的想法就是，直接遍历这个数组，依次填充内容就好；结果发现压根就没有暴露这个接口，而这个属性是protectd，也无法直接访问 然后采用反射获取这个属性值，来绕过限制 模板加载缓存 实际场景中，模板往往是固定的，每次都进行渲染是非常消耗性能的，因此想的是能不能缓存住这个Document，再使用的时候，直接深拷贝一个对象出来，这样就避免了重复加载的开销 直接使用 AbstractDocumen#deepClone(true) 方法 然后，出现了一个鬼畜的并发问题，这个单独领出来细说，此处不展开 III. 最后收尾鉴于篇幅太长，有一些有意思的东西没有深入展开，特别是svg方案的支持中，遇到了一些比较有趣的问题，也涉及到三个好玩的知识点： 深拷贝+反射+并发，后面准备等这一块完结之后，好好的沉淀下，分析下这个case 1. 吐槽后端支持已经很勉强了，请大家都友好点，比如下面几个我实在支持不了 自定义设置字体（jdk字体，没新加一个都需要pe安装到jre的字体库） 图片的左上角圆角（暂时没想到好的解决方法） 渐变色（这个有点难） 这个需求，做得比较恶心，支持得也比较蛋疼，实现得比较猥琐，调bug修问题也比较闹心，总得来说，是一个开始前很有趣，做时让人吐血又很不爽，做完之后又特么的很有收获的需求 发现特别能有收获的事情，往往不是哪种做的特别爽的需求（爽，是因为这些东西你都完全能hold住，没什么难度了），相反是那些让你很闹心，完全不想继续下去的需求（因为你不了解，但是又不得不支持，还会遇到一堆鬼畜的bug，做完简直是吐血三升） 2. 小结图片合成的方式，我想应该不仅限于上面几种，由于限制于见识，终究是没有一个让人特别满意的方案，简单小结下上面的几种case java的开源包 html2image, xhtmlrender, pdfTech 一般来说，不怎么好用，大多不维护状态，对CSS的支持友好度待检验 imagemagic 适用于图片的基本处理，合图太复杂 awt绘图 属于基本的接口了，啥都可以干，只要你可以弄出来 但是工作量太大 js实现html渲染 phantmjs，效果不错，性能略渣，异步请求不友好，且完全不可控 chrome 性能由于上面的 svg渲染 batik 并不能非常完美的支持svg的渲染，有较多的限制要求，各种属性的必填，某些style的无法支持等 基本场景的支持，ok，优化后，性能高于html渲染，且可控 III. 其他体验网址基于react写了个前端，可以来体验渲染 phantomJs渲染 svg渲染 个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"吐槽","slug":"杂记/吐槽","permalink":"https://zbang.online/hexblog/categories/杂记/吐槽/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/tags/杂记/"}],"keywords":[{"name":"杂记","slug":"杂记","permalink":"https://zbang.online/hexblog/categories/杂记/"},{"name":"吐槽","slug":"杂记/吐槽","permalink":"https://zbang.online/hexblog/categories/杂记/吐槽/"}]},{"title":"ForkJoin 学习使用笔记","slug":"ForkJoin-学习使用笔记","date":"2017-09-08T14:24:34.000Z","updated":"2018-04-02T07:43:56.848Z","comments":true,"path":"2017/09/08/ForkJoin-学习使用笔记/","link":"","permalink":"https://zbang.online/hexblog/2017/09/08/ForkJoin-学习使用笔记/","excerpt":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架","text":"ForkJoin 学习使用笔记 Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架 I. 背景在日常的业务需求中，经常出现的批量查询，批量写入等接口的提供，一般来说，最简单最low的方式就是写一个for循环来一次执行，但是当业务方对接口的性能要求较高时，就比较尴尬了 通常可以想到的方式是采用并发操作，首先想到可以实现的方式就是利用线程池来做 通常实现方式如下 12345678910111213141516171819202122// 1. 创建线程池ExecutorService executorService = new ThreadPoolExecutor(3, 5, 60, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;Runnable&gt;(10), new DefaultThreadFactory(\"biz-exec\"), new ThreadPoolExecutor.CallerRunsPolicy());// 2. 创建执行任务List&lt;Future&lt;Object&gt;&gt; futureList = new ArrayList&lt;&gt;();for(Object arg : list) &#123; futureList.add(executorService.submit(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; // xxx &#125; &#125;));&#125;// 3. 结果获取for(Future f: futureList) &#123; Object obj = f.get();&#125; 用上面的这种方式并没有什么问题，我们接下来考虑的是如何使用ForkJoin框架来实现类似的功能 II. ForkJoin 基本知识 Fork: 将大任务拆分成若干个可以并发执行的小任务 Join: 合并所有小任务的执行结果 1. 任务分割ForkJoinTask : 基本任务，使用forkjoin框架必须创建的对象，提供fork,join操作，常用的两个子类 RecursiveAction : 无结果返回的任务 RecursiveTask : 有返回结果的任务 说明： fork : 让task异步执行 join : 让task同步执行，可以获取返回值 ForkJoinTask 在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行 2. 结果合并ForkJoinPool 执行 ForkJoinTask， 任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。 当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务 三中提交方式： execute 异步，无返回结果 submit 异步，有返回结果 （返回Future&lt;T&gt;） invoke 同步，有返回结果 （会阻塞） III. 使用说明 结合两个场景，给出使用姿势 1. 累加 实现从 start - end 的累加求和 首先是定义一个CountTask 来实现求和 首先是确定任务分割的阀值，当 end-start 的差值大于阀值时，将任务一分为二 1234567891011121314151617181920212223242526272829303132333435public class CountTask extends RecursiveTask&lt;Integer&gt; &#123; private int start; private int end; private static final int THRED_HOLD = 30; public CountTask(int start, int end) &#123; this.start = start; this.end = end; &#125; @Override protected Integer compute() &#123; int sum = 0; boolean canCompute = (end - start) &lt;= THRED_HOLD; if (canCompute) &#123; // 不需要拆分 for (int i = start; i &lt;= end; i++) &#123; sum += i; &#125; System.out.println(\"thread: \" + Thread.currentThread() + \" start: \" + start + \" end: \" + end); &#125; else &#123; int mid = (end + start) / 2; CountTask left = new CountTask(start, mid); CountTask right = new CountTask(mid + 1, end); left.fork(); right.fork(); sum = left.join() + right.join(); &#125; return sum; &#125;&#125; 调用case 1234567891011@Testpublic void testFork() throws ExecutionException, InterruptedException &#123; int start = 0; int end = 200; CountTask task = new CountTask(start, end); ForkJoinPool pool = ForkJoinPool.commonPool(); Future&lt;Integer&gt; ans = pool.submit(task); int sum = ans.get(); System.out.println(sum);&#125; 输出结果： 123456789thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 51 end: 75thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 101 end: 125thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 0 end: 25thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 126 end: 150thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] start: 76 end: 100thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 151 end: 175thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] start: 26 end: 50thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] start: 176 end: 20020100 2. 排序 int 数组进行排序 同样先定义一个SortTask, 主要是为了演示ForkJoin的使用姿势，具体的排序和合并的逻辑比较简陋的实现了一下（这块不是重点） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class SortTask extends RecursiveTask&lt;List&lt;Integer&gt;&gt; &#123; private List&lt;Integer&gt; list; private final static int THRESHOLD = 5; public SortTask(List&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override protected List&lt;Integer&gt; compute() &#123; if (list.size() &lt; THRESHOLD) &#123; Collections.sort(list); System.out.println(\"thread: \" + Thread.currentThread() + \" sort: \" + list); return list; &#125; int mid = list.size() &gt;&gt; 1; SortTask l = new SortTask(list.subList(0, mid)); SortTask r = new SortTask(list.subList(mid, list.size())); l.fork(); r.fork(); List&lt;Integer&gt; left = l.join(); List&lt;Integer&gt; right = r.join(); return merge(left, right); &#125; private List&lt;Integer&gt; merge(List&lt;Integer&gt; left, List&lt;Integer&gt; right) &#123; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(left.size() + right.size()); int rightIndex = 0; for (int i = 0; i &lt; left.size(); i++) &#123; if (rightIndex &gt;= right.size() || left.get(i) &lt;= right.get(rightIndex)) &#123; result.add(left.get(i)); &#125; else &#123; result.add(right.get(rightIndex++)); i -= 1; &#125; &#125; if (rightIndex &lt; right.size()) &#123; result.addAll(right.subList(rightIndex, right.size())); &#125; return result; &#125;&#125; 测试case和上面基本一样，我们改用 invoke 替换上面的 submit 12345678@Testpublic void testMerge() throws ExecutionException, InterruptedException &#123; List&lt;Integer&gt; list = Arrays.asList(100, 200, 150, 123, 4512, 3414, 3123, 34, 5412, 34, 1234, 893, 213, 455, 6, 123, 23); SortTask sortTask = new SortTask(list); ForkJoinPool pool = ForkJoinPool.commonPool(); List&lt;Integer&gt; ans = pool.invoke(sortTask); System.out.println(ans);&#125; 输出结果 123456thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [34, 3123, 3414, 4512]thread: Thread[ForkJoinPool.commonPool-worker-1,5,main] sort: [100, 123, 150, 200]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [34, 893, 1234, 5412]thread: Thread[ForkJoinPool.commonPool-worker-0,5,main] sort: [213, 455]thread: Thread[ForkJoinPool.commonPool-worker-3,5,main] sort: [6, 23, 123][6, 23, 34, 34, 100, 123, 123, 150, 200, 213, 455, 893, 1234, 3123, 3414, 4512, 5412] IV. 其他参考 聊聊并发（八）——Fork/Join框架介绍 线程池与ForkJoin比较 关于看完ForkJoinPool和ForkJoinTask文章后一些总结 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"笔记","slug":"笔记","permalink":"https://zbang.online/hexblog/tags/笔记/"},{"name":"并发","slug":"并发","permalink":"https://zbang.online/hexblog/tags/并发/"},{"name":"ForkJoin","slug":"ForkJoin","permalink":"https://zbang.online/hexblog/tags/ForkJoin/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Java","slug":"技术/Java","permalink":"https://zbang.online/hexblog/categories/技术/Java/"},{"name":"并发","slug":"技术/Java/并发","permalink":"https://zbang.online/hexblog/categories/技术/Java/并发/"}]},{"title":"ffmpeg安装","slug":"ffmpeg安装","date":"2017-08-11T09:47:51.000Z","updated":"2018-04-16T01:36:02.894Z","comments":true,"path":"2017/08/11/ffmpeg安装/","link":"","permalink":"https://zbang.online/hexblog/2017/08/11/ffmpeg安装/","excerpt":"I. 音频转码服务支持 机器扩容时，需要手动安装ffmpeg，以支持音频转码","text":"I. 音频转码服务支持 机器扩容时，需要手动安装ffmpeg，以支持音频转码 安装过程如下出于解压方便，将 .tar.xz 格式的压缩包转为 .tar.gz， 传到ftp待用 1234567891011121314151617181920212223242526272829## download ffmpge cmdwget https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-64bit-static.tar.xz## exact packagexz -d ffmpeg-release-64bit-static.tar.xztar -xvf ffmpeg-release-64bit-static.tarmv ffmpeg-release-64bit-static ffmpegtar -zcvf ffmpeg.tar.gz ffmpeg## 将安装包上传到ftpftp ftp.mogujie.orgput ffmpeg.tar.gz## 登录到新的机器， 安装ftpsudo yum install ftp## 下载安装包ftp ftp.mogujie.orgget ffmpeg.tar.gz## 进入mapp目录cp ffmpeg.tar.gz /home/yihui## 解压tar -zxvf ffmpeg.tar.gz II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zbang.online/hexblog/tags/ffmpeg/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"imagemagic安装","slug":"imagemagic安装","date":"2017-08-09T09:45:08.000Z","updated":"2018-04-17T08:13:16.802Z","comments":true,"path":"2017/08/09/imagemagic安装/","link":"","permalink":"https://zbang.online/hexblog/2017/08/09/imagemagic安装/","excerpt":"ImageMagic 安装ImageMagic/GraphicMagic 使用for java（im4java）","text":"ImageMagic 安装ImageMagic/GraphicMagic 使用for java（im4java） 1. 环境配置一键安装方式 123456789101112yum install libjpeg-develyum install libpng-devel本地环境搭建sudo brew install jpegsudo brew install libpngsudo brew install GraphicsMagickgm convert input.jpg -thumbnail '100x100' output_1.jpggm convert -crop 640x960+0+0 test.jpg output.jpg 源码安装方式 安装jpeg 包 wget ftp://223.202.54.10/pub/web/php/libjpeg-6b.tar.gz 安装webp 包 wget http://www.imagemagick.org/download/delegates/libwebp-0.5.1.tar.gz 安装png 包 wget http://www.imagemagick.org/download/delegates/libpng-1.6.24.tar.gz 安装 graphicsmagick wget http://nchc.dl.sourceforge.net/project/graphicsmagick/graphicsmagick/1.3.22/GraphicsMagick-1.3.22.tar.gz 安装imagemagick wget http://www.imagemagick.org/download/ImageMagick.tar.gz 安装命令 sudo ./configure; sudo make; sudo make install 几个命令 make distclean 清除上次make的东西 裁图命令 convert test.jpg -crop 640x960+0+0 output.jpg 问题修复 linux 安装imagemagick 发现一直找不到 png的依赖，查阅需要安装 http://pkgconfig.freedesktop.org/releases/pkg-config-0.28.tar.gz imagemagick 依然无法读取png图片 执行 convert 提示linux shared libraries 不包含某个库 –》临时解决方案： export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH 一劳永逸的方案：https://my.oschina.net/guanyue/blog/220264 vi /etc/ld.so.conf 在这个文件里加入：/usr/local/lib 来指明共享库的搜索位置 然后再执行/sbin/ldconf 2. 常用命令汇总图片操作方式 裁图 + 旋转 + 缩放 + 缩略图 + 翻转（flip） + 镜像（flop） + 水印(composite) + 边框(border) 裁图 convert test.jpg -crop 640x960+0+0 output.jpg 旋转 convert test.jpg -rotate 90 output.jpg 缩放 convert test.jpg -resize 200x200 output.jpg 强制宽高缩放 convert test.jpg -resize 200x200! output.jpg 缩略图 convert -thumbnail 200x300 test.jpg thumb.jpg 翻转 上下翻转： convert -flip foo.png bar.png 左右翻转： convert -flop foo.png bar.png 图片合成方式 水印 ：composite -gravity northwest -dissolve 100 -geometry +0+0 water.png temp.jpg out.jpg 其中 gravity 表示起始位置dissolve 表示水印图片的透明度， 100 表示100%透明water.png为水印图， temp.jpg 为背景图, out.jpg 为输出图片 方法二：convert -gravity southeast -geometry +5+10 -composite test.jpg water.png out.jpg water.png作为水印图片，合在test.jpg的东南 （5，10）坐标处，输出文件为 out.jpg 添加边框 : convert -border 6x6 -bordercolor &quot;#ffffff&quot; test.jpg bord.jpg 去除边框 : convert -thumbnail 200x300 test.jpg thumb.jpg II. 其他个人博客： 一灰灰Blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正 微博地址: 小灰灰Blog QQ： 一灰灰/3302797840 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://zbang.online/hexblog/tags/教程/"},{"name":"imagemagic","slug":"imagemagic","permalink":"https://zbang.online/hexblog/tags/imagemagic/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Shell","slug":"技术/Shell","permalink":"https://zbang.online/hexblog/categories/技术/Shell/"},{"name":"环境搭建","slug":"技术/Shell/环境搭建","permalink":"https://zbang.online/hexblog/categories/技术/Shell/环境搭建/"}]},{"title":"4. SPI框架实现之旅四：使用测试","slug":"SPI框架实现之旅四：使用测试","date":"2017-05-30T12:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/30/SPI框架实现之旅四：使用测试/","link":"","permalink":"https://zbang.online/hexblog/2017/05/30/SPI框架实现之旅四：使用测试/","excerpt":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等","text":"使用测试 前面三篇主要是介绍如何设计的，如何实现的，这一篇，则主要集中在如何使用。实现得再好，如果不好用，也白搭 本篇介绍几个简单的使用case，包括静态使用，动态适配，自定义选择器等 1. 简单的静态使用定义一个SPI接口 IPrint, 两个实现 FilePrint, ConsolePrint 123456789101112131415161718@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125; 添加配置文件 com.hust.hui.quicksilver.spi.test.print.IPrint, 内容如下 com.hust.hui.quicksilver.spi.test.print.ConsolePrint com.hust.hui.quicksilver.spi.test.print.FilePrint 测试代码如下 1234567891011121314151617181920212223242526272829@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;); print.print(&quot;console----&gt;&quot;); print = spiLoader.getService(&quot;FilePrint&quot;); print.print(&quot;file----&gt;&quot;); try &#123; print = spiLoader.getService(&quot;undefine&quot;); print.print(&quot;undefine----&quot;); Assert.assertTrue(false); &#125; catch (Exception e) &#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125; try &#123; print = spiLoader.getService(123); print.print(&quot;type error----&quot;); Assert.assertTrue(false); &#125; catch (Exception e)&#123; System.out.println(&quot;type error--&gt;&quot; + e); &#125;&#125; 输出如下 1234console print: console----&gt;file print: file----&gt;type error--&gt;com.hust.hui.quicksilver.spi.exception.NoSpiMatchException: no spiImpl match the name you choose! your choose is: undefinetype error--&gt;java.lang.IllegalArgumentException: conf spiInterfaceType should be sub class of [class java.lang.String] but yours:class java.lang.Integer 演示如下 2. 动态适配与静态的使用有点区别，主要的区别点在于接口的定义（需要注意第一个参数是作为选择器选择SPI实现的参数），同样是上面这个spi接口 123456789101112131415161718192021222324252627282930313233@Spipublic interface IPrint &#123; void print(String str); void adaptivePrint(String conf, String str);&#125; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"file adaptivePrint: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125; @Override public void adaptivePrint(String conf, String str) &#123; System.out.println(\"console adaptivePrint: \" + str); &#125;&#125; 主要是新增了一个接口 adaptivePrint, 其他的没有啥区别，测试代码如下 12345678@Testpublic void testAdaptivePrint() throws SpiProxyCompileException &#123; IPrint print = SpiLoader.load(IPrint.class).getAdaptive(); print.adaptivePrint(\"FilePrint\", \"[file print]\"); print.adaptivePrint(\"ConsolePrint\", \"[console print]\");&#125; 输出结果 1234567891011121314151617181920212223242526file adaptivePrint: [file print]console adaptivePrint: [console print]``` 演示图 ![http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif](http://s2.mogucdn.com/mlcdn/c45406/170531_54f638fkcl58c6lihl92adei31c78_1222x718.gif)## 3. 自定义选择器&gt; 上面两个很简单的演示了下使用方式，最基本的方法， 没有加上 @SpiConf 注解， 没有显示指定选择器类型，下面则演示下，如何自定义选择器**SPI接口**有一个欢迎方法，我们需求根据用户的来源显示不同的欢迎至此， 下面定义了一个 `UserSelector`选择器，这个就是我们自定义的选择器```java@Spipublic interface IUser &#123; @SpiAdaptive(selector = UserSelector.class) void welcome(UserDO userDO);&#125; spi实现类 123456789101112131415public class QQUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"qq 欢迎你! \" + userDO); &#125;&#125;public class WeixinUser implements IUser &#123; @Override public void welcome(UserDO userDO) &#123; System.out.println(\"weixin 欢迎你! \" + userDO); &#125;&#125; META-INF/services/ 目录下的配置如下 com.hust.hui.quicksilver.spi.def.spi.IUser com.hust.hui.quicksilver.spi.def.spi.QQUser com.hust.hui.quicksilver.spi.def.spi.WeixinUser 选择器实现如下 12345678910111213141516171819public class UserSelector implements ISelector&lt;UserDO&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, UserDO conf) throws NoSpiMatchException &#123; if (conf == null || conf.getMarket() == null) &#123; throw new IllegalArgumentException(\"userDo or userDO#market should not be null!\"); &#125; String name = conf.getMarket().getName(); if (map.containsKey(name)) &#123; return map.get(name).getSpiImpl(); &#125; throw new NoSpiMatchException(\"no spiImp matched marked: \" + conf.getMarket()); &#125;&#125; 从上面的选择器逻辑可以看出，我们是根据 UserDO的market参数来进行选择的， UserDO的定义如下 12345678910111213141516171819202122232425262728@Getter@Setter@ToStringpublic class UserDO &#123; private String uname; private String avatar; private MarketEnum market;&#125;public enum MarketEnum &#123; WEIXIN(\"WeixinUser\"), QQ(\"QQUser\"); private String name; MarketEnum(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 测试代码如下 123456789101112131415161718192021@Testpublic void testUserSPI() throws SpiProxyCompileException &#123; SpiLoader&lt;IUser&gt; loader = SpiLoader.load(IUser.class); IUser user = loader.getAdaptive(); UserDO weixinUser = new UserDO(); weixinUser.setAvatar(\"weixin.avatar.jpg\"); weixinUser.setUname(\"微信用户\"); weixinUser.setMarket(MarketEnum.WEIXIN); user.welcome(weixinUser); UserDO qqUser = new UserDO(); qqUser.setAvatar(\"qq.avatar.jpg\"); qqUser.setUname(\"qq用户\"); qqUser.setMarket(MarketEnum.QQ); user.welcome(qqUser); System.out.println(\"-----over------\");&#125; 输出结果: weixin 欢迎你! UserDO(uname=微信用户, avatar=weixin.avatar.jpg, market=WEIXIN) qq 欢迎你! UserDO(uname=qq用户, avatar=qq.avatar.jpg, market=QQ) 演示如下: 3. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"使用手册","slug":"使用手册","permalink":"https://zbang.online/hexblog/tags/使用手册/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"3. SPI框架实现之旅三：实现说明","slug":"SPI框架实现之旅三：实现说明","date":"2017-05-29T02:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/29/SPI框架实现之旅三：实现说明/","link":"","permalink":"https://zbang.online/hexblog/2017/05/29/SPI框架实现之旅三：实现说明/","excerpt":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下：","text":"实现说明 前一篇 《SPI框架实现之旅二：整体设计》中，介绍了几个定义的接口，注解；叙述了实现流程；并简单的介绍了 SpiLoader中的部分实现； 本篇则主要介绍SpiLoader类的实现 类图结构如下： SpiLoader 全解析 spiImpl选择的核心类，包括初始化选择器，初始化spiImpl实现列表，解析spiImpl的选择条件，返回具体的实现类等 1. 获取spiLoader对象 SpiLoader 是一个泛型对象，每个SPI接口，对应一个SpiLoader&lt;T&gt; 对象，我们提供了一个静态方法来获取这个对象 实现优先从缓存中获取， 如果缓存没有，则新建一个；缓存中有， 则直接返回 123456789101112131415161718192021222324252627282930/*** spiLoader缓存, 其中key为 spi接口, value为对应的Loader对象*/private static final ConcurrentMap&lt;Class&lt;?&gt;, SpiLoader&lt;?&gt;&gt; loaderCache = new ConcurrentHashMap&lt;&gt;();@SuppressWarnings(\"unchecked\")public static &lt;T&gt; SpiLoader&lt;T&gt; load(Class&lt;T&gt; type) &#123; if (null == type) &#123; throw new IllegalArgumentException(\"common cannot be null...\"); &#125; if (!type.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must be interface!\"); &#125; if (!withSpiAnnotation(type)) &#123; throw new IllegalArgumentException(\"common class:\" + type + \" must have the annotation of @Spi\"); &#125; SpiLoader&lt;T&gt; spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); if (spiLoader == null) &#123; loaderCache.putIfAbsent(type, new SpiLoader&lt;&gt;(type)); spiLoader = (SpiLoader&lt;T&gt;) loaderCache.get(type); &#125; return spiLoader;&#125; 说明 上面有几个校验，前一篇已经说明，不再赘述 上面新建对象，不是线程安全的 2. 新建 SpiLoader对象 创建对象，主要会初始化选择器 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private SpiLoader(Class&lt;T&gt; type) &#123; // 初始化默认的选择器, 为保留项目, 必然会提供的服务 selectorInstanceCacheMap.putIfAbsent(DefaultSelector.class, DEFAULT_SELECTOR); this.spiInterfaceType = type; initSelector();&#125;private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 持有一个选择器缓存列表，selectorInstanceCacheMap 保证每种类型的选择器，在这个SpiLoader中，只会有一个实例存在 不做成全局唯一的原因是尽量隔离, 比如 ParamsSelector 内部缓存了spi实现的列表，如果全局公用的话，就会混掉，导致这个列表中就出现非这个spi接口的实现类 类选择器 + 方法选择器 currentSelector ： 类选择器, 解析 @Spi 注解获取，适用于静态选择 + 动态选择两种使用方式 currentMethodSelector : 方法选择器，解析 @SpiAdaptive 注解获取， 仅适用于动态选择SPI实现的方式 优先级： 方法上定义的选择器 由于 类上定义的选择器； 方法上未定义时，默认使用类定义的选择器 3. 静态使用 静态使用方式，表示根据传入的条件，选择一个满足条件的实现返回 实现1234567891011121314151617181920212223242526272829303132333435/*** 根据传入条件, 选择具体的spi实现类* &lt;p/&gt;* 这里要求conf的类型和选择器的参数类型匹配, 否则会尝试使用默认的选择器补救, 若补救失败, 则抛异常** @param conf* @return* @throws NoSpiMatchException* @throws IllegalArgumentException*/@SuppressWarnings(\"unchecked\")public T getService(Object conf) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; if (!currentSelector.getConditionType().isAssignableFrom(conf.getClass())) &#123; /** * 参数类型不匹配时, 判断是否可以根据默认的选择器来获取 */ if (conf instanceof String) &#123; return (T) DEFAULT_SELECTOR.getSelector().selector(spiImplClassCacheMap, conf); &#125; /** * 参数类型完全不匹配, 则抛参数异常 */ throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; return (T) currentSelector.getSelector().selector(spiImplClassCacheMap, conf);&#125; 说明 spiImplClassCacheMap spi实现的缓存映射表，优先判断缓存映射表是否存在，不存在时需要初始化；存在时，则进入校验逻辑 校验 校验传入的参数，是否匹配当前的选择器参数类型，为了保证选择器可以正常运行 当不匹配时，会有一个兼容逻辑，判断传参类型是否为String， 是则采用默认的选择器，根据name来选择spi实现 （这种实现可能造成选择的实现不是预期的） 静态使用方式，使用类定义选择器 : currentSelector 静态使用的方式，目标就是事前就确认使用这个实现了，不会出现变动了； 相当于一次确认，所有的调用都是确认的 静态使用，方法注解的选择器无效。这个我们从逆向的思路进行解释 IPrint 是一个Spi接口， 有两个实现 FilePrint, ConsolePrint 假设 `currentSelector=DefaultSelector`， 方法 methodA 上定义的是 ParamsSelector 时 静态使用方式，获取一个spi实现，希望在所有的spi接口使用处，都输出到文件，用户根据 `FilePrint` 选择 FilePrint 这个类来执行具体的输出逻辑， 如果在调用 methodA 方法执行时， 假设根据 ParamsSelector 判断， ConsolePrint 才满足这儿条件，这是相当于在具体实现时，换成了另一个 ConsolePrint, 这下子就与我们的初衷背离了（如果目标是想实现这个场景，显然动态适配的方式才是正确的使用姿势） loadService 的逻辑后面详细说明 4. 动态使用 动态使用区别于静态的直接确定实现类， 通过getService 获取的并不是某个特定对的实现类，而是一个动态生成的代理，每次具体执行之前，会去判断一下，应该选择哪一个实现来执行 设计的出发点可以考虑下，我们的目标是在执行方法之前，需要判断一下哪个实现类满足要求，选择这个实现类来执行这个方法，那么我们可以怎么去做？ 考虑到切面的方式，如果有一种手段，在方法执行之前，织入一段业务逻辑，就可以达到上面的目的 最开始虽然是怎么想的，但是有点尴尬的是，不知道怎么去实现；因此换了一个思路，我自己新生成一个接口的实现类，在这个实现类里面做选择逻辑，然后把这个实现类对象返回 实现如下和静态实现的逻辑差不多，一般流程如下: 判断spi实现类的映射关系表是否初始化，若没有则初始化 获取选择器 优先从方法选择器中查找， 若存在，则直接选中； 不存在，则使用类选择器 校验：判断传入条件参数类型是否满足选择器的参数类型匹配（将方法的第一个参数，作为选择器的选择条件） 返回实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@SuppressWarnings(\"unchecked\")public T getService(Object conf, String methodName) throws NoSpiMatchException &#123; if (spiImplClassCacheMap == null || spiImplClassCacheMap.size() == 0) &#123; loadSpiService(); &#125; // 首先获取对应的selector SelectorWrapper selector = currentMethodSelector.get(methodName); if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector); &#125; if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; selector = DEFAULT_SELECTOR; &#125; if (spiImplMethodCacheMap.size() == 0) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; try &#123; // 采用默认的选择器,根据指定name 进行查询时, 需要兼容一下, 因为method对应的缓存key为 SpiImpName_methodName if (DEFAULT_SELECTOR.equals(selector)) &#123; if (spiImplMethodCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; if (spiImplClassCacheMap.containsKey(conf)) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf + \"_\" + methodName); &#125; else &#123; return (T) selector.getSelector().selector(spiImplMethodCacheMap, conf); &#125; &#125; catch (Exception e) &#123; return (T) selector.getSelector().selector(spiImplClassCacheMap, conf); &#125;&#125; 说明 这个方法通常是由框架生成的代理实现类来调用（后面会说明动态生成代理类的逻辑） 区别与静态使用方式， 优先根据方法名，查找对应的选择器；当未定义时，使用类选择器 默认选择器，根据name来查询实现时，传入的参数特殊处理下，主要是因为 spiImplMethodCacheMap 中key的生成，有一个小转换 若实现类上没有 @SpiConf注解，或者 @SpiConf的注解没有定义 name 属性，则类的唯一标识name为：简单类名； 否则为指定的name属性 若方法上显示使用 @SpiConf 指定了name属性，则key的生成规则为： 方法注解上指定的name； 如果没有 @SpiConf注解，或其中没有指定name属性，则key生成规则: 类name属性 + 下划线 + 方法名 这一点单独看可能不太好理解，因此可以和下面的spi实现类映射关系的初始化结合起来 动态生成代理类的逻辑，放在最后进行说明 5. spi实现类映射关系表初始化 为了避免每次选择具体的实现类时，都去加载一遍，耗时耗力好性能，因此加一个缓存是很有必要的，这里主要说下这个实现逻辑，以及为啥这么干 缓存结构使用了两个Map： 一个是类级别的映射关系 spiImplClassCacheMap 静态使用时，只会用搞这个 动态适配时，当下面的映射关系中无法获取满足条件的实现时，会再次从这里进行判断 key： @SpiConf 注解中定义的name； 或者spi实现类的简单类名 一个是方法的映射关系 spiImplMethodCacheMap 动态适配时， 选择器优先从这里进行判断 key: @SpiConf 注解中定义的name； 或者是 实现类的 name + “_” + 方法名 12345678910/*** name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplClassCacheMap;/*** 自适应时, 根据方法选择实现; name : spiImpl 的映射表*/private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; spiImplMethodCacheMap; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101private void loadSpiService() &#123; List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;(); List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceMethodList = new ArrayList&lt;&gt;(); ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType); SpiConf spiConf; String implName; int implOrder; for (T t : serviceLoader) &#123; spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); String methodImplName; int methodImplOrder; Map&lt;String, String&gt; methodParams; for (Method method : methods) &#123; spiConf = method.getAnnotation(SpiConf.class); if (spiConf == null) &#123; continue; &#125; // 方法上有自定义注解, 且定义的name与类实现名不同, 则直接采用 // 否则采用 ServiceName_MethodName 方式定义 if (StringUtils.isBlank(spiConf.name()) || implName.equals(spiConf.name())) &#123; methodImplName = implName + \"_\" + method.getName(); &#125; else &#123; methodImplName = spiConf.name(); &#125; // 优先级, 以最小的为准 （即一个类上的优先级很低, 也可以定义优先级高的方法） // 方法注解未定义顺序时, 继承类上的顺序 methodImplOrder = Math.min(implOrder, spiConf.order() &lt; 0 ? implOrder : spiConf.order()); // 自适应方法的参数限制, 要求继承类上的参数 methodParams = parseParms(spiConf.params()); if (map.size() &gt; 0) &#123; // 方法的参数限定会继承类上的参数限定 if (methodParams.size() == 0) &#123; methodParams = map; &#125; else &#123; methodParams.putAll(map); &#125; &#125; spiServiceMethodList.add(new SpiImplWrapper&lt;&gt;(t, methodImplOrder, methodImplName, methodParams)); &#125; &#125; if (spiServiceList.size() == 0) &#123; throw new IllegalStateException(\"no spiImpl implements spi: \" + spiInterfaceType); &#125; this.spiImplClassCacheMap = initSpiImplMap(spiServiceList); this.spiImplMethodCacheMap = initSpiImplMap(spiServiceMethodList);&#125;private Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; initSpiImplMap(List&lt;SpiImplWrapper&lt;T&gt;&gt; list) &#123; // 映射为map, 限定不能重名 Map&lt;String, SpiImplWrapper&lt;T&gt;&gt; tempMap = new ConcurrentHashMap&lt;&gt;(); for (SpiImplWrapper&lt;T&gt; wrapper : list) &#123; if (tempMap.containsKey(wrapper.getName())) &#123; throw new IllegalArgumentException(\"duplicate spiImpl name \" + wrapper.getName()); &#125; tempMap.put(wrapper.getName(), wrapper); &#125; return tempMap;&#125; 上面的逻辑可以分为两块，一块是上半边的初始化，获取spiImplClassCacheMap;下一块则是扫描实现类的所有方法，将方法上标有@SpiConf注解的捞出来，用于初始化 spiImplMethodCacheMap 说明 缓存结构中value为 SpiImplWrapper 缓存value并不是简单的实现类，封装类的定义如下，将条件和排序也同时封装进去了 1234567891011121314151617181920private T spiImpl;private int order;/*** spiImpl 的标识name, 要求唯一* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.DefaultSelector 选择具体的SpiImpl 时使用&#125;*/private String name;/*** 参数校验规则* &lt;p/&gt;* &#123;@link com.hust.hui.quicksilver.spi.selector.ParamsSelector&#125; 选择具体的SpiImpl 时使用* 要求每个实现类都有注解 &#123;@link SpiConf&#125;*/private Map&lt;String, String&gt; paramCondition; name 的定义，类与方法两个纬度的缓存中，定义规则不同，具体可以看《缓存结构》这里的说明 采用 ParamsSelector 时， 要求 @SpiConf 注解必须存在 注意扫描所有方法对应的注解, spi实现类，如果存在继承则会出现问题 // todo 改成 getMethods(), 但是过滤掉 Object类中的基础方法 Method[] methods = t.getClass().getDeclaredMethods(); 动态代码生成 上面在谈论动态使用的时候，采用的方案是，生成一个代理类，实现spi接口， 在具体的实现逻辑中，使用选择器来获取满足条件的实现类，然后执行相应的方法 1. 代理类格式采用倒推方式，先给出一个实际的代理类如下，具体的实现中其实只有两行代码 获取具体的实现类 （调用上面的 SpiLoader.getService(conf, methodName） 执行实现类的接口 123456789101112131415161718192021222324package com.hust.hui.quicksilver.spi.test.print;import com.hust.hui.quicksilver.spi.SpiLoader;public class IPrint$Proxy implements com.hust.hui.quicksilver.spi.test.print.IPrint &#123; public void print(java.lang.String arg0) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"print\"); spiImpl.print(arg0); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125; public void adaptivePrint(java.lang.String arg0, java.lang.String arg1) &#123; try &#123; com.hust.hui.quicksilver.spi.test.print.IPrint spiImpl = SpiLoader.load(com.hust.hui.quicksilver.spi.test.print.IPrint.class).getService(arg0, \"adaptivePrint\"); spiImpl.adaptivePrint(arg0, arg1); &#125; catch (com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e) &#123; throw new java.lang.RuntimeException(e); &#125; &#125;&#125; 上面给出了一个代理类的演示，那么剩下两个问题，一个是如何生成代理类； 一个是如何运行代理类（上面是java代码，我们知道运行得是字节码才行） 代理类生成对着上面的实现，反推代码生成，其实比较简单了，无非就是生成一大串的String罢了，这里真没什么特殊的，贴下实现，逻辑省略 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 构建SPI接口的实现代理类, 在执行动态适配的方法时, 调用SpiLoader的 spiImpl选择器, 选择具体的实现类执行 * * @return */public static String buildTempImpl(Class type) &#123; StringBuilder codeBuilder = new StringBuilder(); codeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\"); codeBuilder.append(\"\\nimport \").append(SpiLoader.class.getName()).append(\";\"); codeBuilder.append(\"\\npublic class \").append(type.getSimpleName()).append(\"$Proxy implements \").append(type.getCanonicalName()).append(\" &#123;\\n\"); Method[] methods = type.getMethods(); for (Method method : methods) &#123; Class&lt;?&gt; returnType = method.getReturnType(); //函数返回值 Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//函数参数列表 Class&lt;?&gt;[] exceptionTypes = method.getExceptionTypes();//函数异常列表 // build method code StringBuilder code = new StringBuilder(512); if (parameterTypes.length &lt; 0) &#123; //检查该函数参数列表中，第一个参数作为选择器参数 code.append(\"throw new IllegalArgumentException(\\\"there should be one argument for selector to choose spiImpl\\\")\"); &#125; else &#123; // 没有 SpiAdaptive注解的, 采用默认的注解方式 code.append(\"try&#123;\\n\"); code.append(type.getName()).append(\" spiImpl=\") .append(\"SpiLoader.load(\") .append(type.getName()).append(\".class\") .append(\").getService(arg0,\\\"\") .append(method.getName()) .append(\"\\\");\"); if (!\"void\".equals(returnType.getName())) &#123; code.append(\"return \"); &#125; code.append(\"spiImpl.\").append(method.getName()).append(\"(arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; code.append(\",\").append(\"arg\").append(i); &#125; code.append(\");\"); code.append(\"\\n&#125; catch(com.hust.hui.quicksilver.spi.exception.NoSpiMatchException e)&#123;\\nthrow new java.lang.RuntimeException(e);\\n&#125;\"); &#125; // build method signature codeBuilder.append(\"\\npublic \").append(returnType.getName()).append(\" \").append(method.getName()) .append(\"(\").append(parameterTypes[0].getName()).append(\" arg0\"); for (int i = 1; i &lt; parameterTypes.length; i++) &#123; codeBuilder.append(\", \").append(parameterTypes[i].getName()).append(\" arg\").append(i); &#125; codeBuilder.append(\") \"); if (exceptionTypes.length &gt; 0) &#123; codeBuilder.append(\"throw \").append(exceptionTypes[0].getName()); for (int i = 1; i &lt; exceptionTypes.length; i++) &#123; codeBuilder.append(\", \").append(exceptionTypes[i].getName()); &#125; &#125; codeBuilder.append(\"&#123;\\n\"); codeBuilder.append(code.toString()).append(\"\\n&#125;\"); &#125; codeBuilder.append(\"\\n&#125;\"); return codeBuilder.toString();&#125; 动态编译运行动态编译，最开始想的是利用jdk的动态编译方式，试来试去没搞成功，然后选择了一个折中的方案，把代理类看成是groovy代码，利用 GroovyEngine 来实现动态运行, 这一块的逻辑也超级简单，下面的短短几行代码即可； 后面有空单独研究下java的动态编译 12345678910111213141516@SuppressWarnings(\"unchecked\")public static &lt;T&gt; T compile(String code, Class&lt;T&gt; interfaceType, ClassLoader classLoader) throws SpiProxyCompileException &#123; GroovyClassLoader loader = new GroovyClassLoader(classLoader); Class clz = loader.parseClass(code); if (!interfaceType.isAssignableFrom(clz)) &#123; throw new IllegalStateException(\"illegal proxy type!\"); &#125; try &#123; return (T) clz.newInstance(); &#125; catch (Exception e) &#123; throw new SpiProxyCompileException(\"init spiProxy error! msg: \" + e.getMessage()); &#125;&#125; 小结至此，核心的东西基本上都过了一遍，主要的设计思路，实现逻辑，执行流程都说完了 博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"2. SPI框架实现之旅二：整体设计","slug":"SPI框架实现之旅二：整体设计","date":"2017-05-28T02:50:37.000Z","updated":"2018-04-02T07:43:56.850Z","comments":true,"path":"2017/05/28/SPI框架实现之旅二：整体设计/","link":"","permalink":"https://zbang.online/hexblog/2017/05/28/SPI框架实现之旅二：整体设计/","excerpt":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式","text":"整体设计 上一篇简单的说了一下spi相关的东西， 接下来我们准备开动，本篇博文主要集中在一些术语，使用规范的约定和使用方式 设计思路下图围绕 SpiLoader 为中心，描述了三个主要的流程： load所有的spi实现 初始化选择器 selector 获取spi实现类 （or一个实现类代理） 基础类说明 主要介绍一下框架中涉及到的接口和注解，并指出需要注意的点 1. Selector 选择器 为了最大程度的支持业务方对spi实现类的选择，我们定义了一个选择器的概念，用于获取spi实现类 接口定义如下:123public interface ISelector&lt;T&gt; &#123; &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, T conf) throws NoSpiMatchException;&#125; 结合上面的接口定义，我们可以考虑下，选择器应该如何工作？ 根据传入的条件，从所有的实现类中，找到一个最匹配的实现类返回 如果查不到，则抛一个异常NoSpiMatchException出去 所以传入的参数会是两个， 一个是所有的实现类列表map（至于上面为什么用map，后续分析），一个是用于判断的输入条件conf 框架中会提供两种基本的选择器实现， DefaultSelector ， 对每个实现类赋予唯一的name，默认选择器则表示根据name来查找实现类 ParamsSelector， 在实现类上加上 @SpiConf 注解，定义其中的 params，当传入的参数(conf)， 能完全匹配定义的params，表示这个实现类就是你所需要的 自定义实现自定义实现比较简单，实现上面的接口即可 2. Spi 注解 要求所有的spi接口，都必须有这个注解； 定义如下主要是有一个参数，用于指定是选择器类型，定义spi接口的默认选择器， 123456@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Spi &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明在上一篇《SPI框架实现之旅一》中，使用jdk的spi方式中，并没有使用注解依然可以正常工作，我们这里定义这个注解且要求必需有，出于下面几个考虑 醒目，告诉开发者，这个接口是声明的spi接口， 使用的时候注意下 加入选择器参数，方便用户扩展自己的选择方式 3. SpiAdaptive 注解 对需要自适应的场景，为了满足一个spi接口，应用多重不同的选择器场景，可以加上这个注解；如果不加这个注解，则表示采用默认的选择器来自适应 接口说明1234567891011/** * SPI 自适应注解, 表示该方法会用到spi实现 * &lt;p/&gt; * Created by yihui on 2017/5/24. */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)public @interface SpiAdaptive &#123; Class&lt;? extends ISelector&gt; selector() default DefaultSelector.class;&#125; 说明这个注解内容和 @Spi 基本上一模一样，唯一的区别是一个放在类上，一个放在方法上，那么为什么这么考虑？ @Spi 注解放在类上，更多的表名这个接口是我们定义的一个SPI接口，但是使用方式可以有两种（静态 + 动态确认） @SpiAdaptive 只能在自适应的场景下使用，用于额外指定spi接口中某个方法的选择器 （如果一个spi接口全部只需要一个选择器即可，那么可以不使用这个注解） 如下面的这个例子，print方法和 echo方法其实是等价的，都是采用 DefaultSelector 来确认具体的实现类；而 write 和 pp 方法则是采用 ParamsSelector 选择器; 1234567891011121314151617181920/** * Created by yihui on 2017/5/25. */@Spipublic interface ICode &#123; void print(String name, String contet); @SpiAdaptive void echo(String name, String content); @SpiAdaptive(selector = ParamsSelector.class) void write(Context context, String content); @SpiAdaptive(selector = ParamsSelector.class) void pp(Context context, String content);&#125; 4. SpiConf 注解 这个主键主要是用在实现类上（或实现类的方法上），里面存储一些选择条件，通常是和Selector搭配使用 定义如下定义了三个字段: name 唯一标识，用于 DefaultSelector； params 参数条件， 用于 ParamsSelector； order : 优先级， 主要是为了解决多个实现类都满足选择条件时， 应该选择哪一个 （谈到这里就有个想法， 通过一个参数，来选择是否让满足条件的全部返回） 123456789101112131415161718192021222324252627282930@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface SpiConf &#123; /** * 唯一标识 * * @return */ String name() default \"\"; /** * 参数过滤, 单独一个元素,表示参数必须包含; 用英文分号,左边为参数名,右边为参数值,表示参数的值必须是右边的 * &lt;p/&gt; * 形如 &#123;\"a\", \"a:12\", \"b:TAG\"&#125; * * @return */ String[] params() default &#123;&#125;; /** * 排序, 越小优先级越高 * * @return */ int order() default -1;&#125; 说明SpiConf 注解可以修饰类，也可以修饰方法，因此当一个实现类中，类和方法都有这个注解时， 怎么处理 ？ 以下面的这个测试类进行说明 1234567891011121314151617181920212223242526272829303132333435/** * Created by yihui on 2017/5/25. */@SpiConf(params = \"code\", order = 1)public class ConsoleCode implements ICode &#123; @Override public void print(String name, String contet) &#123; System.out.println(\"console print:---&gt;\" + contet); &#125; /** * 显示指定了name, 因此可以直接通过 consoleEcho 来确定调用本实现方法 * @param name * @param content */ @Override @SpiConf(name = \"consoleEcho\") public void echo(String name, String content) &#123; System.out.println(\"console echo:----&gt;\" + content); &#125; /** * 实际的优先级取 方法 和类上的最高优先级, 实际为1； * `ParamsSelector`选择器时， 执行该方法的条件等同于 `&#123;\"code\", \"type:console\"&#125;` * @param context * @param content */ @Override @SpiConf(params = &#123;\"type:console\"&#125;, order = 3) public void write(Context context, String content) &#123; System.out.println(\"console write:----&gt;\" + content); &#125;&#125; 在设计中，遵循下面几个原则： 类上的SpiConf注解， 默认适用与类中的所有方法 方法上有SpiConf注解，采取下面的规则 方法注解声明name时，两个会同时生效，即想调用上面的echo方法， 通过传入 ConsoleCode（类注解不显示赋值时，采用类名代替） 和 consoleEcho 等价 方法注解未声明name时，只能通过类注解上定义的name（or默认的类名）来选择 order，取最高优先级，如上面的 write 方法的优先级是 1; 当未显示定义order时，以定义的为准 params: 取并集，即要求类上 + 方法上的条件都满足 SPI加载器 spi加载器的主要业务逻辑集中在 SpiLoader 类中，包含通过spi接口，获取所有的实现类； 获取spi接口对应的选择器 （包括类对应的选择器， 方法对应的选择器）； 返回Spi接口实现类（静态确认的实现类，自适应的代理类） 从上面的简述，基本上可以看出这个类划分为三个功能点， 下面将逐一说明，本篇博文主要集中在逻辑的设计层，至于优化（如懒加载，缓存优化等） 放置下一篇博文单独叙述 1. 加载spi实现类 这一块比较简单，我们直接利用了jdk的 ServiceLoader 来根据接口，获取所有的实现类；因此我们的spi实现，需要满足jdk定义的这一套规范 具体的代码业务逻辑非常简单，大致流程如下 1234567891011121314151617 if (null == spiInterfaceType) &#123; throw new IllegalArgumentException(\"common cannot be null...\");&#125;if (!spiInterfaceType.isInterface()) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must be interface!\");&#125;if (!withSpiAnnotation(spiInterfaceType)) &#123; throw new IllegalArgumentException(\"common class:\" + spiInterfaceType + \" must have the annotation of @Spi\");&#125; ServiceLoader&lt;T&gt; serviceLoader = ServiceLoader.load(spiInterfaceType);for(T spiImpl: serviceLoader) &#123; // xxx&#125; 注意 因为使用了jdk的标准，因此每定义一个spi接口，必须在 META_INF.services 下新建一个文件， 文件名为包含包路径的spi接口名， 内部为包含包路径的实现类名 每个spi接口，要求必须有 @Spi 注解 Spi接口必须是 interface 类型， 不支持抽象类和类的方式 拓展虽然这里直接使用了spi的规范，我们其实完全可以自己定义标准的，只要能将这个接口的所有实现类找到， 怎么实现都可以由你定义 如使用spring框架后，可以考虑通过 applicationContext.getBeansOfAnnotaion(xxx ) 来获取所有的特定注解的bean，这样就可以不需要自己新建一个文件，来存储spi接口和其实现类的映射关系了 构建spi实现的关系表上面获取了spi实现类，显然我们的目标并不局限于简单的获取实现类，在获取实现类之后，还需要解析其中的 @SpiConf 注解信息，用于表示要选择这个实现，必须满足什么样的条件 SpiImplWrapper : spi实现类，以及定义的各种条件的封装类 注解的解析过程流程如下: name: 注解定义时，采用定义的值； 否则采用简单类名 （因此一个系统中不允许两个实现类同名的情况） order： 优先级， 注解定义时，采用定义的值；未定义时采用默认； params: 参数约束条件， 会取类上和方法上的并集（原则上要求类上的约束和方法上的约束不能冲突） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152List&lt;SpiImplWrapper&lt;T&gt;&gt; spiServiceList = new ArrayList&lt;&gt;();// 解析注解spiConf = t.getClass().getAnnotation(SpiConf.class); Map&lt;String, String&gt; map; if (spiConf == null) &#123; // 没有添加注解时， 采用默认的方案 implName = t.getClass().getSimpleName(); implOrder = SpiImplWrapper.DEFAULT_ORDER; // 参数选择器时, 要求spi实现类必须有 @SpiConf 注解, 否则选择器无法获取校验条件参数 if (currentSelector.getSelector() instanceof ParamsSelector) &#123; throw new IllegalStateException(\"spiImpl must contain annotation @SpiConf!\"); &#125; map = Collections.emptyMap(); &#125; else &#123; implName = spiConf.name(); if (StringUtils.isBlank(implName)) &#123; implName = t.getClass().getSimpleName(); &#125; implOrder = spiConf.order() &lt; 0 ? SpiImplWrapper.DEFAULT_ORDER : spiConf.order(); map = parseParms(spiConf.params()); &#125; // 添加一个类级别的封装类 spiServiceList.add(new SpiImplWrapper&lt;&gt;(t, implOrder, implName, map)); // ------------ // 解析参数的方法 private Map&lt;String, String&gt; parseParms(String[] params) &#123; if (params.length == 0) &#123; return Collections.emptyMap(); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(params.length); String[] strs; for (String param : params) &#123; strs = StringUtils.split(param, \":\"); if (strs.length &gt;= 2) &#123; map.put(strs[0].trim(), strs[1].trim()); &#125; else if (strs.length == 1) &#123; map.put(strs[0].trim(), null); &#125; &#125; return map; &#125; 2. 初始化选择器 我们的选择器会区分为两类，一个是类上定义的选择器， 一个是方法上定义的选择器； 在自适应的使用方式中，方法上定义的优先级 &gt; 类上定义 简单来讲，初始化选择器，就是扫一遍SPI接口中的注解，实例化选择器后，缓存住对应的结果, 实现如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 /*** 选择器, 根据条件, 选择具体的 SpiImpl;*/private SelectorWrapper currentSelector;/*** 自适应时, 方法对应的选择器*/private Map&lt;String, SelectorWrapper&gt; currentMethodSelector;/*** 每一个 SpiLoader 中, 每种类型的选择器, 只保存一个实例* 因此可以在选择器中, 如&#123;@link ParamsSelector&#125; 对spiImplMap进行处理并缓存结果*/private ConcurrentHashMap&lt;Class, SelectorWrapper&gt; selectorInstanceCacheMap = new ConcurrentHashMap&lt;&gt;(); private void initSelector() &#123; Spi ano = spiInterfaceType.getAnnotation(Spi.class); if (ano == null) &#123; currentSelector = initSelector(DefaultSelector.class); &#125; else &#123; currentSelector = initSelector(ano.selector()); &#125; Method[] methods = this.spiInterfaceType.getMethods(); currentMethodSelector = new ConcurrentHashMap&lt;&gt;(); SelectorWrapper temp; for (Method method : methods) &#123; if (!method.isAnnotationPresent(SpiAdaptive.class)) &#123; continue; &#125; temp = initSelector(method.getAnnotation(SpiAdaptive.class).selector()); if (temp == null) &#123; continue; &#125; currentMethodSelector.put(method.getName(), temp); &#125;&#125;private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) &#123; // 优先从选择器缓存中获取类型对应的选择器 if (selectorInstanceCacheMap.containsKey(clz)) &#123; return selectorInstanceCacheMap.get(clz); &#125; try &#123; ISelector selector = clz.newInstance(); Class paramClz = null; Type[] types = clz.getGenericInterfaces(); for (Type t : types) &#123; if (t instanceof ParameterizedType) &#123; paramClz = (Class) ((ParameterizedType) t).getActualTypeArguments()[0]; break; &#125; &#125; Assert.check(paramClz != null); SelectorWrapper wrapper = new SelectorWrapper(selector, paramClz); selectorInstanceCacheMap.putIfAbsent(clz, wrapper); return wrapper; &#125; catch (Exception e) &#123; throw new IllegalArgumentException(\"illegal selector defined! yous:\" + clz); &#125;&#125; 说明 SeectorWrapper 选择器封装类 这里我们在获取选择器时，特意定义了一个封装类，其中包含具体的选择器对象，以及所匹配的参数类型，因此可以在下一步通过选择器获取实现类时，保证传入的参数类型合法 private SelectorWrapper initSelector(Class&lt;? extends ISelector&gt; clz) 具体的实例化选择器的方法 从实现来看，优先从选择器缓存中获取选择器对象，这样的目的是保证一个spi接口，每种类型的选择器只有一个实例；因此在自定义选择器中，你完全可以做一些选择判断的缓存逻辑，如 ParamsSelector 中的spi实现类的有序缓存列表 currentSelector , currentMethodSelector, selectorInstanceCacheMap currentSelector: 对应的是类选择器，每个SPI接口必然会有一个，作为打底的选择器 currentMethodSelector: 方法选择器映射关系表，key为方法名，value为该方法对应的选择器； 所以spi接口中，不支持重载 selectorInstanceCacheMap: spi接口所有定义的选择器映射关系表，key为选择器类型，value是实例；用于保障每个spi接口中选择器只会有一个实例 3. 获取实现类 对使用者而言，最关注的就是这个接口，这里会返回我们需要的实现类（or代理）；内部的逻辑也比较清楚，首先确定选择器，然后通过选择器便利所有的实现类，把满足条件的返回即可 从上面的描述可以看到，主要分为两步 获取选择器 根据选择器，遍历所有的实现类，找出匹配的返回 获取选择器初始化选择器之后，我们会有 currentSelector , currentMethodSelector 两个缓存 静态确定spi实现时，直接用 currentSelector 即可 （spi接口中所有方法都公用类定义选择器） 动态适配时， 根据方法名在 currentMethodSelector 中获取选择器，如果没有，则表示该方法没有@SpiAdaptive注解，直接使用类的选择器 currentMethodSelector 即可 123456789101112131415// 动态适配时，获取方法对应对应的selector实现逻辑SelectorWrapper selector = currentMethodSelector.get(methodName);if (selector == null) &#123; // 自适应方法上未定义选择器, 则默认继承类的 selector = currentSelector; currentMethodSelector.putIfAbsent(methodName, selector);&#125;if (!selector.getConditionType().isAssignableFrom(conf.getClass())) &#123; // 选择器类型校验 if (!(conf instanceof String)) &#123; throw new IllegalArgumentException(\"conf spiInterfaceType should be sub class of [\" + currentSelector.getConditionType() + \"] but yours:\" + conf.getClass()); &#125; // 参数不匹配时，且传入的参数为String类型， 则尝试使用默认选择器进行兼容（不建议在实现时，出现这种场景） selector = DEFAULT_SELECTOR;&#125; 选择实现类这个的主要逻辑就是遍历所有的实现类，判断是否满足选择器的条件，将第一个找到的返回即可，所有的业务逻辑都在 ISelector 中实现，如下面给出的默认选择器，根据name来获取实现类 1234567891011121314151617181920212223242526/** * 默认的根据name 获取具体的实现类 * &lt;p/&gt; * Created by yihui on 2017/5/24. */public class DefaultSelector implements ISelector&lt;String&gt; &#123; @Override public &lt;K&gt; K selector(Map&lt;String, SpiImplWrapper&lt;K&gt;&gt; map, String name) throws NoSpiMatchException &#123; if (StringUtils.isBlank(name)) &#123; throw new IllegalArgumentException(\"spiName should not be empty!\"); &#125; if (map == null || map.size() == 0) &#123; throw new IllegalArgumentException(\"no impl spi!\"); &#125; if (!map.containsKey(name)) &#123; throw new NoSpiMatchException(\"no spiImpl match the name you choose! your choose is: \" + name); &#125; return map.get(name).getSpiImpl(); &#125;&#125; 流程说明 上面主要就各个点单独的进行了说明，看起来可能比较分散，看完之后可能没有一个清晰的流程，这里就整个实现的流程顺一遍，主要从使用者的角度出发，当定义了一个SPI接口后，到获取spi实现的过程中，上面的这些步骤是怎样串在一起的 流程图先拿简单的静态获取SPI实现流程说明（动态的其实差不多，具体的差异下一篇说明），先看下这种用法的使用姿势 1234567891011121314151617181920212223242526@Spipublic interface IPrint &#123; void print(String str);&#125;public class FilePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"file print: \" + str); &#125;&#125;public class ConsolePrint implements IPrint &#123; @Override public void print(String str) &#123; System.out.println(\"console print: \" + str); &#125;&#125;@Testpublic void testPrint() throws NoSpiMatchException &#123; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class); IPrint print = spiLoader.getService(\"ConsolePrint\"); print.print(\"console----&gt;\");&#125; SpiLoader&lt;IPrint&gt; spiLoader = SpiLoader.load(IPrint.class);这行代码触发的action 主要是初始化所有的选择器, 如下图 首先从缓存中查 是否已经初始化过了有则直接返回； 缓存中没有，则进入new一个新的对象出来 解析类上注解 @Spi，初始化 currentSelector 解析所有方法的注解 @SpiAdaptive ， 初始化 currentMethodSelector 塞入缓存，并返回 IPrint print = spiLoader.getService(&quot;ConsolePrint&quot;);根据name获取实现类，具体流程如下 判断是否加载过所有实现类 spiImplClassCacheMap 没有加载，则重新加载所有的实现类 通过jdk的 ServiceLoader.load() 方法获取所有的实现类 遍历实现类，根据 @SpiConf 注解初始化参数，封装 SpiImplWrapper对象 保存封装的 SpiImplWrapper对象到缓存 执行 currentSelector.select() 方法，获取匹配的实现类 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]},{"title":"1. SPI框架实现之旅一：背景介绍","slug":"SPI框架实现之旅一：背景介绍","date":"2017-05-26T02:46:42.000Z","updated":"2018-04-02T07:43:56.849Z","comments":true,"path":"2017/05/26/SPI框架实现之旅一：背景介绍/","link":"","permalink":"https://zbang.online/hexblog/2017/05/26/SPI框架实现之旅一：背景介绍/","excerpt":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制","text":"背景介绍 SPI的全名为Service Provider Interface，简单的总结下java spi机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。 java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制 1. 背景上面摘抄了一下spi的概念，接着以个人的理解，简单的谈一下为什么会用到SPI， 什么场景下可以用到这个， 以及使用了SPI机制后有什么优越性 什么是SPI虽然最开始就引用了spi的解释，这里浅谈一下个人理解。Service Provider Interface 以接口方式提供服务， 和API不同，spi的机制是定义一套标准规范的接口，实现交给其他人来做。 所以一个接口，可以有很多的实现，你完全可以根据自己的需要去选择具体的实现方式，因为是面向接口的开发，所以你的业务代码基本上就不用修改，就可以切到另一个实现了 什么场景可以用 分别从框架层面和业务层面，给出一个我认为比较合适的场景 1. 日志输出 SLF4jSLF4j：大名鼎鼎的日志输出接口，这个jar包里面提供的都只是接口方式，具体的实现需要自己去实现，当然比较常用的 logback 就是一个具体的实现包了， 在项目中使用 slf4j 的api进行日志的输出， 通过简单的配置，引入logback， 就可以使用logback来实现具体的日志输出； 也可以换一个日志实现 commons-logging，业务上不需要任何的改动，就可以用不同的实现来输出日志 2. 业务场景假设你现在有个用户注册成功后的欢迎用户的业务，不同渠道（微信，qq，微博等）注册的，显示的欢迎不同，对此有两种不同的实现方式 如果每个不同的渠道进来的，都有一个独立的应用来响应 （因为绝大多数的业务都一样，可能就欢迎词不同，如果做到代码最大程度的复用） 只有一个应用，来处理所有的这些场景 可以怎么用 结合上面的业务场景，来描述下可以怎么用 1. 代码复用为了实现代码最大程度的复用，那么可以将不同的地方，抽象成一个SPI接口，在业务层通过接口来代替具体的实现类实现业务逻辑； 每个渠道，都有个独立的应用，那么在微信渠道，创建一个 WeixinSpiImpl来实现接口 在qq渠道，实现 QQSpiImpl；那么在具体的接口调用处，实际上就是执行的spi实现类方法 2. 业务场景的选择区分这个与上面不同，同一个服务接口，根据不同的业务场景，选择不同的实现来执行；当然你是完全可以使用 if， else来实现这种场景，唯一的问题就是扩展比较麻烦； 这种场景下，我们希望的就是这个接口，能自动的根据业务场景，来选择最合适的实现类来执行 简单来讲，就是\u0010spi接口执行之前，其实需要有一个自动选择匹配的实现类的前置过程； 通常这种业务场景下，具体的spi实现会有多个，但是需要有一个选择的策略 2. 小目标 在具体的实现之前，先定义一个小目标，我们想要实现一个什么样子的东西出来 通过上面的背景描述，我们的小目标也就很明确了，我们的实现至少需要满足两个场景 静态选择SPI实现， 即在选择完成之后，所有对这个spi接口的引用都是确定由这个实现来承包 动态选择SPI实现， 不到运行之时，你都不知道会是哪个spi实现来干这件事 3. 技术储备 java本身就提供了一套spi的支持方式: ServiceLoader，我们后续的开发，也会在这个基础之上进行 利用java的 ServiceLoader 找到服务接口的实现类，有一些约定，下面给出要求说明和一个测试case 一般实现流程 定义spi接口 ： IXxx 具体的实现类: AXxx, BXxx 在jar包的META-INF/services/目录下新建一个文件，命名为 spi接口的完整类名，内容为spi接口实现的完整类名，一个实现类占一行 测试case如下 spi接口 com.hust.hui.quicksilver.commons.spi.HelloInterface 12345678910package com.hust.hui.quicksilver.commons.spi;/** * Created by yihui on 2017/3/17. */public interface HelloInterface &#123; void sayHello();&#125; spi接口的两个实现类 com.hust.hui.quicksilver.commons.spi.impl.ImageHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class ImageHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"image hello!\"); &#125;&#125; com.hust.hui.quicksilver.commons.spi.impl.TextHello.java 12345678910111213package com.hust.hui.quicksilver.commons.spi.impl;import com.hust.hui.quicksilver.commons.spi.HelloInterface;/** * Created by yihui on 2017/3/17. */public class TextHello implements HelloInterface &#123; @Override public void sayHello() &#123; System.out.println(\"text hello\"); &#125;&#125; 配置文件 com.hust.hui.quicksilver.commons.spi.HelloInterface 12com.hust.hui.quicksilver.commons.spi.impl.ImageHellocom.hust.hui.quicksilver.commons.spi.impl.TextHello 测试类 1234567891011public class HelloSpiTest &#123; @Test public void testSPI() &#123; ServiceLoader&lt;HelloInterface&gt; serviceLoader = ServiceLoader.load(HelloInterface.class); for (HelloInterface hello: serviceLoader) &#123; hello.sayHello(); &#125; &#125;&#125; 输出如下: 12image hello!text hello 测试类演示如下图: 4. 设计思路画了一下结构图，方便理解, 下面的核心是 SpiLoader 类， 负责加载spi接口的所有实现类， 初始化所有定义的选择器， 返回一个spi接口的实现类初始化用户自定义的spi对象，然后用户持有此对象调用spi接口中提供的方法即可 5. 其他博客系列链接： SPI框架实现之旅四：使用测试 SPI框架实现之旅三：实现说明 SPI框架实现之旅二：整体设计 SPI框架实现之旅一：背景介绍 项目: QuickAlarm 项目地址： Quick-SPI 博客地址： 小灰灰Blog 个人博客： Z+|blog基于hexo + github pages搭建的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛 声明尽信书则不如，已上内容，纯属一家之言，因本人能力一般，见识有限，如发现bug或者有更好的建议，随时欢迎批评指正，我的微博地址: 小灰灰Blog 扫描关注","categories":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://zbang.online/hexblog/tags/Java/"},{"name":"SPI","slug":"SPI","permalink":"https://zbang.online/hexblog/tags/SPI/"},{"name":"整体设计","slug":"整体设计","permalink":"https://zbang.online/hexblog/tags/整体设计/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://zbang.online/hexblog/categories/技术/"},{"name":"Quick系列项目","slug":"技术/Quick系列项目","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/"},{"name":"QuickSpi","slug":"技术/Quick系列项目/QuickSpi","permalink":"https://zbang.online/hexblog/categories/技术/Quick系列项目/QuickSpi/"}]}]